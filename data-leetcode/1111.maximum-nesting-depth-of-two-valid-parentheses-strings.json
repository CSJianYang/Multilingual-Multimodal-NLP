[
    {
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
        "question_content": "A string is a valid parentheses string&nbsp;(denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\r\n\r\n\r\n\tIt is the empty string, or\r\n\tIt can be written as&nbsp;AB&nbsp;(A&nbsp;concatenated with&nbsp;B), where&nbsp;A&nbsp;and&nbsp;B&nbsp;are VPS's, or\r\n\tIt can be written as&nbsp;(A), where&nbsp;A&nbsp;is a VPS.\r\n\r\n\r\nWe can&nbsp;similarly define the nesting depth depth(S) of any VPS S as follows:\r\n\r\n\r\n\tdepth(\"\") = 0\r\n\tdepth(A + B) = max(depth(A), depth(B)), where A and B are VPS's\r\n\tdepth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\r\n\r\n\r\nFor example,&nbsp; \"\",&nbsp;\"()()\", and&nbsp;\"()(()())\"&nbsp;are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\r\n\r\n&nbsp;\r\n\r\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that&nbsp;A and B are VPS's (and&nbsp;A.length + B.length = seq.length).\r\n\r\nNow choose any such A and B such that&nbsp;max(depth(A), depth(B)) is the minimum possible value.\r\n\r\nReturn an answer array (of length seq.length) that encodes such a&nbsp;choice of A and B:&nbsp; answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.&nbsp; Note that even though multiple answers may exist, you may return any of them.\r\n&nbsp;\nExample 1:\n\nInput: seq = \"(()())\"\nOutput: [0,1,1,1,1,0]\n\nExample 2:\n\nInput: seq = \"()(())()\"\nOutput: [0,0,0,1,1,0,1,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= seq.size <= 10000",
        "solutions": [
            {
                "id": 358419,
                "title": "confused-by-this-problem-i-was-too-here-is-how-it-became-crystal-clear",
                "content": "# Some observations\\n\\n1. This problem uses very abstract and non-intuitive language; this is not a bad thing, just makes it hard to understand for those of us who are not well versed in that particular language.\\n2. The problem uses seemingly ambiguous language, when overloading the meaning of `A` and `B`: It first talks about `A` and `B` in the context of the definition of a VPS, but then re-defines `A` and `B` later as two disjoint subsequences in the solution of the problem, absolutely unrelated to the first definition.\\n3. After looking at some explanations and code samples, I see that the solution depends on whether or not the depth of a parenthesis is odd or not, but I did not get why, so I kept on pondering...\\n\\n# First things first: What is a VPS?\\nA VPS (or \"valid parentheses string\") is just a string containing balanced parentheses, i.e. any opening parenthesis is followed by exactly one that closes it, and any closing parenthesis is preceded by at least one unbalanced opening parenthesis.\\n\\nValid examples: `((()))`, `(())()`, `()((((((()))))))()()()()` etc.\\n\\nInvalid examples: `)(`, `))`, `(())()))` etc.\\n\\n# Now, what does this problem really want from me?\\n\\nWe are trying to minimize depth of a VPS by splitting all pairs of parentheses into two groups `A` and `B`. `A` and `B` can be any **disjoint** sub-sequence of the input sequence, as long as they are still VPS **without changing the order** of anything (side-note: the `order` constraint is implied by the word `sequence`).\\n\\nSome examples:\\n\\n1. `\"(())\"` can be grouped into `A = \"()\"` and `B = \"()\"` or, `A = \"\"` and `B = \"(())\"`, but, for example, not `A = \"((\"` and `B = \"))\"` as those are not VPS\\n1. `\"(())()\"` can be grouped into `A = \"(())\"` and `B = \"()\"`, and many other ways\\n\\nHowever, the goal is to **minimize** the **max depth** of both groups.\\n\\nIn the last example (`\"(())()\"`), the grouping (`A = \"(())\"` and `B = \"()\"`) is not minimal, because `A` has a max-depth of 2 while there exists a grouping where both only have a depth of 1, namely: `A = ()()` and `B = ()`, or to visualize the designation:\\n\\n```\\nparentheses =   [ (, (, ), ), (, )]\\ndepths =        [ 1, 2, 2, 1, 1, 1 ]\\ngroups =        [ A, B, B, A, A, A]\\nsolution =      [ 0, 1, 1, 0, 0, 0]\\n```\\n\\nNOTE: One of several other solutions would be: `[1, 0, 0, 1, 0, 0]`, as `A` and `B` maintain a max depth of 1. Solutions are not unique.\\n\\n\\n# Going deeper: How to minimize the depth?\\n\\nThis optimization problem does not really care too much about anything but the most deeply nested subset. If we can solve that, we can easily solve the rest. For example, in the previous example that deepest stack would be `(())`. The remaining `()` we can put either in `A` or `B` (because, as it turns out they will have a depth of at most (roughly) `maxDepth/2`, so we don\\'t care whether they are in `A` or in `B`; explained later).\\n\\nSo, given a tall, but simple stack of parentheses, such as `((((((((()))))))))`, how do we split it into two disjoint sub-sequences that happen to be VPS, while also *minimizing* each of their depth?\\n\\nSince we can only split all parentheses into two groups, the minimum depth we can achieve will always be `ceil(maxDepth/2)` and we achieve it by putting one half in each group. Trying to put less than half in one of the two groups, will leave the other group with more than one half.\\n\\nOnce we handled the deepest stack, we can handle all other stacks using the same strategy, making sure that no other parenthesis will increase the max depth.\\n\\nInteresting side note: Any stack in the sequence that is of max depth less or equal to `ceil(globalMaxDepth/2)` (of the entire sequence) we can assign any which way we want (as long as we maintain the VPS property), since they cannot increase the max depth of the resulting split.\\nE.g.: when looking at `\"((()))()()()()\"`, we just gotta take good care of the first `\"((()))\"`, then we can assign each following parenthesis pair `\"()\"` to `A` or `B` any which way we want, since their max depth is less or equal to `ceil(3/2) = 2`.\\n\\n# Solution\\n\\nSo what we need is a strategy to cut any stack in half while making sure that the resulting half-stacks are balanced VPS. There are many ways of doing that, but one of the easiest (and seemingly a very common) approach is the odd/even strategy:\\n\\n1. Get the depth at every index of the string\\n1. Put all odd-depth parentheses in one group, and all even-depth in the other\\n1. Done.\\n\\nNOTE: Using this solution, parentheses at the same depth are always in the same group, so you can ensure that the resulting groups are balanced VPS.\\n\\n\\n# Code\\n\\nYou can find many examples on this discussion board; here is mine:\\n\\n```python\\nclass Solution:\\n  def maxDepthAfterSplit(self, s: str) -> List[int]:\\n    groups = []\\n    d = 0\\n    for c in s:\\n      open = c == \\'(\\'\\n      if open:\\n        d += 1\\n      groups.append(d % 2)  # group determined through parity (odd/even?) of depth\\n      if not open:\\n        d -=1\\n    \\n    return groups\\n```",
                "solutionTags": [],
                "code": "```\\nparentheses =   [ (, (, ), ), (, )]\\ndepths =        [ 1, 2, 2, 1, 1, 1 ]\\ngroups =        [ A, B, B, A, A, A]\\nsolution =      [ 0, 1, 1, 0, 0, 0]\\n```\n```python\\nclass Solution:\\n  def maxDepthAfterSplit(self, s: str) -> List[int]:\\n    groups = []\\n    d = 0\\n    for c in s:\\n      open = c == \\'(\\'\\n      if open:\\n        d += 1\\n      groups.append(d % 2)  # group determined through parity (odd/even?) of depth\\n      if not open:\\n        d -=1\\n    \\n    return groups\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328841,
                "title": "java-c-python-o-1-extra-space-except-output",
                "content": "## Solution 0: Alternatively Distribute Parentheses\\nBasically, `(` is 1 point, `)` is `-1` point.\\nWe try to keep total points of two groups even,\\nby distributing parentheses alternatively.\\n\\nThe good part of this solution is that,\\nwe actually need no extra variable to record anything.\\n\\n\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length(), res[] = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : (1 - i & 1);\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.length());\\n        for (int i = 0; i < seq.length(); ++i)\\n            res[i] = i & 1 ^ (seq[i] == \\'(\\');\\n        return res;\\n    }\\n```\\n\\n**1-line Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```\\n<br>\\n\\n# Complexity\\nTime `O(N)` for one pass\\nSpace `O(1)` extra space,  `O(N)` for output\\n<br>\\n\\n# More\\nAlso provide some more easy understood ideas for this problem,\\npick the the one you like.\\n(As I keep receiving complaints about the readability,\\nlike no parentheses in solution for problem of parentheses)\\n<br>\\n\\n# Solution 1: Keep Two Group Even\\nCount the number of open parentheses of group `A` and group `B`.\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (A < B) {\\n                    ++A;\\n                } else {\\n                    ++B;\\n                    res[i] = 1;\\n                }\\n            } else {\\n                if (A > B) {\\n                    --A;\\n                } else {\\n                    --B;\\n                    res[i] = 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\') {\\n                if (A < B) ++A;\\n                else ++B, res[i] = 1;\\n            } else {\\n                if (A > B) --A;\\n                else --B, res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        A = B = 0\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B):\\n                A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n\\n```\\n<br>\\n\\n# Solution 2: Split by Half\\nCount the number of level of whole string.\\nThen split it by half.\\nGroup 0: the part under the half height\\nGroup 1: the part above the half height\\n\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (int i = 0; i < n; ++i) {\\n            cur +=  seq.charAt(i) == \\'(\\' ?  1 : -1;\\n            depth = Math.max(depth, cur);\\n        }\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (++cur > depth / 2)\\n                    res[i] = 1;\\n            } else {\\n                if (cur-- > depth / 2)\\n                    res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (char c : seq)\\n            depth = max(depth, cur += c == \\'(\\' ? 1 : -1);\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\' && ++cur > depth / 2) res[i] = 1;\\n            if (seq[i] == \\')\\' && cur-- > depth / 2) res[i] = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        depth = cur = 0\\n        for c in seq:\\n            if c == \\'(\\':\\n                cur += 1\\n                depth = max(depth, cur)\\n            else:\\n                cur -= 1\\n        half = depth / 2\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                cur += 1\\n                if cur > half: res[i] = 1\\n            else:\\n                if cur > half: res[i] = 1\\n                cur -= 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length(), res[] = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : (1 - i & 1);\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.length());\\n        for (int i = 0; i < seq.length(); ++i)\\n            res[i] = i & 1 ^ (seq[i] == \\'(\\');\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (A < B) {\\n                    ++A;\\n                } else {\\n                    ++B;\\n                    res[i] = 1;\\n                }\\n            } else {\\n                if (A > B) {\\n                    --A;\\n                } else {\\n                    --B;\\n                    res[i] = 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\') {\\n                if (A < B) ++A;\\n                else ++B, res[i] = 1;\\n            } else {\\n                if (A > B) --A;\\n                else --B, res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        A = B = 0\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B):\\n                A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n\\n```\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (int i = 0; i < n; ++i) {\\n            cur +=  seq.charAt(i) == \\'(\\' ?  1 : -1;\\n            depth = Math.max(depth, cur);\\n        }\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (++cur > depth / 2)\\n                    res[i] = 1;\\n            } else {\\n                if (cur-- > depth / 2)\\n                    res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (char c : seq)\\n            depth = max(depth, cur += c == \\'(\\' ? 1 : -1);\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\' && ++cur > depth / 2) res[i] = 1;\\n            if (seq[i] == \\')\\' && cur-- > depth / 2) res[i] = 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        depth = cur = 0\\n        for c in seq:\\n            if c == \\'(\\':\\n                cur += 1\\n                depth = max(depth, cur)\\n            else:\\n                cur -= 1\\n        half = depth / 2\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                cur += 1\\n                if cur > half: res[i] = 1\\n            else:\\n                if cur > half: res[i] = 1\\n                cur -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328920,
                "title": "very-easy-and-clean-code-one-pass-o-n-with-explanation",
                "content": "# intuition\\nif we are going deeper, take turns to assign to A and B\\n```\\n1.         ( ( ( ( ( ) ) ) ) )\\n   level   1 2 3 4 5 5 4 3 2 1  \\n   A takes level 1,3,5 and B takes level 2,4 ==> A : ( ( ( ) ) ) , B : ( ( ) )\\n2.         ( ( ) ) ( ( ( ) ) )\\n   level   1 2 2 1 1 2 3 3 2 1\\n   A takes level 1,3 and B takes level 2 ==> A : ( ) ( ( ) ) , B : ( ) ( )\\n   \\nwhen to increase/decrese level ?\\n1. meet a new \\'(\\' level up\\n2. meet a new \\')\\' level down\\n\\nif you can understand the level conception, coding is quite easy.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.size(),0);\\n        int level = 0, index = 0;\\n        while(index < seq.size()){\\n            if(seq[index] ==\\'(\\')\\n                res[index] = ++level%2;\\n            else\\n                res[index] = level--%2;\\n            index++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1.         ( ( ( ( ( ) ) ) ) )\\n   level   1 2 3 4 5 5 4 3 2 1  \\n   A takes level 1,3,5 and B takes level 2,4 ==> A : ( ( ( ) ) ) , B : ( ( ) )\\n2.         ( ( ) ) ( ( ( ) ) )\\n   level   1 2 2 1 1 2 3 3 2 1\\n   A takes level 1,3 and B takes level 2 ==> A : ( ) ( ( ) ) , B : ( ) ( )\\n   \\nwhen to increase/decrese level ?\\n1. meet a new \\'(\\' level up\\n2. meet a new \\')\\' level down\\n\\nif you can understand the level conception, coding is quite easy.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.size(),0);\\n        int level = 0, index = 0;\\n        while(index < seq.size()){\\n            if(seq[index] ==\\'(\\')\\n                res[index] = ++level%2;\\n            else\\n                res[index] = level--%2;\\n            index++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328843,
                "title": "mountain-shaving-algorithm",
                "content": "\\n\\nJust shave off all sub-VPSs of `level > max_level / 2` to 1 and appoint the rest to 0.\\nThis may be visualized with a mountain that corresponds to a VPS.\\n\\nThe visualiztion method:\\n```\\n      _\\n( =  /     (Uphill)\\n\\n     _\\n) =   \\\\    (Downhill)\\n```\\n\\n`()(())() will give the following hill`\\n\\n```\\n( ) ( ( ) ) ( )\\n       __\\n __  _/  \\\\_  __  ____________________<] FIRE LASER     \\n/  \\\\/      \\\\/  \\\\                      | & SHAVE THE MOUNTAIN!\\n\\n                     ||\\n                    \\\\||/\\n                \\t \\\\/\\n\\n       __\\n      /  \\\\           Top of mountain  = \"   ()   \"       \\n      \\n __  ______  __\\n/  \\\\/      \\\\/  \\\\     Base of mountain = \"()(  )()\"\\n\\n```\\n\\nPR0GR4M C0D3:\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int lvl = 0, maxlvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl++;\\n                maxlvl = max(lvl, maxlvl);\\n            } else if (c == \\')\\') {\\n                lvl--;\\n            }\\n        }\\n        int cnt1 = 0;\\n        vector<int> ret(seq.size());\\n        vector<int> openings;\\n        int pos = 0;\\n        lvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl ++;\\n                openings.push_back(pos);\\n            } else if (c == \\')\\') {\\n                bool should_make_1 = false;\\n                \\n                if (pos == seq.size()-1 && cnt1 == 0) {\\n                    should_make_1 = true;\\n                }\\n                if (/*lvl > maxlvl/2*/ lvl == maxlvl/2 + 1) {\\n                    should_make_1 = true;\\n                }\\n                \\n                if (should_make_1) {\\n                    for (int i=openings.back(); i<=pos; i++) {\\n                        if (ret[i] == 0) cnt1 ++;\\n                        ret[i] = 1;\\n                    }\\n                }\\n                openings.pop_back();\\n                lvl --;\\n            }\\n            \\n            pos ++;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n      _\\n( =  /     (Uphill)\\n\\n     _\\n) =   \\\\    (Downhill)\\n```\n```\\n( ) ( ( ) ) ( )\\n       __\\n __  _/  \\\\_  __  ____________________<] FIRE LASER     \\n/  \\\\/      \\\\/  \\\\                      | & SHAVE THE MOUNTAIN!\\n\\n                     ||\\n                    \\\\||/\\n                \\t \\\\/\\n\\n       __\\n      /  \\\\           Top of mountain  = \"   ()   \"       \\n      \\n __  ______  __\\n/  \\\\/      \\\\/  \\\\     Base of mountain = \"()(  )()\"\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int lvl = 0, maxlvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl++;\\n                maxlvl = max(lvl, maxlvl);\\n            } else if (c == \\')\\') {\\n                lvl--;\\n            }\\n        }\\n        int cnt1 = 0;\\n        vector<int> ret(seq.size());\\n        vector<int> openings;\\n        int pos = 0;\\n        lvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl ++;\\n                openings.push_back(pos);\\n            } else if (c == \\')\\') {\\n                bool should_make_1 = false;\\n                \\n                if (pos == seq.size()-1 && cnt1 == 0) {\\n                    should_make_1 = true;\\n                }\\n                if (/*lvl > maxlvl/2*/ lvl == maxlvl/2 + 1) {\\n                    should_make_1 = true;\\n                }\\n                \\n                if (should_make_1) {\\n                    for (int i=openings.back(); i<=pos; i++) {\\n                        if (ret[i] == 0) cnt1 ++;\\n                        ret[i] = 1;\\n                    }\\n                }\\n                openings.pop_back();\\n                lvl --;\\n            }\\n            \\n            pos ++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328847,
                "title": "python-greedy-o-n-with-clarification-and-analysis",
                "content": "### To clarify the question\\n\\nThe split result is two subsequences, not necessarily two substrings. The difference between a subsequence and a substring is that a subsequence doesn\\'t have to be continuous. For example, `\"ABDG\"` is not a substring of `\"ABCDEFG\"`, but it is a subsequence.\\n\\n---\\n\\n### Solution Analysis\\nSince we are spliting the original string into subsequences, we don\\'t care whether they are continuous. As long as the resulting subsequences have their parentheses from the original string **in the original order**, that is good enough. To guarantee they are in the original order, we can simply scan from left to right once, and hopefully we can determine which (A or B) subsequence does the parenthesis belong to **right after we scan to it**. -- so we are looking for a greedy algorithm.\\n\\nSo can we determine it right away? Yes. Apart from keeping the origional order, the **only** other goal is to minimize the depth. That means, **to achieve this goal**, when we see a `\"(\"` we should allocate it to the subsequence with less unmatched `\"(\"`; when we see a `\")\"`, we should allocate it to the subsequence with more unmatched `\"(\"`.\\n\\n---\\n\\n### Code [Python]\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        res = [None] * len(seq)\\n        A = B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if A <= B:\\n                    A += 1\\n                    res[i] = 0\\n                else:\\n                    B += 1\\n                    res[i] = 1\\n            else:\\n                if A >= B:\\n                    A -= 1\\n                    res[i] = 0\\n                else:\\n                    B -= 1\\n                    res[i] = 1\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        res = [None] * len(seq)\\n        A = B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if A <= B:\\n                    A += 1\\n                    res[i] = 0\\n                else:\\n                    B += 1\\n                    res[i] = 1\\n            else:\\n                if A >= B:\\n                    A -= 1\\n                    res[i] = 0\\n                else:\\n                    B -= 1\\n                    res[i] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328946,
                "title": "submitting-only-1-s-works-edit-fixed",
                "content": "Edit: This was fixed, this doesn\\'t work anymore.\\n\\nIf you submit a vector with all 1\\'s, it works.\\n\\nThe code below for C++ actually works.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> answer(seq.length());\\n        for(int i=0;i<seq.length();i++) answer[i]=1;\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> answer(seq.length());\\n        for(int i=0;i<seq.length();i++) answer[i]=1;\\n        return answer;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 328842,
                "title": "c-java-o-n-greedy",
                "content": "# Intuition\\n1. We need to minimize the depth of two disjoint subsequences. \\n3. For ```A``` string, we can reduce the depth by half by splitting ```A``` into two disjoint subsequences.\\n   - for example, the depth of ```(((())))``` is 4, and the best split we can do is ```(())``` and ```(())``` with the depth of 2.  \\n   - we can put parentheses with odd depth into the first subsequence, and with even - to the second. \\n3. For ```AB``` string, we can solve the problem independently for ```A``` and ```B```.\\n   - for example, ```((()))(()())``` is concatenation of ```((()))``` and ```(()())``` with depths 3 and 2 correspondingly.\\n# C++\\n```\\nvector<int> maxDepthAfterSplit(string seq, int depth = 0) {\\n  vector<int> res;\\n  for (auto c : seq) {\\n    if (c == \\'(\\') res.push_back(depth++ % 2);\\n    else res.push_back(--depth % 2);        \\n  }\\n  return res;\\n}\\n```\\n# Java\\n```\\npublic int[] maxDepthAfterSplit(String seq) {\\n  int[] res = new int[seq.length()];\\n  for (int i = 0, depth = 0; i < seq.length(); ++i) {\\n    if (seq.charAt(i) == \\'(\\') res[i] = depth++ % 2;\\n    else res[i] = --depth % 2;\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n)*;\\nMemory: *O(1)*, or *O(n)* if we consider the result.",
                "solutionTags": [],
                "code": "```A```\n```A```\n```(((())))```\n```(())```\n```(())```\n```AB```\n```A```\n```B```\n```((()))(()())```\n```((()))```\n```(()())```\n```\\nvector<int> maxDepthAfterSplit(string seq, int depth = 0) {\\n  vector<int> res;\\n  for (auto c : seq) {\\n    if (c == \\'(\\') res.push_back(depth++ % 2);\\n    else res.push_back(--depth % 2);        \\n  }\\n  return res;\\n}\\n```\n```\\npublic int[] maxDepthAfterSplit(String seq) {\\n  int[] res = new int[seq.length()];\\n  for (int i = 0, depth = 0; i < seq.length(); ++i) {\\n    if (seq.charAt(i) == \\'(\\') res[i] = depth++ % 2;\\n    else res[i] = --depth % 2;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329275,
                "title": "i-don-t-know-why-it-is-wrong",
                "content": "![image](https://assets.leetcode.com/users/arajo/image_1562506850.png)\\n\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        out = [0]\\n        f = seq[0]\\n        \\n        if len(seq)==0: return depth\\n        else:\\n            n = 1\\n            while n < len(seq):\\n                if f==seq[n]:\\n                    out.append(1)\\n                    n += 1\\n                    if n < len(seq) and f != seq[n] :\\n                        out.append(1)\\n                        n += 1\\n                else: \\n                    out.append(0)\\n                    f = seq[n]\\n                    n += 1\\n        return out",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/arajo/image_1562506850.png)\\n\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        out = [0]\\n        f = seq[0]\\n        \\n        if len(seq)==0: return depth\\n        else:\\n            n = 1\\n            while n < len(seq):\\n                if f==seq[n]:\\n                    out.append(1)\\n                    n += 1\\n                    if n < len(seq) and f != seq[n] :\\n                        out.append(1)\\n                        n += 1\\n                else: \\n                    out.append(0)\\n                    f = seq[n]\\n                    n += 1\\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 1206226,
                "title": "100-solution-clear-description-simple-explanation-time-o-n-space-o-1",
                "content": "The problem:\\n\\n```\\nFor example,\\nseq = \"()(())\"\\nA   = \"()(  )\"\\nB   = \"   () \"\\nans = \"000110\"\\n```\\nSpliting the given string seq into two sub-sequences A and B, so that:\\n1. A and B are both VPS\\n2. the number of \"(\" of A plus that of B equals to the number of \"(\" of seq. (sub-sequence, not substring)\\n3. let M=max(depth(A), depth(B)), our job is to find the right A and B to minimize M\\n4. using 0 to denote that the i\\'th character belongs to A\\n\\n\\nThe Algorithm:\\n\\nIt starts as an algorithm to pair \"(\" and \")\" of the given string named \"seq\". We use stack to record the position i of every \"(\" and pop the stack to get a pair.\\n\\nNow, let us focus on the max depth of the stack, which is also the depth of VPS. e.g. \"((()))\". According to the problem, our job is to minimized such depth. \\n\\nOur method is to slow the growth of the depth of VPS, distribute the \"(\" and corresponding \")\" to A and B so that it takes twice effort to increase the depth. Actually, we can track the depth of the stack,\\nas long as it is odd, distribute them to B, and distribute to A for even (we can also swap A and B). \\n\\nActually, the stack is useless, we just need a counter to track the depth of the stack. The codes are given in the following.\\n\\nIn case it helps your, plz upvote to supprt.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cnt=-1;\\n        int N=seq.size();\\n        const char * c=seq.c_str();\\n        vector<int> ans (N);\\n        for(int i=0; i<N; ++i) {\\n            if(c[i]==\\'(\\') {\\n                ++cnt;\\n                ans[i]=cnt&1;\\n            } else {\\n                ans[i]=cnt&1;\\n                --cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFor example,\\nseq = \"()(())\"\\nA   = \"()(  )\"\\nB   = \"   () \"\\nans = \"000110\"\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cnt=-1;\\n        int N=seq.size();\\n        const char * c=seq.c_str();\\n        vector<int> ans (N);\\n        for(int i=0; i<N; ++i) {\\n            if(c[i]==\\'(\\') {\\n                ++cnt;\\n                ans[i]=cnt&1;\\n            } else {\\n                ans[i]=cnt&1;\\n                --cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329273,
                "title": "strange-error-need-help-28-31-test-cases-passed-and-then-a-strange-error",
                "content": "![image](https://assets.leetcode.com/users/dkcs/image_1562506547.png)\\n\\nany idea why its being shown like this?\\nIt says 28/31 test cases passed and this error\\nmy code is as follows:\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) \\n    {        \\n        char ch[]=seq.toCharArray();\\n        int c=0;\\n        int n[]=new int[ch.length];\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                ++c;\\n                if(c%2!=0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }\\n            else\\n            {\\n                --c;\\n                if(c%2==0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }   \\n        }\\n        return n;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) \\n    {        \\n        char ch[]=seq.toCharArray();\\n        int c=0;\\n        int n[]=new int[ch.length];\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                ++c;\\n                if(c%2!=0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }\\n            else\\n            {\\n                --c;\\n                if(c%2==0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }   \\n        }\\n        return n;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340417,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n        A = B = 0 # max opens for 2 groups\\n        res = [0] * len(seq) # we split into sequences, not continuous subarrays\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B): A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n    \\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n        A = B = 0 # max opens for 2 groups\\n        res = [0] * len(seq) # we split into sequences, not continuous subarrays\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B): A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n    \\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329635,
                "title": "c-100-javascript-c-odd-even-levels-easy-to-understand",
                "content": "When depth increases - change set, so we divide depths/levels between sets as even as possible. \\n\\nIf you imagine histogram with parentheses nesting depth represented as height of the bars, and put all even vertical levels to one set and the rest (odd levels) to the other, then you basically get a solution to the problem.\\n\\nSmall catch, to match open to close parenthesis, for open parenthesis first increment then calculate set code (0 or 1), for close case first calculate set then decrement depth, this way parenthesis will match.\\n\\nC++ human friendly version\\n```\\nvector<int> maxDepthAfterSplit1(string seq) {\\n    int size = seq.size();\\n    vector<int> result(size);\\n    int depth = 0;\\n    for(int i = 0; i < size; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nC++\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n    vector<int> result;\\n    int depth = 0;\\n    for(auto& ch: seq) \\n        result.push_back(ch == \\'(\\' ? ++depth % 2 : depth-- % 2);\\n    return result;\\n}\\n```\\n\\nC# human friendly version\\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nC# short version\\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i)\\n        result[i] = seq[i] == \\'(\\' ? ++depth % 2 : depth-- % 2;\\n    return result;\\n}\\n```\\n\\nJavascript human friendly version\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        if (ch == \\'(\\') {\\n            ++depth;\\n            result.push(depth & 1);\\n        } else  {\\n            result.push(depth & 1);\\n            --depth;\\n        }\\n    }\\n    return result;\\n};\\n```\\n\\nJavascript\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        result.push(ch == \\'(\\' ? ++depth & 1 : depth-- & 1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvector<int> maxDepthAfterSplit1(string seq) {\\n    int size = seq.size();\\n    vector<int> result(size);\\n    int depth = 0;\\n    for(int i = 0; i < size; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n    vector<int> result;\\n    int depth = 0;\\n    for(auto& ch: seq) \\n        result.push_back(ch == \\'(\\' ? ++depth % 2 : depth-- % 2);\\n    return result;\\n}\\n```\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i)\\n        result[i] = seq[i] == \\'(\\' ? ++depth % 2 : depth-- % 2;\\n    return result;\\n}\\n```\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        if (ch == \\'(\\') {\\n            ++depth;\\n            result.push(depth & 1);\\n        } else  {\\n            result.push(depth & 1);\\n            --depth;\\n        }\\n    }\\n    return result;\\n};\\n```\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        result.push(ch == \\'(\\' ? ++depth & 1 : depth-- & 1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420665,
                "title": "java-optimize-easy",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] a = new int[seq.length()];\\n        \\n        int count = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n                a[i] = count++ % 2;\\n            }else{\\n                a[i] = --count % 2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] a = new int[seq.length()];\\n        \\n        int count = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n                a[i] = count++ % 2;\\n            }else{\\n                a[i] = --count % 2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609304,
                "title": "c-0-ms-faster-than-100-with-intuition-using-two-stacks-easy-to-understand",
                "content": "## Intuition:\\nWe need A and  B subsequences and they need to be valid paranthesis strings.\\n\\nLets traverse the array and assign each character of given string to A or B.\\n if current character is \\'(\\'\\n* we can assign it to A or B, but we have to decrease the max(depth(A),depth(B))\\n* if we have more \\'(\\' already in A than B that didn\\'t get corresponding \\')\\' yet. Then we should add it to B. because B is having less \\'(\\' waiting for \\')\\'.\\n* else if B has more \\'(\\' than \\'A\\' or both have equal \\'(\\' , we assign the cuurent \\'(\\' to A\\n\\n\\nIf current character is \\')\\'\\n* If A has more \\'(\\' waiting for corresponding \\')\\' than B. We assign the current \\')\\' to A\\n* else we assign to B\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        stack<int> st1 , st2 ; \\n\\t\\t// st1 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n\\t\\t// st2 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n\\t\\t\\t    // assign current \\'(\\' to the one with less number of \\'(\\' waiting\\n\\t\\t\\t\\t// so we push into respective stacks and mark ans[i] accordingly\\n                if(st1.size()>st2.size())\\n                {\\n                    st2.push(i) ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.push(i) ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t   \\n\\t\\t\\t    // assign current \\')\\' to the one with more number of \\'(\\' waiting\\n\\t\\t\\t\\t//and pop one \\'(\\' from the group(A or B) to which the current \\')\\' has been assigned to\\n\\t\\t\\t\\t//mark ans[i] accordingly\\n                if(st1.size()<st2.size())\\n                {\\n                    st2.pop() ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.pop() ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```\\n\\n**Time** : O(n)\\n**Space** O(n)\\n\\n## Approach - 2 : (Optimised version of 1)\\nIf you can observe, we need not store the indices of \\'(\\'. We just need the count of \\'(\\' waiting in each stack.\\n\\nSo instead of using 2 stacks. We can just keep track of count\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        int c1 = 0 , c2 = 0 ;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                if(c1>c2)\\n                {\\n                    c2++ ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1++ ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n                if(c1<c2)\\n                {\\n                    c2-- ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1-- ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\n**Time** : O(n)\\n**Space**: O(1) not considering the vector to be returned",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        stack<int> st1 , st2 ; \\n\\t\\t// st1 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n\\t\\t// st2 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n\\t\\t\\t    // assign current \\'(\\' to the one with less number of \\'(\\' waiting\\n\\t\\t\\t\\t// so we push into respective stacks and mark ans[i] accordingly\\n                if(st1.size()>st2.size())\\n                {\\n                    st2.push(i) ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.push(i) ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t   \\n\\t\\t\\t    // assign current \\')\\' to the one with more number of \\'(\\' waiting\\n\\t\\t\\t\\t//and pop one \\'(\\' from the group(A or B) to which the current \\')\\' has been assigned to\\n\\t\\t\\t\\t//mark ans[i] accordingly\\n                if(st1.size()<st2.size())\\n                {\\n                    st2.pop() ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.pop() ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        int c1 = 0 , c2 = 0 ;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                if(c1>c2)\\n                {\\n                    c2++ ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1++ ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n                if(c1<c2)\\n                {\\n                    c2-- ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1-- ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346040,
                "title": "easy-python3-97-39-lesser-memory",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def toggler(toggle: int) -> int:\\n            if toggle == 1:\\n                return 0\\n            return 1\\n        ans = list()\\n        toggle = 0\\n        ans.append(toggle)\\n        l = len(seq)\\n        for i in range(l-1):\\n            if seq[i] == seq[i+1]:\\n                toggle = toggler(toggle)\\n            ans.append(toggle)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def toggler(toggle: int) -> int:\\n            if toggle == 1:\\n                return 0\\n            return 1\\n        ans = list()\\n        toggle = 0\\n        ans.append(toggle)\\n        l = len(seq)\\n        for i in range(l-1):\\n            if seq[i] == seq[i+1]:\\n                toggle = toggler(toggle)\\n            ans.append(toggle)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201480,
                "title": "cpp-c-easy-to-understand-beginner-friendly-solution-with-comments",
                "content": "```\\ncomments are written inside //  //.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;                                    // first wee created vector tu put store resulting values//\\n        int max=0;                                       // created variable and assign with zero to count brackets//\\n        for(int i=0;i<seq.length();i++)       // traverse overr string //\\n        {\\n            if(seq[i]==\\'(\\')                          // cheacked for opening bracket condition//\\n                max++;                            //increse count//\\n            p.push_back(max%2);        //here is the logic \"max%2\" it gives the required op//\\n            if(seq[i]==\\')\\')                    //condition if brackets are empty//\\n                max--;                        //count decreases//\\n        }\\n        return p;                        //returned the vector as op//\\n    }\\n};\\n```\\n## *please upvote if yoou like the solution and feel free to ask any doubt in comments will surely reply.*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ncomments are written inside //  //.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;                                    // first wee created vector tu put store resulting values//\\n        int max=0;                                       // created variable and assign with zero to count brackets//\\n        for(int i=0;i<seq.length();i++)       // traverse overr string //\\n        {\\n            if(seq[i]==\\'(\\')                          // cheacked for opening bracket condition//\\n                max++;                            //increse count//\\n            p.push_back(max%2);        //here is the logic \"max%2\" it gives the required op//\\n            if(seq[i]==\\')\\')                    //condition if brackets are empty//\\n                max--;                        //count decreases//\\n        }\\n        return p;                        //returned the vector as op//\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106478,
                "title": "python-simplest-solution-ac",
                "content": "if the previous bracket is same take it to the other VPS. Since given string is a valid VPS, this implementation will never raise any incorrect VPSs.\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = [0]*len(seq)\\n        x = 0\\n        for i in range(1,len(seq)):\\n            if seq[i]==seq[i-1]:\\n                x = 1-x\\n            ans[i] = x\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = [0]*len(seq)\\n        x = 0\\n        for i in range(1,len(seq)):\\n            if seq[i]==seq[i-1]:\\n                x = 1-x\\n            ans[i] = x\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902281,
                "title": "allocate-each-opening-bracket-alternately-to-a-and-b-98",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        out = []\\n        prev = \\'B\\'\\n        for l in seq:\\n            if l==\"(\":\\n                if prev==\\'A\\':\\n                    out.append(1)\\n                    prev = \\'B\\'\\n                else:\\n                    out.append(0)\\n                    prev = \\'A\\'\\n            else:\\n                if prev==\\'A\\':\\n                    out.append(0)\\n                    prev=\\'B\\'\\n                else:\\n                    out.append(1)\\n                    prev=\\'A\\'\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        out = []\\n        prev = \\'B\\'\\n        for l in seq:\\n            if l==\"(\":\\n                if prev==\\'A\\':\\n                    out.append(1)\\n                    prev = \\'B\\'\\n                else:\\n                    out.append(0)\\n                    prev = \\'A\\'\\n            else:\\n                if prev==\\'A\\':\\n                    out.append(0)\\n                    prev=\\'B\\'\\n                else:\\n                    out.append(1)\\n                    prev=\\'A\\'\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537260,
                "title": "easy-solution-beats-100-in-both-runtime-space",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector <int> ans(seq.length());\\n        stack <char> st;\\n        \\n        for(int i=0;i<seq.length();i++) {\\n            if(st.empty() || seq[i] == \\'(\\') {\\n                st.push(seq[i]);\\n                ans[i] = (st.size() - 1)%2;\\n            }    \\n            else {\\n                ans[i] = (st.size() - 1)%2;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector <int> ans(seq.length());\\n        stack <char> st;\\n        \\n        for(int i=0;i<seq.length();i++) {\\n            if(st.empty() || seq[i] == \\'(\\') {\\n                st.push(seq[i]);\\n                ans[i] = (st.size() - 1)%2;\\n            }    \\n            else {\\n                ans[i] = (st.size() - 1)%2;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513623,
                "title": "java-concise-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int level = 0, n = seq.length();\\n        int[] ans = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(seq.charAt(i) == \\'(\\') ans[i] = ++level%2;\\n            else ans[i] = level--%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int level = 0, n = seq.length();\\n        int[] ans = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(seq.charAt(i) == \\'(\\') ans[i] = ++level%2;\\n            else ans[i] = level--%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054088,
                "title": "c-stack-solution-very-easy-to-understand",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> answer(n, 0);\\n\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i < n; i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(!st.empty()) st.push({st.top().first == 0 ? 1 : 0, i});\\n                else st.push({0, i});\\n            }else{\\n                auto [cnt, idx] = st.top(); st.pop();\\n                answer[idx] = cnt;\\n                answer[i] = cnt;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> answer(n, 0);\\n\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i < n; i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(!st.empty()) st.push({st.top().first == 0 ? 1 : 0, i});\\n                else st.push({0, i});\\n            }else{\\n                auto [cnt, idx] = st.top(); st.pop();\\n                answer[idx] = cnt;\\n                answer[i] = cnt;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825324,
                "title": "python-98-06-faster-greedy-approach-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans=[]\\n        prev=1\\n        for i in seq:\\n            if i==\\'(\\':\\n                if prev==0:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n            else:\\n                ans.append(prev)\\n            if prev==0:\\n                prev=1\\n            else:\\n                prev=0\\n        return ans\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans=[]\\n        prev=1\\n        for i in seq:\\n            if i==\\'(\\':\\n                if prev==0:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n            else:\\n                ans.append(prev)\\n            if prev==0:\\n                prev=1\\n            else:\\n                prev=0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580050,
                "title": "stack-based-easy-python-solution-explained-o-n",
                "content": "Idea is that if the dept is greater than 1, we alternatively allocate bracket pairs to A and B.\\nEg: (()) => Outer pair to A and inner pair to B => [0,1,1,0]. Similarly ((())) => [0,1,0,0,1,0] => Outermost pair to A, middle pair to B and innermost pair to A again.\\n\\nWe use a stack to stor info of last unclosed bracket and in which block  (A = 0 or B = 1) it belongs. And pop it to close it whenever closing bracket appears during iteration.\\n\\nUpvote if you understood the logic :)\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack = []\\n        ans = []\\n        \\n        for s in seq:\\n            if s == \\'(\\':\\n                if not stack or stack[-1]:\\n                    ans.append(0)\\n                    stack.append(0)\\n                else:\\n                    ans.append(1)\\n                    stack.append(1)\\n            else:\\n                if stack[-1]:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n                stack.pop()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack = []\\n        ans = []\\n        \\n        for s in seq:\\n            if s == \\'(\\':\\n                if not stack or stack[-1]:\\n                    ans.append(0)\\n                    stack.append(0)\\n                else:\\n                    ans.append(1)\\n                    stack.append(1)\\n            else:\\n                if stack[-1]:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n                stack.pop()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522944,
                "title": "c-easy-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        int depth = -1;\\n        for(auto s : seq) {\\n            if(s == \\'(\\') {\\n                depth++;\\n                res.push_back(depth%2);\\n            } else if(s == \\')\\') {\\n                res.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        return res;        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725698,
                "title": "java-o-n-divide-into-2-group-based-odd-and-even-depths",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        \\n        int n = seq.length();\\n        int ans[] = new int[n];\\n        char  chars[] = seq.toCharArray();\\n        int depth = 0;\\n\\n        for(int i =0; i < n ;i++){\\n            if(chars[i] == \\'(\\'){\\n                depth++;\\n                if(depth % 2 == 0){\\n             \\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n            }else{\\n                if(depth %2 == 0){\\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n                depth--;\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        \\n        int n = seq.length();\\n        int ans[] = new int[n];\\n        char  chars[] = seq.toCharArray();\\n        int depth = 0;\\n\\n        for(int i =0; i < n ;i++){\\n            if(chars[i] == \\'(\\'){\\n                depth++;\\n                if(depth % 2 == 0){\\n             \\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n            }else{\\n                if(depth %2 == 0){\\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n                depth--;\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273245,
                "title": "java-iterative-easiest-faster-than-100-with-explaination",
                "content": "What we have to do is ..\\nfrom the given string which is VPS,we have to divide it into two subsequences of minimum length.\\n\\nLet\\'s say subsequence strings are A and B.\\n\\nDuring visiting each chars of given VPS string......\\nwhen we first get \\'(\\' we allocate it for string A.\\n               next time for B.\\n\\t\\t\\t   next time for A.\\n\\t\\t\\t   and likewise.....\\n\\nWhen we first get \\')\\' we allocate it for string B.\\n\\t\\t\\tnext time for A.\\n\\t\\t\\tnext time for B.\\n\\t\\t\\tand likewise......\\n\\t\\t\\t\\nTo do this alternatively we can use boolean variable for open and close parantheses.\\t\\t\\t\\n\\n\\n```\\nclass Solution {\\n    int arr[];\\n    public int[] maxDepthAfterSplit(String seq) {\\n        boolean open=false,close=false;\\n        //if open=false  ==> next \\'(\\' will be allocated for A otherwise for B.\\n\\t\\t//if close=false ==> next \\')\\' will be allocated for A otherwise for B.\\n        \\n        int arr[]=new int[seq.length()];\\n        for(int i=0;i<seq.length();i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                if(close){\\n                    arr[i]=1;\\n                    close=false;//to allocate next \\'(\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    close=true;//to allocate next \\'(\\' to B.\\n                }\\n            }else{\\n                if(open){\\n                    arr[i]=1;\\n                    open=false;//to allocate next \\')\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    open=true;//to allocate next \\')\\' to B.\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int arr[];\\n    public int[] maxDepthAfterSplit(String seq) {\\n        boolean open=false,close=false;\\n        //if open=false  ==> next \\'(\\' will be allocated for A otherwise for B.\\n\\t\\t//if close=false ==> next \\')\\' will be allocated for A otherwise for B.\\n        \\n        int arr[]=new int[seq.length()];\\n        for(int i=0;i<seq.length();i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                if(close){\\n                    arr[i]=1;\\n                    close=false;//to allocate next \\'(\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    close=true;//to allocate next \\'(\\' to B.\\n                }\\n            }else{\\n                if(open){\\n                    arr[i]=1;\\n                    open=false;//to allocate next \\')\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    open=true;//to allocate next \\')\\' to B.\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218640,
                "title": "easy-c-recursive-100-fastest-explanation-inside",
                "content": "//say, ans contains depth of string and we have ans as {0,1,1,1,1,0}, thus we can always make disjoint set of 1st and last element i.e. {0,0} and remaining (1 to 4 index ) elements making their depth {0,0,0,0} Since parent parent parenthesis is no more so depth reduced by one\\n//we can always separate max depth and max depth-1 parenthesis making max(a,b)=0, except ()(), where max(a,b) will always be 1 so doesn\\'t matter how you break\\n//so take one in a and other in b\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int i=0;\\n    void sol(string &s,int dep){\\n        if(i==s.length())return;\\n        if(s[i]==\\'(\\'){\\n            ans[i]=dep;\\n            i++;\\n            sol(s,dep+1);\\n        }\\n        else {\\n            ans[i]=dep-1;\\n            i++;\\n            sol(s,dep-1);\\n            \\n        }\\n    }\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        ans.resize(seq.length(),-1);\\n        sol(seq,0);\\n        for(auto &i:ans)i=i&1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int i=0;\\n    void sol(string &s,int dep){\\n        if(i==s.length())return;\\n        if(s[i]==\\'(\\'){\\n            ans[i]=dep;\\n            i++;\\n            sol(s,dep+1);\\n        }\\n        else {\\n            ans[i]=dep-1;\\n            i++;\\n            sol(s,dep-1);\\n            \\n        }\\n    }\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        ans.resize(seq.length(),-1);\\n        sol(seq,0);\\n        for(auto &i:ans)i=i&1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083691,
                "title": "c-beats-100-simple-solution-easy-to-understand-with-comments",
                "content": "**Do upvote if you liked the code !**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int count = 0;\\n        vector<int>depths(seq.size());\\n        int maxx = 0;\\n        for(int i=0;i<seq.size();i++){                       \\n//             assigning depths\\n//             for opening assign before & for closing assign afterwards\\n//             with this corresponding pair of brackets will have same depth\\n            if(seq[i]==\\'(\\'){\\n                depths[i] = count+1;\\n                count++;\\n            }\\n            else{\\n                count--;\\n                depths[i] = count+1;\\n            }\\n            maxx = max(maxx,count);\\n        }\\n//         Now to have least max(depth(A), depth(B)) is the minimum possible value.\\n//         divide them into 2 groups one having\\n//         height > maxx/2 other smaller\\n//         this way the depths of both groups will get reduced\\n        for(int i=0;i<seq.size();i++){                       \\n            if(depths[i]>maxx/2)\\n                depths[i] = 1;\\n            else\\n                depths[i] = 0;\\n        }\\n        return depths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int count = 0;\\n        vector<int>depths(seq.size());\\n        int maxx = 0;\\n        for(int i=0;i<seq.size();i++){                       \\n//             assigning depths\\n//             for opening assign before & for closing assign afterwards\\n//             with this corresponding pair of brackets will have same depth\\n            if(seq[i]==\\'(\\'){\\n                depths[i] = count+1;\\n                count++;\\n            }\\n            else{\\n                count--;\\n                depths[i] = count+1;\\n            }\\n            maxx = max(maxx,count);\\n        }\\n//         Now to have least max(depth(A), depth(B)) is the minimum possible value.\\n//         divide them into 2 groups one having\\n//         height > maxx/2 other smaller\\n//         this way the depths of both groups will get reduced\\n        for(int i=0;i<seq.size();i++){                       \\n            if(depths[i]>maxx/2)\\n                depths[i] = 1;\\n            else\\n                depths[i] = 0;\\n        }\\n        return depths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885478,
                "title": "easy-c-solution-no-fancy-stuff",
                "content": "The idea is that all paratheses in the seuquence have their closing parentheses, which means that we can create other VPS\\'s of depth 1 : depth(\"()\") = 1.\\nTo not get larger depths by having  things like \"(())\" each time we affect parantheses of the sime type that are side by side to a different sub-sequence : 0 1 1 0.\\n\\n```\\n vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> res(n);\\n        res[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (seq[i] != seq[i - 1]) {\\n                res[i] = res[i - 1];\\n            } else {\\n                res[i] = 1 - res[i - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> res(n);\\n        res[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (seq[i] != seq[i - 1]) {\\n                res[i] = res[i - 1];\\n            } else {\\n                res[i] = 1 - res[i - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826894,
                "title": "thinking-process",
                "content": "In order to minimize maximum depth, we ought to divide the deepest VPS substring into two subsequences evenly.\\n\\nConstructing a VPS is like counting `score`, where `(` is 1 and `)` is -1. If accumulative `score` is never negative and equal to 0 in the end, a VPS is constructed.\\n\\nDividing a VPS evenly also uses the concept of `score`. We want to maintain the **invariant** that `score difference` of two subsequences is no larger than 1.\\n\\n****\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        int A = 0, B = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            System.out.println(\"== A: \" + A + \" B: \" + B + \" ==\");\\n            int score = seq.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (score > 0 && A < B || score < 0 && A > B) {\\n                System.out.println(score + \" to A\");\\n                A += score;\\n            } else {\\n                System.out.println(score + \" to B\");\\n                B += score;\\n                res[i] = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n****\\nThe invariant above holds in the code:\\n- If deepest VPS substring has even pairs of parentheses, e.g.  `\"(())\"`\\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\\n\\n- If deepest VPS substring has odd pairs of parentheses, e.g. = `\"((()))\"`,\\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n1 to B\\n== A: 1 B: 2 ==\\n-1 to B\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        int A = 0, B = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            System.out.println(\"== A: \" + A + \" B: \" + B + \" ==\");\\n            int score = seq.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (score > 0 && A < B || score < 0 && A > B) {\\n                System.out.println(score + \" to A\");\\n                A += score;\\n            } else {\\n                System.out.println(score + \" to B\");\\n                B += score;\\n                res[i] = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n1 to B\\n== A: 1 B: 2 ==\\n-1 to B\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722564,
                "title": "c-greedy-mountain-visualization-technique-with-pictures",
                "content": "Refer this post for the visualization part https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328843/%22Mountain-Shaving%22-algorithm\\nSee the picture for clarity ->\\n![image](https://assets.leetcode.com/users/images/70882a8d-87ea-45af-b615-a8bee204d809_1594037022.3392315.png)\\n\\nThe code given in that link has some uneccesary stuff going on. Here is a clean code.\\n\\n```\\nclass Solution {\\n   public:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        if (seq.empty())\\n            return {};\\n\\n        int currLevel = 0;\\n        int maxLevel = 0;\\n        int N = (int)seq.length();\\n        vector<int> levels(N);\\n        for (int i = 0; i < N; ++i) {\\n            char c = seq[i];\\n            if (c == \\'(\\') {\\n                levels[i] = currLevel;\\n                currLevel++;\\n            } else {\\n                currLevel--;\\n                levels[i] = currLevel;\\n            }\\n            maxLevel = max(maxLevel, currLevel);\\n        }\\n\\n        int threshold = maxLevel / 2;\\n        //level[i] >= threshold then it belongs to B else A\\n        for (int i = 0; i < levels.size(); ++i) {\\n            if (levels[i] >= threshold)\\n                levels[i] = 1;\\n            else\\n                levels[i] = 0;\\n        }\\n\\n        return levels;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        if (seq.empty())\\n            return {};\\n\\n        int currLevel = 0;\\n        int maxLevel = 0;\\n        int N = (int)seq.length();\\n        vector<int> levels(N);\\n        for (int i = 0; i < N; ++i) {\\n            char c = seq[i];\\n            if (c == \\'(\\') {\\n                levels[i] = currLevel;\\n                currLevel++;\\n            } else {\\n                currLevel--;\\n                levels[i] = currLevel;\\n            }\\n            maxLevel = max(maxLevel, currLevel);\\n        }\\n\\n        int threshold = maxLevel / 2;\\n        //level[i] >= threshold then it belongs to B else A\\n        for (int i = 0; i < levels.size(); ++i) {\\n            if (levels[i] >= threshold)\\n                levels[i] = 1;\\n            else\\n                levels[i] = 0;\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636983,
                "title": "greedy-approach-cpp-easy-solution-with-comments",
                "content": "\\n\\nRuntime: 8 ms, faster than 84.62% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 7.9 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n```\\n    class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        //since we want the difference to be as low as possible so we will try to balance both A and B by trying to maintain the number of paranthesis as close as close as possible\\n        vector<int> indexA, indexB, res(seq.length(), 0 );\\n\\t\\t//initailly assuming all parenthesis belong to A so filling res with 0\\n        int i = 0;\\n        int addToA = 0, addToB = 0;\\n        while(i < seq.length()){\\n            if(seq[i] == \\'(\\'){\\n                if(addToA <= addToB){\\n                    //adding depth to A when it\\'s depth is lesser or equal to b\\n                    indexA.push_back(i);\\n                    addToA ++;\\n                }else{\\n                    indexB.push_back(i);\\n                    addToB++;\\n                }\\n            }else{\\n                // removing depth from string whose depth is maximum as we have to keep the difference minimum\\n                if(addToA >= addToB){\\n                    addToA--;\\n                    indexA.push_back(i);\\n                }else{\\n                    indexB.push_back(i);\\n                    addToB--;\\n                }\\n            }\\n           i++;\\n        }\\n         for(i = 0; i < indexB.size(); i++){\\n                res[indexB[i]] = 1;\\n            }\\n         return res;   \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        //since we want the difference to be as low as possible so we will try to balance both A and B by trying to maintain the number of paranthesis as close as close as possible\\n        vector<int> indexA, indexB, res(seq.length(), 0 );\\n\\t\\t//initailly assuming all parenthesis belong to A so filling res with 0\\n        int i = 0;\\n        int addToA = 0, addToB = 0;\\n        while(i < seq.length()){\\n            if(seq[i] == \\'(\\'){\\n                if(addToA <= addToB){\\n                    //adding depth to A when it\\'s depth is lesser or equal to b\\n                    indexA.push_back(i);\\n                    addToA ++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 629097,
                "title": "o-n-simple-idea-easy-to-understand-java-with-comments-99-fast",
                "content": "Basic idea - The max you can reduce the degree is half. ie for continous opening brackets, you can split them into 2 groups. Remaining brackets you can split in any choice. \\n\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        char[] arr = seq.toCharArray();\\n        int l = arr.length;\\n        int[] res = new int[l];\\n        \\n        int deg = 0;\\n        int maxDegree = 0;\\n\\t\\t\\n\\t\\t// calculate the maximum degree of given string\\n        for(int i=0; i<l; i++) {\\n            if (arr[i] == \\'(\\') {\\n                deg++;\\n                maxDegree = Math.max(maxDegree, deg);\\n            }\\n            else {\\n                deg--;\\n            }\\n        }\\n\\t\\t\\n        int currdeg = 0;\\n        int groupBcounter = 0; // maintain a counter for providing closing brackets for group B.\\n\\t\\t\\n        for(int i=0; i<l; i++) {\\n            if (arr[i]==\\'(\\') {\\n\\t\\t\\t// if the current degree is greater than half, put the bracket in group B.\\n                if (currdeg >= maxDegree/2) {\\n                    res[i] = 1;\\n                    groupBcounter++;\\n                }\\n                currdeg++;\\n            }\\n            else {\\n                currdeg--;\\n\\t\\t\\t\\t// if group B requires closing, assign \\')\\' to B.\\n                if (groupBcounter > 0) {\\n                    res[i] = 1;\\n                    groupBcounter--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        char[] arr = seq.toCharArray();\\n        int l = arr.length;\\n        int[] res = new int[l];\\n        \\n        int deg = 0;\\n        int maxDegree = 0;\\n\\t\\t\\n\\t\\t// calculate the maximum degree of given string\\n        for(int i=0; i<l; i++) {\\n            if (arr[i] == \\'(\\') {\\n                deg++;\\n                maxDegree = Math.max(maxDegree, deg);\\n            }\\n            else {\\n                deg--;\\n            }\\n        }\\n\\t\\t\\n        int currdeg = 0;\\n        int groupBcounter = 0; // maintain a counter for providing closing brackets for group B.\\n\\t\\t\\n        for(int i=0; i<l; i++) {\\n            if (arr[i]==\\'(\\') {\\n\\t\\t\\t// if the current degree is greater than half, put the bracket in group B.\\n                if (currdeg >= maxDegree/2) {\\n                    res[i] = 1;\\n                    groupBcounter++;\\n                }\\n                currdeg++;\\n            }\\n            else {\\n                currdeg--;\\n\\t\\t\\t\\t// if group B requires closing, assign \\')\\' to B.\\n                if (groupBcounter > 0) {\\n                    res[i] = 1;\\n                    groupBcounter--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588230,
                "title": "c-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        short curr = 0;\\n        vector<int> ret;\\n        for (char& c : seq)\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ret.push_back(curr);\\n                curr ^= 1;\\n            }\\n            else\\n            {\\n                curr ^= 1;\\n                ret.push_back(curr);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        short curr = 0;\\n        vector<int> ret;\\n        for (char& c : seq)\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ret.push_back(curr);\\n                curr ^= 1;\\n            }\\n            else\\n            {\\n                curr ^= 1;\\n                ret.push_back(curr);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422002,
                "title": "without-increment-using-flag-easy-to-understand",
                "content": "Lets say for every character we push either 1 or 0 based on flag F.\\n() -> result should be FF (eg 00, or 11)\\n)( -> result should be FF (eg 00 or 11) as they allow us to keep minimum depth\\nfor other cases it should be F!F (eg 01 or 10)\\n\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool isA = true;\\n        char old = \\')\\';\\n        \\n        for(auto ch : seq) {\\n            if ((old == \\'(\\' && ch == \\')\\') || \\n                (old == \\')\\' && ch == \\'(\\')) { \\n                /* don\\'t change while processing () and )( */ \\n            } else { \\n                isA = !isA; // change is above pattern not found\\n            }\\n\\n            // push integer based on isA\\n            if (isA) res.push_back(1);\\n            else res.push_back(0);\\n            \\n            // update old char\\n            old = ch;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool isA = true;\\n        char old = \\')\\';\\n        \\n        for(auto ch : seq) {\\n            if ((old == \\'(\\' && ch == \\')\\') || \\n                (old == \\')\\' && ch == \\'(\\')) { \\n                /* don\\'t change while processing () and )( */ \\n            } else { \\n                isA = !isA; // change is above pattern not found\\n            }\\n\\n            // push integer based on isA\\n            if (isA) res.push_back(1);\\n            else res.push_back(0);\\n            \\n            // update old char\\n            old = ch;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401663,
                "title": "easy-to-understand-c-solution-20ms-one-pass",
                "content": "Runtime: 20 ms, faster than 94.77% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> res;\\n        int depth = 0;\\n        \\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n                depth++;\\n            res.push_back(depth%2);\\n            if(seq[i] == \\')\\')\\n                depth--;\\n        } \\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 94.77% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> res;\\n        int depth = 0;\\n        \\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n                depth++;\\n            res.push_back(depth%2);\\n            if(seq[i] == \\')\\')\\n                depth--;\\n        } \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 330657,
                "title": "python-simple-idea-split-depths-into-even-and-odd-o-n-time-o-1-space",
                "content": "The simple idea here is to get the depth of each brace and basically split those depths into two sections A and B such that A contains all braces with even depths and B contains all braces with odd depths.\\n\\nLet\\'s say you have the input as \"( ( ( ) ( ) ( ) ) ( ) )\". Let\\'s first construct the depths array.\\narr = [0, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0]. Each element in the depths array depicts the depth of that particular brace in the sequence.\\n\\nOnce we have this arr, we want to modify this such that all elements where depths[i]%2 == 1 are labelled as 1 and all elements with deptsh[i]%2 == 0 are labelled as 0. \\n\\nFollowing is the code that shows this.\\n\\n\\tdef maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        lvl = -1\\n        for c in seq:\\n            if c == \\'(\\':\\n                lvl += 1\\n                res.append(lvl%2)\\n            elif c == \\')\\':\\n                res.append(lvl%2)\\n                lvl -=1\\n        return res",
                "solutionTags": [],
                "code": "The simple idea here is to get the depth of each brace and basically split those depths into two sections A and B such that A contains all braces with even depths and B contains all braces with odd depths.\\n\\nLet\\'s say you have the input as \"( ( ( ) ( ) ( ) ) ( ) )\". Let\\'s first construct the depths array.\\narr = [0, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0]. Each element in the depths array depicts the depth of that particular brace in the sequence.\\n\\nOnce we have this arr, we want to modify this such that all elements where depths[i]%2 == 1 are labelled as 1 and all elements with deptsh[i]%2 == 0 are labelled as 0. \\n\\nFollowing is the code that shows this.\\n\\n\\tdef maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        lvl = -1\\n        for c in seq:\\n            if c == \\'(\\':\\n                lvl += 1\\n                res.append(lvl%2)\\n            elif c == \\')\\':\\n                res.append(lvl%2)\\n                lvl -=1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 328852,
                "title": "python-solution-3-7-o-n-with-detailed-explanation",
                "content": "This question annoyed me at first, because it\\'s so verbose. However, if you can get past the verbosity, it\\'s actually not so difficult to solve.\\n\\nThe problem is the following: You have a string, seq, which is a valid parentheses string (VPS) as defined in the question. depth(seq) is equal to the maximum depth that any pair of parentheses in the sequence has; so, if seq is \"()((()))\" for example, then depth(seq) = 3 because that\\'s as \"deep\" as the sequence goes. \\n\\nIf you removed the left and right parentheses at indices 4 and 5, respectively, then you\\'d have \"()(())\" and depth(seq) would only be\\n2.\\n\\nHowever, if you inserted a \"()\" at index 5, then you\\'d have \"()(((())))\" and depth(seq) would be 4.\\n\\nIf you remove the \"()\" at the beginning of seq, then you\\'d have \"((()))\", and depth(seq) would still be 3. You removed a pair of parentheses, but the maximum depth reached by seq is still 3.\\n\\nYou need to separate seq into what the problem calls \"two disjoint subsequences\" A and B, where A and B are also VPS\\'s. This means that every individual parenthesis in seq needs to be in either A or B, but not both, and A and B must also meet the requirements of a VPS. The idea is to minimize the depth of both A and B while choosing what they should be; you have to cover all of seq with both A and B, but max(depth(A), depth(B)) needs to be as low as possible.\\n\\nIf you struggled to understand the question when you read it and gave up, you should try giving it some more thought before moving on.\\n\\nYou should realize that, for every seq, there is at least one solution where (first case) depth(A) = depth(B), or (second case) depth(A) is either depth(B)+1 or depth(B)-1 (they\\'re both the same case since A and B are interchangeable). If depth(seq) is even, then the first case holds; otherwise, the second case holds. This means that max(depth(A), depth(B)) is either equal to depth(seq)//2 or depth(seq)//2 + 1.\\n\\nHow do we know this? Because, no matter what seq is, the fact that it\\'s a VPS allows us to just take any pair of parentheses, whether or not they have other parentheses nested within them, and add them to either sequence. So, we can just choose to add pairs that will allow us to make depth(A) equal to depth(B), or equal to depth(B)-1.\\n\\nI understand that this is a lot of information, so here\\'s my code. Feel free to ask away in the comments, I know this is still a lot to wrap your head around.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # idea: max(depth(A), depth(B)) can only be as low as 1/2 * depth(seq),\\n        #       because otherwise A and B are either (a) not actually VPS\\'s, or\\n        #       (b) do not actually constitute the smallest possible max(depth(A),\\n        #       depth(B)). So, just choose any A and B where depth(A) = depth(B)\\n        #       or depth(A) = depth(B) + 1. They\\'ll be equal if depth(seq) is\\n        #       an even number, otherwise they\\'ll be off by one.\\n        \\n        depthSeq = 0\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            depthSeq = max(depthSeq, curDepth)\\n\\n        ret = []\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            if curDepth > depthSeq//2 or (curDepth == depthSeq//2 and el != \\'(\\'):\\n                ret.append(1)\\n            else:\\n                ret.append(0)\\n                \\n        return ret\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # idea: max(depth(A), depth(B)) can only be as low as 1/2 * depth(seq),\\n        #       because otherwise A and B are either (a) not actually VPS\\'s, or\\n        #       (b) do not actually constitute the smallest possible max(depth(A),\\n        #       depth(B)). So, just choose any A and B where depth(A) = depth(B)\\n        #       or depth(A) = depth(B) + 1. They\\'ll be equal if depth(seq) is\\n        #       an even number, otherwise they\\'ll be off by one.\\n        \\n        depthSeq = 0\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            depthSeq = max(depthSeq, curDepth)\\n\\n        ret = []\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            if curDepth > depthSeq//2 or (curDepth == depthSeq//2 and el != \\'(\\'):\\n                ret.append(1)\\n            else:\\n                ret.append(0)\\n                \\n        return ret\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658648,
                "title": "100-faster-only-ternary-operator-used-c-4-lines-of-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    \\n    vector<int> maxDepthAfterSplit(string s) {\\n        int a = 1,b = 0,latest = 0,n = s.size();\\n        vector<int> v(n,0);\\n\\nfor(int i = 1;i<n;i++)(s[i] == \\'(\\')?((latest == 0)? (b++,latest = 1,v[i] = 1):(latest == 1 ? (a++,latest = 0,v[i] =0):0)) : (v[i] = latest,((latest == 0)?(a--,latest = 1):(b--,latest =0)));\\n\\n      return v;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    vector<int> maxDepthAfterSplit(string s) {\\n        int a = 1,b = 0,latest = 0,n = s.size();\\n        vector<int> v(n,0);\\n\\nfor(int i = 1;i<n;i++)(s[i] == \\'(\\')?((latest == 0)? (b++,latest = 1,v[i] = 1):(latest == 1 ? (a++,latest = 0,v[i] =0):0)) : (v[i] = latest,((latest == 0)?(a--,latest = 1):(b--,latest =0)));\\n\\n      return v;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971954,
                "title": "python-binary-search-solution-o-n-log-n",
                "content": "When we\\'re asked for the \"minimum maximum\", it\\'s a very strong hint that we can use binary search.\\n\\nThe solution range is given by the minimum and maximum possible depth of a VPS. The minimum is zero. The maximum is N // 2. For example:\\n```\\nN=0 --> \"\"\\nN=8 --> \"(((())))\"\\n```\\n\\nIf we use a depth that is too small, we won\\'t be able to split the sequence into two VPS while keeping max(depth(A), depth(B)) <= depth.\\n\\nIf we use a depth that is too large, let\\'s say N // 2, we\\'ll be able to keep max(depth(A), depth(B)) <= depth.\\n\\nWe can binary search the minimum possible depth that is going to be enough to split the sequence into two VPS.\\n\\nTo test if a given depth is enough we can use a simple greedy algorithm. We assign as much as we can to string A. Whenever we go above our target depth, the only possible option is assigning what is left to string B.\\n\\nIf both, depth(A) and depth(B) are less than or equal to our target depth, then we\\'ve found a possible answer. However, we need to keep searching until we find the smallest one (optimal answer).\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # T: O(N log(N)), S: O(N)\\n        N = len(seq)\\n        def test(targetDepth, output):\\n            depth, s = [0, 0], 0\\n            maxDepth = 0\\n            for i, c in enumerate(seq):\\n                if c == \\'(\\':\\n                    if depth[0] == targetDepth: s = 1\\n                    depth[s] += 1\\n                    output[i] = s\\n                else:\\n                    depth[s] -= 1\\n                    output[i] = s\\n                    if depth[1] == 0: s = 0\\n\\n                maxDepth = max(maxDepth, depth[0], depth[1])\\n            return maxDepth <= targetDepth\\n\\n        l, r = 0, N // 2\\n        ans = []            \\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            candidate = [0] * N\\n            if test(m, candidate):\\n                ans = candidate\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        return ans\\n\\n```\\n\\nThis solution is suboptimal compared with the linear time ones, but I believe it\\'s still an interesting solution for practicing binary search.\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nN=0 --> \"\"\\nN=8 --> \"(((())))\"\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # T: O(N log(N)), S: O(N)\\n        N = len(seq)\\n        def test(targetDepth, output):\\n            depth, s = [0, 0], 0\\n            maxDepth = 0\\n            for i, c in enumerate(seq):\\n                if c == \\'(\\':\\n                    if depth[0] == targetDepth: s = 1\\n                    depth[s] += 1\\n                    output[i] = s\\n                else:\\n                    depth[s] -= 1\\n                    output[i] = s\\n                    if depth[1] == 0: s = 0\\n\\n                maxDepth = max(maxDepth, depth[0], depth[1])\\n            return maxDepth <= targetDepth\\n\\n        l, r = 0, N // 2\\n        ans = []            \\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            candidate = [0] * N\\n            if test(m, candidate):\\n                ans = candidate\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825291,
                "title": "python-easy-explained-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) # Here m is the maximium depth of the VPS\\n            elif seq[i]==\\')\\': \\n                c-=1\\n        a=[]\\n        m//=2 # Minimum depth possible by breaking string in two parts A and B\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                if c<=m:\\n                    a.append(0) #For A\\n                else:\\n                    a.append(1) #For B\\n            else:\\n                if c<=m:\\n                    a.append(0)\\n                else:\\n                    a.append(1)\\n                c-=1\\n        return a\\n```\\n\\n**Upvote if you like the soluiton or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) # Here m is the maximium depth of the VPS\\n            elif seq[i]==\\')\\': \\n                c-=1\\n        a=[]\\n        m//=2 # Minimum depth possible by breaking string in two parts A and B\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                if c<=m:\\n                    a.append(0) #For A\\n                else:\\n                    a.append(1) #For B\\n            else:\\n                if c<=m:\\n                    a.append(0)\\n                else:\\n                    a.append(1)\\n                c-=1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494917,
                "title": "100-faster-solution-1ms-runtime-java-easy-n-simple",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087484,
                "title": "python-simple-stack-solution",
                "content": "\\n    def maxDepthAfterSplit(self, seq):\\n        stack = [0]\\n        \\n        for i in range(1,len(seq)):\\n            if seq[i] == seq[i-1]:\\n                stack.append(1-stack[i-1])\\n            else:\\n                stack.append(stack[i-1])\\n            \\n        return stack",
                "solutionTags": [],
                "code": "\\n    def maxDepthAfterSplit(self, seq):\\n        stack = [0]\\n        \\n        for i in range(1,len(seq)):\\n            if seq[i] == seq[i-1]:\\n                stack.append(1-stack[i-1])\\n            else:\\n                stack.append(stack[i-1])\\n            \\n        return stack",
                "codeTag": "Python3"
            },
            {
                "id": 1785090,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++){\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1-i & 1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++){\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1-i & 1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587607,
                "title": "java-easy-solution",
                "content": "\\n\\n\\n     class Solution {\\n    public int[] maxDepthAfterSplit(String s) {\\n        \\n        int[] arr = new int[s.length()];\\n        int a=0;\\n        Stack st1 = new Stack();\\n        Stack st2 = new Stack();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               if(st1.size()<=st2.size())\\n               {\\n                   st1.push(\\'(\\');\\n                   arr[a]=0;\\n                   a++;\\n               }\\n               else\\n               {\\n                  st2.push(\\'(\\');\\n                   arr[a]=1;\\n                   a++;    \\n               }\\n            }\\n\\n            \\n            if(s.charAt(i)==\\')\\')\\n            {\\n                if(st1.size()>=st2.size())\\n                {\\n                   st1.pop();\\n                   arr[a]=0;\\n                   a++;\\n                }\\n                else\\n                {\\n                    st2.pop();\\n                    arr[a]=1;\\n                    a++;             \\n                }\\n                \\n            }\\n        }\\n       \\n        return arr;\\n        \\n     }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String s) {\\n        \\n        int[] arr = new int[s.length()];\\n        int a=0;\\n        Stack st1 = new Stack();\\n        Stack st2 = new Stack();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               if(st1.size()<=st2.size())\\n               {\\n                   st1.push(\\'(\\');\\n                   arr[a]=0;\\n                   a++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1467578,
                "title": "c-simple-solution",
                "content": "The idea is to find the \"level\" of each char. Starting from 0, \\nwhen we met \\'(\\' we increase the level by 1\\nwhen we met \\')\\' we decrease the level by 1.\\n\\nSo \"(()())\" becomes \"122221\"\\n\"()()(())\" becomes \"11111221\"\\n\\nThen we try to put the odd leveled chars to string A, and even leveled chars to string B. And that\\'s it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> v(n, 0);\\n        int lvl = 0;\\n        \\n        for(int i=0; i<n; ++i) {\\n            if(seq[i] == \\'(\\') {\\n                lvl++;\\n                v[i] = lvl;\\n            } else {\\n                v[i] = lvl;\\n                lvl--;\\n            }    \\n        }\\n        \\n        for(int i=0; i<n; ++i) {\\n            v[i] = v[i] % 2 == 1 ? 0 : 1;\\n        }\\n        return v;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> v(n, 0);\\n        int lvl = 0;\\n        \\n        for(int i=0; i<n; ++i) {\\n            if(seq[i] == \\'(\\') {\\n                lvl++;\\n                v[i] = lvl;\\n            } else {\\n                v[i] = lvl;\\n                lvl--;\\n            }    \\n        }\\n        \\n        for(int i=0; i<n; ++i) {\\n            v[i] = v[i] % 2 == 1 ? 0 : 1;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295673,
                "title": "easy-greedy-o-n-python",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        \\n        \\n        ans=[]\\n        la=0\\n        lb=0\\n        \\n        for i in range(len(seq)):\\n            \\n            if seq[i]==\\'(\\':\\n                \\n                if la > lb:\\n                    lb+=1\\n                    ans.append(0)\\n                elif lb>la:\\n                    la+=1\\n                    ans.append(1)\\n                else:\\n                    la+=1\\n                    ans.append(1)\\n            else:\\n                if la >0:\\n                    ans.append(1)\\n                    la-=1\\n                elif lb>0:\\n                    ans.append(0)\\n                    lb-=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        \\n        \\n        ans=[]\\n        la=0\\n        lb=0\\n        \\n        for i in range(len(seq)):\\n            \\n            if seq[i]==\\'(\\':\\n                \\n                if la > lb:\\n                    lb+=1\\n                    ans.append(0)\\n                elif lb>la:\\n                    la+=1\\n                    ans.append(1)\\n                else:\\n                    la+=1\\n                    ans.append(1)\\n            else:\\n                if la >0:\\n                    ans.append(1)\\n                    la-=1\\n                elif lb>0:\\n                    ans.append(0)\\n                    lb-=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290392,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int depth = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\') depth++;\\n            ans.push_back(depth%2);\\n            if(seq[i] == \\')\\') depth--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int depth = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\') depth++;\\n            ans.push_back(depth%2);\\n            if(seq[i] == \\')\\') depth--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252877,
                "title": "golang-solution-with-explanation-for-understanding",
                "content": "I wouldn\\'t say that this problem statment is the easiest to understand, so I am going to try to explain it in my own words. Let us say that we have `(())()()` the maximum depth is `2`, because `(())` has a depth of `2` the problem wants us to find two subsequences `A`, and `B`, so that `A` and `B` are both at their minimum depths, and minimum lengths (When we want minimum lengths `seq` has to be split into two pieces) so in the following input, `A` and `B` will be shown:\\n\\ninput := `( ( ) ) ( ) ( )`\\ndepth = `1 2 2 1 1 1 1 1`\\nA and B `A B B A B B A A`\\n\\n```\\nfunc maxDepthAfterSplit(seq string) []int {\\n\\tres := make([]int, len(seq))\\n\\tevenOrOdd := 0\\n\\tfor i, i2 := range seq {\\n\\t\\tif i2 == \\'(\\' {\\n\\t\\t\\tevenOrOdd++\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t} else {\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t\\tevenOrOdd--\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n\\tres := make([]int, len(seq))\\n\\tevenOrOdd := 0\\n\\tfor i, i2 := range seq {\\n\\t\\tif i2 == \\'(\\' {\\n\\t\\t\\tevenOrOdd++\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t} else {\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t\\tevenOrOdd--\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235341,
                "title": "c-0ms-100-easy-to-understand",
                "content": "\\n```\\nvector<int> maxDepthAfterSplit(string &seq) {\\n        vector<int> ans(seq.size());\\n        int a=0,b=0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i]==\\'(\\')\\n                if(a<=b) ans[i]=0, a++;\\n                else ans[i]=1, b++;\\n            else\\n                if(b>0) ans[i]=1, b--;\\n                else ans[i]=0, a--;\\n        }\\n        return ans;\\n    }\\n```\\n# if y0u find it helpful, plz upvote",
                "solutionTags": [],
                "code": "```\\nvector<int> maxDepthAfterSplit(string &seq) {\\n        vector<int> ans(seq.size());\\n        int a=0,b=0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i]==\\'(\\')\\n                if(a<=b) ans[i]=0, a++;\\n                else ans[i]=1, b++;\\n            else\\n                if(b>0) ans[i]=1, b--;\\n                else ans[i]=0, a--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203132,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        depth = 0\\n        for char in seq:\\n          open = char == \\'(\\'\\n          if open:\\n            depth += 1\\n          ans.append(depth % 2) \\n\\t\\t  if not open:\\n            depth -=1\\n\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        depth = 0\\n        for char in seq:\\n          open = char == \\'(\\'\\n          if open:\\n            depth += 1\\n          ans.append(depth % 2) \\n\\t\\t  if not open:\\n            depth -=1\\n\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1170766,
                "title": "c-0ms-faster-than-100-submissions-supa-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans;\\n        bool op=1,cl=1;\\n        for(auto x :seq){\\n            if(x==\\'(\\')\\n                ans.push_back(op),op=!op;\\n            else\\n                ans.push_back(cl),cl=!cl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans;\\n        bool op=1,cl=1;\\n        for(auto x :seq){\\n            if(x==\\'(\\')\\n                ans.push_back(op),op=!op;\\n            else\\n                ans.push_back(cl),cl=!cl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152278,
                "title": "2-variations",
                "content": "**Iffless \"checkerboard\" 1-pass solution : time `O(N)` space `O(1)`**\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/7968f864-ecf8-4c0c-9249-8abfe8aafdc8_1618656610.675834.png)\\n\\n<br>\\n\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\tfor(int i{0}; i<size(s); ++i)\\n\\t\\tout[i]=i+s[i]&1;\\n\\treturn out;\\n}\\n```\\nNote that we don\\'t need to use `\\'(\\'` and `\\')\\'` constants.\\nBTW, due to [operator precedence rules](https://en.cppreference.com/w/cpp/language/operator_precedence): `i+s[i]&1 \\u2261 (i+s[i])&1`.\\n||\\nwith the help of `stl`\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=-1](auto c) mutable { return ++h+c&1; });\\n\\treturn out;\\n}\\n```\\nBTW, `++h+c&1` could be reexpressed in a number of ways.\\nSee [this problem](https://leetcode.com/problems/determine-color-of-a-chessboard-square/discuss/1141116/5-1-liners) for an example. In essence\\n\\n```\\nbool((x+y)&1) \\u2261 bool((x&1)-(y&1)) \\u2261 bool((x-y)&1) \\u2261 bool((x^y)&1) \\u2261 bool((x&1)^(y&1)) \\u2261 bool(x%2!=y%2) \\u2261 bool(x&1!=y&1)\\n```\\n\\n**Intuitive \"height bookkeeping\" 1-pass solution : time `O(N)` space `O(1)`**\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/6c12b767-5f26-4386-abfe-79dd09cf7a56_1618133418.8952794.png)\\n\\n<br>\\n\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out;\\n\\tfor(auto h{0}; const auto & c : s)\\n\\t\\tif(c==\\'(\\') \\n\\t\\t{\\n\\t\\t\\th++;\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t\\th--;\\n\\t\\t}\\n\\treturn out;\\n}\\n```\\n||\\nwith the help of `stl`\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=0](const auto & c) mutable { return c==\\'(\\' and ++h&1 or c==\\')\\' and h--&1; });\\n\\treturn out;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\tfor(int i{0}; i<size(s); ++i)\\n\\t\\tout[i]=i+s[i]&1;\\n\\treturn out;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=-1](auto c) mutable { return ++h+c&1; });\\n\\treturn out;\\n}\\n```\n```\\nbool((x+y)&1) \\u2261 bool((x&1)-(y&1)) \\u2261 bool((x-y)&1) \\u2261 bool((x^y)&1) \\u2261 bool((x&1)^(y&1)) \\u2261 bool(x%2!=y%2) \\u2261 bool(x&1!=y&1)\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out;\\n\\tfor(auto h{0}; const auto & c : s)\\n\\t\\tif(c==\\'(\\') \\n\\t\\t{\\n\\t\\t\\th++;\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t\\th--;\\n\\t\\t}\\n\\treturn out;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=0](const auto & c) mutable { return c==\\'(\\' and ++h&1 or c==\\')\\' and h--&1; });\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000543,
                "title": "max-depth-2",
                "content": "Use the `cnts` as usual for parentheses algorithms to count the depth, and use the `depth` to keep the depth of all parentheses.\\n\\nE.g.,\\n\\n`\"(()())\"`\\n\\nWe have `cnts = [1, 2, 1, 2, 1, 0]`, and `depth = [1, 2, 2, 2, 2, 1]`. \\n\\nNow we know the max depth is 2, so we use max-depth / 2 = 1 to separate two VPs: `depth <= 1` is one and otherwise the other.\\n\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cnts = [0] * len(seq)\\n        depth = [0] * len(seq)\\n        \\n        cnts[0] = 1  # for VPs\\n        depth[0] = 1\\n        \\n        for i in range(1, len(seq)):\\n            if seq[i] == \\'(\\':\\n                cnts[i] = cnts[i-1] + 1\\n                depth[i] = cnts[i]\\n            else:\\n                cnts[i] = cnts[i-1] - 1\\n                depth[i] = cnts[i-1]\\n        \\n        res = [0 if x <= max(cnts) // 2 else 1 for x in depth]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cnts = [0] * len(seq)\\n        depth = [0] * len(seq)\\n        \\n        cnts[0] = 1  # for VPs\\n        depth[0] = 1\\n        \\n        for i in range(1, len(seq)):\\n            if seq[i] == \\'(\\':\\n                cnts[i] = cnts[i-1] + 1\\n                depth[i] = cnts[i]\\n            else:\\n                cnts[i] = cnts[i-1] - 1\\n                depth[i] = cnts[i-1]\\n        \\n        res = [0 if x <= max(cnts) // 2 else 1 for x in depth]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976339,
                "title": "greedy-solution-in-cpp-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int a = 0;\\n        int b = 0;\\n        for(int i = 0; i < seq.size(); i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(a == 0 or a <= b) {\\n                    ans[i] = 0;\\n                    a++;\\n                }\\n                else {\\n                    ans[i] = 1;\\n                    b++;\\n                }\\n            }\\n            else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }\\n                else {\\n                    ans[i] = 0;\\n                    a--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int a = 0;\\n        int b = 0;\\n        for(int i = 0; i < seq.size(); i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(a == 0 or a <= b) {\\n                    ans[i] = 0;\\n                    a++;\\n                }\\n                else {\\n                    ans[i] = 1;\\n                    b++;\\n                }\\n            }\\n            else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }\\n                else {\\n                    ans[i] = 0;\\n                    a--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911805,
                "title": "easy-python",
                "content": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        c=0\\n        s=seq\\n        a=[0]*len(s)\\n        \\n        for i in range(len(s)):\\n            \\n            if c == 0:\\n                c = c+1\\n                if s[i] == \\'(\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            elif c == 1:\\n                c = c-1\\n                if s[i] == \\')\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            \\n        return a",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        c=0\\n        s=seq\\n        a=[0]*len(s)\\n        \\n        for i in range(len(s)):\\n            \\n            if c == 0:\\n                c = c+1\\n                if s[i] == \\'(\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            elif c == 1:\\n                c = c-1\\n                if s[i] == \\')\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            \\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 868492,
                "title": "simple-c-greedy-solution-o-n",
                "content": "/*\\n    Simple greedy solution\\n    1. push all indices that have opening bracket character in one queue\\n    2. push all indices that have closing bracket character in another queue\\n    3. match fronts of both queue alternatively.\\n*/\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n\\t\\t\\tint n = seq.size();\\n        \\tvector<int> ans(n, -1);\\n\\t\\t\\tqueue<int> qo;\\n\\t\\t\\tqueue<int> qc;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(seq[i] == \\'(\\')\\n\\t\\t\\t\\t\\tqo.push(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tqc.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tint u, v;\\n\\t\\t\\twhile(!qo.empty()){\\n\\t\\t\\t\\tu = qo.front();\\n\\t\\t\\t\\tqo.pop();\\n\\t\\t\\t\\tv = qc.front();\\n\\t\\t\\t\\tqc.pop();\\n\\t\\t\\t\\tans[u] = ans[v] = carry;\\n\\t\\t\\t\\tcarry = 1 - carry;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n\\t\\t\\tint n = seq.size();\\n        \\tvector<int> ans(n, -1);\\n\\t\\t\\tqueue<int> qo;\\n\\t\\t\\tqueue<int> qc;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(seq[i] == \\'(\\')\\n\\t\\t\\t\\t\\tqo.push(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tqc.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tint u, v;\\n\\t\\t\\twhile(!qo.empty()){\\n\\t\\t\\t\\tu = qo.front();\\n\\t\\t\\t\\tqo.pop();\\n\\t\\t\\t\\tv = qc.front();\\n\\t\\t\\t\\tqc.pop();\\n\\t\\t\\t\\tans[u] = ans[v] = carry;\\n\\t\\t\\t\\tcarry = 1 - carry;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832816,
                "title": "python-simple-solution",
                "content": "To translate the problem, actually it is looking to group the valid patenthesis into two groups. If there are multiple levels of (), what we need is to put the levels 1, 3, 5.. to one group, and levels 0, 2, 4, 6... to the other group. To do this, we can use a stack to track the number of \\'(\\'. When we encouter an odd number of this count, we can assign it to group number 1.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        dq = deque()\\n        for i, s in enumerate(seq):\\n            if s == \\'(\\':\\n                dq.append(i)\\n            if s == \\')\\':\\n                if len(dq) % 2 == 0:\\n                    res[dq[-1]] = 1\\n                    res[i] = 1\\n                dq.pop()\\n            \\n        return res",
                "solutionTags": [],
                "code": "To translate the problem, actually it is looking to group the valid patenthesis into two groups. If there are multiple levels of (), what we need is to put the levels 1, 3, 5.. to one group, and levels 0, 2, 4, 6... to the other group. To do this, we can use a stack to track the number of \\'(\\'. When we encouter an odd number of this count, we can assign it to group number 1.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        dq = deque()\\n        for i, s in enumerate(seq):\\n            if s == \\'(\\':\\n                dq.append(i)\\n            if s == \\')\\':\\n                if len(dq) % 2 == 0:\\n                    res[dq[-1]] = 1\\n                    res[i] = 1\\n                dq.pop()\\n            \\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 765308,
                "title": "easy-python-with-explanation",
                "content": "o mean which one is open and c mean which one is close also best answer occurs when both the nesting are aqual (reason: think of A.M. and G.M. inequality)\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, s: str) -> List[int]:\\n        o=0\\n        c=0\\n        ans=[0]*(len(s))\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                ans[i]=o\\n                o^=1\\n            else:\\n                ans[i]=c\\n                c^=1\\n        return ans\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, s: str) -> List[int]:\\n        o=0\\n        c=0\\n        ans=[0]*(len(s))\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                ans[i]=o\\n                o^=1\\n            else:\\n                ans[i]=c\\n                c^=1\\n        return ans\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 726077,
                "title": "a-simple-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int[] maxDepthAfterSplit(String seq) \\n    {\\n        int l=0;\\n        int[] result=new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++)\\n        {\\n            if(seq.charAt(i)==\\'(\\')\\n            {\\n                l++;\\n                if(l%2==0)\\n                    result[i]=1;\\n            }\\n            else\\n            {\\n                if(l%2==0)\\n                    result[i]=1;\\n                l--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] maxDepthAfterSplit(String seq) \\n    {\\n        int l=0;\\n        int[] result=new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++)\\n        {\\n            if(seq.charAt(i)==\\'(\\')\\n            {\\n                l++;\\n                if(l%2==0)\\n                    result[i]=1;\\n            }\\n            else\\n            {\\n                if(l%2==0)\\n                    result[i]=1;\\n                l--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724205,
                "title": "python-simple-greedy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n        foo = lambda x: 1 if seq[x]==\"(\" else -1\\n\\n        # get max depth // 2 \\n        m = max(itertools.accumulate(map(foo, range(len(seq))))) // 2\\n        \\n        # variable to store if we are in above depth \"m\"\\n        inSecond = 0\\n        \\n        # stores result\\n        res = []\\n\\n        # loop through all seq and keep track of sum \"i\" given by {-1 for \\')\\' and +1 for \"(\" }\\n        # if we are in above depth \"m\" (we are in second subset) append 1 else if after going into\\n        # second subset the depth is less than \"m\", we are now in first subset append 0\\n        for i in itertools.accumulate(map(foo, range(len(seq)))):\\n            if i<m:\\tinSecond = 0\\n            if i>m:\\tinSecond = 1\\n            res.append(inSecond)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n        foo = lambda x: 1 if seq[x]==\"(\" else -1\\n\\n        # get max depth // 2 \\n        m = max(itertools.accumulate(map(foo, range(len(seq))))) // 2\\n        \\n        # variable to store if we are in above depth \"m\"\\n        inSecond = 0\\n        \\n        # stores result\\n        res = []\\n\\n        # loop through all seq and keep track of sum \"i\" given by {-1 for \\')\\' and +1 for \"(\" }\\n        # if we are in above depth \"m\" (we are in second subset) append 1 else if after going into\\n        # second subset the depth is less than \"m\", we are now in first subset append 0\\n        for i in itertools.accumulate(map(foo, range(len(seq)))):\\n            if i<m:\\tinSecond = 0\\n            if i>m:\\tinSecond = 1\\n            res.append(inSecond)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647490,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 1;\\n        vector<int> res;\\n        for (char c:seq){\\n            if (c==\\'(\\'){\\n                cur = (cur+1)%2;\\n                res.push_back(cur);\\n            }else{\\n                res.push_back(cur);\\n                cur = (cur+1)%2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 1;\\n        vector<int> res;\\n        for (char c:seq){\\n            if (c==\\'(\\'){\\n                cur = (cur+1)%2;\\n                res.push_back(cur);\\n            }else{\\n                res.push_back(cur);\\n                cur = (cur+1)%2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597444,
                "title": "python-beats-99-very-easy-solution-with-explanations",
                "content": "- The only key idea to use is: when we have a nested parentheses string, we distribute them equally by having each nest belong to alternating groups.\\n- In order to achieve this, we use a binary variable ```tmp``` which only switches value when we encounter two consecutive identical symbols, to alternate the membership.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t# tmp is either 0 or 1\\n        tmp, res = 0, []\\n        for i, c in enumerate(seq[:-1]):\\n\\t\\t\\t# if \"((\" or \"))\", change tmp after appending\\n            if c == seq[i + 1]:\\n                res.append(tmp)\\n                tmp ^= 1\\n            else:\\n                res.append(tmp)\\n        return res + [tmp]\\n```",
                "solutionTags": [],
                "code": "```tmp```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t# tmp is either 0 or 1\\n        tmp, res = 0, []\\n        for i, c in enumerate(seq[:-1]):\\n\\t\\t\\t# if \"((\" or \"))\", change tmp after appending\\n            if c == seq[i + 1]:\\n                res.append(tmp)\\n                tmp ^= 1\\n            else:\\n                res.append(tmp)\\n        return res + [tmp]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595738,
                "title": "python3-90-speed-100-space-proof-included",
                "content": "```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t## represent left parentheses to close\\n        A,B = 0\\n        answer = []\\n        for s in seq:\\n            if s == \\'(\\':\\n                if B < A:\\n                    B += 1\\n                    answer.append(1)\\n                else:\\n                    A += 1\\n                    answer.append(0)\\n            else:\\n                if B < A:\\n                    A -= 1\\n                    answer.append(0)\\n                else:\\n                    B -= 1\\n                    answer.append(1)\\n        return answer\\n```\\n\\nProof that this algorithm creates a splitting with minimal depth: Let n_i be the number of left parenthesis between indices [0,i] and m_i by the number of right parenthesis between [0,i]. The two claims together combine to a proof.\\n\\nClaim 1: Every splitting has depth at least max_i ceil((n_i - m_i) / 2). At point i, we have seen n_i - m_i more left parentheses than right parentheses. No matter the splitting of parentheses between A and B, one of A or B will have ceil((n_i - m_i) / 2) left parentheses that have not been closed. So the depth must be at least ceil((n_i - m_i) / 2) and this is true for every index i.\\n\\nClaim 2: The above code produces a splitting with depth at most max_i ceil((n_i - m_i) / 2). A and B represent that amount of left parentheses to close in each string. A and B are updated at each step so that their difference is at most 1. Since A+B = n_i - m_i at every step in the loop, max(A,B) = ceil((n_i - m_i)/2). Therefore, A and B are always less than or equal to max_i ceil((n_i - m_i)/2). Since A and B represent the number of left parentheses to close, the maximum they reach is the depth of the strings, which shows the claim.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t## represent left parentheses to close\\n        A,B = 0\\n        answer = []\\n        for s in seq:\\n            if s == \\'(\\':\\n                if B < A:\\n                    B += 1\\n                    answer.append(1)\\n                else:\\n                    A += 1\\n                    answer.append(0)\\n            else:\\n                if B < A:\\n                    A -= 1\\n                    answer.append(0)\\n                else:\\n                    B -= 1\\n                    answer.append(1)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558675,
                "title": "rust-one-expression-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        seq.chars().scan(0, |d, c| {\\n            if c == \\'(\\' {\\n                *d += 1;\\n                Some(*d & 1)\\n            } else {\\n                *d -= 1;\\n                Some((*d + 1) & 1)\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        seq.chars().scan(0, |d, c| {\\n            if c == \\'(\\' {\\n                *d += 1;\\n                Some(*d & 1)\\n            } else {\\n                *d -= 1;\\n                Some((*d + 1) & 1)\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535654,
                "title": "swift-stack-solution",
                "content": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        var stack:[Character] = []\\n        let arr = Array(seq)\\n        var res:[Int] = []\\n        for item in arr{\\n            if item == \"(\"{\\n                res.append(stack.count%2)\\n                stack.append(item)\\n            }else if item == \")\"{\\n                stack.removeLast()\\n                res.append(stack.count%2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        var stack:[Character] = []\\n        let arr = Array(seq)\\n        var res:[Int] = []\\n        for item in arr{\\n            if item == \"(\"{\\n                res.append(stack.count%2)\\n                stack.append(item)\\n            }else if item == \")\"{\\n                stack.removeLast()\\n                res.append(stack.count%2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529194,
                "title": "rust-5-lines-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut res = vec![0]; \\n        let cs:Vec<char> = seq.chars().collect();\\n        for i in 1..seq.len() {\\n            res.push(if cs[i] == \\'(\\' { i as i32 & 1 } else { 1 - (i as i32 & 1)});\\n        }\\n        res \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut res = vec![0]; \\n        let cs:Vec<char> = seq.chars().collect();\\n        for i in 1..seq.len() {\\n            res.push(if cs[i] == \\'(\\' { i as i32 & 1 } else { 1 - (i as i32 & 1)});\\n        }\\n        res \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461180,
                "title": "python-3-beats-95-readable",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, P: str) -> List[int]:\\n        D, A, v = {\\'(\\':1, \\')\\':-1}, [], 0\\n        for p in P:\\n            if v*D[p] > 0:\\n                v -= D[p]\\n                A.append(0)\\n            else:\\n                v += D[p]\\n                A.append(1)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, P: str) -> List[int]:\\n        D, A, v = {\\'(\\':1, \\')\\':-1}",
                "codeTag": "Java"
            },
            {
                "id": 423375,
                "title": "i-don-t-know-how-i-solved-that-may-be-someone-else-will-understand-this",
                "content": "I genuinely do not know how I came up with that but it works. My brain just told me to type this and I am serious.\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A, B,ans = 0,0,[]\\n        for c in seq:\\n            if c == \"(\":\\n                if A>=B:\\n                    ans.append(1)\\n                    B += 1\\n                else:\\n                    ans.append(0)\\n                    A += 1\\n            else:\\n                if A>=B:\\n                    ans.append(0)\\n                    A -= 1\\n                else:\\n                    ans.append(1)\\n                    B -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A, B,ans = 0,0,[]\\n        for c in seq:\\n            if c == \"(\":\\n                if A>=B:\\n                    ans.append(1)\\n                    B += 1\\n                else:\\n                    ans.append(0)\\n                    A += 1\\n            else:\\n                if A>=B:\\n                    ans.append(0)\\n                    A -= 1\\n                else:\\n                    ans.append(1)\\n                    B -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383271,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut cur_group = 0;\\n        let mut setup = vec![];\\n        let mut stack = vec![]; //para stack\\n        \\n        seq.chars().for_each(|ch| {\\n            match ch {\\n                \\'(\\' =>{\\n                    if !stack.is_empty() {\\n                        cur_group = 1 - cur_group;\\n                    }\\n                    setup.push(cur_group);\\n                    stack.push(cur_group);\\n                }\\n                \\')\\' =>{\\n                    setup.push(stack.pop().unwrap());\\n                    cur_group = 1 - cur_group;\\n                }\\n                _ => {/**/}\\n            }\\n        });\\n        setup\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut cur_group = 0;\\n        let mut setup = vec![];\\n        let mut stack = vec![]; //para stack\\n        \\n        seq.chars().for_each(|ch| {\\n            match ch {\\n                \\'(\\' =>{\\n                    if !stack.is_empty() {\\n                        cur_group = 1 - cur_group;\\n                    }\\n                    setup.push(cur_group);\\n                    stack.push(cur_group);\\n                }\\n                \\')\\' =>{\\n                    setup.push(stack.pop().unwrap());\\n                    cur_group = 1 - cur_group;\\n                }\\n                _ => {/**/}\\n            }\\n        });\\n        setup\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 343699,
                "title": "no-stack-no-recursion-python-o-n-solution",
                "content": "check if current char is in a nested parenthesis, if it is, label it differently from previous\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*len(seq)\\n        for i in xrange(1,len(seq)):\\n            if seq[i] != seq[i-1]:\\n                res[i] = res[i-1]\\n            else:\\n                if res[i-1] == 1:\\n                    res[i] = 0\\n                else:\\n                    res[i] = 1\\n        return res",
                "solutionTags": [],
                "code": "check if current char is in a nested parenthesis, if it is, label it differently from previous\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*len(seq)\\n        for i in xrange(1,len(seq)):\\n            if seq[i] != seq[i-1]:\\n                res[i] = res[i-1]\\n            else:\\n                if res[i-1] == 1:\\n                    res[i] = 0\\n                else:\\n                    res[i] = 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 332815,
                "title": "simply-c-solution-with-explanation",
                "content": "The idea is to visualize the parentheses as a line plot.\\nFor those segments on even levels, we assign it to first group; otherwise, we assign it to second group.\\nThe remaining is just implementation details.\\n```\\n   /\\\\   ---- odd level\\n/\\\\/  \\\\  ---- even level\\n```\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int level = 0;\\n        vector<int> ans;\\n        for (char c : seq) {\\n            ans.push_back((level % 2 == 0 && c == \\'(\\') || (level % 2 == 1 && c == \\')\\'));\\n            ++level;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n   /\\\\   ---- odd level\\n/\\\\/  \\\\  ---- even level\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int level = 0;\\n        vector<int> ans;\\n        for (char c : seq) {\\n            ans.push_back((level % 2 == 0 && c == \\'(\\') || (level % 2 == 1 && c == \\')\\'));\\n            ++level;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329109,
                "title": "o-1-space-concise-python-solution",
                "content": "Alternate between choice of using a new opening parenthesis in subsequence A or B. Swap the choice before considering whichsubsequence to put a closing parenthesis in. \\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        l = True\\n        s = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                s[i] = int(l)\\n                l =  not l\\n            else:\\n                l = not l\\n                s[i] = int(l)\\n        return s\\n      \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        l = True\\n        s = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                s[i] = int(l)\\n                l =  not l\\n            else:\\n                l = not l\\n                s[i] = int(l)\\n        return s\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 328918,
                "title": "javascript-straight-forward-stack-solution-with-explanation",
                "content": "I used 2 stacks to track the status.\\nWhen we loop through the seq, if it\\'s \"(\", we push it to one of the stack, if it\\'s \")\", we pop it from one of the stack.\\nHow to decide which stack to go? Our default choice is `stack0`, but final choice depends on our current `seq[i]` and the length of `stack0` and `stack1`, which is the logic in the code.\\n\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    let res = new Array(seq.length).fill(0);\\n    let stack0 = [];\\n    let stack1 = [];\\n    \\n    for(let i=0; i<seq.length; i++){\\n        if(seq[i] === \"(\"){\\n            if(stack0 <= stack1) {\\n                stack0.push(\"(\");\\n                res[i] = 0;\\n            } else {\\n                stack1.push(\"(\");\\n                res[i] = 1;\\n            }\\n        } else {\\n            if(stack0 <= stack1){\\n                stack1.pop();\\n                res[i] = 1;\\n            } else {\\n                stack0.pop();\\n                res[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDepthAfterSplit = function(seq) {\\n    let res = new Array(seq.length).fill(0);\\n    let stack0 = [];\\n    let stack1 = [];\\n    \\n    for(let i=0; i<seq.length; i++){\\n        if(seq[i] === \"(\"){\\n            if(stack0 <= stack1) {\\n                stack0.push(\"(\");\\n                res[i] = 0;\\n            } else {\\n                stack1.push(\"(\");\\n                res[i] = 1;\\n            }\\n        } else {\\n            if(stack0 <= stack1){\\n                stack1.pop();\\n                res[i] = 1;\\n            } else {\\n                stack0.pop();\\n                res[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328898,
                "title": "simple-java-solution",
                "content": "Tracking the outermost parentheses.\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] depth = new int[seq.length()];\\n        int stack = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                stack++;\\n                if (stack == 1) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            } else {\\n                stack--;\\n                if (stack == 0) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] depth = new int[seq.length()];\\n        int stack = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                stack++;\\n                if (stack == 1) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            } else {\\n                stack--;\\n                if (stack == 0) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328897,
                "title": "java-concise-code",
                "content": "```\\npublic int[] maxDepthAfterSplit(String seq) {\\n        char[] tem = seq.toCharArray();\\n        int[] res = new int[seq.length()];\\n        int level = -1;\\n        for (int i = 0; i < tem.length; i++) {\\n            if (tem[i] == \\'(\\') {\\n                level++;\\n                res[i] = level % 2;\\n            } else {\\n                res[i] = level % 2;\\n                level--;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] maxDepthAfterSplit(String seq) {\\n        char[] tem = seq.toCharArray();\\n        int[] res = new int[seq.length()];\\n        int level = -1;\\n        for (int i = 0; i < tem.length; i++) {\\n            if (tem[i] == \\'(\\') {\\n                level++;\\n                res[i] = level % 2;\\n            } else {\\n                res[i] = level % 2;\\n                level--;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 328885,
                "title": "simple-java-solution-with-explaination",
                "content": "**Intuitive:**\\nIn order to make the depth of two groups as close as possible, we select parenthesis with levels at interval. \\n\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] res = new int[n];\\n        int lv = 0; // level\\n        for (int i = 0; i < n; i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                lv++;\\n                res[i] = lv % 2;  \\n            } else {\\n                res[i] = lv % 2;         \\n                lv--;\\n            }    \\n        }       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] res = new int[n];\\n        int lv = 0; // level\\n        for (int i = 0; i < n; i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                lv++;\\n                res[i] = lv % 2;  \\n            } else {\\n                res[i] = lv % 2;         \\n                lv--;\\n            }    \\n        }       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328844,
                "title": "simple-and-short-python-stack-based",
                "content": "The idea is to choose different depths for each nested level.\\nWhen there is a nesting, we determine the current level\\'s 0/1 value based on the opposite of the previous nesting.\\n\\n```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res, stack = [], []\\n        init = 1\\n        for ch in seq:        \\n            if not stack:\\n                init = init ^ 1\\n                stack.append(init)\\n                res.append(init)\\n            elif ch == \"(\":\\n                stack.append(stack[-1]^1)\\n                res.append(stack[-1])\\n            else:\\n                res.append(stack.pop())\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res, stack = [], []\\n        init = 1\\n        for ch in seq:        \\n            if not stack:\\n                init = init ^ 1\\n                stack.append(init)\\n                res.append(init)\\n            elif ch == \"(\":\\n                stack.append(stack[-1]^1)\\n                res.append(stack[-1])\\n            else:\\n                res.append(stack.pop())\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093425,
                "title": "simple-alternating-class-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n We assign each VPS to either A or B via a class parameter. The intuition is nuanced but to find the disjoint subsequence of VPS with minimum depth for max(depth(A), depth(B)), then essentially all we need to do is find minimum depth for split for the sequence. We need split the nested VPS\\'s with max depth. The trick is to see the following: 1) if we have ((())) and we need to split it so as to have minimum depth as outlined in problem, then we can assing the outer bracket (first nested bracket) to class 0, the second nested bracket to class 1 and the third bracket (that is not nested) again to class 0. The maximum depth would be 2 and this would be the minimal depth given the problem constraint. To this end, a simple solution is as follows:\\n1) Whenever we encounter a nested bracket we alternate our class, if previosely 0, then for next layer of the nested bracket it is turned to zero.\\n2) for \"summed\" VPS\\'s we do not change the class, that is if we have the following situation: ()(), as the depth does not change.   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n#\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n#\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n\\n        stack_ = []\\n        N_stack = 0 \\n        arr_ = []\\n        class_ = 0\\n\\n        for seq_ in seq:\\n            if seq_==\")\":\\n                class_ = 1 - class_\\n                stack_  =stack_[1:]\\n                N_stack-=1\\n                arr_ +=[class_]\\n            else:\\n                arr_+=[class_]\\n                stack_ +=[\"(\"]\\n                class_ = 1 - class_\\n                N_stack +=1\\n                \\n\\n        return(arr_)    \\n                 \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n\\n        stack_ = []\\n        N_stack = 0 \\n        arr_ = []\\n        class_ = 0\\n\\n        for seq_ in seq:\\n            if seq_==\")\":\\n                class_ = 1 - class_\\n                stack_  =stack_[1:]\\n                N_stack-=1\\n                arr_ +=[class_]\\n            else:\\n                arr_+=[class_]\\n                stack_ +=[\"(\"]\\n                class_ = 1 - class_\\n                N_stack +=1\\n                \\n\\n        return(arr_)    \\n                 \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081669,
                "title": "c-less-than-10-lines-beats-100-in-runtime",
                "content": "# Intuition\\nIf we want to decrease the depths of the two VPS A and B we can not include the deepest substring of the given VPS seq in any of the two. We must divide it in the two equally as possible. So here I have assigned them alternately.\\n\\n# Approach\\nSince the first character will always be \\'(\\' we can assign it to any one (I assigned it to A, i.e. 0)\\nIf the second character is also \\'(\\' that means the depth is increasing so we must put this character in the other VPS (which will be B in this case)\\nBut if it is \\')\\' then we must put it in the same VPS as previous one (A in this case) for it to be the valid VPS\\nSo we conclude that if the current character is same as the previous character then we change the VPS and if the character is different then we keep the VPS same\\n\\nExample: (()())    \\nDepth is increasing At index 1 and the previous and current characters are same so the VPS must be changed from 0 to 1. So our ans becomes {0, 1} \\nAt index 2 we got \\')\\' and the last char was \\'(\\' so the VPS must be same {0, 1, 1}\\nAt index 3 we got another \\'(\\' but the last char was also \\')\\' so we will not change the VPS {0, 1, 1, 1}\\nAt index 4 \\')\\' and the previous character was \\'(\\'. Different character same VPS {0, 1, 1, 1, 1}\\nAt index 5 \\')\\'and the previous character was \\')\\'. Same character change the VPS (from 1 to 0) resulting in the final answer {0, 1, 1, 1, 1, 0}.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> ans (n);\\n        ans[0] = 0;\\n\\n        for (int i = 1, j = 0; i < n; ++i, ++j) {\\n            ans[i] = (seq[j] == seq[i]) ? !ans[j] : ans[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> ans (n);\\n        ans[0] = 0;\\n\\n        for (int i = 1, j = 0; i < n; ++i, ++j) {\\n            ans[i] = (seq[j] == seq[i]) ? !ans[j] : ans[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961685,
                "title": "maximum-nesting-depth-of-two-valid-parentheses-strings-two-approach-easy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n       /* stack<int>st,st1;\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<seq.size();i++){\\n            if(seq[i]==\\'(\\'&&count==0){\\n                st.push(seq[i]);\\n                ans.push_back(0);\\n                count++;\\n            }\\n            else if(seq[i]==\\'(\\'&&count>0){\\n                st1.push(seq[i]);\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&count>0&&!st1.empty()){\\n                st1.pop();\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&st1.empty()){\\n                st.pop();\\n                ans.push_back(0);\\n                count--;\\n            }*/\\n    vector<int>ans;\\n    int count=0;\\n    for(int i=0;i<seq.size();i++){\\n        if(seq[i]==\\'(\\'){\\n            count++;\\n            ans.push_back(count%2);\\n        }else{\\n            ans.push_back(count%2);\\n            count--;\\n        }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n       /* stack<int>st,st1;\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<seq.size();i++){\\n            if(seq[i]==\\'(\\'&&count==0){\\n                st.push(seq[i]);\\n                ans.push_back(0);\\n                count++;\\n            }\\n            else if(seq[i]==\\'(\\'&&count>0){\\n                st1.push(seq[i]);\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&count>0&&!st1.empty()){\\n                st1.pop();\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&st1.empty()){\\n                st.pop();\\n                ans.push_back(0);\\n                count--;\\n            }*/\\n    vector<int>ans;\\n    int count=0;\\n    for(int i=0;i<seq.size();i++){\\n        if(seq[i]==\\'(\\'){\\n            count++;\\n            ans.push_back(count%2);\\n        }else{\\n            ans.push_back(count%2);\\n            count--;\\n        }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959829,
                "title": "maximum-nesting-depth-of-two-valid-parentheses-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- just divide \\'()\\' into two groups , either 0 o 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Brute-Force Approach:**\\nIterate through the parentheses, assigning different depths to alternating groups. However, this doesn\\'t ensure balanced groups. Time: O(n), Space: O(n).\\n\\n- **Optimal Approach:**\\nAssign alternating group numbers to opening and closing parentheses, ensuring balanced groups. Traverse input once. Time: O(n), Space: O(n). This approach maintains equal maximum depths in two separate balanced groups of parentheses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> ans; // To store the assigned group numbers\\n        int group = 0;   // Initialize group number (0 or 1)\\n\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                ans.push_back(group);      // Assign current group to opening parenthesis\\n                group = 1 - group;        // Alternate the group number between 0 and 1\\n            } else {\\n                group = 1 - group;        // Alternate the group number for closing parenthesis\\n                ans.push_back(group);      // Assign the opposite group to closing parenthesis\\n            }\\n        }\\n\\n        return ans; // Return the assigned group numbers\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> ans; // To store the assigned group numbers\\n        int group = 0;   // Initialize group number (0 or 1)\\n\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                ans.push_back(group);      // Assign current group to opening parenthesis\\n                group = 1 - group;        // Alternate the group number between 0 and 1\\n            } else {\\n                group = 1 - group;        // Alternate the group number for closing parenthesis\\n                ans.push_back(group);      // Assign the opposite group to closing parenthesis\\n            }\\n        }\\n\\n        return ans; // Return the assigned group numbers\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916548,
                "title": "run-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        st = deque()\\n        out = []\\n\\n        for i in range(len(seq)):\\n            if not len(st) and seq[i] == \"(\" :\\n                depth = 1\\n                st.append((seq[i],depth))\\n                out.append(0)\\n            elif len(st) and seq[i] == \"(\" :\\n                depth = 1+st[-1][1]\\n                st.append((seq[i],depth))\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n            elif len(st) and seq[i] == \")\" :\\n                depth = st[-1][1]\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n                st.pop()\\n        return out \\n            \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        st = deque()\\n        out = []\\n\\n        for i in range(len(seq)):\\n            if not len(st) and seq[i] == \"(\" :\\n                depth = 1\\n                st.append((seq[i],depth))\\n                out.append(0)\\n            elif len(st) and seq[i] == \"(\" :\\n                depth = 1+st[-1][1]\\n                st.append((seq[i],depth))\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n            elif len(st) and seq[i] == \")\" :\\n                depth = st[-1][1]\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n                st.pop()\\n        return out \\n            \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862328,
                "title": "100-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s){\\n        vector<int>v;\\n        int mx=0;\\n        for(auto i:s){\\n            if(i==\\'(\\'){\\n                mx++;\\n            }\\n            v.push_back(mx&1);\\n            if(i==\\')\\'){\\n                mx--;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s){\\n        vector<int>v;\\n        int mx=0;\\n        for(auto i:s){\\n            if(i==\\'(\\'){\\n                mx++;\\n            }\\n            v.push_back(mx&1);\\n            if(i==\\')\\'){\\n                mx--;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857315,
                "title": "easy-n-simple-0ms-runtime-100-faster",
                "content": "\\n# Complexity\\n time complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856989,
                "title": "use-flags",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution lies in the observation that the difference in nesting depth between two groups of parentheses can be maximized by alternating their handling of opening and closing parentheses. By doing so, the depth of one group will consistently be one level less than the other, leading to a balanced distribution of nested parentheses. This approach effectively minimizes the common depth between the two groups while maintaining overall balance, resulting in the maximum possible nesting depth difference between the groups.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key approach in this solution is to maintain two boolean flags, opening_A_turn and closing_A_turn, which determine the turn for two different groups. These flags alternate their states based on whether an opening or closing parenthesis is encountered. When an opening parenthesis is encountered, the flag associated with that group is toggled, and the corresponding group index is assigned to the current position in the output array. Similarly, when a closing parenthesis is encountered, the flag for the other group is toggled, and its index is assigned to the output array. This alternating mechanism ensures that the two groups take turns in handling the parentheses, leading to a balanced distribution of nested parentheses and maximizing the difference in nesting depth between the two groups.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nStore index and the group which it belongs to in a map\\nConvert this into an array\\n*/\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> OutputArr(seq.size(),-1);\\n        bool opening_A_turn = true;\\n        bool closing_A_turn = true;\\n\\n        for(int i=0; i<seq.size(); i++){\\n            char curr = seq[i];\\n            // ( and A turn\\n            if(curr == \\'(\\' && opening_A_turn){\\n                OutputArr[i] = 0;\\n                opening_A_turn = !opening_A_turn;\\n            }\\n            // ( and B turn\\n            else if(curr == \\'(\\' && !opening_A_turn ){\\n                OutputArr[i] = 1;\\n                opening_A_turn= !opening_A_turn;\\n            }\\n            // ) and A turn\\n            else if(curr == \\')\\' && closing_A_turn){\\n                OutputArr[i] = 0;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n            // ) and B turn\\n            else{\\n                OutputArr[i] = 1;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n/*\\nStore index and the group which it belongs to in a map\\nConvert this into an array\\n*/\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> OutputArr(seq.size(),-1);\\n        bool opening_A_turn = true;\\n        bool closing_A_turn = true;\\n\\n        for(int i=0; i<seq.size(); i++){\\n            char curr = seq[i];\\n            // ( and A turn\\n            if(curr == \\'(\\' && opening_A_turn){\\n                OutputArr[i] = 0;\\n                opening_A_turn = !opening_A_turn;\\n            }\\n            // ( and B turn\\n            else if(curr == \\'(\\' && !opening_A_turn ){\\n                OutputArr[i] = 1;\\n                opening_A_turn= !opening_A_turn;\\n            }\\n            // ) and A turn\\n            else if(curr == \\')\\' && closing_A_turn){\\n                OutputArr[i] = 0;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n            // ) and B turn\\n            else{\\n                OutputArr[i] = 1;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756090,
                "title": "python-90-faster-clear-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/e118239d-09dd-49b8-b343-918fd195d191_1689183834.8018787.png)\\n\\n\\nI was very confused by this problem, but after looking at some of the testcases, what we have to return is if the depth is odd, we have to return 0, and if it is even, we have to return 1, or I think we can do vice versa. Below is clear and simple code for checking the depth and returning the result respectively.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack=[]\\n        oc=0\\n        res=[]\\n        for i in seq:\\n            if i==\"(\":\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n                oc+=1\\n            else:\\n                oc-=1\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack=[]\\n        oc=0\\n        res=[]\\n        for i in seq:\\n            if i==\"(\":\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n                oc+=1\\n            else:\\n                oc-=1\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696753,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        ans.reserve(seq.size());\\n\\n        int a = 0;\\n        int b = 0;\\n        for(char& ch : seq) {\\n            if (ch == \\')\\') {\\n                if (a > b) {\\n                    ans.push_back(0);\\n                    a--;\\n                } else {\\n                    ans.push_back(1);\\n                    b--;\\n                }\\n            } else {\\n                if (a > b) {\\n                    ans.push_back(1);\\n                    b++;\\n                } else {\\n                    ans.push_back(0);\\n                    a++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        ans.reserve(seq.size());\\n\\n        int a = 0;\\n        int b = 0;\\n        for(char& ch : seq) {\\n            if (ch == \\')\\') {\\n                if (a > b) {\\n                    ans.push_back(0);\\n                    a--;\\n                } else {\\n                    ans.push_back(1);\\n                    b--;\\n                }\\n            } else {\\n                if (a > b) {\\n                    ans.push_back(1);\\n                    b++;\\n                } else {\\n                    ans.push_back(0);\\n                    a++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659860,
                "title": "c-easy-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n    int k=0;\\n    vector<int> ans(s.size(),0);\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'(\\')\\n        {\\n            k++;\\n            ans[i]=k%2;\\n        } else {\\n            ans[i]=k%2;\\n            k--;\\n        }\\n    }  \\n    return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n    int k=0;\\n    vector<int> ans(s.size(),0);\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'(\\')\\n        {\\n            k++;\\n            ans[i]=k%2;\\n        } else {\\n            ans[i]=k%2;\\n            k--;\\n        }\\n    }  \\n    return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559307,
                "title": "solutions-using-stack-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n<!-- Using Vector -->\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> v;\\n        int d =0;\\n        for(auto &x : s){\\n            d+=x==\\'(\\';\\n            v.push_back(d%2);\\n            d-=x==\\')\\';\\n        }\\n        return v;\\n    \\n\\n\\n<!-- Using stack -->\\n\\n    stack<int> st;\\n    int n = s.length();\\n    vector<int> depth(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'(\\') {\\n            if (!st.empty()) {\\n                depth[i] = st.top() + 1;\\n            }\\n            st.push(depth[i]);\\n        } else if (s[i] == \\')\\') {\\n            if (!st.empty()) {\\n                st.pop();\\n            }\\n            depth[i] = st.empty() ? 0 : st.top() + 1;\\n        }\\n    }\\n\\n    return depth;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n<!-- Using Vector -->\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> v;\\n        int d =0;\\n        for(auto &x : s){\\n            d+=x==\\'(\\';\\n            v.push_back(d%2);\\n            d-=x==\\')\\';\\n        }\\n        return v;\\n    \\n\\n\\n<!-- Using stack -->\\n\\n    stack<int> st;\\n    int n = s.length();\\n    vector<int> depth(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'(\\') {\\n            if (!st.empty()) {\\n                depth[i] = st.top() + 1;\\n            }\\n            st.push(depth[i]);\\n        } else if (s[i] == \\')\\') {\\n            if (!st.empty()) {\\n                st.pop();\\n            }\\n            depth[i] = st.empty() ? 0 : st.top() + 1;\\n        }\\n    }\\n\\n    return depth;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378439,
                "title": "python-greedy-solution",
                "content": "# Intuition\\nFirst we store the current depth of `A` and `B` in `level_A` and `level_B` respectively.\\n\\nThe current depth is defined to be the number of unclosed brackets in the string. For example\\n```\\nA = ()()() ; depth = 0\\nA = (      ; depth = 1\\nA = ((     ; depth = 2\\nA = (()    ; depth = 1\\n```\\n- When encounters a `(`, we greedily choose to append it to `A` or `B` based on the lower depth.\\n- When encounters a `)`, we greedily choose to append it to `A` or `B` based on the highest depth.\\n\\n# Example\\nRun through the example on the string`()(())()`:\\n\\n1. Initialize `A = \"\", B = \"\"`, encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"(\"`\\n2. Encounters `)`: \\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()\"`\\n3. Encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()(\"`\\n4. Encounters `(`:\\n    insert into `B = \"(\"` since `level_B` is smaller.\\n5. Encounters `)`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()()\"`\\n6. Encounters `)`:\\n    insert into `B = \"()\"` since `level_B` is greater.\\n7. Encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()()(\"` \\n8. Encounters `)`:\\n    insert into `A = \"()()()\"` since `level_A` is greater.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        result = []\\n        level_A = 0\\n        level_B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if level_A < level_B:\\n                    result.append(0)\\n                    level_A += 1\\n                else:\\n                    result.append(1)\\n                    level_B += 1\\n            else:\\n                if level_A > level_B:\\n                    result.append(0)\\n                    level_A -= 1\\n                else:\\n                    result.append(1)\\n                    level_B -= 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nA = ()()() ; depth = 0\\nA = (      ; depth = 1\\nA = ((     ; depth = 2\\nA = (()    ; depth = 1\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        result = []\\n        level_A = 0\\n        level_B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if level_A < level_B:\\n                    result.append(0)\\n                    level_A += 1\\n                else:\\n                    result.append(1)\\n                    level_B += 1\\n            else:\\n                if level_A > level_B:\\n                    result.append(0)\\n                    level_A -= 1\\n                else:\\n                    result.append(1)\\n                    level_B -= 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374604,
                "title": "considering-all-the-cases-tc-o-n-sc-o-1",
                "content": "I wanted to solve this question by considering diff cases as it forces you to think from diff angles.\\nHere is the process of how I solved the problem...\\n\\nA and B such that max(depth(A), depth(B)) is the minimum possible value. : is the given statement.\\nTo get the min possible depth we will have to divide the depth equally among both A & B.\\n\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\nO/p ans: A = ()() , B = ()\\n\\n[Note: Keep a track of no. of non-closed parenthesis in both grps. And when corresponding \")\" is found decrement the no. for that grp by 1.]\\n\\nWe cannot place consecutive (( in the same group...otherwise it will increase the depth. (place them in alternate fashion: ((( --> 0 1 0 ).\\n\\nIf the consecutive chars are () we add both () to the same grp. While adding them to the same grp (0 or 1) we will make sure that it is not getting added to the same grp whose ( is opened but not closed yet. Just like the above example.\\n\\nif consecutive chars are ))...we can keep track of the no. of \"(\" in both groups that doesn\\'t have \"(\". Take max no. and reduce it by 1 since we found the \")\" and place that corresponding grp no. there.\\n\\nI hope this helps...\\nDo upvote if it does...\\nAlso...Pls share your thoughts and suggestions.\\nHave a great coding day everyone!\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int i = 0, n = seq.length(), a = 0, b = 0;\\n        int[] ans = new int[n];\\n\\n        while(i < n-1) {\\n            char ch1 = seq.charAt(i), ch2 = seq.charAt(i+1);\\n            if(ch1 == \\'(\\' && ch2 == \\')\\') {\\n                if(a > 0) {\\n                    ans[i] = 1;\\n                    ans[i+1] = 1;\\n                }\\n                i += 2;\\n            }else if(ch1 == ch2 && ch1 == \\'(\\') {\\n                if(i != 0) {\\n                    if(ans[i-1] == 0) {\\n                        ans[i] = 1;\\n                        ans[i+1] = 0;\\n                    }else {\\n                        ans[i] = 0;\\n                        ans[i+1] = 1;\\n                    }\\n                }else ans[i+1] = 1;\\n                a++;\\n                b++;\\n                i += 2;\\n            }else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }else {\\n                    a--;\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int i = 0, n = seq.length(), a = 0, b = 0;\\n        int[] ans = new int[n];\\n\\n        while(i < n-1) {\\n            char ch1 = seq.charAt(i), ch2 = seq.charAt(i+1);\\n            if(ch1 == \\'(\\' && ch2 == \\')\\') {\\n                if(a > 0) {\\n                    ans[i] = 1;\\n                    ans[i+1] = 1;\\n                }\\n                i += 2;\\n            }else if(ch1 == ch2 && ch1 == \\'(\\') {\\n                if(i != 0) {\\n                    if(ans[i-1] == 0) {\\n                        ans[i] = 1;\\n                        ans[i+1] = 0;\\n                    }else {\\n                        ans[i] = 0;\\n                        ans[i+1] = 1;\\n                    }\\n                }else ans[i+1] = 1;\\n                a++;\\n                b++;\\n                i += 2;\\n            }else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }else {\\n                    a--;\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338649,
                "title": "track-height-and-closing-bracket-of-each-opening-bracket-you-can-include-maxdepth-2-height-in-a",
                "content": "# Intuition\\nTrack height and closing bracket of each opening bracket. You can include maxDepth / 2 height in A\\n# Code\\n```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    stack := make([]int, 100000)\\n    top := 0\\n    height := make([]int, len(seq))\\n    closing := make([]int, len(seq))\\n    for i, _ := range height {\\n        height[i] = -1\\n        closing[i] = -1\\n    }\\n    clen := 0\\n    maxLen := 0\\n    update := func(x int) {\\n        if x > maxLen {\\n            maxLen = x\\n        }\\n    }\\n    for i, br := range seq {\\n        if br == \\'(\\' {\\n            clen++\\n            update(clen)\\n            height[i] = clen\\n            stack[top] = i\\n            top++\\n        } else {\\n            clen--\\n            if clen < 0 {\\n                panic(\"invalid vps\")\\n            }\\n            closing[stack[top-1]] = i\\n            top--\\n        }\\n    }\\n    reqH := maxLen / 2\\n    aIndex := make(map[int]bool)\\n    for i:=0; i<len(seq); i++ {\\n        if seq[i] == \\'(\\' && height[i] <= reqH {\\n            aIndex[i] = true\\n            aIndex[closing[i]] = true\\n        }\\n    }\\n    result := make([]int, len(seq))\\n    for i, _ := range result {\\n        _, isA := aIndex[i]\\n        if isA {\\n            result[i] = 0\\n        } else {\\n            result[i] = 1\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    stack := make([]int, 100000)\\n    top := 0\\n    height := make([]int, len(seq))\\n    closing := make([]int, len(seq))\\n    for i, _ := range height {\\n        height[i] = -1\\n        closing[i] = -1\\n    }\\n    clen := 0\\n    maxLen := 0\\n    update := func(x int) {\\n        if x > maxLen {\\n            maxLen = x\\n        }\\n    }\\n    for i, br := range seq {\\n        if br == \\'(\\' {\\n            clen++\\n            update(clen)\\n            height[i] = clen\\n            stack[top] = i\\n            top++\\n        } else {\\n            clen--\\n            if clen < 0 {\\n                panic(\"invalid vps\")\\n            }\\n            closing[stack[top-1]] = i\\n            top--\\n        }\\n    }\\n    reqH := maxLen / 2\\n    aIndex := make(map[int]bool)\\n    for i:=0; i<len(seq); i++ {\\n        if seq[i] == \\'(\\' && height[i] <= reqH {\\n            aIndex[i] = true\\n            aIndex[closing[i]] = true\\n        }\\n    }\\n    result := make([]int, len(seq))\\n    for i, _ := range result {\\n        _, isA := aIndex[i]\\n        if isA {\\n            result[i] = 0\\n        } else {\\n            result[i] = 1\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336084,
                "title": "easy-c-100-faster-by-using-depth-parity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int d = 0;\\n        for(auto x:seq)\\n        {\\n            if(x==\\'(\\') d++;\\n            ans.push_back(d%2);\\n            if(x==\\')\\') d--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int d = 0;\\n        for(auto x:seq)\\n        {\\n            if(x==\\'(\\') d++;\\n            ans.push_back(d%2);\\n            if(x==\\')\\') d--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318138,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string seq) {\\n        var result = new int[seq.Length];\\n\\n        for (int i = 0; i < seq.Length; i++)\\n        {\\n            result[i] = seq[i] == \\'(\\' ? i % 2 : (i - 1) % 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string seq) {\\n        var result = new int[seq.Length];\\n\\n        for (int i = 0; i < seq.Length; i++)\\n        {\\n            result[i] = seq[i] == \\'(\\' ? i % 2 : (i - 1) % 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291212,
                "title": "c-o-n-runtime-o-1-space-except-output",
                "content": "```\\nclass Solution {\\npublic:\\n    // algorithm\\n    // any time the depth is > max height / 2, assign other one\\n    // try even and odd cases\\n    // 3, > 3/2 = 2\\n    // 2, > 2/2 = 1\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 0, largest = 0, prev = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            largest = max(largest, cur);\\n        }\\n        vector<int> ans;\\n        cur = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            if (cur > largest / 2 || prev > largest / 2) ans.push_back(0);\\n            else ans.push_back(1);\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // algorithm\\n    // any time the depth is > max height / 2, assign other one\\n    // try even and odd cases\\n    // 3, > 3/2 = 2\\n    // 2, > 2/2 = 1\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 0, largest = 0, prev = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            largest = max(largest, cur);\\n        }\\n        vector<int> ans;\\n        cur = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            if (cur > largest / 2 || prev > largest / 2) ans.push_back(0);\\n            else ans.push_back(1);\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263097,
                "title": "easy-understanding-easy-stack-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTask is to divide the given parentheses into two groups such that maximum depth of both groups should be minimum. \\n<!-- I thought of dividing string into group with depth -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can divide parentheses into two groups based on depth by creating a group with depth less than equal to maxDepth/2 and more than maxDepth/2\\n\\nIn 1st traversal check the max depth by checking size of stack containing only \\'(\\'.\\nIn 2nd traversal assign value to answer array with help of stack size i.e all parantheses with stack size less than equal to maxDepth/2 is assigned group 1 and rest group 2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nwhere n== string length\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        stack<int>st;\\n        int mx=0;       //max size of stack with \\'(\\'\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                st.push(c);\\n                mx=max(mx,(int)st.size());\\n            }\\n            else{\\n                st.pop();\\n            }\\n        }\\n        vector<int>ans(s.size());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n            }\\n            else{\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        stack<int>st;\\n        int mx=0;       //max size of stack with \\'(\\'\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                st.push(c);\\n                mx=max(mx,(int)st.size());\\n            }\\n            else{\\n                st.pop();\\n            }\\n        }\\n        vector<int>ans(s.size());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n            }\\n            else{\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257369,
                "title": "python-use-two-levels-to-split-seq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        arr = list(seq)\\n        res = []\\n        level = 0\\n        while arr:\\n            current = arr.pop(0)\\n            if current == \"(\":\\n                level = 1 - level\\n                res.append(level)\\n            else:\\n                res.append(level)\\n                level = 1 - level\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        arr = list(seq)\\n        res = []\\n        level = 0\\n        while arr:\\n            current = arr.pop(0)\\n            if current == \"(\":\\n                level = 1 - level\\n                res.append(level)\\n            else:\\n                res.append(level)\\n                level = 1 - level\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254832,
                "title": "python-o-n-time-and-o-1-space-really-short-and-easy-to-understand",
                "content": "So the idea is almost the same as [Maximum Nesting Depth of the Parentheses](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/). The idea is to \\n* have a variable `count` to check open parentheses \\n* assign the group before increase the `count` if char == \\'(\\'\\n* decrease `count` before assign the group if char == \\')\\'\\n\\nReason:\\nLet\\'s have the example `(()())`.\\nIf we don\\'t include the logic to assign group, the final count would be `[1, 2, 1, 2 ,1, 0]` and we want the count to become `[1, 2, 2, 2, 2, 1]`  or `[0, 1, 1, 1, 1, 0]` then we could use module to assign group for each position. \\n\\nSo the key part is to assign group before increase and decrease first then assign (or vise versa) to have each parentheses the same group.\\n\\n```\\n         (   (   )   (   )   )   \\nres      0   0   0   0   0   0     start with count = 0\\nres      0   0   0   0   0   0     now pointer moves to idx = 0, assign 0 % 2 = 0 to res[0], then count += 1  -> count = 1\\nres      0   1   0   0   0   0     now pointer moves to idx = 1, assign 1 % 2 = 1 to res[1], then count += 1  -> count = 2\\nres      0   1   1   0   0   0     now pointer moves to idx = 2, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[2]\\nres      0   1   1   1   0   0     now pointer moves to idx = 3, assign 1 % 2 = 1 to res[3], then count += 1  -> count = 2\\nres      0   1   1   1   1   0     now pointer moves to idx = 4, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[4]\\nres      0   1   1   1   1   0     now pointer moves to idx = 5, !decrease count first!, count -= 1 -> count = 0, assign 0 % 2 = 0 to res[5]\\n```\\n\\nC0DE, the least important part:\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        count = 0\\n        \\n        for idx, i in enumerate(seq):\\n            if i == \\'(\\':\\n\\t\\t\\t\\t# Assign group first, then increase count\\n                res[idx] = count % 2\\n                count += 1\\n            else:\\n\\t\\t\\t\\t# Decrease group first then assign\\n                count -= 1\\n                res[idx] = count % 2\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n         (   (   )   (   )   )   \\nres      0   0   0   0   0   0     start with count = 0\\nres      0   0   0   0   0   0     now pointer moves to idx = 0, assign 0 % 2 = 0 to res[0], then count += 1  -> count = 1\\nres      0   1   0   0   0   0     now pointer moves to idx = 1, assign 1 % 2 = 1 to res[1], then count += 1  -> count = 2\\nres      0   1   1   0   0   0     now pointer moves to idx = 2, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[2]\\nres      0   1   1   1   0   0     now pointer moves to idx = 3, assign 1 % 2 = 1 to res[3], then count += 1  -> count = 2\\nres      0   1   1   1   1   0     now pointer moves to idx = 4, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[4]\\nres      0   1   1   1   1   0     now pointer moves to idx = 5, !decrease count first!, count -= 1 -> count = 0, assign 0 % 2 = 0 to res[5]\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        count = 0\\n        \\n        for idx, i in enumerate(seq):\\n            if i == \\'(\\':\\n\\t\\t\\t\\t# Assign group first, then increase count\\n                res[idx] = count % 2\\n                count += 1\\n            else:\\n\\t\\t\\t\\t# Decrease group first then assign\\n                count -= 1\\n                res[idx] = count % 2\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254104,
                "title": "intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust alternate group every position belongs to \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll you have to do is to make sure that you\\'re not repeating the group you\\'ve used before.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\nfun maxDepthAfterSplit(seq: String): IntArray {\\n\\n    val stack = Stack<ParentEle>()\\n    var group = 1\\n    val answer = IntArray(seq.length) { -1 }\\n    for (i in 0 until seq.length) {\\n        if (seq[i] == \\'(\\') {\\n            stack.push(ParentEle(i, \\'(\\'))\\n            group = if (group == 1) 0 else 1\\n        } else if (stack.peek().char == \\'(\\') {\\n            val prev = stack.pop()\\n            answer[prev.pos] = group\\n            answer[i] = group\\n            group = if (group == 1) 0 else 1\\n        }\\n    }\\n    return answer\\n}\\n\\ndata class ParentEle(val pos: Int, val char: Char)\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\nfun maxDepthAfterSplit(seq: String): IntArray {\\n\\n    val stack = Stack<ParentEle>()\\n    var group = 1\\n    val answer = IntArray(seq.length) { -1 }\\n    for (i in 0 until seq.length) {\\n        if (seq[i] == \\'(\\') {\\n            stack.push(ParentEle(i, \\'(\\'))\\n            group = if (group == 1) 0 else 1\\n        } else if (stack.peek().char == \\'(\\') {\\n            val prev = stack.pop()\\n            answer[prev.pos] = group\\n            answer[i] = group\\n            group = if (group == 1) 0 else 1\\n        }\\n    }\\n    return answer\\n}\\n\\ndata class ParentEle(val pos: Int, val char: Char)\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225836,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] arr = new int[seq.length()];\\n\\n        int length = arr.length;\\n        int count=0;\\n        for(int i=0; i<length; i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                count++;\\n                arr[i] = count%2;\\n            }\\n            else{\\n                arr[i] = count%2;\\n                count--;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] arr = new int[seq.length()];\\n\\n        int length = arr.length;\\n        int count=0;\\n        for(int i=0; i<length; i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                count++;\\n                arr[i] = count%2;\\n            }\\n            else{\\n                arr[i] = count%2;\\n                count--;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217530,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        \\n        var ds = [Int]()\\n        var d = 0\\n\\n        for c in seq {\\n            if c == \"(\" {\\n                d += 1\\n                ds.append(d)\\n            }\\n            else {\\n                ds.append(d)\\n                d -= 1\\n            }\\n        }\\n\\n        let m = (ds.min()! + ds.max()!) / 2\\n\\n        return ds.map { $0 > m ? 1 : 0 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        \\n        var ds = [Int]()\\n        var d = 0\\n\\n        for c in seq {\\n            if c == \"(\" {\\n                d += 1\\n                ds.append(d)\\n            }\\n            else {\\n                ds.append(d)\\n                d -= 1\\n            }\\n        }\\n\\n        let m = (ds.min()! + ds.max()!) / 2\\n\\n        return ds.map { $0 > m ? 1 : 0 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148890,
                "title": "clean-python-1-line-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134157,
                "title": "easy-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust make all left braces and right braces ABAB...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool left=true,right=true;\\n        for(char c:seq)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                res.push_back(left?0:1);\\n                left=!left;\\n            }\\n            else\\n            {\\n                res.push_back(right?0:1);\\n                right=!right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool left=true,right=true;\\n        for(char c:seq)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                res.push_back(left?0:1);\\n                left=!left;\\n            }\\n            else\\n            {\\n                res.push_back(right?0:1);\\n                right=!right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121400,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n       int[] arr=new int[seq.length()];\\n       int lvl=0;\\n       for(int i=0;i<seq.length();i++){\\n           if(seq.charAt(i)==\\'(\\'){\\n                arr[i]=++lvl%2;\\n           }else{\\n               arr[i]=lvl--%2;\\n           }\\n       } \\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n       int[] arr=new int[seq.length()];\\n       int lvl=0;\\n       for(int i=0;i<seq.length();i++){\\n           if(seq.charAt(i)==\\'(\\'){\\n                arr[i]=++lvl%2;\\n           }else{\\n               arr[i]=lvl--%2;\\n           }\\n       } \\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916017,
                "title": "100-faster-soln-only-stack-easy-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;\\n        int max=0;\\n        for(int i=0;i<seq.length();i++){\\n            if(seq[i]==\\'(\\') max++;\\n            p.push_back(max%2);\\n            if(seq[i]==\\')\\') max--; \\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;\\n        int max=0;\\n        for(int i=0;i<seq.length();i++){\\n            if(seq[i]==\\'(\\') max++;\\n            p.push_back(max%2);\\n            if(seq[i]==\\')\\') max--; \\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794266,
                "title": "stack-iteration",
                "content": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] ans = new int[seq.length()];\\n                    int count = 0;\\n\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n               ans[i] = ++count%2;\\n            }\\n            else if (seq.charAt(i) == \\')\\'){\\n                ans[i] = count--%2;\\n            }\\n            // ans[i] = count;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] ans = new int[seq.length()];\\n                    int count = 0;\\n\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n               ans[i] = ++count%2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2792026,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A = []\\n        B = []\\n        ans = []\\n        for i in seq:\\n            if i == \\'(\\':\\n                if A == [] and B == []:\\n                    A.append(i)\\n                    ans.append(0)\\n                elif len(A) < len(B):\\n                    A.append(i)\\n                    ans.append(0)\\n                else:\\n                    B.append(i)\\n                    ans.append(1)\\n            elif i == \\')\\':\\n                if A and A[-1] == \\'(\\':\\n                    A.pop()\\n                    ans.append(0)\\n                elif B and B[-1] == \\'(\\':\\n                    B.pop()\\n                    ans.append(1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A = []\\n        B = []\\n        ans = []\\n        for i in seq:\\n            if i == \\'(\\':\\n                if A == [] and B == []:\\n                    A.append(i)\\n                    ans.append(0)\\n                elif len(A) < len(B):\\n                    A.append(i)\\n                    ans.append(0)\\n                else:\\n                    B.append(i)\\n                    ans.append(1)\\n            elif i == \\')\\':\\n                if A and A[-1] == \\'(\\':\\n                    A.pop()\\n                    ans.append(0)\\n                elif B and B[-1] == \\'(\\':\\n                    B.pop()\\n                    ans.append(1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786540,
                "title": "python-3-simple-o-n-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        curOpen = 0\\n        answer = []\\n        for c in seq:\\n            if c == \\'(\\':\\n                curOpen += 1\\n                answer.append(curOpen & 1)\\n            else:\\n                answer.append(curOpen & 1)\\n                curOpen -= 1\\n        \\n        return answer\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        curOpen = 0\\n        answer = []\\n        for c in seq:\\n            if c == \\'(\\':\\n                curOpen += 1\\n                answer.append(curOpen & 1)\\n            else:\\n                answer.append(curOpen & 1)\\n                curOpen -= 1\\n        \\n        return answer\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693402,
                "title": "c-easunderstnding-basic-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>s;\\n        int d = 0;\\n        for(auto c : seq){\\n            bool flag = c == \\'(\\';\\n            if(flag)d++; // open bracket\\n            s.push_back(d%2);\\n            if(!flag)d--; // closed bracket\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>s;\\n        int d = 0;\\n        for(auto c : seq){\\n            bool flag = c == \\'(\\';\\n            if(flag)d++; // open bracket\\n            s.push_back(d%2);\\n            if(!flag)d--; // closed bracket\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657782,
                "title": "c-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\n`O(n)` -> `n` is the length of string `seq`.\\n\\n- Space complexity:\\n`O(n)` -> `n` is the length of string `seq`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> ret;\\n        int st = 0, max_depth = 0;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                max_depth = max(max_depth, ++st);\\n            else\\n                --st;\\n        const int half_depth = max_depth >> 1;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                ret.push_back(++st > half_depth);\\n            else\\n                ret.push_back(st-- > half_depth);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> ret;\\n        int st = 0, max_depth = 0;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                max_depth = max(max_depth, ++st);\\n            else\\n                --st;\\n        const int half_depth = max_depth >> 1;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                ret.push_back(++st > half_depth);\\n            else\\n                ret.push_back(st-- > half_depth);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605751,
                "title": "simple-intuitive-python-solution",
                "content": "The maximum of the depths of the 2 parts is minimum when both the parts have almost same length.\\nIn other sub-optimal cases, the less deeper one part gets, the more deeper the other has to get which increases the maximum depth of the 2 parts. \\n\\nSo, we need to break down the string to two parts that are as balanced as possible.\\n\\nOne way to do this:\\n- Start with 2 empty stacks\\n- When there is an opening parenthesis, we want to keep both stack lengths as close as possible. Pushing to the larger stack will only increase the gap between the two. So, we push to the smaller stack.\\n- When there is a closing parenthesis, popping from the smaller stack will further increase the gap. So, we need to pop from the larger stack.\\n- At every element in the sequence, we append 0 to the result array if we are pushing/popping from stack 1 and append 1 if we are pushing/popping from stack 2.\\n\\n\\nNote: Since we are only concerned with the stack lengths - we don\\'t need 2 stacks but just 2 counters that store the lengths of stack 1 and stack 2. We increment the counter while pushing and decrement it while popping.\\n\\n```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack1 = 0\\n        stack2 = 0\\n        res = []\\n        \\n        for ele in seq:\\n            if ele == \\'(\\':\\n                if stack1 <= stack2:\\n                    res.append(0)\\n                    stack1 += 1\\n                else:\\n                    res.append(1)\\n                    stack2 += 1\\n            else:\\n                if stack1 >= stack2:\\n                    res.append(0)\\n                    stack1 -= 1\\n                else:\\n                    res.append(1)\\n                    stack2 -= 1\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The maximum of the depths of the 2 parts is minimum when both the parts have almost same length.\\nIn other sub-optimal cases, the less deeper one part gets, the more deeper the other has to get which increases the maximum depth of the 2 parts. \\n\\nSo, we need to break down the string to two parts that are as balanced as possible.\\n\\nOne way to do this:\\n- Start with 2 empty stacks\\n- When there is an opening parenthesis, we want to keep both stack lengths as close as possible. Pushing to the larger stack will only increase the gap between the two. So, we push to the smaller stack.\\n- When there is a closing parenthesis, popping from the smaller stack will further increase the gap. So, we need to pop from the larger stack.\\n- At every element in the sequence, we append 0 to the result array if we are pushing/popping from stack 1 and append 1 if we are pushing/popping from stack 2.\\n\\n\\nNote: Since we are only concerned with the stack lengths - we don\\'t need 2 stacks but just 2 counters that store the lengths of stack 1 and stack 2. We increment the counter while pushing and decrement it while popping.\\n\\n```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack1 = 0\\n        stack2 = 0\\n        res = []\\n        \\n        for ele in seq:\\n            if ele == \\'(\\':\\n                if stack1 <= stack2:\\n                    res.append(0)\\n                    stack1 += 1\\n                else:\\n                    res.append(1)\\n                    stack2 += 1\\n            else:\\n                if stack1 >= stack2:\\n                    res.append(0)\\n                    stack1 -= 1\\n                else:\\n                    res.append(1)\\n                    stack2 -= 1\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2448152,
                "title": "java-easy-soln",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        Stack <Character> stk= new Stack<>();\\n        int []soln= new int[seq.length()];\\n        for (int i = 0; i < seq.length(); i++) {\\n            if(stk.isEmpty()){\\n                stk.push(\\'(\\');\\n                soln[i]=0;\\n            }\\n            else if(seq.charAt(i)==\\'(\\'){\\n                stk.push(\\'(\\');\\n                if(stk.size()%2==0) soln[i]=1;\\n                else soln[i]=0;\\n            }\\n            else{\\n                stk.pop();\\n                if(stk.isEmpty()) soln[i]=0;\\n                else if(stk.size()%2==0) soln[i]=0;\\n                else soln[i]=1;\\n            }\\n        }\\n        return soln;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        Stack <Character> stk= new Stack<>();\\n        int []soln= new int[seq.length()];\\n        for (int i = 0; i < seq.length(); i++) {\\n            if(stk.isEmpty()){\\n                stk.push(\\'(\\');\\n                soln[i]=0;\\n            }\\n            else if(seq.charAt(i)==\\'(\\'){\\n                stk.push(\\'(\\');\\n                if(stk.size()%2==0) soln[i]=1;\\n                else soln[i]=0;\\n            }\\n            else{\\n                stk.pop();\\n                if(stk.isEmpty()) soln[i]=0;\\n                else if(stk.size()%2==0) soln[i]=0;\\n                else soln[i]=1;\\n            }\\n        }\\n        return soln;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406730,
                "title": "c-easy-solution-o-n",
                "content": "Time complexity   :- O(N)\\nspace complexity :- O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n         vector< int > ans ;\\n         int openc = 0 ;\\n         int maxi = 0 ;\\n         for( auto x : seq)\\n         {\\n             if ( x == \\'(\\' )\\n             {\\n                 openc++ ;\\n                 maxi = max(  maxi , openc ) ;\\n             }\\n             else openc-- ;\\n         }\\n         maxi = (maxi+1)/2 ;\\n         openc = 0 ;\\n         int  flag = 0  ;\\n        for( int i = 0 ; i<seq.length() ; i++ )\\n        {\\n            if( seq[i] == \\'(\\' ) openc++ ;\\n            else openc-- ;\\n            \\n            if( flag ) \\n            {   ans.push_back(0) ;\\n                flag = 0  ;\\n                continue ;\\n            }\\n            if( openc <= maxi )\\n                ans.push_back( 1 ) ;\\n            else \\n            {   ans.push_back( 0 ) ;\\n                flag = 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n         vector< int > ans ;\\n         int openc = 0 ;\\n         int maxi = 0 ;\\n         for( auto x : seq)\\n         {\\n             if ( x == \\'(\\' )\\n             {\\n                 openc++ ;\\n                 maxi = max(  maxi , openc ) ;\\n             }\\n             else openc-- ;\\n         }\\n         maxi = (maxi+1)/2 ;\\n         openc = 0 ;\\n         int  flag = 0  ;\\n        for( int i = 0 ; i<seq.length() ; i++ )\\n        {\\n            if( seq[i] == \\'(\\' ) openc++ ;\\n            else openc-- ;\\n            \\n            if( flag ) \\n            {   ans.push_back(0) ;\\n                flag = 0  ;\\n                continue ;\\n            }\\n            if( openc <= maxi )\\n                ans.push_back( 1 ) ;\\n            else \\n            {   ans.push_back( 0 ) ;\\n                flag = 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394086,
                "title": "c-simple-loop",
                "content": "Here we have to distribute `(` and `)` *evenly* between `A` and `B`. We can do in this way:\\n\\n1. If we have `(` and the last opened `(` was in A, put it into B and vice versa\\n2. If we have `)` and last opened `(` was in A put it into A and mark B as having last opened \\'(` and vice versa.\\n\\n**Code**, time complexity O(n), extra space (answer excluded) - `O(1)`\\n\\n```\\npublic class Solution {\\n     public int[] MaxDepthAfterSplit(string seq) {\\n        int current = 1;\\n        \\n        int[] result = new int[seq.Length];\\n        \\n        for (int i = 0; i < seq.Length; ++i) \\n            if (seq[i] == \\'(\\') \\n                result[i] = (current = 1 - current);\\n            else {\\n                result[i] = current;\\n                \\n                current = 1 - current;\\n            }\\n                \\n        return result;\\n    }\\n }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n     public int[] MaxDepthAfterSplit(string seq) {\\n        int current = 1;\\n        \\n        int[] result = new int[seq.Length];\\n        \\n        for (int i = 0; i < seq.Length; ++i) \\n            if (seq[i] == \\'(\\') \\n                result[i] = (current = 1 - current);\\n            else {\\n                result[i] = current;\\n                \\n                current = 1 - current;\\n            }\\n                \\n        return result;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381145,
                "title": "python-o-1-space-solution",
                "content": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\ts, seq = 0, list(seq)\\n\\tfor i in range(len(seq)):\\n\\t\\tc = seq[i]\\n\\t\\tif c==\\'(\\':\\n\\t\\t\\tseq[i] = int(s>0)\\n\\t\\t\\tif s <= 0:\\n\\t\\t\\t\\ts += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts -= 1\\n\\t\\telse:\\n\\t\\t\\tseq[i] = int(s<0)\\n\\t\\t\\tif s >= 0:\\n\\t\\t\\t\\ts -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts += 1\\n\\treturn seq\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\ts, seq = 0, list(seq)\\n\\tfor i in range(len(seq)):\\n\\t\\tc = seq[i]\\n\\t\\tif c==\\'(\\':\\n\\t\\t\\tseq[i] = int(s>0)\\n\\t\\t\\tif s <= 0:\\n\\t\\t\\t\\ts += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts -= 1\\n\\t\\telse:\\n\\t\\t\\tseq[i] = int(s<0)\\n\\t\\t\\tif s >= 0:\\n\\t\\t\\t\\ts -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts += 1\\n\\treturn seq\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2277171,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> vec;\\n        int mx=0, ans=0;\\n        for(auto itr: seq)\\n        {\\n            if(itr==\\'(\\')\\n                ans++;\\n            mx = max(mx, ans);\\n            vec.push_back(ans);\\n            if(itr==\\')\\')\\n                ans--;\\n        }\\n        \\n        mx = mx/2;\\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(vec[i]<=mx)\\n                vec[i]=0;\\n            else\\n                vec[i]=1;\\n        }\\n        \\n        return vec;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> vec;\\n        int mx=0, ans=0;\\n        for(auto itr: seq)\\n        {\\n            if(itr==\\'(\\')\\n                ans++;\\n            mx = max(mx, ans);\\n            vec.push_back(ans);\\n            if(itr==\\')\\')\\n                ans--;\\n        }\\n        \\n        mx = mx/2;\\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(vec[i]<=mx)\\n                vec[i]=0;\\n            else\\n                vec[i]=1;\\n        }\\n        \\n        return vec;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236885,
                "title": "c-2-passes-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int depth(const string& s) {\\n        int l = 0, res = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            l += s[i] == \\'(\\' ? 1 : -1;\\n            res = max(res, l);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int d = depth(seq) / 2;\\n        int l = 0;\\n        vector<int> res(seq.size());\\n        for (int i = 0; i < seq.size(); ++i) {\\n            res[i] = seq[i] == \\'(\\' ? ++l > d : l-- > d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth(const string& s) {\\n        int l = 0, res = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            l += s[i] == \\'(\\' ? 1 : -1;\\n            res = max(res, l);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int d = depth(seq) / 2;\\n        int l = 0;\\n        vector<int> res(seq.size());\\n        for (int i = 0; i < seq.size(); ++i) {\\n            res[i] = seq[i] == \\'(\\' ? ++l > d : l-- > d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178655,
                "title": "python-sol-greedy-easy-explained-linear-time-complexity",
                "content": "# EXPLANATION\\n```\\n\\n\\n**DURING OPENING CHOOSE THE PART WHERE NO OF OPENING BRAKCETS ARE LESS\\nDURING CLOSING CHOOSE THE PART WHERE NO OF OPENING BRACKETS ARE MORE**\\n\\n\\nThe idea is simple :\\nwe need to minimize the maximum ( depth(A) , depth(B) )\\nSO whenever we open a bracket :\\n1. If previous opening was for A : open for B\\n2. If previous opening was for B : open for A\\n\\nwhenever we close a bracket :\\n1. If previous opening was for A : close for A\\n2. If previous opening was for B : close for B\\n\\n\\nBy this we ensure to get the required answer\\n```\\n\\n\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        last = 1\\n        for i in seq:\\n            if i == \\'(\\':\\n                if last == 0: ans.append(1)\\n                else:ans.append(0)\\n            else:\\n                ans.append(last)\\n            last = (last + 1) % 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n\\n\\n**DURING OPENING CHOOSE THE PART WHERE NO OF OPENING BRAKCETS ARE LESS\\nDURING CLOSING CHOOSE THE PART WHERE NO OF OPENING BRACKETS ARE MORE**\\n\\n\\nThe idea is simple :\\nwe need to minimize the maximum ( depth(A) , depth(B) )\\nSO whenever we open a bracket :\\n1. If previous opening was for A : open for B\\n2. If previous opening was for B : open for A\\n\\nwhenever we close a bracket :\\n1. If previous opening was for A : close for A\\n2. If previous opening was for B : close for B\\n\\n\\nBy this we ensure to get the required answer\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        last = 1\\n        for i in seq:\\n            if i == \\'(\\':\\n                if last == 0: ans.append(1)\\n                else:ans.append(0)\\n            else:\\n                ans.append(last)\\n            last = (last + 1) % 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147600,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/ca0cac29-1d8b-4fc1-a0c7-76e8bc029520_1655132341.8941426.png)\\n```\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    int len = strlen(seq), top = 0;\\n    int* ans = (int*) calloc(len, sizeof(int));\\n    for (int i = 0; i < len; i++) {\\n        if (seq[i] == \\'(\\') {\\n            top++;\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n        }\\n        if (seq[i] == \\')\\') {\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n            top--;\\n        }\\n    }\\n    *returnSize = len;\\n    return ans;\\n}\\n//----------------------- another way -----------------------//\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    *returnSize = strlen(seq);\\n    int idx = 0;\\n    int* ans = (int*) calloc((*returnSize), sizeof(int));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        ans[idx] = (seq[i] ^ idx) & 1;\\n\\t\\tidx++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    int len = strlen(seq), top = 0;\\n    int* ans = (int*) calloc(len, sizeof(int));\\n    for (int i = 0; i < len; i++) {\\n        if (seq[i] == \\'(\\') {\\n            top++;\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n        }\\n        if (seq[i] == \\')\\') {\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n            top--;\\n        }\\n    }\\n    *returnSize = len;\\n    return ans;\\n}\\n//----------------------- another way -----------------------//\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    *returnSize = strlen(seq);\\n    int idx = 0;\\n    int* ans = (int*) calloc((*returnSize), sizeof(int));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        ans[idx] = (seq[i] ^ idx) & 1;\\n\\t\\tidx++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109577,
                "title": "c-using-two-variables-very-easy",
                "content": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n            \\n        vector<int> ans;\\n        int a = 0;\\n        int b = 0;\\n        \\n        for(auto c: seq){\\n            if(c == \\'(\\'){\\n                if(a <= b){\\n                    a++;\\n                    ans.push_back(0);\\n                } else {\\n                    b++;\\n                    ans.push_back(1);\\n                }\\n            } else {\\n                if(a >= b){\\n                    a--;\\n                    ans.push_back(0);\\n                } else {\\n                    b--;\\n                    ans.push_back(1);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n            \\n        vector<int> ans;\\n        int a = 0;\\n        int b = 0;\\n        \\n        for(auto c: seq){\\n            if(c == \\'(\\'){\\n                if(a <= b){\\n                    a++;\\n                    ans.push_back(0);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2016574,
                "title": "c-solution-for-this-very-interesting-medium-level-puzzle",
                "content": "To solve this problem, one must realize that A and B shall only pick parentheses at certain levels. \\n\\nFor instance:\\n```\\n(())()((()))\\n122111123321\\n```\\n\\nYou can set all the parentheses at odd-numbered levels for partition A and the remaining ones for B. (It\\'s up to you). The maximum depth is minimal.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lvl;\\n    stack<int> S;\\n    \\n    vector<int> maxDepthAfterSplit(string seq) {        \\n        lvl = 0;\\n        int len = seq.length();\\n        vector<int> res = vector<int>(len, -1);\\n        int st = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (seq[i] == \\'(\\') {\\n                S.push(i);\\n                lvl++;\\n            }\\n            else if (seq[i] == \\')\\') {\\n                int st = S.top(); S.pop();\\n                int mk = 0;\\n                if ((lvl & 1) == 0) mk = 1;\\n                res[st] = mk;\\n                res[i] = mk;\\n                lvl--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n(())()((()))\\n122111123321\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lvl;\\n    stack<int> S;\\n    \\n    vector<int> maxDepthAfterSplit(string seq) {        \\n        lvl = 0;\\n        int len = seq.length();\\n        vector<int> res = vector<int>(len, -1);\\n        int st = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (seq[i] == \\'(\\') {\\n                S.push(i);\\n                lvl++;\\n            }\\n            else if (seq[i] == \\')\\') {\\n                int st = S.top(); S.pop();\\n                int mk = 0;\\n                if ((lvl & 1) == 0) mk = 1;\\n                res[st] = mk;\\n                res[i] = mk;\\n                lvl--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010764,
                "title": "golang",
                "content": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    deep :=0\\n    res := make([]int,len(seq))\\n    for i,c := range []byte(seq) {\\n        if c == \\'(\\'{\\n            deep++\\n            res[i] = deep%2\\n        }else {\\n            res[i] = deep%2\\n            deep--\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    deep :=0\\n    res := make([]int,len(seq))\\n    for i,c := range []byte(seq) {\\n        if c == \\'(\\'{\\n            deep++\\n            res[i] = deep%2\\n        }else {\\n            res[i] = deep%2\\n            deep--\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982903,
                "title": "easy-c-solution-runtime-faster-than-80-43-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n=seq.length();\\n        vector<int> ans(n);\\n\\t\\t\\n        int cur = 0;\\n        int max_depth = 0;\\n        for(int i=0;i<n;i++){\\n            if(seq[i]==\\'(\\'){\\n                ans[i] = ++cur;\\n                max_depth = max(max_depth,cur);\\n            }\\n            else\\n                ans[i] = cur--;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ans[i]<=max_depth/2)\\n                ans[i] = 0;\\n            else\\n                ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n=seq.length();\\n        vector<int> ans(n);\\n\\t\\t\\n        int cur = 0;\\n        int max_depth = 0;\\n        for(int i=0;i<n;i++){\\n            if(seq[i]==\\'(\\'){\\n                ans[i] = ++cur;\\n                max_depth = max(max_depth,cur);\\n            }\\n            else\\n                ans[i] = cur--;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ans[i]<=max_depth/2)\\n                ans[i] = 0;\\n            else\\n                ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960254,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i = 0, n = s.length();\\n        vector<int> ans(n,0);\\n        \\n        while(i < n) {\\n            int cnt = 1, depth = 1, j = i+1;\\n            while(j < n and cnt) {\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                \\n                depth = max(depth,cnt);\\n                j++;\\n            }\\n        \\n            cnt = 0;\\n            for(int k = i; k < j; k++) {\\n                if(s[k] == \\'(\\') {\\n                    cnt++;\\n                    if(cnt > depth/2) ans[k] = 1;\\n                }\\n                else {\\n                    if(cnt > depth/2) ans[k] = 1;\\n                    cnt--;\\n                }\\n            }\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i = 0, n = s.length();\\n        vector<int> ans(n,0);\\n        \\n        while(i < n) {\\n            int cnt = 1, depth = 1, j = i+1;\\n            while(j < n and cnt) {\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                \\n                depth = max(depth,cnt);\\n                j++;\\n            }\\n        \\n            cnt = 0;\\n            for(int k = i; k < j; k++) {\\n                if(s[k] == \\'(\\') {\\n                    cnt++;\\n                    if(cnt > depth/2) ans[k] = 1;\\n                }\\n                else {\\n                    if(cnt > depth/2) ans[k] = 1;\\n                    cnt--;\\n                }\\n            }\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952350,
                "title": "working-solution-java",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] output = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++) {\\n            output[i] = (seq.charAt(i) == \\'(\\') ?\\n                            (i&1) : \\n                            ((1 - i) & 1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] output = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++) {\\n            output[i] = (seq.charAt(i) == \\'(\\') ?\\n                            (i&1) : \\n                            ((1 - i) & 1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890224,
                "title": "python3-99-7-runtime-91-6-space",
                "content": "We only care about minimizing `max(depth_A, depth_B)`. The best way to do this is to place all the chars at even depth into split `A`, and all the chars at odd depth into split `B`. This means that split `A` will have depth `floor(max_depth / 2)`, and split `B` will have depth `ceil(max_depth / 2)`.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878940,
                "title": "c-parity-by-depth",
                "content": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string s) {\\n        Stack<int> st = new Stack<int>();\\n        int n = s.Length;\\n        int[] depth = new int[n];\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') {\\n                st.Push(i);\\n            } else {\\n                depth[i] = depth[st.Pop()] = st.Count;\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; ++i) {\\n            max = Math.Max(max, depth[i]);\\n        }\\n        if (max == 0) {\\n            ans[0] = ans[1] = 0;\\n            for (int i = 2; i < n; ++i) ans[i] = 1;\\n        } else {\\n            for (int i = 0; i < n; ++i) {\\n                if (depth[i] % 2 == 0) {\\n                    ans[i] = 0;\\n                } else {\\n                    ans[i] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string s) {\\n        Stack<int> st = new Stack<int>();\\n        int n = s.Length;\\n        int[] depth = new int[n];\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') {\\n                st.Push(i);\\n            } else {\\n                depth[i] = depth[st.Pop()] = st.Count;\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; ++i) {\\n            max = Math.Max(max, depth[i]);\\n        }\\n        if (max == 0) {\\n            ans[0] = ans[1] = 0;\\n            for (int i = 2; i < n; ++i) ans[i] = 1;\\n        } else {\\n            for (int i = 0; i < n; ++i) {\\n                if (depth[i] % 2 == 0) {\\n                    ans[i] = 0;\\n                } else {\\n                    ans[i] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841684,
                "title": "c-alternative-splitting-by-depth-o-n",
                "content": "How you split the string does\\'nt matter but the relative ordering of indices of slipted string matters, that is, relative ordering of elements of string in both the splitted string should not change.\\nSplitting can be done by **alternative splitting by** **depth** in the following way:\\n1. find the depth of each VPS in the string\\n1. if the depth is even, split it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        vector<int> nums(n,0); int depth = 0,i=0;\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push(i); depth++; \\n                if(depth%2==0) nums[i] = 1;\\n            }\\n            else{\\n                nums[i] = nums[st.top()]; depth--; st.pop();\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        vector<int> nums(n,0); int depth = 0,i=0;\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push(i); depth++; \\n                if(depth%2==0) nums[i] = 1;\\n            }\\n            else{\\n                nums[i] = nums[st.top()]; depth--; st.pop();\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793665,
                "title": "c-0ms-100-space-o1-explained",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 7.4 MB, less than 43.69% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n**General idea :**\\n1. Do traversal from leftmost to rightmost and find maximal depth for each brace\\n2. Devide our maximal depth on 2. \\n3. Do traversal from leftmost to rightmost and check : have our current depth value greater than maximal depth or not for each brace. if have answer = 1, if not answer = 0 .\\n\\n```\\nclass Solution {\\npublic:\\n  vector<int> maxDepthAfterSplit(string seq) {\\n    int max_depth = 0, cur_depth = 0;    \\n    \\n    for(auto ch: seq)\\n      if(ch == \\'(\\') cur_depth++;\\n      else max_depth = max<int>(max_depth, cur_depth--);\\n       \\n    max_depth >>= 1, cur_depth = 0;\\n    vector<int>ans(seq.size(), 0);\\n    for(int i = 0; i != seq.size(); i++)\\n      if(seq[i] == \\'(\\') {if(++cur_depth > max_depth) ans[i] = 1;}\\n      else if(cur_depth-- > max_depth) ans[i] = 1;\\n      \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> maxDepthAfterSplit(string seq) {\\n    int max_depth = 0, cur_depth = 0;    \\n    \\n    for(auto ch: seq)\\n      if(ch == \\'(\\') cur_depth++;\\n      else max_depth = max<int>(max_depth, cur_depth--);\\n       \\n    max_depth >>= 1, cur_depth = 0;\\n    vector<int>ans(seq.size(), 0);\\n    for(int i = 0; i != seq.size(); i++)\\n      if(seq[i] == \\'(\\') {if(++cur_depth > max_depth) ans[i] = 1;}\\n      else if(cur_depth-- > max_depth) ans[i] = 1;\\n      \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785117,
                "title": "beginner-friendly-javascript-solution",
                "content": "Time Complexity : O(n)\\n```\\n/**\\n * @param {string} seq\\n * @return {number[]}\\n */\\nvar maxDepthAfterSplit = function(seq) {\\n    let arr = []\\n    for(let i=0; i<seq.length; i++){\\n        arr.push(seq[i] == \"(\" ? i & 1 : 1-i & 1)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} seq\\n * @return {number[]}\\n */\\nvar maxDepthAfterSplit = function(seq) {\\n    let arr = []\\n    for(let i=0; i<seq.length; i++){\\n        arr.push(seq[i] == \"(\" ? i & 1 : 1-i & 1)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760836,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) \\n    {\\n        vector<int> ans;\\n        int depth=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                depth++;\\n                ans.push_back(depth%2);\\n            }\\n            else\\n            {\\n                ans.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) \\n    {\\n        vector<int> ans;\\n        int depth=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                depth++;\\n                ans.push_back(depth%2);\\n            }\\n            else\\n            {\\n                ans.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663111,
                "title": "javascript-nothing-fancy-but-still-runs-in-o-n-time-and-o-1-space",
                "content": "The idea is to have the max depth of each subgroup near the 1/2 of the original seq.  So I :\\n1. get max depth of seq and determine that the new max depth for each group must be newMaxDepth=Math.round(maxDepth/2) for one group, the other group will have max depth of maxDepth-newMaxDepth\\n2. traverse from left to right, use greedy approach to collect up to (including) dep into group A if currentDepth<newMaxDepth\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    let r=new Array(seq.length).fill(1);\\n    let mdep=0, cdep=0;\\n    for (let c of seq) \\n        if (c===\\'(\\') mdep=Math.max(++cdep,mdep);\\n        else --cdep;\\n    let dep=Math.round(mdep/2);\\n    //find VPS string A, marked with 0\\n    cdep=0;\\n    for (let i=0; i<seq.length; ++i) {\\n        if (seq[i]===\\'(\\') {\\n           if (cdep<dep) {\\n              r[i]=0; \\n              ++cdep;\\n           }\\n        }\\n        else {\\n            if (cdep<=dep && cdep>0) {\\n                r[i]=0;\\n                --cdep;\\n            }\\n        }\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepthAfterSplit = function(seq) {\\n    let r=new Array(seq.length).fill(1);\\n    let mdep=0, cdep=0;\\n    for (let c of seq) \\n        if (c===\\'(\\') mdep=Math.max(++cdep,mdep);\\n        else --cdep;\\n    let dep=Math.round(mdep/2);\\n    //find VPS string A, marked with 0\\n    cdep=0;\\n    for (let i=0; i<seq.length; ++i) {\\n        if (seq[i]===\\'(\\') {\\n           if (cdep<dep) {\\n              r[i]=0; \\n              ++cdep;\\n           }\\n        }\\n        else {\\n            if (cdep<=dep && cdep>0) {\\n                r[i]=0;\\n                --cdep;\\n            }\\n        }\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658656,
                "title": "python3-6-lines-o-n",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res,depth=[],0\\n        for el in seq:\\n            if el==\\'(\\': depth+=1\\n            res.append(depth%2)\\n            if el==\\')\\': depth-=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res,depth=[],0\\n        for el in seq:\\n            if el==\\'(\\': depth+=1\\n            res.append(depth%2)\\n            if el==\\')\\': depth-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621825,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] r = new int[seq.length()];\\n        int md = 0;\\n        int cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n            if (cd>md) md = cd;\\n        }\\n        int hd = md/2;\\n        cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (cd>hd) r[i] = 1;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n        }\\n        \\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] r = new int[seq.length()];\\n        int md = 0;\\n        int cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n            if (cd>md) md = cd;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1517903,
                "title": "java-solution-with-explanation-bitwise-operator",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] result = new int[n];\\n        for(int i =0 ; i < n; i++){\\n            //& is a bitwise operator which gives 0 or 1 if even or odd respectively.\\n            //1-i&1 : this basically does inverse of above\\n            result[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1 - i & 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] result = new int[n];\\n        for(int i =0 ; i < n; i++){\\n            //& is a bitwise operator which gives 0 or 1 if even or odd respectively.\\n            //1-i&1 : this basically does inverse of above\\n            result[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1 - i & 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500796,
                "title": "simple-linear-traversal",
                "content": "We want to make subsequence such that we can break the original string into subseq A and B both of them finally to be of the form \"()()()()\" as a result the max depth will always be equal to min equal to 1 \\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i,n=s.length();\\n        vector<int> ans(n,0);\\n        for(i=1;i<n;i++){\\n            if(s[i]==s[i-1])\\n                ans[i]=1-ans[i-1];\\n            else\\n                ans[i]=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i,n=s.length();\\n        vector<int> ans(n,0);\\n        for(i=1;i<n;i++){\\n            if(s[i]==s[i-1])\\n                ans[i]=1-ans[i-1];\\n            else\\n                ans[i]=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420857,
                "title": "python-greedy-beats-100",
                "content": "```\\n\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        A_depth = 0\\n        B_depth = 0\\n        sol = []\\n        last_open = []\\n        last_closed = 0\\n        for i in range(len(seq)):\\n            if seq[i] == \\'(\\':\\n                if A_depth <= B_depth:\\n                    sol.append(0)\\n                    A_depth += 1\\n                else:\\n                    sol.append(1)\\n                    B_depth += 1\\n                last_open.append(i)\\n            else:\\n                x = sol[last_open.pop()]\\n                sol.append(x)\\n                if x == 0:\\n                    A_depth -= 1\\n                else:\\n                    B_depth -= 1\\n        return sol",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1414307,
                "title": "beats-100-5-liner-easy-code-depth-of-parenthesis",
                "content": "We always want to split the nested parentesis into alternatively, i.e. \\n1st goes to A, 2nd goes to B, 3rd goes to A, $th goes to B and so on, to minimize the overall depth\\n```\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;int d=0;\\n        for(auto e:seq)\\n            if(e==\\'(\\')ans.push_back(1&d++);\\n            else ans.push_back(--d&1);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "We always want to split the nested parentesis into alternatively, i.e. \\n1st goes to A, 2nd goes to B, 3rd goes to A, $th goes to B and so on, to minimize the overall depth\\n```\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;int d=0;\\n        for(auto e:seq)\\n            if(e==\\'(\\')ans.push_back(1&d++);\\n            else ans.push_back(--d&1);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1384132,
                "title": "python-one-pass-value-switching-method-o-n",
                "content": "The idea is simple, as deeper you go in a parenthesis, you keep switching value (0 -> 1, 1-> 0). This ensures that the max depth between group0 and group1 keeps minimum.\\n```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def switch(n):\\n            if n == 0:\\n                return 1\\n            else:\\n                return 0\\n        val = 0\\n        q = []\\n        dicc = {}\\n        ans = []\\n        q.append(seq[0])\\n        dicc[0] = val\\n        for s in range(1, len(seq)):\\n            if seq[s] == \\')\\':\\n                dicc[s] = val\\n                q.pop()\\n                if q:\\n                    val = switch (val)\\n            else:\\n                if q:\\n                    val = switch(val)\\n                dicc[s] = val\\n                q.append(seq[s])\\n        for i in dicc.keys():\\n            ans.append(dicc[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def switch(n):\\n            if n == 0:\\n                return 1\\n            else:\\n                return 0\\n        val = 0\\n        q = []\\n        dicc = {}\\n        ans = []\\n        q.append(seq[0])\\n        dicc[0] = val\\n        for s in range(1, len(seq)):\\n            if seq[s] == \\')\\':\\n                dicc[s] = val\\n                q.pop()\\n                if q:\\n                    val = switch (val)\\n            else:\\n                if q:\\n                    val = switch(val)\\n                dicc[s] = val\\n                q.append(seq[s])\\n        for i in dicc.keys():\\n            ans.append(dicc[i])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1281783,
                "title": "c-very-easy-to-understand-solution-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size(), maxdepth = 0, d = 0;\\n        vector<int> arr(n);\\n        for(int i=0; i<n; i++){\\n            if(seq[i] == \\'(\\'){\\n                d++;          \\n                arr[i] = d;\\n            }                \\n            else{\\n                arr[i] = d;\\n                d--;                \\n            }                \\n            \\n            if(maxdepth < d){\\n                maxdepth = d;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(2*arr[i] <= maxdepth)\\n                arr[i] = 0;\\n            else\\n                arr[i] = 1;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size(), maxdepth = 0, d = 0;\\n        vector<int> arr(n);\\n        for(int i=0; i<n; i++){\\n            if(seq[i] == \\'(\\'){\\n                d++;          \\n                arr[i] = d;\\n            }                \\n            else{\\n                arr[i] = d;\\n                d--;                \\n            }                \\n            \\n            if(maxdepth < d){\\n                maxdepth = d;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(2*arr[i] <= maxdepth)\\n                arr[i] = 0;\\n            else\\n                arr[i] = 1;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280652,
                "title": "need-help-the-output-i-m-generating-is-wrong-why",
                "content": "Wrong Answer\\nRuntime: 0 ms\\nYour input\\n\"(()())\"\\nOutput\\n[1,0,1,0,0,0]\\nExpected\\n[0,1,1,1,1,0]",
                "solutionTags": [],
                "code": "Wrong Answer\\nRuntime: 0 ms\\nYour input\\n\"(()())\"\\nOutput\\n[1,0,1,0,0,0]\\nExpected\\n[0,1,1,1,1,0]",
                "codeTag": "Unknown"
            },
            {
                "id": 1272383,
                "title": "python-stack-solution",
                "content": "1) Allocate all string to A by marking all elements in result[ ] as 0  \\n2) First Calculate Depths of all independent VPS(valid paranthesis string)\\n3) For paranthesis that is in deep below depth//2 mark 1\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def calculateDepth(index):\\n            stack = [seq[index]]\\n            depth = 1\\n            index+=1\\n            while stack:\\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                    depth = max(depth,len(stack))\\n                else:\\n                    stack.pop()\\n                index+=1\\n            return [depth,index]\\n        \\n        def colourize(depth,index,result):\\n            stack = [seq[index]]\\n            index+=1\\n            while stack:        \\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                else:\\n                    if len(stack)>depth//2 and result[index-1]:\\n                        result[index]=1\\n                    stack.pop()\\n                    index+=1\\n                    continue\\n                    \\n                if len(stack)>depth//2:\\n                    result[index]=1\\n                index+=1\\n                \\n            return index\\n        \\n        starts = {}\\n        result = [0 for i in range(len(seq))]\\n        index = 0\\n        \\n        \\n        while index<len(seq):\\n            depth,i= calculateDepth(index)\\n            starts[index] = depth\\n            index = i\\n        \\n        index = 0\\n        while index<len(seq):\\n            index = colourize(starts[index],index,result)\\n        \\n        return result",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def calculateDepth(index):\\n            stack = [seq[index]]\\n            depth = 1\\n            index+=1\\n            while stack:\\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                    depth = max(depth,len(stack))\\n                else:\\n                    stack.pop()\\n                index+=1\\n            return [depth,index]\\n        \\n        def colourize(depth,index,result):\\n            stack = [seq[index]]\\n            index+=1\\n            while stack:        \\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                else:\\n                    if len(stack)>depth//2 and result[index-1]:\\n                        result[index]=1\\n                    stack.pop()\\n                    index+=1\\n                    continue\\n                    \\n                if len(stack)>depth//2:\\n                    result[index]=1\\n                index+=1\\n                \\n            return index\\n        \\n        starts = {}",
                "codeTag": "Java"
            },
            {
                "id": 1269991,
                "title": "c-solution-simple-observation",
                "content": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int num=1;\\n        for(int i=0;i<seq.length();i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                num=1-num;\\n                ans.push_back(num);\\n            }\\n            else\\n            {\\n                ans.push_back(num);\\n                num=1-num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int num=1;\\n        for(int i=0;i<seq.length();i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                num=1-num;\\n                ans.push_back(num);\\n            }\\n            else\\n            {\\n                ans.push_back(num);\\n                num=1-num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266469,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n=s.size();\\n        \\n        vector<int> result(n);\\n        vector<int> open;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                int temp =  open.size();\\n                if(temp==0)\\n                {\\n                    open.push_back(0);\\n                    result[i]=0;\\n                }\\n                else\\n                {\\n                        if(open[temp-1]==0)\\n                        {\\n                            open.push_back(1);\\n                            result[i] = 1;\\n                        }\\n                        else\\n                        {\\n                            open.push_back(0);\\n                            result[i]=0;\\n                        }\\n                }    \\n            }\\n            else\\n            {\\n                int temp=open.size();\\n                result[i]=open[temp-1];\\n                open.pop_back();\\n            }\\n        }\\n    return result;\\n    }   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n=s.size();\\n        \\n        vector<int> result(n);\\n        vector<int> open;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                int temp =  open.size();\\n                if(temp==0)\\n                {\\n                    open.push_back(0);\\n                    result[i]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1266375,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> result;\\n        int depth = 0;\\n        for(int i = 0; i < seq.size(); ++i) {\\n            if(seq[i] == \\'(\\') {\\n                result.push_back(depth % 2);\\n                ++depth;\\n            } else if(seq[i] == \\')\\') {\\n                --depth;\\n                result.push_back(depth % 2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> result;\\n        int depth = 0;\\n        for(int i = 0; i < seq.size(); ++i) {\\n            if(seq[i] == \\'(\\') {\\n                result.push_back(depth % 2);\\n                ++depth;\\n            } else if(seq[i] == \\')\\') {\\n                --depth;\\n                result.push_back(depth % 2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255230,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.length());\\n        int first = 0, second = 0;\\n        \\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(i == 0 || first <= second){\\n                    ans[i] = 0;\\n                    first++;\\n                }\\n                else{\\n                    ans[i] = 1;\\n                    second++;\\n                }\\n            }\\n            else{\\n                if(second > first){\\n                    ans[i] = 1;\\n                    second--;\\n                }\\n                else{\\n                    ans[i] = 0;\\n                    first--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.length());\\n        int first = 0, second = 0;\\n        \\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(i == 0 || first <= second){\\n                    ans[i] = 0;\\n                    first++;\\n                }\\n                else{\\n                    ans[i] = 1;\\n                    second++;\\n                }\\n            }\\n            else{\\n                if(second > first){\\n                    ans[i] = 1;\\n                    second--;\\n                }\\n                else{\\n                    ans[i] = 0;\\n                    first--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246468,
                "title": "c-solution-100-beats-time",
                "content": "Simple Greedy Solution :\\n\\nWe have two buckets named **bucket-0** and **bucket-1**\\n\\nDecisions :\\n1) if current bracket is opening bracket, then put it into the bucket which has **less opening brackets**\\n2) if current bracket is closing bracket, then put it into the bucket which has **more opening brackets** (since we are equally assigning the opening brackets to the both buckets, difference between the number of opening brakcets of in two buckets is less than or eqaul to 1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int open_0 = 0, open_1 = 0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(open_0 <= open_1)\\n                    ans[i] = 0, open_0++;\\n                else\\n                    ans[i] = 1, open_1++;\\n            }\\n            else{\\n                if(open_1 >= open_0)\\n                    ans[i] = 1, open_1--;\\n                else\\n                    ans[i] = 0, open_0--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int open_0 = 0, open_1 = 0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(open_0 <= open_1)\\n                    ans[i] = 0, open_0++;\\n                else\\n                    ans[i] = 1, open_1++;\\n            }\\n            else{\\n                if(open_1 >= open_0)\\n                    ans[i] = 1, open_1--;\\n                else\\n                    ans[i] = 0, open_0--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238137,
                "title": "c-greedy-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans(seq.length(),-1);\\n        ans[0] = 0;\\n        for(int i=1;i<seq.size();i++)\\n        {\\n            if(seq[i-1]==\\'(\\' && seq[i]==\\')\\'||seq[i-1]==\\')\\' && seq[i]==\\'(\\')\\n                ans[i] = ans[i-1];\\n            else if(seq[i-1]==seq[i])\\n                ans[i] = !ans[i-1];\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans(seq.length(),-1);\\n        ans[0] = 0;\\n        for(int i=1;i<seq.size();i++)\\n        {\\n            if(seq[i-1]==\\'(\\' && seq[i]==\\')\\'||seq[i-1]==\\')\\' && seq[i]==\\'(\\')\\n                ans[i] = ans[i-1];\\n            else if(seq[i-1]==seq[i])\\n                ans[i] = !ans[i-1];\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229916,
                "title": "simple-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> v;\\n        stack<int> st;\\n        v.push_back(0);\\n        st.push(0);\\n        for(int i = 1; i<seq.length(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n            {\\n                if(st.empty() || st.top() == 1)\\n                {\\n                    st.push(0);\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    st.push(1);\\n                    v.push_back(1);\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\nTIme - O(n)\\nSpace - O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> v;\\n        stack<int> st;\\n        v.push_back(0);\\n        st.push(0);\\n        for(int i = 1; i<seq.length(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n            {\\n                if(st.empty() || st.top() == 1)\\n                {\\n                    st.push(0);\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    st.push(1);\\n                    v.push_back(1);\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565708,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565869,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565330,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565871,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568375,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566359,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566868,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566567,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568176,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1567608,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565708,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565869,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565330,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565871,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568375,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566359,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566868,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566567,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568176,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1567608,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            }
        ]
    }
]