[
    {
        "title": "Symmetric Tree",
        "question_content": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n&nbsp;\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n&nbsp;\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t-100 <= Node.val <= 100\n&nbsp;\nFollow up: Could you solve it both recursively and iteratively?",
        "solutions": [
            {
                "id": 33054,
                "title": "recursive-and-non-recursive-solutions-in-java",
                "content": "Recursive--400ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || isSymmetricHelp(root.left, root.right);\\n    }\\n    \\n    private boolean isSymmetricHelp(TreeNode left, TreeNode right){\\n        if(left==null || right==null)\\n            return left==right;\\n        if(left.val!=right.val)\\n            return false;\\n        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);\\n    }\\n\\nNon-recursive(use Stack)--460ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null)  return true;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode left, right;\\n        if(root.left!=null){\\n            if(root.right==null) return false;\\n            stack.push(root.left);\\n            stack.push(root.right);\\n        }\\n        else if(root.right!=null){\\n            return false;\\n        }\\n            \\n        while(!stack.empty()){\\n            if(stack.size()%2!=0)   return false;\\n            right = stack.pop();\\n            left = stack.pop();\\n            if(right.val!=left.val) return false;\\n            \\n            if(left.left!=null){\\n                if(right.right==null)   return false;\\n                stack.push(left.left);\\n                stack.push(right.right);\\n            }\\n            else if(right.right!=null){\\n                return false;\\n            }\\n                \\n            if(left.right!=null){\\n                if(right.left==null)   return false;\\n                stack.push(left.right);\\n                stack.push(right.left);\\n            }\\n            else if(right.left!=null){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "Recursive--400ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || isSymmetricHelp(root.left, root.right);\\n    }\\n    \\n    private boolean isSymmetricHelp(TreeNode left, TreeNode right){\\n        if(left==null || right==null)\\n            return left==right;\\n        if(left.val!=right.val)\\n            return false;\\n        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);\\n    }\\n\\nNon-recursive(use Stack)--460ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null)  return true;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode left, right;\\n        if(root.left!=null){\\n            if(root.right==null) return false;\\n            stack.push(root.left);\\n            stack.push(root.right);\\n        }\\n        else if(root.right!=null){\\n            return false;\\n        }\\n            \\n        while(!stack.empty()){\\n            if(stack.size()%2!=0)   return false;\\n            right = stack.pop();\\n            left = stack.pop();\\n            if(right.val!=left.val) return false;\\n            \\n            if(left.left!=null){\\n                if(right.right==null)   return false;\\n                stack.push(left.left);\\n                stack.push(right.right);\\n            }\\n            else if(right.right!=null){\\n                return false;\\n            }\\n                \\n            if(left.right!=null){\\n                if(right.left==null)   return false;\\n                stack.push(left.right);\\n                stack.push(right.left);\\n            }\\n            else if(right.left!=null){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33050,
                "title": "recursively-and-iteratively-solution-in-python",
                "content": "Basically, this question is recursively. Or we can say, the tree structure is recursively, so the recursively solution maybe easy to write:\\n\\nTC: O(b) SC: O(log n)\\n\\n    class Solution:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n        else:\\n          return self.isMirror(root.left, root.right)\\n\\n      def isMirror(self, left, right):\\n        if left is None and right is None:\\n          return True\\n        if left is None or right is None:\\n          return False\\n\\n        if left.val == right.val:\\n          outPair = self.isMirror(left.left, right.right)\\n          inPiar = self.isMirror(left.right, right.left)\\n          return outPair and inPiar\\n        else:\\n          return False\\n\\nThe essence of recursively is Stack, so we can use our own stack to rewrite it into iteratively:\\n\\n     class Solution2:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n\\n        stack = [[root.left, root.right]]\\n\\n        while len(stack) > 0:\\n          pair = stack.pop(0)\\n          left = pair[0]\\n          right = pair[1]\\n\\n          if left is None and right is None:\\n            continue\\n          if left is None or right is None:\\n            return False\\n          if left.val == right.val:\\n            stack.insert(0, [left.left, right.right])\\n\\n            stack.insert(0, [left.right, right.left])\\n          else:\\n            return False\\n        return True",
                "solutionTags": [],
                "code": "Basically, this question is recursively. Or we can say, the tree structure is recursively, so the recursively solution maybe easy to write:\\n\\nTC: O(b) SC: O(log n)\\n\\n    class Solution:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n        else:\\n          return self.isMirror(root.left, root.right)\\n\\n      def isMirror(self, left, right):\\n        if left is None and right is None:\\n          return True\\n        if left is None or right is None:\\n          return False\\n\\n        if left.val == right.val:\\n          outPair = self.isMirror(left.left, right.right)\\n          inPiar = self.isMirror(left.right, right.left)\\n          return outPair and inPiar\\n        else:\\n          return False\\n\\nThe essence of recursively is Stack, so we can use our own stack to rewrite it into iteratively:\\n\\n     class Solution2:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n\\n        stack = [[root.left, root.right]]\\n\\n        while len(stack) > 0:\\n          pair = stack.pop(0)\\n          left = pair[0]\\n          right = pair[1]\\n\\n          if left is None and right is None:\\n            continue\\n          if left is None or right is None:\\n            return False\\n          if left.val == right.val:\\n            stack.insert(0, [left.left, right.right])\\n\\n            stack.insert(0, [left.right, right.left])\\n          else:\\n            return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 33104,
                "title": "1ms-recursive-java-solution-easy-to-understand",
                "content": "     public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return isMirror(root.left,root.right);\\n    }\\n    public boolean isMirror(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isMirror(p.left,q.right) && isMirror(p.right,q.left);\\n    }",
                "solutionTags": [],
                "code": "     public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return isMirror(root.left,root.right);\\n    }\\n    public boolean isMirror(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isMirror(p.left,q.right) && isMirror(p.right,q.left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290112,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n To check if a binary tree is symmetric, we need to compare its left subtree and right subtree. To do this, we can traverse the tree recursively and compare the left and right subtrees at each level. If they are symmetric, we continue the traversal. Otherwise, we can immediately return false.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.\\n\\n\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $$O(n)$$, where n is the number of nodes in the binary tree. We need to visit each node once to check if the tree is symmetric.\\n- Space complexity:\\nThe space complexity of the algorithm is $$O(h)$$, where h is the height of the binary tree. In the worst case, the tree can be completely unbalanced, and the recursion stack can go as deep as the height of the tree.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return isMirror(root.left, root.right);\\n    }\\n    \\n    private boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) {\\n            return true;\\n        }\\n        if (node1 == null || node2 == null) {\\n            return false;\\n        }\\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def isMirror(self, left, right):\\n        if not left and not right:\\n            return True\\n        if not left or not right:\\n            return False\\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\\n    \\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* left, TreeNode* right) {\\n    if (!left && !right) return true;\\n    if (!left || !right) return false;\\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\\n}\\n\\nbool isSymmetric(TreeNode* root) {\\n    if (!root) return true;\\n    return isMirror(root->left, root->right);\\n}\\n\\n};\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return isMirror(root.left, root.right);\\n    }\\n    \\n    private boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) {\\n            return true;\\n        }\\n        if (node1 == null || node2 == null) {\\n            return false;\\n        }\\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution(object):\\n    def isMirror(self, left, right):\\n        if not left and not right:\\n            return True\\n        if not left or not right:\\n            return False\\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\\n    \\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* left, TreeNode* right) {\\n    if (!left && !right) return true;\\n    if (!left || !right) return false;\\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\\n}\\n\\nbool isSymmetric(TreeNode* root) {\\n    if (!root) return true;\\n    return isMirror(root->left, root->right);\\n}\\n\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33089,
                "title": "my-c-accepted-code-in-16ms-with-iteration-solution",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            TreeNode *left, *right;\\n            if (!root)\\n                return true;\\n            \\n            queue<TreeNode*> q1, q2;\\n            q1.push(root->left);\\n            q2.push(root->right);\\n            while (!q1.empty() && !q2.empty()){\\n                left = q1.front();\\n                q1.pop();\\n                right = q2.front();\\n                q2.pop();\\n                if (NULL == left && NULL == right)\\n                    continue;\\n                if (NULL == left || NULL == right)\\n                    return false;\\n                if (left->val != right->val)\\n                    return false;\\n                q1.push(left->left);\\n                q1.push(left->right);\\n                q2.push(right->right);\\n                q2.push(right->left);\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            TreeNode *left, *right;\\n            if (!root)\\n                return true;\\n            \\n            queue<TreeNode*> q1, q2;\\n            q1.push(root->left);\\n            q2.push(root->right);\\n            while (!q1.empty() && !q2.empty()){\\n                left = q1.front();\\n                q1.pop();\\n                right = q2.front();\\n                q2.pop();\\n                if (NULL == left && NULL == right)\\n                    continue;\\n                if (NULL == left || NULL == right)\\n                    return false;\\n                if (left->val != right->val)\\n                    return false;\\n                q1.push(left->left);\\n                q1.push(left->right);\\n                q2.push(right->right);\\n                q2.push(right->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33056,
                "title": "15-lines-of-c-solution-8-ms",
                "content": "    bool isSymmetric(TreeNode *root) {\\n            if (!root) return true;\\n            return helper(root->left, root->right);\\n        }\\n        \\n        bool helper(TreeNode* p, TreeNode* q) {\\n            if (!p && !q) {\\n                return true;\\n            } else if (!p || !q) {\\n                return false;\\n            }\\n            \\n            if (p->val != q->val) {\\n                return false;\\n            }\\n            \\n            return helper(p->left,q->right) && helper(p->right, q->left); \\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    bool isSymmetric(TreeNode *root) {\\n            if (!root) return true;\\n            return helper(root->left, root->right);\\n        }\\n        \\n        bool helper(TreeNode* p, TreeNode* q) {\\n            if (!p && !q) {\\n                return true;\\n            } else if (!p || !q) {\\n                return false;\\n            }\\n            \\n            if (p->val != q->val) {\\n                return false;\\n            }\\n            \\n            return helper(p->left,q->right) && helper(p->right, q->left); \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1064732,
                "title": "c-easy-solution-with-comments-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33068,
                "title": "6line-ac-python",
                "content": "\\n\\n\\n        def isSymmetric(self, root):\\n            def isSym(L,R):\\n                if not L and not R: return True\\n                if L and R and L.val == R.val: \\n                    return isSym(L.left, R.right) and isSym(L.right, R.left)\\n                return False\\n            return isSym(root, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n\\n        def isSymmetric(self, root):\\n            def isSym(L,R):\\n                if not L and not R: return True\\n                if L and R and L.val == R.val: \\n                    return isSym(L.left, R.right) and isSym(L.right, R.left)\\n                return False\\n            return isSym(root, root)",
                "codeTag": "Python3"
            },
            {
                "id": 3094040,
                "title": "easiest-beginner-friendly-sol-with-diagram-dfs-o-n-time-and-o-h-space",
                "content": "**For Iterative approach please find below link :**\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3290155/day-72-with-diagram-iterative-and-recursive-easiest-beginner-friendly-sol/\\n# Intuition\\nWe need to validate only 3 conditions including base condition and recursively call to the function:\\n- If both \"leftRoot\" and \"rightRoot\" are null, return true\\n- If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n\\n![WhatsApp Image 2023-01-24 at 6.54.24 PM.jpeg](https://assets.leetcode.com/users/images/3ce67a24-c51f-4cff-a5ac-58425726b650_1674566690.8242106.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function \"isTreeSymmetric\" that takes in two TreeNode pointers as inputs, \"leftRoot\" and \"rightRoot\"\\n2. If both \"leftRoot\" and \"rightRoot\" are null, return true\\n3. If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n4. If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n5. If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n6. Return true if both recursive calls return true, else return false\\n7. Define a function \"isSymmetric\" that takes in a TreeNode pointer \"root\" as input\\n8. Call \"isTreeSymmetric\" on the left child of \"root\" and the right child of \"root\" and return the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, where n is the total number of nodes in the binary tree. This is because the solution visits each node once and compares its values with the corresponding symmetric node, thus the function isTreeSymmetric() is called on each node at most once. The time complexity of the isTreeSymmetric() function is O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric) and in the worst case it visits all nodes in the tree (when the tree is not symmetric).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, the height of the tree is equal to n, thus the space complexity becomes O(n). However, in the best case when the binary tree is perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n)).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33325,
                "title": "python-short-recursive-and-iterative-solutions",
                "content": "\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.dfs(root.left, root.right)\\n        \\n    def dfs(self, l, r):\\n        if l and r:\\n            return l.val == r.val and self.dfs(l.left, r.right) and self.dfs(l.right, r.left)\\n        return l == r\\n\\t\\t\\n\\tdef isSymmetric(self, root):\\n        if not root:\\n            return True\\n        stack = [(root.left, root.right)]\\n        while stack:\\n            l, r = stack.pop()\\n            if not l and not r:\\n                continue\\n            if not l or not r or (l.val != r.val):\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.dfs(root.left, root.right)\\n        \\n    def dfs(self, l, r):\\n        if l and r:\\n            return l.val == r.val and self.dfs(l.left, r.right) and self.dfs(l.right, r.left)\\n        return l == r\\n\\t\\t\\n\\tdef isSymmetric(self, root):\\n        if not root:\\n            return True\\n        stack = [(root.left, root.right)]\\n        while stack:\\n            l, r = stack.pop()\\n            if not l and not r:\\n                continue\\n            if not l or not r or (l.val != r.val):\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 33152,
                "title": "short-and-clean-java-iterative-solution",
                "content": "     public boolean isSymmetric(TreeNode root) {\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            if(root == null) return true;\\n            q.add(root.left);\\n            q.add(root.right);\\n            while(q.size() > 1){\\n                TreeNode left = q.poll(),\\n                         right = q.poll();\\n                if(left== null&& right == null) continue;\\n                if(left == null ^ right == null) return false;\\n                if(left.val != right.val) return false;\\n                q.add(left.left);\\n                q.add(right.right);\\n                q.add(left.right);\\n                q.add(right.left);            \\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "     public boolean isSymmetric(TreeNode root) {\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            if(root == null) return true;\\n            q.add(root.left);\\n            q.add(root.right);\\n            while(q.size() > 1){\\n                TreeNode left = q.poll(),\\n                         right = q.poll();\\n                if(left== null&& right == null) continue;\\n                if(left == null ^ right == null) return false;\\n                if(left.val != right.val) return false;\\n                q.add(left.left);\\n                q.add(right.right);\\n                q.add(left.right);\\n                q.add(right.left);            \\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 33073,
                "title": "javascript-recursive-and-iterative-solutions",
                "content": "The idea is to check whether the tree's left and right subtrees are mirroring each other, we can use preorder traversal:\\n```\\nvar isSymmetric = function(root) {\\n    if (!root) { // Sanity check\\n        return true;\\n    }\\n\\n    // Check if tree s & t are mirroring each other\\n    function isMirror(s, t) {\\n        if (!s && !t) {\\n            return true; // Both nodes are null, ok\\n        }\\n        if (!s || !t || s.val !== t.val) {\\n            return false; // Found a mismatch\\n        }\\n        // Compare the left subtree of `s` with the right subtree of `t`\\n        // and the right subtree of `s` with the left subtree of `t`\\n        return isMirror(s.left, t.right) && isMirror(s.right, t.left);\\n    }\\n\\n    return isMirror(root.left, root.right);\\n};\\n```\\nAs it's preorder DFS, time complexity is `O(n)`, and space complexity is `O(1)` if we ignore the recursion stack which is the height of the tree.\\n\\nThe question asks us to implement the solution iteratively, and it's easy to convert the above preorder to make it traverse iteratively using stack:\\n```\\nfunction isMirror(p, q) {\\n    // Create two stacks\\n    var s1 = [p], s2 = [q];\\n\\n    // Perform preorder traversal\\n    while (s1.length > 0 || s2.length > 0) {\\n        var n1 = s1.pop(), n2 = s2.pop();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        s1.push(n1.left); s1.push(n1.right);\\n        s2.push(n2.right); s2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\\nTime complexity is still `O(n)`, and space complexity is the height of the tree.\\n\\nAnother solution is to use BFS, we just need to traverse both subtrees in level order, one from left to right, and the other is right to left, let's modify the above `isMirror` function to the following:\\n```\\nfunction isMirror(s, t) {\\n    var q1 = [s], q2 = [t];\\n\\n    // Perform breadth-first search\\n    while (q1.length > 0 || q2.length > 0) {\\n        // Dequeue\\n        var n1 = q1.shift(), n2 = q2.shift();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        q1.push(n1.left); q1.push(n1.right);\\n        q2.push(n2.right); q2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\\nTime complexity is `O(n)` and space complexity is the width of the tree.",
                "solutionTags": [],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if (!root) { // Sanity check\\n        return true;\\n    }\\n\\n    // Check if tree s & t are mirroring each other\\n    function isMirror(s, t) {\\n        if (!s && !t) {\\n            return true; // Both nodes are null, ok\\n        }\\n        if (!s || !t || s.val !== t.val) {\\n            return false; // Found a mismatch\\n        }\\n        // Compare the left subtree of `s` with the right subtree of `t`\\n        // and the right subtree of `s` with the left subtree of `t`\\n        return isMirror(s.left, t.right) && isMirror(s.right, t.left);\\n    }\\n\\n    return isMirror(root.left, root.right);\\n};\\n```\n```\\nfunction isMirror(p, q) {\\n    // Create two stacks\\n    var s1 = [p], s2 = [q];\\n\\n    // Perform preorder traversal\\n    while (s1.length > 0 || s2.length > 0) {\\n        var n1 = s1.pop(), n2 = s2.pop();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        s1.push(n1.left); s1.push(n1.right);\\n        s2.push(n2.right); s2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\n```\\nfunction isMirror(s, t) {\\n    var q1 = [s], q2 = [t];\\n\\n    // Perform breadth-first search\\n    while (q1.length > 0 || q2.length > 0) {\\n        // Dequeue\\n        var n1 = q1.shift(), n2 = q2.shift();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        q1.push(n1.left); q1.push(n1.right);\\n        q2.push(n2.right); q2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423766,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Symmetric Tree.\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        // Soecial case...\\n        if (root == null)\\n\\t\\t    return true;\\n        // call the function  recursively...\\n\\t    return isSymmetric(root.left, root.right);\\n    }\\n    // After division the tree will be divided in two parts...\\n    // The root of the left part is rootleft & the root of the right part is rootright...\\n    public boolean isSymmetric(TreeNode rootleft, TreeNode rootright) {\\n        // If root of the left part & the root of the right part is same, return true...\\n\\t    if (rootleft == null && rootright == null) {\\n\\t\\t    return true;\\n\\t    }\\n        // If root of any part is null, then the binary tree is not symmetric. So return false...\\n        else if (rootright == null || rootleft == null) {\\n\\t\\t    return false;\\n\\t    }\\n        // If the value of the root of the left part is not equal to the value of the root of the right part...\\n        if (rootleft.val != rootright.val)\\n\\t\\t    return false;\\n        // In case of not symmetric...\\n        if (!isSymmetric(rootleft.left, rootright.right))\\n\\t\\t    return false;\\n\\t    if (!isSymmetric(rootleft.right, rootright.left))\\n\\t\\t    return false;\\n        // Otherwise, return true...\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        // Special case...\\n        if(root == nullptr) return true;\\n        // Return the function recursively...\\n        return isSymmetric(root->left,root->right);\\n    }\\n    // A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    bool isSymmetric(TreeNode* leftroot,TreeNode* rightroot){\\n        // If both root nodes are null pointers, return true...\\n        if(!leftroot && !rightroot)  return true;\\n        // If exactly one of them is a null node, return false...\\n        if(!leftroot || !rightroot)  return false;\\n        // If root nodes haven\\'t same value, return false...\\n        if(leftroot->val != rightroot->val)  return false;\\n        // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return isSymmetric(leftroot->left, rightroot->right) && isSymmetric(leftroot->right, rightroot->left);\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\\n            \\n# **JavaScript Solution:**\\nRuntime: 66 ms, faster than 97.80% of JavaScript online submissions for Symmetric Tree.\\n```\\nvar isSymmetric = function(root) {\\n    // Special case...\\n    if (!root)\\n        return true;\\n    // Return the function recursively...\\n    return isSame(root.left, root.right);\\n};\\n// A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\nvar isSame = function (leftroot, rightroot) {\\n    // If both root nodes are null pointers, return true...\\n    // If exactly one of them is a null node, return false...\\n    // If root nodes haven\\'t same value, return false...\\n    if ((!leftroot && rightroot) || (leftroot && !rightroot) || (leftroot && rightroot && leftroot.val !== rightroot.val))\\n        return false;\\n    // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n    if (leftroot && rightroot)\\n        return isSame(leftroot.left, rightroot.right) && isSame(leftroot.right, rightroot.left);\\n    return true;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        // Soecial case...\\n        if (root == null)\\n\\t\\t    return true;\\n        // call the function  recursively...\\n\\t    return isSymmetric(root.left, root.right);\\n    }\\n    // After division the tree will be divided in two parts...\\n    // The root of the left part is rootleft & the root of the right part is rootright...\\n    public boolean isSymmetric(TreeNode rootleft, TreeNode rootright) {\\n        // If root of the left part & the root of the right part is same, return true...\\n\\t    if (rootleft == null && rootright == null) {\\n\\t\\t    return true;\\n\\t    }\\n        // If root of any part is null, then the binary tree is not symmetric. So return false...\\n        else if (rootright == null || rootleft == null) {\\n\\t\\t    return false;\\n\\t    }\\n        // If the value of the root of the left part is not equal to the value of the root of the right part...\\n        if (rootleft.val != rootright.val)\\n\\t\\t    return false;\\n        // In case of not symmetric...\\n        if (!isSymmetric(rootleft.left, rootright.right))\\n\\t\\t    return false;\\n\\t    if (!isSymmetric(rootleft.right, rootright.left))\\n\\t\\t    return false;\\n        // Otherwise, return true...\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        // Special case...\\n        if(root == nullptr) return true;\\n        // Return the function recursively...\\n        return isSymmetric(root->left,root->right);\\n    }\\n    // A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    bool isSymmetric(TreeNode* leftroot,TreeNode* rightroot){\\n        // If both root nodes are null pointers, return true...\\n        if(!leftroot && !rightroot)  return true;\\n        // If exactly one of them is a null node, return false...\\n        if(!leftroot || !rightroot)  return false;\\n        // If root nodes haven\\'t same value, return false...\\n        if(leftroot->val != rightroot->val)  return false;\\n        // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return isSymmetric(leftroot->left, rightroot->right) && isSymmetric(leftroot->right, rightroot->left);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\n```\\nvar isSymmetric = function(root) {\\n    // Special case...\\n    if (!root)\\n        return true;\\n    // Return the function recursively...\\n    return isSame(root.left, root.right);\\n};\\n// A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\nvar isSame = function (leftroot, rightroot) {\\n    // If both root nodes are null pointers, return true...\\n    // If exactly one of them is a null node, return false...\\n    // If root nodes haven\\'t same value, return false...\\n    if ((!leftroot && rightroot) || (leftroot && !rightroot) || (leftroot && rightroot && leftroot.val !== rightroot.val))\\n        return false;\\n    // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n    if (leftroot && rightroot)\\n        return isSame(leftroot.left, rightroot.right) && isSame(leftroot.right, rightroot.left);\\n    return true;\\n};\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290198,
                "title": "image-explanation-recursive-non-recursive-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/41j4iR4Gx9s\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/a0ec0746-4ddd-4dec-adbd-d540f823e889_1678669824.4317465.png)\\n![image.png](https://assets.leetcode.com/users/images/a7825991-e7bf-44b1-ba38-c68853372580_1678669848.2439427.png)\\n![image.png](https://assets.leetcode.com/users/images/7065f13f-bb82-4066-983e-cba9fc6239ab_1678669858.1537697.png)\\n![image.png](https://assets.leetcode.com/users/images/c86dff88-7545-47af-a3ee-214e784692ff_1678669864.8307462.png)\\n![image.png](https://assets.leetcode.com/users/images/8f319a20-de8c-496c-9b8b-a0594c51114e_1678669872.3450804.png)\\n![image.png](https://assets.leetcode.com/users/images/a1a5be50-9390-4d6a-9019-08f2eb5dae6f_1678669881.0141463.png)\\n![image.png](https://assets.leetcode.com/users/images/401aedaf-4111-4649-81c8-16282f60662a_1678669890.8298717.png)\\n![image.png](https://assets.leetcode.com/users/images/a2194d4e-58e3-45ec-9f0b-79968f851827_1678669898.3149576.png)\\n![image.png](https://assets.leetcode.com/users/images/01d99578-7858-415f-9e4f-931f458bf59c_1678669906.1509514.png)\\n![image.png](https://assets.leetcode.com/users/images/da50d440-dc6b-4c47-a46e-b4a5376151b3_1678669914.0028672.png)\\n\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\\n        if(leftNode==NULL && rightNode==NULL) return true;\\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n        \\n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n        return isSymmetricHelper(root->left, root->right);\\n    }\\n};\\n```\\n\\n# Non-Recursive Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n\\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        while(!q.empty()){\\n            TreeNode* leftNode = q.front();\\n            q.pop();\\n            TreeNode* rightNode = q.front();\\n            q.pop();\\n\\n            if(leftNode==NULL && rightNode==NULL) continue;\\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n            q.push(leftNode->left);\\n            q.push(rightNode->right);\\n            q.push(leftNode->right);\\n            q.push(rightNode->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\\n        if(leftNode==NULL && rightNode==NULL) return true;\\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n        \\n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n        return isSymmetricHelper(root->left, root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n\\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        while(!q.empty()){\\n            TreeNode* leftNode = q.front();\\n            q.pop();\\n            TreeNode* rightNode = q.front();\\n            q.pop();\\n\\n            if(leftNode==NULL && rightNode==NULL) continue;\\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n            q.push(leftNode->left);\\n            q.push(rightNode->right);\\n            q.push(leftNode->right);\\n            q.push(rightNode->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433170,
                "title": "ismirror-dfs-recursion-one-two-stacks-bfs-queue-solution-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/symmetric-tree/) <span class=\"gray\">EPI 9.2</span>\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\\n\\n**Example:** \\n\\n`[1,2,2,3,4,4,3]` is symmetric:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\\n\\nBut the following `[1,2,2,null,3,null,3]` is not:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n   \\\\   \\\\\\n   3    3\\n```\\n\\n**Follow up:** Bonus points if you could solve it both `recursively` and `iteratively`.\\n\\n\\n\\n\\n## Analysis\\n\\n**Idea:** A tree is symmetric if it is a `mirror reflection` of itself.\\n\\n**Note:** Distinguish the concept of `symmetric` (one tree) and `mirror reflection` (two trees).\\n\\n```java\\n    1\\n   / \\\\\\n  2   2       t1 & t2\\n / \\\\ / \\\\\\n3  4 4  3\\n|  | |  |\\n---|-|----->  isMirror(t1.left, t2.right)\\n   | |      \\n   -------->  isMirror(t1.right, t2.left)\\n```\\n\\nThe question is when are two trees a mirror reflection of each other? **Three conditions:**\\n\\n- Their two roots have the same value.\\n- The right subtree `t1.right` of each tree `t1` is a mirror reflection of the left subtree `t2.left` of the other tree `t2`.\\n- The left subtree `t1.left` of each tree `t1` is a mirror reflection of the right subtree `t2.right` of the other tree `t2`.\\n\\n**Bad Idea (the wrong direction):**\\n\\nA tree is symmetric if its left subtree is symmetric and its right subtree is symmetric. Consider this case:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\\n\\nTwo subtrees of root are not symmetric, but the root is symmetric.\\n\\n\\nFrom EPI, swapping any subtrees of a tree and comparing with the original is also workable.\\n\\n\\n\\n### Recursion\\n\\nCome up with the recursive structure.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  return isMirror(root, root);\\n}\\n\\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\\n  // base case\\n  if (t1 == null && t2 == null) return true;\\n  if (t1 == null || t2 == null) return false;\\n  // check values\\n  if (t1.val != t2.val) return false;\\n  // check left subtree and right subtree\\n  return isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\\n}\\n```\\n\\n**Improvement:**\\n\\nActually, there is not too much improvement since it is bounded by a constant `2`.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // required\\n    return true;\\n  }\\n  return isMirror(root.left, root.right); // so t1 and t2 are different trees\\n}\\n```\\n\\n**Time:** `O(N)` because we traverse the entire input tree once (`\\\\sim 2N`).\\n**Space:** `O(h)`\\n\\n\\n\\n\\n### Iteration (One/Two Stacks)\\n\\nUse two stacks to simulate the recursive method.\\n\\n**Note:** Null check => Value check\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // need checking because we use root\\'s value\\n    return true;\\n  }\\n  Stack<TreeNode> lStack = new Stack<>();\\n  Stack<TreeNode> rStack = new Stack<>();\\n  // Preorder-like traversal\\n  lStack.push(root.left); rStack.push(root.right);\\n  \\n  while (lStack.size() > 0 && rStack.size() > 0)  {\\n    TreeNode t1 = lStack.pop();\\n    TreeNode t2 = rStack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    lStack.push(t1.right); lStack.push(t1.left); // could be null\\n    rStack.push(t2.left);  rStack.push(t2.right);\\n  }\\n  // One of the stack might be empty\\n  return lStack.size() == 0 && rStack.size() == 0;\\n}\\n```\\n\\nOr just use one stack:\\n\\n- Be careful of the ordering of pushing.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  if (root.left == null && root.right == null) return true;\\n  if (root.left == null || root.right == null) return false;\\n  // children are not null\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n  \\n  while (stack.size() > 0) {\\n    TreeNode t1 = stack.pop();\\n    TreeNode t2 = stack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    stack.push(t1.right); stack.push(t2.left); // could be null\\n    stack.push(t1.left); stack.push(t2.right);\\n  }\\n  \\n  return true;\\n}\\n```\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(h)`\\n\\n\\n\\n\\n### Iteration (BFS)\\n\\nCompare nodes at each layer.\\n- Each two consecutive nodes in the queue should be equal.\\n- Each time, two nodes are extracted and their values are compared.\\n- Then their right and left children of the two nodes are enqueued in opposite order.\\n\\n```java\\n    1\\n   / \\\\\\n  2   2     queue: 2    2 (t1)\\n / \\\\ / \\\\\\n3  4 4  3   queue: 4    4    3    3\\n                           t2.r t1.l\\n```\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  Queue<TreeNode> queue = new LinkedList<>();\\n  queue.offer(root.left);\\n  queue.offer(root.right);\\n\\n  while (queue.size() > 0) {\\n    TreeNode t1 = queue.poll();\\n    TreeNode t2 = queue.poll();\\n    // check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    if (t1.val != t2.val) return false;\\n    // offer children\\n    queue.offer(t1.left);\\n    queue.offer(t2.right);\\n\\n    queue.offer(t1.right);\\n    queue.offer(t2.left);\\n  }\\n  return true;\\n}\\n```\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(w)` where `w` is the maximum number nodes in a level of the tree.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\n```java\\n    1\\n   / \\\\\\n  2   2\\n   \\\\   \\\\\\n   3    3\\n```\n```java\\n    1\\n   / \\\\\\n  2   2       t1 & t2\\n / \\\\ / \\\\\\n3  4 4  3\\n|  | |  |\\n---|-|----->  isMirror(t1.left, t2.right)\\n   | |      \\n   -------->  isMirror(t1.right, t2.left)\\n```\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  return isMirror(root, root);\\n}\\n\\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\\n  // base case\\n  if (t1 == null && t2 == null) return true;\\n  if (t1 == null || t2 == null) return false;\\n  // check values\\n  if (t1.val != t2.val) return false;\\n  // check left subtree and right subtree\\n  return isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // required\\n    return true;\\n  }\\n  return isMirror(root.left, root.right); // so t1 and t2 are different trees\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // need checking because we use root\\'s value\\n    return true;\\n  }\\n  Stack<TreeNode> lStack = new Stack<>();\\n  Stack<TreeNode> rStack = new Stack<>();\\n  // Preorder-like traversal\\n  lStack.push(root.left); rStack.push(root.right);\\n  \\n  while (lStack.size() > 0 && rStack.size() > 0)  {\\n    TreeNode t1 = lStack.pop();\\n    TreeNode t2 = rStack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    lStack.push(t1.right); lStack.push(t1.left); // could be null\\n    rStack.push(t2.left);  rStack.push(t2.right);\\n  }\\n  // One of the stack might be empty\\n  return lStack.size() == 0 && rStack.size() == 0;\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  if (root.left == null && root.right == null) return true;\\n  if (root.left == null || root.right == null) return false;\\n  // children are not null\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n  \\n  while (stack.size() > 0) {\\n    TreeNode t1 = stack.pop();\\n    TreeNode t2 = stack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    stack.push(t1.right); stack.push(t2.left); // could be null\\n    stack.push(t1.left); stack.push(t2.right);\\n  }\\n  \\n  return true;\\n}\\n```\n```java\\n    1\\n   / \\\\\\n  2   2     queue: 2    2 (t1)\\n / \\\\ / \\\\\\n3  4 4  3   queue: 4    4    3    3\\n                           t2.r t1.l\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  Queue<TreeNode> queue = new LinkedList<>();\\n  queue.offer(root.left);\\n  queue.offer(root.right);\\n\\n  while (queue.size() > 0) {\\n    TreeNode t1 = queue.poll();\\n    TreeNode t2 = queue.poll();\\n    // check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    if (t1.val != t2.val) return false;\\n    // offer children\\n    queue.offer(t1.left);\\n    queue.offer(t2.right);\\n\\n    queue.offer(t1.right);\\n    queue.offer(t2.left);\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33080,
                "title": "recursive-and-iterative-dfs-and-bfs-in-c-easy-to-understand",
                "content": "**Iterative in BFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<nodepair> q;\\n        q.push(make_pair(root->left, root->right));\\n        while(!q.empty()){\\n            nodepair p = q.front();\\n            q.pop();\\n            if(!p.first && !p.second) continue;\\n            if(!p.first || !p.second) return false;\\n            if(p.first->val != p.second->val) return false;\\n            q.push(make_pair(p.first->left, p.second->right));\\n            q.push(make_pair(p.first->right, p.second->left));\\n        }\\n        return true;\\n    }\\n\\n**Iterative in DFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        stack<TreeNode*> sl, sr;\\n        sl.push(root);\\n        sr.push(root);\\n        TreeNode * lp = root->left, *rp = root->right;\\n        while(lp || ! sl.empty() || rp || !sl.empty()){\\n            if((!lp && rp) || (lp && !rp)) return false;\\n            if(lp && rp){\\n                if(lp->val != rp->val) return false;\\n                sl.push(lp);\\n                sr.push(rp);\\n                lp = lp->left;\\n                rp = rp->right;\\n            }else{\\n                lp = sl.top()->right;\\n                rp = sr.top()->left;\\n                sl.pop();\\n                sr.pop();\\n            }\\n        }\\n        return true;\\n    }\\n\\n**Recursive**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return helper(root->left, root->right);\\n    }\\n    bool helper(TreeNode* left, TreeNode* right){\\n        if(!left && !right) return true;\\n        if(!left || !right) return false;\\n        return (left->val == right->val) && helper(left->left, right->right) && helper(left->right, right->left);\\n    }",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "**Iterative in BFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<nodepair> q;\\n        q.push(make_pair(root->left, root->right));\\n        while(!q.empty()){\\n            nodepair p = q.front();\\n            q.pop();\\n            if(!p.first && !p.second) continue;\\n            if(!p.first || !p.second) return false;\\n            if(p.first->val != p.second->val) return false;\\n            q.push(make_pair(p.first->left, p.second->right));\\n            q.push(make_pair(p.first->right, p.second->left));\\n        }\\n        return true;\\n    }\\n\\n**Iterative in DFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        stack<TreeNode*> sl, sr;\\n        sl.push(root);\\n        sr.push(root);\\n        TreeNode * lp = root->left, *rp = root->right;\\n        while(lp || ! sl.empty() || rp || !sl.empty()){\\n            if((!lp && rp) || (lp && !rp)) return false;\\n            if(lp && rp){\\n                if(lp->val != rp->val) return false;\\n                sl.push(lp);\\n                sr.push(rp);\\n                lp = lp->left;\\n                rp = rp->right;\\n            }else{\\n                lp = sl.top()->right;\\n                rp = sr.top()->left;\\n                sl.pop();\\n                sr.pop();\\n            }\\n        }\\n        return true;\\n    }\\n\\n**Recursive**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return helper(root->left, root->right);\\n    }\\n    bool helper(TreeNode* left, TreeNode* right){\\n        if(!left && !right) return true;\\n        if(!left || !right) return false;\\n        return (left->val == right->val) && helper(left->left, right->right) && helper(left->right, right->left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290298,
                "title": "c-easy-solution-recursive-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFRecursive Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode*r1,TreeNode*r2){\\n        //if we have both root to nullptr then we will return true\\n        //else we will be returning false\\n        \\n        if(!r1||!r2)\\n            return r1==r2;\\n        //if not null then we will check for the r1 and r2 values\\n        if(r1->val==r2->val){\\n        //we will check for the r1 left and r2 right because they will be on opposite sides\\n            return isEqual(r1->left,r2->right)&&isEqual(r1->right,r2->left);\\n        }\\n        //if r1 val not equal to r2 val then return false\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        //The Approach is simple i.e. we will have to check if \\n            //1. the right and left is equal \\n        return isEqual(root->left,root->right);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode*r1,TreeNode*r2){\\n        //if we have both root to nullptr then we will return true\\n        //else we will be returning false\\n        \\n        if(!r1||!r2)\\n            return r1==r2;\\n        //if not null then we will check for the r1 and r2 values\\n        if(r1->val==r2->val){\\n        //we will check for the r1 left and r2 right because they will be on opposite sides\\n            return isEqual(r1->left,r2->right)&&isEqual(r1->right,r2->left);\\n        }\\n        //if r1 val not equal to r2 val then return false\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        //The Approach is simple i.e. we will have to check if \\n            //1. the right and left is equal \\n        return isEqual(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398964,
                "title": "c-recursive-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {    \\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        return solve(root->left, root->right);     \\n    }\\n};\\n```\\n\\nExplanation :\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {\\n        // See the tree diagram are r1 and r2 null ? No, so this line dont execute\\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are\\n        // same so this else if wont execute either\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        // Now comes the main part, we are calling 2 seperate function calls \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n        // First solve() before && will execute\\n        // r1->left is 3 and r2->right = 3\\n        // Both values are same , they will by pass both if and else if statement\\n        // Now again r1->left is null and r2->right is null\\n        // So they will return true from first if condtion\\n        // Now the scene is : we have executed first solve() before && and it has\\n        // returned us True so expression becomes \\' return true && solve() \\'\\n        // Now solve after && will execute \\n        // Similarly it will check for 4 and 4 , it will by pass if else statements\\n        // next time both will become null, so will return true\\n        // Thus 2nd solve() at the end will also hold true\\n        // and we know \\'true && true\\' is true\\n        // so true will be returned to caller, and thus tree is mirror of itself.\\n        // Similarly you can check for any testcase, flow of execution will remain same.\\n        \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        // Imagine a tree:    1\\n        //                 2     2\\n        //               3   4 4   3\\n        // We are standing on root that is 1, function begins\\n        // and now r1 and r2 points to 2 and 2 respectively.                      \\n        return solve(root->left, root->right);     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {    \\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        return solve(root->left, root->right);     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {\\n        // See the tree diagram are r1 and r2 null ? No, so this line dont execute\\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are\\n        // same so this else if wont execute either\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        // Now comes the main part, we are calling 2 seperate function calls \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n        // First solve() before && will execute\\n        // r1->left is 3 and r2->right = 3\\n        // Both values are same , they will by pass both if and else if statement\\n        // Now again r1->left is null and r2->right is null\\n        // So they will return true from first if condtion\\n        // Now the scene is : we have executed first solve() before && and it has\\n        // returned us True so expression becomes \\' return true && solve() \\'\\n        // Now solve after && will execute \\n        // Similarly it will check for 4 and 4 , it will by pass if else statements\\n        // next time both will become null, so will return true\\n        // Thus 2nd solve() at the end will also hold true\\n        // and we know \\'true && true\\' is true\\n        // so true will be returned to caller, and thus tree is mirror of itself.\\n        // Similarly you can check for any testcase, flow of execution will remain same.\\n        \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        // Imagine a tree:    1\\n        //                 2     2\\n        //               3   4 4   3\\n        // We are standing on root that is 1, function begins\\n        // and now r1 and r2 points to 2 and 2 respectively.                      \\n        return solve(root->left, root->right);     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33057,
                "title": "python-iterative-way-using-a-queue",
                "content": "Each iteration, it checks whether two nodes are symmetric and then push (node1.left, node2.right), (node1.right, node2.left) to the end of queue.\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n\\n        dq = collections.deque([(root.left,root.right),])\\n        while dq:\\n            node1, node2 = dq.popleft()\\n            if not node1 and not node2:\\n                continue\\n            if not node1 or not node2:\\n                return False\\n            if node1.val != node2.val:\\n                return False\\n            # node1.left and node2.right are symmetric nodes in structure\\n            # node1.right and node2.left are symmetric nodes in structure\\n            dq.append((node1.left,node2.right))\\n            dq.append((node1.right,node2.left))\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Each iteration, it checks whether two nodes are symmetric and then push (node1.left, node2.right), (node1.right, node2.left) to the end of queue.\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n\\n        dq = collections.deque([(root.left,root.right),])\\n        while dq:\\n            node1, node2 = dq.popleft()\\n            if not node1 and not node2:\\n                continue\\n            if not node1 or not node2:\\n                return False\\n            if node1.val != node2.val:\\n                return False\\n            # node1.left and node2.right are symmetric nodes in structure\\n            # node1.right and node2.left are symmetric nodes in structure\\n            dq.append((node1.left,node2.right))\\n            dq.append((node1.right,node2.left))\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 494632,
                "title": "javascript-95-speed-100-memory-w-comments",
                "content": "```\\nvar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33313,
                "title": "slim-java-solution",
                "content": "The idea is:\\n1. level traversal.\\n2. push nodes onto stack, every 2 consecutive is a pair, and should either be both null or have equal value.\\nrepeat until stack is empty.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root.left);\\n        stack.push(root.right);\\n        while (!stack.isEmpty()) {\\n            TreeNode node1 = stack.pop();\\n            TreeNode node2 = stack.pop();\\n            if (node1 == null && node2 == null)\\n                continue;\\n            if (node1 == null || node2 == null)\\n                return false;\\n            if (node1.val != node2.val)\\n                return false;\\n            stack.push(node1.left);\\n            stack.push(node2.right);\\n            stack.push(node1.right);\\n            stack.push(node2.left);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "The idea is:\\n1. level traversal.\\n2. push nodes onto stack, every 2 consecutive is a pair, and should either be both null or have equal value.\\nrepeat until stack is empty.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root.left);\\n        stack.push(root.right);\\n        while (!stack.isEmpty()) {\\n            TreeNode node1 = stack.pop();\\n            TreeNode node2 = stack.pop();\\n            if (node1 == null && node2 == null)\\n                continue;\\n            if (node1 == null || node2 == null)\\n                return false;\\n            if (node1.val != node2.val)\\n                return false;\\n            stack.push(node1.left);\\n            stack.push(node2.right);\\n            stack.push(node1.right);\\n            stack.push(node2.left);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1805548,
                "title": "python-simple-python-solution-using-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 41 ms, faster than 29.46% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 13.8 MB, less than 99.68% of Python3 online submissions for Symmetric Tree.\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef check_mirror_image(root1, root2):\\n\\n\\t\\t\\t\\tif root1 == None and root2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tif root1 != None and root2 == None or root1 == None and root2 != None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\treturn check_mirror_image(root1.left, root2.right) and check_mirror_image(root1.right, root2.left)\\n\\n\\t\\t\\treturn check_mirror_image(root, root)\\n\\t\\t\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 41 ms, faster than 29.46% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 13.8 MB, less than 99.68% of Python3 online submissions for Symmetric Tree.\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef check_mirror_image(root1, root2):\\n\\n\\t\\t\\t\\tif root1 == None and root2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tif root1 != None and root2 == None or root1 == None and root2 != None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\treturn check_mirror_image(root1.left, root2.right) and check_mirror_image(root1.right, root2.left)\\n\\n\\t\\t\\treturn check_mirror_image(root, root)\\n\\t\\t\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 33361,
                "title": "another-passed-java-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) \\n                return true;\\n            \\n            return isSymmetric(root.left, root.right);\\n        }\\n        \\n        boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null && right == null) \\n                return true;\\n\\n            if (left == null || right == null) \\n                return false;\\n\\n            if (left.val != right.val) \\n                return false;\\n\\n            return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) \\n                return true;\\n            \\n            return isSymmetric(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33127,
                "title": "easy-and-simple-using-one-queue-iterative-in-java",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if(root == null) return true;\\n            Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n            queue.offer(root.left);\\n            queue.offer(root.right);\\n            while(!queue.isEmpty()){\\n                TreeNode left = queue.poll();\\n                TreeNode right = queue.poll();\\n                if(left == null && right == null) continue;\\n                if(left == null || right == null) return false;\\n                if(left.val != right.val) return false;\\n                queue.offer(left.left);\\n                queue.offer(right.right);\\n                queue.offer(left.right);\\n                queue.offer(right.left);\\n                \\n            }\\n            return true;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if(root == null) return true;\\n            Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n            queue.offer(root.left);\\n            queue.offer(root.right);\\n            while(!queue.isEmpty()){\\n                TreeNode left = queue.poll();\\n                TreeNode right = queue.poll();\\n                if(left == null && right == null) continue;\\n                if(left == null || right == null) return false;\\n                if(left.val != right.val) return false;\\n                queue.offer(left.left);\\n                queue.offer(right.right);\\n                queue.offer(left.right);\\n                queue.offer(right.left);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 939789,
                "title": "python-best-and-explained-o-n-recursion",
                "content": "```python\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        def isMirror(tree1, tree2):\\n            if not tree1 or not tree2: # if one of them is null\\n                return tree2 == tree1  # compare them\\n            if tree1.val != tree2.val: # if above not executed, means they are both number\\n                return False           # if they are both different return false\\n                                       # if they are similar go and look further\\n            return isMirror(tree1.left, tree2.right) and isMirror(tree1.right, tree2.left)\\n            \\n        return isMirror(root.left, root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        def isMirror(tree1, tree2):\\n            if not tree1 or not tree2: # if one of them is null\\n                return tree2 == tree1  # compare them\\n            if tree1.val != tree2.val: # if above not executed, means they are both number\\n                return False           # if they are both different return false\\n                                       # if they are similar go and look further\\n            return isMirror(tree1.left, tree2.right) and isMirror(tree1.right, tree2.left)\\n            \\n        return isMirror(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311745,
                "title": "easy-to-understand-python",
                "content": "Recursive\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.check(root.left, root.right)\\n        \\n    def check(self, left, right):\\n        if left is None and right is None:\\n            return True\\n        if left is None or right is None:\\n            return False\\n        if left.val != right.val:\\n            return False\\n        a = self.check(left.left, right.right)\\n        b = self.check(left.right, right.left)\\n        return a and b\\n```\\nIterative\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        stack = collections.deque([(root.left, root.right)])\\n        while stack:\\n            l, r = stack.pop()\\n            if l is None and r is None:\\n                continue\\n            if l is None or r is None:\\n                return False\\n            if l.val != r.val:\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.check(root.left, root.right)\\n        \\n    def check(self, left, right):\\n        if left is None and right is None:\\n            return True\\n        if left is None or right is None:\\n            return False\\n        if left.val != right.val:\\n            return False\\n        a = self.check(left.left, right.right)\\n        b = self.check(left.right, right.left)\\n        return a and b\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        stack = collections.deque([(root.left, root.right)])\\n        while stack:\\n            l, r = stack.pop()\\n            if l is None and r is None:\\n                continue\\n            if l is None or r is None:\\n                return False\\n            if l.val != r.val:\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33290,
                "title": "share-my-recursive-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if (root == NULL)\\n                return true;\\n            \\n            return checkSymmetric(root->left, root->right);\\n        }\\n        //check the two nodes in symmetric position\\n        bool checkSymmetric(TreeNode *leftSymmetricNode, TreeNode *rightSymmetricNode)\\n        {\\n            if (leftSymmetricNode == NULL && rightSymmetricNode == NULL)\\n                return true;\\n            if (leftSymmetricNode == NULL || rightSymmetricNode == NULL)\\n                return false;\\n            if (leftSymmetricNode->val == rightSymmetricNode->val)\\n                return checkSymmetric(leftSymmetricNode->left, rightSymmetricNode->right) && checkSymmetric(leftSymmetricNode->right, rightSymmetricNode->left);\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if (root == NULL)\\n                return true;\\n            \\n            return checkSymmetric(root->left, root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 160691,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def isSym(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            elif root1 == None and root2 != None:\\n                return False\\n            elif root1 != None and root2 == None:\\n                return False\\n            else:\\n                if root1.val != root2.val:\\n                    return False\\n                else:\\n                    return isSym(root1.left, root2.right) and isSym(root1.right,root2.left)\\n        return root == None or isSym(root.left,root.right)\\n```\\nIterative (DFS):\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        stack = [root,root]\\n        while stack:\\n            r1 = stack.pop()\\n            r2 = stack.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            stack.append(r1.left)\\n            stack.append(r2.right)\\n            stack.append(r1.right)\\n            stack.append(r2.left)\\n        return True\\n```\\nIterative (BFS):\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        queue = collections.deque([root, root])\\n        while queue:\\n            r1 = queue.pop()\\n            r2 = queue.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            queue.append(r1.left)\\n            queue.append(r2.right)\\n            queue.append(r1.right)\\n            queue.append(r2.left)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def isSym(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            elif root1 == None and root2 != None:\\n                return False\\n            elif root1 != None and root2 == None:\\n                return False\\n            else:\\n                if root1.val != root2.val:\\n                    return False\\n                else:\\n                    return isSym(root1.left, root2.right) and isSym(root1.right,root2.left)\\n        return root == None or isSym(root.left,root.right)\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        stack = [root,root]\\n        while stack:\\n            r1 = stack.pop()\\n            r2 = stack.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            stack.append(r1.left)\\n            stack.append(r2.right)\\n            stack.append(r1.right)\\n            stack.append(r2.left)\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        queue = collections.deque([root, root])\\n        while queue:\\n            r1 = queue.pop()\\n            r2 = queue.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            queue.append(r1.left)\\n            queue.append(r2.right)\\n            queue.append(r1.right)\\n            queue.append(r2.left)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878795,
                "title": "elegant-swift-solution-by-conforming-to-equatable",
                "content": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748090,
                "title": "python-3-dfs-iterative-solution-using-stack-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        stack = []\\n        if root: stack.append([root.left, root.right])\\n\\n        while(len(stack) > 0):\\n            left, right = stack.pop()\\n            \\n            if left and right:\\n                if left.val != right.val: return False\\n                stack.append([left.left, right.right])\\n                stack.append([right.left, left.right])\\n        \\n            elif left or right: return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        stack = []\\n        if root: stack.append([root.left, root.right])\\n\\n        while(len(stack) > 0):\\n            left, right = stack.pop()\\n            \\n            if left and right:\\n                if left.val != right.val: return False\\n                stack.append([left.left, right.right])\\n                stack.append([right.left, left.right])\\n        \\n            elif left or right: return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689461,
                "title": "java-easy-recursive-solution-easiest-approach-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n       return root == null || isMirror(root.left, root.right);\\n    }\\n    boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) return true;\\n        \\n        if (node1 == null || node2 == null) return false;\\n        \\n        if (node1.val != node2.val) return false;\\n        return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/0ad972be-ccb4-4c1f-92f1-2ec39d38b178_1665474715.5691338.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n       return root == null || isMirror(root.left, root.right);\\n    }\\n    boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) return true;\\n        \\n        if (node1 == null || node2 == null) return false;\\n        \\n        if (node1.val != node2.val) return false;\\n        return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749982,
                "title": "java-bfs-and-dfs",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n##### 1. DFS approach:\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return help(root.left, root.right);\\n    }\\n\\n    private boolean help(TreeNode left, TreeNode right) {\\n        if (left == null || right == null) {\\n            return left == right;\\n        }\\n        if (left.val != right.val) {\\n            return false;\\n        }\\n        boolean check1 = help(left.left, right.right);\\n        boolean check2 = help(left.right, right.left);\\n        return check1 && check2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 2. BFS approach:\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < n; i++) {\\n                TreeNode curr = q.poll();\\n\\n                if (curr == null) list.add(null);\\n                else {\\n                    list.add(curr.val);\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n\\n            if (!checkSymmetry(list)) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean checkSymmetry(List<Integer> list) {\\n        int l = 0, r = list.size() - 1;\\n\\n        while (l < r) {\\n            if (list.get(l++) != list.get(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return help(root.left, root.right);\\n    }\\n\\n    private boolean help(TreeNode left, TreeNode right) {\\n        if (left == null || right == null) {\\n            return left == right;\\n        }\\n        if (left.val != right.val) {\\n            return false;\\n        }\\n        boolean check1 = help(left.left, right.right);\\n        boolean check2 = help(left.right, right.left);\\n        return check1 && check2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < n; i++) {\\n                TreeNode curr = q.poll();\\n\\n                if (curr == null) list.add(null);\\n                else {\\n                    list.add(curr.val);\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n\\n            if (!checkSymmetry(list)) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean checkSymmetry(List<Integer> list) {\\n        int l = 0, r = list.size() - 1;\\n\\n        while (l < r) {\\n            if (list.get(l++) != list.get(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33247,
                "title": "2-lines-java-solution-use-1ms",
                "content": "\\n\\n    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isMirror(root,root);\\n        }\\n    \\n        public boolean isMirror(TreeNode a,TreeNode b){\\n            return a==null||b==null?a==b:a.val==b.val&&isMirror(a.left,b.right)&&isMirror(a.right,b.left);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isMirror(root,root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3293275,
                "title": "php-javascript-recursive-iterative-solutions",
                "content": "### 1. Recursive Solution\\nThis solution uses recursion to check if a binary tree is symmetric. The recursive helper function isMirror() checks if the two nodes of the binary tree are mirror images of each other, by comparing their values, and then recursively checking if their left and right nodes are mirror images of each other. If the values are equal and the subtrees are mirrors, then the function returns true. Otherwise, it returns false.\\n\\nThe *time complexity* of this solution is O(n) as all nodes in the binary tree must be visited in order to determine if the tree is symmetric. \\nThe *space complexity* is also O(n) as the recursive stack may contain up to n elements.\\n\\n\\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    return isMirror(root.left, root.right);\\n\\n    function isMirror(leftNode, rightNode) {\\n        if (leftNode == null && rightNode == null) return true;\\n        if (leftNode == null || rightNode == null) return false;\\n        return leftNode.val === rightNode.val &&\\n            isMirror(leftNode.left, rightNode.right) &&\\n            isMirror(leftNode.right, rightNode.left);\\n    }\\n};\\n```\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        return $this->isNodesMirror($root->left, $root->right);\\n    }\\n\\n    function isNodesMirror(?TreeNode $leftNode, ?TreeNode $rightNode): bool {\\n        if ($leftNode === null && $rightNode === null) {\\n            return true;\\n        }\\n        if ($leftNode === null || $rightNode === null) {\\n            return false;\\n        }\\n        return $leftNode->val === $rightNode->val &&\\n            $this->isNodesMirror($leftNode->left, $rightNode->right) &&\\n            $this->isNodesMirror($leftNode->right, $rightNode->left);\\n    }\\n}\\n```\\n\\n\\n### 2. Iterative Solution\\nThis solution uses a Breadth-First Search approach to traverse the tree. A queue is used to store left and right nodes of the tree at each level. If the left node and right node are both null then the loop continues. If either one is null or the values of the nodes do not match then false is returned. If the values match then the left and right children of each node are pushed to the queue for comparison. If the loop completes without returning false then true is returned.\\n*Time complexity*: O(n) as the algorithm visits each node once.\\n*Space complexity*: O(n) as the queue stores all nodes at each level.\\n\\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    let queue = [root.left, root.right];\\n    while (queue.length > 0) {\\n        let leftNode = queue.shift();\\n        let rightNode = queue.shift();\\n        if (leftNode == null && rightNode == null) continue;\\n        if (leftNode == null ||\\n            rightNode == null ||\\n            leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        queue.push(leftNode.left, rightNode.right);\\n        queue.push(leftNode.right, rightNode.left);\\n    }\\n    return true;\\n}\\n```\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(?TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        $queue = [[$root->left, $root->right]];\\n\\n        while ($queue) {\\n            $newQueue = [];\\n            foreach ($queue as [$leftNode, $rightNode]) {\\n                if ($leftNode === null && $rightNode === null) {\\n                    continue;\\n                }\\n                if ($leftNode->val !== $rightNode->val ||\\n                    $leftNode === null ||\\n                    $rightNode === null) {\\n                    return false;\\n                }\\n                $newQueue[] = [$leftNode->left, $rightNode->right];\\n                $newQueue[] = [$leftNode->right, $rightNode->left];\\n            }\\n            $queue = $newQueue;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n\\n### If my work was useful for you, please upvote\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP"
                ],
                "code": "```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    return isMirror(root.left, root.right);\\n\\n    function isMirror(leftNode, rightNode) {\\n        if (leftNode == null && rightNode == null) return true;\\n        if (leftNode == null || rightNode == null) return false;\\n        return leftNode.val === rightNode.val &&\\n            isMirror(leftNode.left, rightNode.right) &&\\n            isMirror(leftNode.right, rightNode.left);\\n    }\\n};\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        return $this->isNodesMirror($root->left, $root->right);\\n    }\\n\\n    function isNodesMirror(?TreeNode $leftNode, ?TreeNode $rightNode): bool {\\n        if ($leftNode === null && $rightNode === null) {\\n            return true;\\n        }\\n        if ($leftNode === null || $rightNode === null) {\\n            return false;\\n        }\\n        return $leftNode->val === $rightNode->val &&\\n            $this->isNodesMirror($leftNode->left, $rightNode->right) &&\\n            $this->isNodesMirror($leftNode->right, $rightNode->left);\\n    }\\n}\\n```\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    let queue = [root.left, root.right];\\n    while (queue.length > 0) {\\n        let leftNode = queue.shift();\\n        let rightNode = queue.shift();\\n        if (leftNode == null && rightNode == null) continue;\\n        if (leftNode == null ||\\n            rightNode == null ||\\n            leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        queue.push(leftNode.left, rightNode.right);\\n        queue.push(leftNode.right, rightNode.left);\\n    }\\n    return true;\\n}\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(?TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        $queue = [[$root->left, $root->right]];\\n\\n        while ($queue) {\\n            $newQueue = [];\\n            foreach ($queue as [$leftNode, $rightNode]) {\\n                if ($leftNode === null && $rightNode === null) {\\n                    continue;\\n                }\\n                if ($leftNode->val !== $rightNode->val ||\\n                    $leftNode === null ||\\n                    $rightNode === null) {\\n                    return false;\\n                }\\n                $newQueue[] = [$leftNode->left, $rightNode->right];\\n                $newQueue[] = [$leftNode->right, $rightNode->left];\\n            }\\n            $queue = $newQueue;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636087,
                "title": "python-dfs-bfs",
                "content": "**DFS Solution**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        def dfs(l, r):\\n            if not l and not r:\\n                return True\\n            \\n            if not l or not r:\\n                return False\\n            \\n            if l.val == r.val:\\n                return dfs(l.left, r.right) and dfs(l.right, r.left)\\n            \\n            return False\\n        \\n        return dfs(root.left, root.right)\\n```\\n\\n**BFS Solution**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        q = deque()\\n        q.append((root.left, root.right))\\n        while q:\\n            for _ in range(len(q)):\\n                left, right = q.popleft()\\n                if not left and not right:\\n                    continue\\n                    \\n                elif not left or not right:\\n                    return False\\n                \\n                else:\\n                    if left.val != right.val:\\n                        return False\\n                    \\n                    q.append((left.left, right.right))\\n                    q.append((left.right, right.left))\\n                    \\n        return True\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        def dfs(l, r):\\n            if not l and not r:\\n                return True\\n            \\n            if not l or not r:\\n                return False\\n            \\n            if l.val == r.val:\\n                return dfs(l.left, r.right) and dfs(l.right, r.left)\\n            \\n            return False\\n        \\n        return dfs(root.left, root.right)\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        q = deque()\\n        q.append((root.left, root.right))\\n        while q:\\n            for _ in range(len(q)):\\n                left, right = q.popleft()\\n                if not left and not right:\\n                    continue\\n                    \\n                elif not left or not right:\\n                    return False\\n                \\n                else:\\n                    if left.val != right.val:\\n                        return False\\n                    \\n                    q.append((left.left, right.right))\\n                    q.append((left.right, right.left))\\n                    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944937,
                "title": "c-solution-recursive-and-iterative",
                "content": "**Note**\\nThe answer is true when root is nullptr.\\n```\\nclass Solution\\n{\\npublic:\\n\\t// recursive : 12 ms 16.7 MB\\n\\tbool isSymmetric(TreeNode* root) {\\n\\t\\treturn !root || isEquivalent(root->left, root->right);\\n\\t}\\n\\n\\tbool isEquivalent(TreeNode* leftNode, TreeNode* rightNode)\\n\\t{\\n\\t\\tif (!leftNode && rightNode || leftNode && !rightNode) return false;\\n\\n\\t\\treturn !leftNode || leftNode->val == rightNode->val && isEquivalent(leftNode->left, rightNode->right) && isEquivalent(leftNode->right, rightNode->left);\\n\\t}\\n\\n\\t// iterative : 4 ms\\t16.9 MB\\n\\tbool isSymmetric3(TreeNode* root) {\\n\\t\\tif (!root) return true;\\n\\t\\tqueue<TreeNode*> pending({ root->left, root->right });\\n\\n\\t\\twhile (!pending.empty())\\n\\t\\t{\\n\\t\\t\\tTreeNode* l = pending.front();\\n\\t\\t\\tpending.pop();\\n\\t\\t\\tTreeNode* r = pending.front();\\n\\t\\t\\tpending.pop();\\n\\n\\t\\t\\tif (!l && r || l && !r) return false;\\n\\t\\t\\tif (l)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l->val != r->val) return false;\\n\\t\\t\\t\\tpending.push(l->left);\\n\\t\\t\\t\\tpending.push(r->right);\\n\\t\\t\\t\\tpending.push(l->right);\\n\\t\\t\\t\\tpending.push(r->left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\t// recursive : 12 ms 16.7 MB\\n\\tbool isSymmetric(TreeNode* root) {\\n\\t\\treturn !root || isEquivalent(root->left, root->right);\\n\\t}\\n\\n\\tbool isEquivalent(TreeNode* leftNode, TreeNode* rightNode)\\n\\t{\\n\\t\\tif (!leftNode && rightNode || leftNode && !rightNode) return false;\\n\\n\\t\\treturn !leftNode || leftNode->val == rightNode->val && isEquivalent(leftNode->left, rightNode->right) && isEquivalent(leftNode->right, rightNode->left);\\n\\t}\\n\\n\\t// iterative : 4 ms\\t16.9 MB\\n\\tbool isSymmetric3(TreeNode* root) {\\n\\t\\tif (!root) return true;\\n\\t\\tqueue<TreeNode*> pending({ root->left, root->right });\\n\\n\\t\\twhile (!pending.empty())\\n\\t\\t{\\n\\t\\t\\tTreeNode* l = pending.front();\\n\\t\\t\\tpending.pop();\\n\\t\\t\\tTreeNode* r = pending.front();\\n\\t\\t\\tpending.pop();\\n\\n\\t\\t\\tif (!l && r || l && !r) return false;\\n\\t\\t\\tif (l)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l->val != r->val) return false;\\n\\t\\t\\t\\tpending.push(l->left);\\n\\t\\t\\t\\tpending.push(r->right);\\n\\t\\t\\t\\tpending.push(l->right);\\n\\t\\t\\t\\tpending.push(r->left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33286,
                "title": "java-iterative-recursive-solutions",
                "content": "#Recursive#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\treturn isSymmetric(root.left, root.right);\\n    }\\n    private boolean isSymmetric(TreeNode root1, TreeNode root2) {\\n    \\tif(root1==null && root2==null) return true;\\n    \\tif(root1==null || root2==null) return false;\\n    \\tif(root1.val!=root2.val) return false;\\n    \\treturn isSymmetric(root1.left, root2.right) && isSymmetric(root1.right, root2.left);\\n    }\\n#Iterative#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\tQueue<TreeNode> q1=new LinkedList<>(), q2=new LinkedList<>();\\n    \\tq1.add(root.left); \\n    \\tq2.add(root.right);\\n    \\twhile(!q1.isEmpty() && !q2.isEmpty()) {\\n    \\t\\tint size1=q1.size(), size2=q2.size();\\n    \\t\\tif(size1!=size2) return false;\\n    \\t\\tfor(int i=0; i<size1; i++) {\\n    \\t\\t\\tTreeNode current1=q1.remove(), current2=q2.remove();\\n    \\t\\t\\tif(current1==null && current2==null) continue;\\n    \\t\\t\\tif(current1==null || current2==null) return false; \\n    \\t\\t\\tif(current1.val!=current2.val) return false;\\n    \\t\\t\\tq1.add(current1.left);\\n    \\t\\t\\tq1.add(current1.right);\\n    \\t\\t\\tq2.add(current2.right);\\n    \\t\\t\\tq2.add(current2.left);\\n    \\t\\t}\\n    \\t}\\n    \\treturn q1.isEmpty() && q2.isEmpty();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "#Recursive#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\treturn isSymmetric(root.left, root.right);\\n    }\\n    private boolean isSymmetric(TreeNode root1, TreeNode root2) {\\n    \\tif(root1==null && root2==null) return true;\\n    \\tif(root1==null || root2==null) return false;\\n    \\tif(root1.val!=root2.val) return false;\\n    \\treturn isSymmetric(root1.left, root2.right) && isSymmetric(root1.right, root2.left);\\n    }\\n#Iterative#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\tQueue<TreeNode> q1=new LinkedList<>(), q2=new LinkedList<>();\\n    \\tq1.add(root.left); \\n    \\tq2.add(root.right);\\n    \\twhile(!q1.isEmpty() && !q2.isEmpty()) {\\n    \\t\\tint size1=q1.size(), size2=q2.size();\\n    \\t\\tif(size1!=size2) return false;\\n    \\t\\tfor(int i=0; i<size1; i++) {\\n    \\t\\t\\tTreeNode current1=q1.remove(), current2=q2.remove();\\n    \\t\\t\\tif(current1==null && current2==null) continue;\\n    \\t\\t\\tif(current1==null || current2==null) return false; \\n    \\t\\t\\tif(current1.val!=current2.val) return false;\\n    \\t\\t\\tq1.add(current1.left);\\n    \\t\\t\\tq1.add(current1.right);\\n    \\t\\t\\tq2.add(current2.right);\\n    \\t\\t\\tq2.add(current2.left);\\n    \\t\\t}\\n    \\t}\\n    \\treturn q1.isEmpty() && q2.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33311,
                "title": "4ms-simple-c-code",
                "content": "    class Solution {\\n    public:\\n    bool isSymmetric(TreeNode* root) {\\n            if (!root){\\n                return true;\\n            }\\n            else{\\n                return isSame(root->left, root->right);\\n            }\\n        }\\n    private: // hide functions in the private helps to improve running time\\n        bool isSame (TreeNode* n1, TreeNode* n2){\\n            if (!n1 || !n2){\\n                return n1 == n2;\\n            }\\n            else{\\n                return (n1->val == n2->val && isSame(n1->left, n2->right) && isSame(n1->right, n2->left));\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    bool isSymmetric(TreeNode* root) {\\n            if (!root){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3290825,
                "title": "python-solution-with-easy-explanation",
                "content": "> # *Please Upvote if it helps !* \\n\\n---\\n\\n- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo check whether a tree is mirror symmetric or not, we need to compare the left and right subtrees of each node. If they are mirror images of each other, then the tree is mirror symmetric.\\n\\n- # Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this code, we first check if the root of the tree is None, in which case we return True because an empty tree is mirror symmetric.\\n\\nThen, we define a helper function called `isMirror` which takes two nodes as input and checks whether they are mirror images of each other. If both nodes are None, we return True. If one of them is None, we return False because a node cannot be a mirror image of None. \\n\\nOtherwise, we check if the values of the nodes are equal and then recursively check whether the left subtree of the first node is a mirror image of the right subtree of the second node, and whether the right subtree of the first node is a mirror image of the left subtree of the second node.\\n\\nFinally, we call the `isMirror` function with the left and right subtrees of the root node and return the result. If the tree is mirror symmetric, the function will return True, otherwise it will return False.\\n\\n- # Code\\n\\nHere is the  `Python` code to check whether a tree is mirror symmetric or not:\\n\\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if not t1 or not t2:\\n                return False\\n            return t1.val == t2.val and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\\n        \\n        return isMirror(root, root)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if not t1 or not t2:\\n                return False\\n            return t1.val == t2.val and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\\n        \\n        return isMirror(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290297,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    static boolean mir( TreeNode t1 , TreeNode t2 )\\n    {\\n        if( t1==null && t2== null ) return true;\\n        else if( t1==null || t2==null ) return false;\\n\\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\\n    }\\n    public boolean isSymmetric(TreeNode root) \\n    {\\n        return mir( root , root );\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    static boolean mir( TreeNode t1 , TreeNode t2 )\\n    {\\n        if( t1==null && t2== null ) return true;\\n        else if( t1==null || t2==null ) return false;\\n\\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\\n    }\\n    public boolean isSymmetric(TreeNode root) \\n    {\\n        return mir( root , root );\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053636,
                "title": "c-short-simple-recursive-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecurively check for the subtrees. Return false if they aren\\'t equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isSame(TreeNode* t1, TreeNode* t2){\\n        if(!t1 && !t2){return true;}\\n        if(t1 && !t2){return false;}\\n        if(t2 && !t1){return false;}\\n        if(t1->val==t2->val){return isSame(t1->left,t2->right) && isSame(t1->right,t2->left);}\\n        return false;\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n    return isSame(root->left,root->right);            \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isSame(TreeNode* t1, TreeNode* t2){\\n        if(!t1 && !t2){return true;}\\n        if(t1 && !t2){return false;}\\n        if(t2 && !t1){return false;}\\n        if(t1->val==t2->val){return isSame(t1->left,t2->right) && isSame(t1->right,t2->left);}\\n        return false;\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n    return isSame(root->left,root->right);            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771896,
                "title": "ts-easy-solution-recursive",
                "content": "Let me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\n\\n```\\nconst isSymmetric = (root: TreeNode | null): boolean => {\\n  return isMirror(root, root);\\n};\\n  \\nconst isMirror = (t1: TreeNode | null, t2: TreeNode | null): boolean => {\\n  if (t1 === null && t2 === null) return true;\\n  if (t1 === null || t2 === null) return false;\\n  \\n  return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst isSymmetric = (root: TreeNode | null): boolean => {\\n  return isMirror(root, root);\\n};\\n  \\nconst isMirror = (t1: TreeNode | null, t2: TreeNode | null): boolean => {\\n  if (t1 === null && t2 === null) return true;\\n  if (t1 === null || t2 === null) return false;\\n  \\n  return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089367,
                "title": "facebook-amazon-interview-100ms-easy-to-understand-very-clean-code-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //To check if tree is empty or not\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) // left & right node are NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) // one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left);\\n    }\\n};\\n```\\n\\n# If you understand this solution, then please please upvote!!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //To check if tree is empty or not\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) // left & right node are NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) // one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926232,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n    \\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        isMirror(root, root)\\n    }\\n    \\n    \\n    private func isMirror(_ left: TreeNode?, _ right: TreeNode?) -> Bool {\\n        if left == nil, right == nil { return true }\\n        \\n        guard left?.val == right?.val else { return false }\\n        \\n        return isMirror(left?.left, right?.right) && isMirror(left?.right, right?.left)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n    \\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        isMirror(root, root)\\n    }\\n    \\n    \\n    private func isMirror(_ left: TreeNode?, _ right: TreeNode?) -> Bool {\\n        if left == nil, right == nil { return true }\\n        \\n        guard left?.val == right?.val else { return false }\\n        \\n        return isMirror(left?.left, right?.right) && isMirror(left?.right, right?.left)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120677,
                "title": "100-faster-0ms-runtime-short-c-solution",
                "content": "```\\n\\n\\n    bool isMirror(TreeNode* root1,TreeNode *root2){\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1 && root2 && root1->val == root2->val)\\n            return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);\\n        \\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root,root);\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\n\\n    bool isMirror(TreeNode* root1,TreeNode *root2){\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1 && root2 && root1->val == root2->val)\\n            return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);\\n        \\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root,root);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535045,
                "title": "py3-sol-in-just-few-lines-24ms-beats-97-63",
                "content": "```\\ndef isSymmetricBst(node1, node2):\\n    if node1==None and node2==None:\\n        return True\\n    elif node1==None or node2==None:\\n        return False\\n    else:\\n        return node1.val==node2.val and isSymmetricBst(node1.left,node2.right) and isSymmetricBst(node1.right, node2.left)\\n    \\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n#         since we need to check whether left is mirror to right, vice versa\\n        return isSymmetricBst(root.left, root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isSymmetricBst(node1, node2):\\n    if node1==None and node2==None:\\n        return True\\n    elif node1==None or node2==None:\\n        return False\\n    else:\\n        return node1.val==node2.val and isSymmetricBst(node1.left,node2.right) and isSymmetricBst(node1.right, node2.left)\\n    \\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n#         since we need to check whether left is mirror to right, vice versa\\n        return isSymmetricBst(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518599,
                "title": "c-solution-easy-to-understand-o-n",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode* left, TreeNode* right) {\\n        if (!left && !right)\\n            return true;\\n        \\n        if (!left || !right || left->val != right->val)\\n            return false;\\n        \\n        return isEqual(left->left, right->right) && isEqual(left->right, right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isEqual(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode* left, TreeNode* right) {\\n        if (!left && !right)\\n            return true;\\n        \\n        if (!left || !right || left->val != right->val)\\n            return false;\\n        \\n        return isEqual(left->left, right->right) && isEqual(left->right, right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isEqual(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33370,
                "title": "clean-iterative-solution-in-c",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if(!root) return true;\\n            stack<TreeNode*> sk;\\n            sk.push(root->left);\\n            sk.push(root->right);\\n            \\n            TreeNode* pA, *pB;\\n            while(!sk.empty()) {\\n                pA = sk.top();\\n                sk.pop();\\n                pB = sk.top();\\n                sk.pop();\\n                \\n                if(!pA && !pB) continue;\\n                if(!pA || !pB) return false;\\n                if(pA->val != pB->val) return false;\\n                \\n                sk.push(pA->left);\\n                sk.push(pB->right);\\n                sk.push(pA->right);\\n                sk.push(pB->left);\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if(!root) return true;\\n            stack<TreeNode*> sk;\\n            sk.push(root->left);\\n            sk.push(root->right);\\n            \\n            TreeNode* pA, *pB;\\n            while(!sk.empty()) {\\n                pA = sk.top();\\n                sk.pop();\\n                pB = sk.top();\\n                sk.pop();\\n                \\n                if(!pA && !pB) continue;\\n                if(!pA || !pB) return false;\\n                if(pA->val != pB->val) return false;\\n                \\n                sk.push(pA->left);\\n                sk.push(pB->right);\\n                sk.push(pA->right);\\n                sk.push(pB->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33326,
                "title": "beautiful-recursive-and-iterative-solutions",
                "content": "Very simple ideas. Notice how both look similar to each other.\\n\\n    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    #include<queue>\\n    using namespace std;\\n    typedef pair<TreeNode*,TreeNode*> nodepair;\\n    class Solution {\\n    public:\\n        bool isSymmetricRecursive(TreeNode*a,TreeNode*b){\\n            if(a){\\n                return b && a->val==b->val && \\n                    isSymmetricRecursive(a->left,b->right) &&\\n                    isSymmetricRecursive(a->right,b->left);\\n            }\\n            return !b;\\n        }\\n        bool isSymmetricRecursive(TreeNode*root){\\n            return !root || isSymmetricRecursive(root->left,root->right);\\n        }\\n        bool isSymmetric(TreeNode *root) {\\n            // Level-order BFS.\\n            queue<nodepair> q;\\n            if(root)\\n                q.push(make_pair(root->left,root->right));\\n            while(q.size()){\\n                nodepair p=q.front(); q.pop();\\n                if(p.first){\\n                    if(!p.second)return false;\\n                    if(p.first->val != p.second->val) return false;\\n                    // the order of children pushed to q is the key to the solution.\\n                    q.push(make_pair(p.first->left,p.second->right));\\n                    q.push(make_pair(p.first->right,p.second->left));\\n                }\\n                else if(p.second) return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetricRecursive(TreeNode*a,TreeNode*b){\\n            if(a){\\n                return b && a->val==b->val && \\n                    isSymmetricRecursive(a->left,b->right) &&\\n                    isSymmetricRecursive(a->right,b->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2817548,
                "title": "java",
                "content": "If you like it pls upvote\\n\\n```\\n\\n public boolean isSymmetric(TreeNode root) {\\n  if (root == null) return true;\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n\\n  while (!stack.isEmpty()) {\\n   TreeNode n1 = stack.pop();\\n   TreeNode n2 = stack.pop();\\n\\n   if (n1 == null && n2 == null) continue;\\n   if (n1 == null || n2 == null || n1.val != n2.val) return false;\\n\\n   stack.push(n1.left);\\n   stack.push(n2.right);\\n   stack.push(n1.right);\\n   stack.push(n2.left);\\n  }\\n\\n  return true;\\n }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n public boolean isSymmetric(TreeNode root) {\\n  if (root == null) return true;\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n\\n  while (!stack.isEmpty()) {\\n   TreeNode n1 = stack.pop();\\n   TreeNode n2 = stack.pop();\\n\\n   if (n1 == null && n2 == null) continue;\\n   if (n1 == null || n2 == null || n1.val != n2.val) return false;\\n\\n   stack.push(n1.left);\\n   stack.push(n2.right);\\n   stack.push(n1.right);\\n   stack.push(n2.left);\\n  }\\n\\n  return true;\\n }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725862,
                "title": "recursively-and-iteratively-level-order-traversal-in-python",
                "content": "**Solution 1. recursively solution**\\n\\n```\\ndef isSymmetric(self, root):\\n\\tdef treeMatch(root1, root2):\\n\\t\\tif not root1 and not root2:\\n\\t\\t\\treturn True\\n\\t\\tif (root1 and not root2) or (root2 and not root1):\\n\\t\\t\\treturn False\\n\\t\\tif root1.val != root2.val:\\n\\t\\t\\treturn False\\n\\t\\treturn treeMatch(root1.left, root2.right) and treeMatch(root1.right, root2.left)\\n\\treturn treeMatch(root.left, root.right)\\n```\\n\\n**Solution 2. iteratively solution, using level order traversal**\\n```\\ndef isSymmetric(self, root):\\n\\n\\tdef levelSymetric(nums):\\n\\t\\treturn nums[:] == nums[::-1]\\n\\n\\ttree = [root]\\n\\twhile tree:\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(len(tree)):\\n\\t\\t\\ttmp = tree.pop(0)\\n\\t\\t\\tif not tmp:\\n\\t\\t\\t\\tlevel.append(None)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel.append(tmp.val)\\n\\t\\t\\t\\ttree.append(tmp.left)\\n\\t\\t\\t\\ttree.append(tmp.right)\\n\\t\\tif not levelSymetric(level):\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef isSymmetric(self, root):\\n\\tdef treeMatch(root1, root2):\\n\\t\\tif not root1 and not root2:\\n\\t\\t\\treturn True\\n\\t\\tif (root1 and not root2) or (root2 and not root1):\\n\\t\\t\\treturn False\\n\\t\\tif root1.val != root2.val:\\n\\t\\t\\treturn False\\n\\t\\treturn treeMatch(root1.left, root2.right) and treeMatch(root1.right, root2.left)\\n\\treturn treeMatch(root.left, root.right)\\n```\n```\\ndef isSymmetric(self, root):\\n\\n\\tdef levelSymetric(nums):\\n\\t\\treturn nums[:] == nums[::-1]\\n\\n\\ttree = [root]\\n\\twhile tree:\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(len(tree)):\\n\\t\\t\\ttmp = tree.pop(0)\\n\\t\\t\\tif not tmp:\\n\\t\\t\\t\\tlevel.append(None)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel.append(tmp.val)\\n\\t\\t\\t\\ttree.append(tmp.left)\\n\\t\\t\\t\\ttree.append(tmp.right)\\n\\t\\tif not levelSymetric(level):\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642861,
                "title": "python-simple-bfs-iterative-approach-with-explaination",
                "content": "Think in pairs would really help. \\nTo check if a tree is symmetric, we need a BFS on 2 sides of symmetry: left and right. If left and right value match, we should proceed. \\nThe key is to add the children of left and right in the proper order: outter match, then inner match. Because we are queuing in pairs, the children of inner pairs will match with the inner grandchildren, and so are the outter pairs. \\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            # pop 2 from queue\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            # Evalate the pair\\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            # Enqueue children\\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            # pop 2 from queue\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            # Evalate the pair\\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            # Enqueue children\\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33252,
                "title": "java-solution-1ms-4-lines-code-recursive-easy-to-understand",
                "content": "\\tpublic static boolean isSymmetric(TreeNode root) {\\n\\t\\treturn isSymmetric(root,root);\\n\\t}\\n\\t\\n\\tpublic static boolean isSymmetric(TreeNode p, TreeNode q){\\n\\t\\tif(p==null && q==null) return true;\\n\\t\\tif(p==null || q==null) return false;\\n\\t\\t\\n\\t\\treturn p.val ==q.val&&isSymmetric(p.left,q.right)&&isSymmetric(p.right,q.left);\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic static boolean isSymmetric(TreeNode root) {\\n\\t\\treturn isSymmetric(root,root);\\n\\t}\\n\\t\\n\\tpublic static boolean isSymmetric(TreeNode p, TreeNode q){\\n\\t\\tif(p==null && q==null) return true;\\n\\t\\tif(p==null || q==null) return false;\\n\\t\\t\\n\\t\\treturn p.val ==q.val&&isSymmetric(p.left,q.right)&&isSymmetric(p.right,q.left);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 33401,
                "title": "concise-recursive-java-solution",
                "content": "This method is my best recursive try. Use two TreeNode as parameters.\\n\\nIf you are willing to help, \\n\\nPlease go to https://oj.leetcode.com/discuss/24968/is-my-method-a-recursive-one-java-solution\\nto see my another recursive solution and give some comment on that recursive method.\\n   \\n\\n    public class Solution {\\n            public boolean isSymmetric(TreeNode root) {\\n                if(root==null){return true;}\\n                return isSymmetric(root.left, root.right);\\n            }\\n            \\n            private boolean isSymmetric(TreeNode a, TreeNode b){\\n                if(a==null&&b==null){return true;}\\n                if(a==null||b==null){return false;}\\n                if(a.val!=b.val){return false;}\\n                return isSymmetric(a.left,b.right)&&isSymmetric(a.right,b.left);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n            public boolean isSymmetric(TreeNode root) {\\n                if(root==null){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 3931624,
                "title": "symmetric-tree-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1==NULL || root2==NULL)\\n            return false;\\n        if(root1->val==root2->val)\\n            return check(root1->left, root2->right) && check(root1->right, root2->left);\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left, root->right);\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/21243a90-9cb4-4904-acec-45e72bc6ede1_1692455011.561149.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1==NULL || root2==NULL)\\n            return false;\\n        if(root1->val==root2->val)\\n            return check(root1->left, root2->right) && check(root1->right, root2->left);\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227769,
                "title": "java-solution-0ms-runtime-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy seeing the problem my first intuition was to use BFS to solve the problem,by taking a queue but as i approached the problem i understand that using DFS is more optimal and less complex to solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two parts of the tree - the left one and the right one.\\n**Some Observations :**\\n- The `leftnode` of left subtree is equal to the `rightnode` of right subtree.\\n- Similarly the `rightnode` of left subtree is equal to the `leftnode` of right subtree.\\n\\nSo we can apply these recursively to check if the nodes are equal or not.\\nIf the tree is symmetric then the algorithm reaches the leaf nodes where each node is null, then we return `true`.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        return checkSymmetric(root.left,root.right);\\n    }\\n    public boolean checkSymmetric(TreeNode leftNode,TreeNode rightNode){\\n        if(leftNode == null && rightNode == null){\\n            return true;\\n        }\\n        if(leftNode == null ^ rightNode == null){\\n            return false;\\n        }\\n        if(leftNode.val != rightNode.val){\\n            return false;\\n        }\\n        return checkSymmetric(leftNode.left,rightNode.right) && checkSymmetric(leftNode.right,rightNode.left);\\n\\n    }\\n}\\n```\\nIf any doubt or suggestions, Please do comment :)\\n\\nPLEASE DO UPVOTE GUYS!!! :)\\n\\nThank You!!!",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        return checkSymmetric(root.left,root.right);\\n    }\\n    public boolean checkSymmetric(TreeNode leftNode,TreeNode rightNode){\\n        if(leftNode == null && rightNode == null){\\n            return true;\\n        }\\n        if(leftNode == null ^ rightNode == null){\\n            return false;\\n        }\\n        if(leftNode.val != rightNode.val){\\n            return false;\\n        }\\n        return checkSymmetric(leftNode.left,rightNode.right) && checkSymmetric(leftNode.right,rightNode.left);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796828,
                "title": "0-ms100-iteration-recursion",
                "content": "#### Iteration\\n\\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tvar stack []*TreeNode\\n\\tstack = append(stack, root.Left, root.Right)\\n\\tfor len(stack) > 0 {\\n\\t\\tl, r := stack[0], stack[1]\\n\\t\\tstack = stack[2:]\\n\\t\\tif l == nil && r == nil {\\n\\t\\t\\tcontinue\\n\\t\\t} else if (l == nil && r != nil) || l != nil && r == nil {\\n\\t\\t\\treturn false\\n\\t\\t} else if l.Val != r.Val {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tstack = append(stack, l.Left, r.Right, l.Right, r.Left)\\n\\t}\\n\\treturn true\\n}\\n```\\n\\n#### Recursion\\n\\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\treturn helper(root.Left, root.Right)\\n}\\n\\nfunc helper(left *TreeNode, right *TreeNode) bool {\\n\\tif left == nil || right == nil {\\n\\t\\treturn left == right\\n\\t}\\n\\tif left.Val != right.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn helper(left.Left, right.Right) && helper(left.Right, right.Left)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tvar stack []*TreeNode\\n\\tstack = append(stack, root.Left, root.Right)\\n\\tfor len(stack) > 0 {\\n\\t\\tl, r := stack[0], stack[1]\\n\\t\\tstack = stack[2:]\\n\\t\\tif l == nil && r == nil {\\n\\t\\t\\tcontinue\\n\\t\\t} else if (l == nil && r != nil) || l != nil && r == nil {\\n\\t\\t\\treturn false\\n\\t\\t} else if l.Val != r.Val {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tstack = append(stack, l.Left, r.Right, l.Right, r.Left)\\n\\t}\\n\\treturn true\\n}\\n```\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\treturn helper(root.Left, root.Right)\\n}\\n\\nfunc helper(left *TreeNode, right *TreeNode) bool {\\n\\tif left == nil || right == nil {\\n\\t\\treturn left == right\\n\\t}\\n\\tif left.Val != right.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn helper(left.Left, right.Right) && helper(left.Right, right.Left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283175,
                "title": "0ms-java-10-lines-recursive-explaining-full-few-lines-easy-to-understand",
                "content": "So the solution is a little simple, \\nthe first step is  how to build the algorithm if two tree is the same (The link about that excercise https://leetcode.com/problems/same-tree/)  \\n\\nThis is the code to compare if two **tree is the same** (https://leetcode.com/problems/same-tree/discuss/32687/Five-line-Java-solution-with-recursion)\\n\\n```\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n    if(p == null && q == null) return true;\\n    if(p == null || q == null) return false;\\n    if(p.val == q.val)\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    return false;\\n}\\n```\\n\\nSo, When we developed the excersice before so we only have a little change for do this excercise. The change is the method isSameTree, how the root in the middle have a mirror so in the part of isSameTree we only do a reverse so we compare left with right and right with left. \\n\\nAnd the call with the root \\n\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {        \\n        return isSameTree(root.right, root.left);\\n    }\\n    \\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n    if(p == null && q == null) return true;\\n    if(p == null || q == null) return false;\\n    if(p.val == q.val)\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    return false;\\n}\\n```\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {        \\n        return isSameTree(root.right, root.left);\\n    }\\n    \\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324014,
                "title": "swift-symmetric-tree-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return check(root, root)\\n    }\\n    private final func check(_ l: TreeNode?, _ r: TreeNode?) -> Bool {\\n        if [l,r].allSatisfy({$0 == nil}) { return true }\\n        if l == nil || r == nil { return false }\\n        let n = (l?.left, r?.right)\\n        return l?.val == r?.val && check(n.0,n.1) && check(n.1,n.0)\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.065 (0.067) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isSymmetric(.init([1,2,2,3,4,4,3]))\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isSymmetric(.init([1,2,2,nil,3,nil,3]))\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return check(root, root)\\n    }\\n    private final func check(_ l: TreeNode?, _ r: TreeNode?) -> Bool {\\n        if [l,r].allSatisfy({$0 == nil}) { return true }\\n        if l == nil || r == nil { return false }\\n        let n = (l?.left, r?.right)\\n        return l?.val == r?.val && check(n.0,n.1) && check(n.1,n.0)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.065 (0.067) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isSymmetric(.init([1,2,2,3,4,4,3]))\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isSymmetric(.init([1,2,2,nil,3,nil,3]))\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712470,
                "title": "javascript-iterative-commented",
                "content": "```\\n/**\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n*/\\nvar isSymmetric = function(root) {\\n//     if there is no root that means it is a symettric tree\\n    if(!root) return true\\n//     Start 2 queue one for the left banch and one for the right branch\\n    let q1 = [root.left], q2 = [root.right]\\n//     traverse through both branches, until they are both exhausted at the same time\\n    while (q1.length > 0 && q2.length > 0){\\n//         get current left and compare it to the right of each branch (this is how a mirror works)\\n        let node1 = q1.shift()\\n        let node2 = q2.shift()\\n//         if both are null at the same time, just move on\\n        if(!node1 && !node2) continue\\n//         if the current level is not symmetric (1 of them is null or they are not equal) return false\\n        if(!node1 || !node2 || node1.val !== node2.val) return false\\n//         to mentain comparing left to right (this is the tricky part, you have to push left and right & reverse for each branch)\\n        q1.push(node1.left)\\n        q2.push(node2.right)\\n        q1.push(node1.right)\\n        q2.push(node2.left)\\n    }\\n//     If both are exhausted at the same time and they are symmeteric return true\\n    return true\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n*/\\nvar isSymmetric = function(root) {\\n//     if there is no root that means it is a symettric tree\\n    if(!root) return true\\n//     Start 2 queue one for the left banch and one for the right branch\\n    let q1 = [root.left], q2 = [root.right]\\n//     traverse through both branches, until they are both exhausted at the same time\\n    while (q1.length > 0 && q2.length > 0){\\n//         get current left and compare it to the right of each branch (this is how a mirror works)\\n        let node1 = q1.shift()\\n        let node2 = q2.shift()\\n//         if both are null at the same time, just move on\\n        if(!node1 && !node2) continue\\n//         if the current level is not symmetric (1 of them is null or they are not equal) return false\\n        if(!node1 || !node2 || node1.val !== node2.val) return false\\n//         to mentain comparing left to right (this is the tricky part, you have to push left and right & reverse for each branch)\\n        q1.push(node1.left)\\n        q2.push(node2.right)\\n        q1.push(node1.right)\\n        q2.push(node2.left)\\n    }\\n//     If both are exhausted at the same time and they are symmeteric return true\\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447611,
                "title": "javascript-queue-in-10-lines",
                "content": "```\\nvar isSymmetric = function(root) {\\n  const q = [root, root];\\n  while (q.length) {\\n    const [l, r] = [q.shift(), q.shift()];\\n    if (!l && !r) continue;\\n    if (!!l !== !!r || l.val !== r.val) return false;\\n    q.push(l.left, r.right, l.right, r.left);\\n  }\\n  \\n  return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n  const q = [root, root];\\n  while (q.length) {\\n    const [l, r] = [q.shift(), q.shift()];\\n    if (!l && !r) continue;\\n    if (!!l !== !!r || l.val !== r.val) return false;\\n    q.push(l.left, r.right, l.right, r.left);\\n  }\\n  \\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33297,
                "title": "clean-java-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isSymmetric(root, root);\\n        }\\n        \\n        boolean isSymmetric(TreeNode n1, TreeNode n2) {\\n            if(n1 == null && n2 == null) return true;\\n            if(n1 == null || n2 == null) return false;\\n            if(n1.val != n2.val) return false;\\n            return isSymmetric(n1.left, n2.right) && isSymmetric(n2.right, n1.left);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isSymmetric(root, root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33295,
                "title": "0-ms-c-solution-donerecusively",
                "content": "\\n\\nbool isSymmetricRecursively(struct TreeNode* Lnode ,struct TreeNode* Rnode ){\\n    \\n    if(Lnode==NULL && Rnode==NULL)\\n        return true;\\n        \\n    if(Lnode==NULL || Rnode==NULL)\\n         return false ;\\n    \\n    \\n    return ((Lnode->val==Rnode->val) &&\\n                        isSymmetricRecursively(Lnode->left,Rnode->right) \\n                                   && isSymmetricRecursively(Lnode->right,Rnode->left )) ;\\n            \\n} \\n\\nbool isSymmetric(struct TreeNode* root) {\\n    \\n    if(root==NULL)\\n        return true;\\n        \\n       return isSymmetricRecursively(root->left ,root->right); \\n}",
                "solutionTags": [],
                "code": "\\n\\nbool isSymmetricRecursively(struct TreeNode* Lnode ,struct TreeNode* Rnode ){\\n    \\n    if(Lnode==NULL && Rnode==NULL)\\n        return true;\\n        \\n    if(Lnode==NULL || Rnode==NULL)\\n         return false ;\\n    \\n    \\n    return ((Lnode->val==Rnode->val) &&\\n                        isSymmetricRecursively(Lnode->left,Rnode->right) \\n                                   && isSymmetricRecursively(Lnode->right,Rnode->left )) ;\\n            \\n} \\n\\nbool isSymmetric(struct TreeNode* root) {\\n    \\n    if(root==NULL)\\n        return true;\\n        \\n       return isSymmetricRecursively(root->left ,root->right); \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3292699,
                "title": "iterative-bfs-0-ms-beats-100-cpp-submissions",
                "content": "# Intuition\\nChecking Tree\\'s symmetry comparing values of same level nodes in left and right subtrees.\\n\\n# Approach\\nPerform **Breadth-first search** using queue data structure to do a level order traversal of the tree comparing values of corresponding level nodes in left and right subtrees thus know whether symmetric or not. Pushing two copies of each node into the queue so the comparison of nodes that are non-direct children of each other is feasible. For instance, nodes seperated by null values.\\n\\n# Complexity\\n- Time complexity:\\nWorst case : O(N) where N is the number of nodes in the tree.\\n\\n- Space complexity:\\nO(W) where W is the maximum width of the tree.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n    if(!root) return 1;\\n    queue<TreeNode*> q;\\n    q.push(root), q.push(root);\\n    while(!q.empty()) {\\n        TreeNode* n(q.front());\\n        q.pop();\\n        TreeNode* n2(q.front());\\n        q.pop();\\n        if(n==nullptr and n2==nullptr) continue;\\n        if(n==nullptr or n2==nullptr or n->val!=n2->val) return 0;\\n        q.push(n->left), q.push(n2->right), q.push(n->right), q.push(n2->left);\\n    }\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n    if(!root) return 1;\\n    queue<TreeNode*> q;\\n    q.push(root), q.push(root);\\n    while(!q.empty()) {\\n        TreeNode* n(q.front());\\n        q.pop();\\n        TreeNode* n2(q.front());\\n        q.pop();\\n        if(n==nullptr and n2==nullptr) continue;\\n        if(n==nullptr or n2==nullptr or n->val!=n2->val) return 0;\\n        q.push(n->left), q.push(n2->right), q.push(n->right), q.push(n2->left);\\n    }\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290624,
                "title": "c-recursive-solution-easy-observation-day-13-successfull-leetcodedaily",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn observing we clearly see we have to perform repetitive task for two roots which are mainly the left and right part we want to compare \\nSo we can divide our bigger problem into smaller problem of taking the whole tree and only compare the left and right part of the root  which hints us towards recursion.\\n\\n![subtrees.png](https://assets.leetcode.com/users/images/a72ac51c-afe5-4eee-982b-a88e3050788e_1678681623.2849514.png)\\n\\n \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can observe that a binary tree is symmetric if the following conditions are met:\\n\\n- The value of the left subtree\\'s root node is equal to the value of the right subtree\\'s root node.\\n- The left subtree\\'s left child is identical to the right subtree\\'s right child.\\n- The left subtree\\'s right child is identical to the right subtree\\'s left child.\\n- Both the left and right subtrees are either empty (NULL) or non-empty.\\nIt is important to note that if only one of the left and right subtrees is non-empty, we cannot compare further as the identical part of the subtree is missing. Therefore, both subtrees must be either empty or non-empty in a symmetric binary tree.\\n\\n# Complexity\\n- ## Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where n is the total number of nodes in the binary tree.  The time complexity of the symmetric() function is **O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric)** and in the worst case it **visits all nodes in the tree (when the tree is not symmetric) in this case it is 0(N)**.\\n\\n\\n- ## Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, **the height of the tree is equal to n, thus the space complexity becomes O(n)**. However, in the best case when the binary tree is **perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n))**.\\n\\nFeel free to share any improvements that can be done to the code \\n# If u wish to connect with me [LinkedIn](https://www.linkedin.com/in/pawas-goyal/)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool symmetric(TreeNode *lst,TreeNode *rst){\\n        if(lst==NULL && rst==NULL)return true;\\n        if(lst==NULL || rst==NULL)return false;\\n        if(lst->val!=rst->val)return false;\\n        return symmetric(lst->left,rst->right)&&symmetric(lst->right,rst->left);\\n        \\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root || root->right==NULL && root->left==NULL)return true;\\n        return symmetric(root->left,root->right);\\n        \\n    }\\n};\\n```\\n![06351dc5-1e55-461d-acf2-60c9048c4726_1675165944.4721575.webp](https://assets.leetcode.com/users/images/6c305529-29d2-4a58-b09d-ee292769d403_1678682609.1504712.webp)\\n\\n# UPVOTE IF U LIKE THE SOLUTION\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool symmetric(TreeNode *lst,TreeNode *rst){\\n        if(lst==NULL && rst==NULL)return true;\\n        if(lst==NULL || rst==NULL)return false;\\n        if(lst->val!=rst->val)return false;\\n        return symmetric(lst->left,rst->right)&&symmetric(lst->right,rst->left);\\n        \\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root || root->right==NULL && root->left==NULL)return true;\\n        return symmetric(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691813,
                "title": "easy-understand-recursion-c",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n/* If you like it please upvote */\\n```\\nIf you like it please upvote",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n/* If you like it please upvote */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774561,
                "title": "c-4-ms-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSymmetric(TreeNode* root) {\\n\\t\\t\\treturn (root==NULL || isSymmetricHelp(root->left,root->right));\\n\\t\\t}\\n\\t\\tbool isSymmetricHelp(TreeNode*left,TreeNode*right){\\n\\t\\t\\tif(left==NULL || right==NULL)\\n\\t\\t\\t\\treturn left==right;\\n\\t\\t\\tif(left->val != right->val)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn isSymmetricHelp(left->left,right->right) && isSymmetricHelp(left->right,right->left);\\n\\t\\t}\\n\\t};\\n\\t\\n\\tTC : O(N)\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSymmetric(TreeNode* root) {\\n\\t\\t\\treturn (root==NULL || isSymmetricHelp(root->left,root->right));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1628473,
                "title": "c-100-runtime-iterative-solution",
                "content": "```\\nbool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> queue;\\n        queue.push(root->left);\\n        queue.push(root->right);\\n        while(!queue.empty()) {\\n            TreeNode *left = queue.front(); queue.pop();\\n            TreeNode *right = queue.front(); queue.pop();\\n            if(!left && !right) continue;\\n            if(!left || !right) return false;\\n            if(left->val != right->val) return false;\\n            queue.push(left->left);\\n            queue.push(right->right);\\n            queue.push(left->right);\\n            queue.push(right->left);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nbool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> queue;\\n        queue.push(root->left);\\n        queue.push(root->right);\\n        while(!queue.empty()) {\\n            TreeNode *left = queue.front(); queue.pop();\\n            TreeNode *right = queue.front(); queue.pop();\\n            if(!left && !right) continue;\\n            if(!left || !right) return false;\\n            if(left->val != right->val) return false;\\n            queue.push(left->left);\\n            queue.push(right->right);\\n            queue.push(left->right);\\n            queue.push(right->left);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625640,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\\n{\\n    if (a == NULL && b == NULL)\\n        return true;\\n \\n    if (a == NULL || b == NULL)\\n        return false;\\n\\n    if (a->val != b->val)\\n        return false;\\n    \\n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\\n}\\n\\nbool isSymmetric(struct TreeNode* root)\\n{\\n    if (root == NULL)\\n        return true;\\n    return parallel_traverse(root->left, root->right);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\\n{\\n    if (a == NULL && b == NULL)\\n        return true;\\n \\n    if (a == NULL || b == NULL)\\n        return false;\\n\\n    if (a->val != b->val)\\n        return false;\\n    \\n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\\n}\\n\\nbool isSymmetric(struct TreeNode* root)\\n{\\n    if (root == NULL)\\n        return true;\\n    return parallel_traverse(root->left, root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182013,
                "title": "javascript",
                "content": "```\\nvar isSymmetric = function(root) {\\n    if(!root) \\n        return true;\\n    return dfs(root.left, root.right);\\n    \\n    function dfs(leftNode, rightNode) {\\n        if (!leftNode && !rightNode) {\\n            return true;\\n        }\\n        if(leftNode && !rightNode || !leftNode && rightNode || leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        return dfs(leftNode.right, rightNode.left) && dfs(leftNode.left, rightNode.right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if(!root) \\n        return true;\\n    return dfs(root.left, root.right);\\n    \\n    function dfs(leftNode, rightNode) {\\n        if (!leftNode && !rightNode) {\\n            return true;\\n        }\\n        if(leftNode && !rightNode || !leftNode && rightNode || leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        return dfs(leftNode.right, rightNode.left) && dfs(leftNode.left, rightNode.right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33305,
                "title": "recursive-and-non-recursive-solutions-in-python",
                "content": "Recursive solution (68ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            return self.equals(root.left, root.right)\\n        \\n        def equals(self, node1, node2):\\n            if not node1 and not node2:\\n                return True\\n            elif node1 and node2 and node1.val == node2.val:\\n                return self.equals(node1.left, node2.right) and self.equals(node1.right, node2.left)\\n            else:\\n                return False\\n\\nNon-Recursive solution (52ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            stack = []\\n            stack.append((root.left, root.right))\\n            \\n            while stack:\\n                left, right = stack.pop()\\n                if not left and not right:\\n                    continue\\n                elif left and right and left.val == right.val:\\n                    stack.append((left.left, right.right))\\n                    stack.append((left.right, right.left))\\n                else:\\n                    return False\\n            \\n            return True",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Recursive solution (68ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            return self.equals(root.left, root.right)\\n        \\n        def equals(self, node1, node2):\\n            if not node1 and not node2:\\n                return True\\n            elif node1 and node2 and node1.val == node2.val:\\n                return self.equals(node1.left, node2.right) and self.equals(node1.right, node2.left)\\n            else:\\n                return False\\n\\nNon-Recursive solution (52ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            stack = []\\n            stack.append((root.left, root.right))\\n            \\n            while stack:\\n                left, right = stack.pop()\\n                if not left and not right:\\n                    continue\\n                elif left and right and left.val == right.val:\\n                    stack.append((left.left, right.right))\\n                    stack.append((left.right, right.left))\\n                else:\\n                    return False\\n            \\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 33359,
                "title": "tree-versions-in-java-recursion-optimized-tail-recursion-and-pre-order-iteration",
                "content": "The most simple version is normal recursion:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}\\n    \\n    \\tprivate boolean isMirror(TreeNode t0, TreeNode t1) {\\n\\t\\tif (t0 == null || t1 == null) {\\n\\t\\t\\treturn t0 == t1;\\n\\t\\t}\\n\\t\\treturn t0.val == t1.val\\n\\t\\t\\t\\t&& this.isMirror(t0.left, t1.right)\\n\\t\\t\\t\\t&& this.isMirror(t0.right, t1.left);\\n    \\t}\\n    }\\n\\nAnd the last recursive call in method isMirror() above can be optimized to loop, this will reduce the actual recursive calls:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}\\n    \\n    \\tprivate boolean isMirror(TreeNode t0, TreeNode t1) {\\n    \\t\\twhile (t0 != null && t1 != null) {\\n    \\t\\t\\tif (t0.val != t1.val || !this.isMirror(t0.left, t1.right)) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\tt0 = t0.right;\\n    \\t\\t\\tt1 = t1.left;\\n    \\t\\t}\\n    \\t\\treturn t0 == t1;\\n    \\t}\\n    }\\nThere are two kinds of iteration at least. The BFS-like iteration, which is based on queue, has a space complexity of O(n). And the DFS-like iteration, which is based on stack, has a better space complexity of O(log n).\\n\\nHere is the DFS-like pre-order iteration:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\tDeque<TreeNode[]> stack = new LinkedList<>();\\n    \\t\\tstack.push(new TreeNode[]{root, root});\\n    \\t\\twhile (!stack.isEmpty()) {\\n    \\t\\t\\tTreeNode[] pair = stack.pop();\\n    \\t\\t\\tTreeNode t0 = pair[0], t1 = pair[1];\\n    \\t\\t\\tif (t0 == null && t1 == null) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (t0 == null || t1 == null || t0.val != t1.val) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\tstack.push(new TreeNode[]{t0.left, t1.right});\\n    \\t\\t\\tstack.push(new TreeNode[]{t0.right, t1.left});\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 33193,
                "title": "my-ac-code-is-there-a-better-method",
                "content": "     public boolean checkSymmetric(TreeNode lsubTree,TreeNode rsubTree){\\n        if(lsubTree==null&&rsubTree==null) return true;\\n        else if(lsubTree!=null&&rsubTree==null) return false;\\n        else if(lsubTree==null&&rsubTree!=null) return false;\\n        else if(lsubTree.val!=rsubTree.val) return false;\\n        boolean lt=checkSymmetric(lsubTree.left,rsubTree.right);\\n        boolean rt=checkSymmetric(lsubTree.right,rsubTree.left);\\n        return lt&&rt;\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return checkSymmetric(root.left,root.right);\\n    }",
                "solutionTags": [],
                "code": "     public boolean checkSymmetric(TreeNode lsubTree,TreeNode rsubTree){\\n        if(lsubTree==null&&rsubTree==null) return true;\\n        else if(lsubTree!=null&&rsubTree==null) return false;\\n        else if(lsubTree==null&&rsubTree!=null) return false;\\n        else if(lsubTree.val!=rsubTree.val) return false;\\n        boolean lt=checkSymmetric(lsubTree.left,rsubTree.right);\\n        boolean rt=checkSymmetric(lsubTree.right,rsubTree.left);\\n        return lt&&rt;\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return checkSymmetric(root.left,root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2927946,
                "title": "101-symmetric-tree-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At first i was thinking to solve it with iterative approach, but it would be costly to use a queue for this, so i thought to use the recursive approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We use recursive approach to solve this problem, the tree would be symmetric if it\\'s foldable you know, so we should start by checking first if the root is null so we have a symmetric tree.\\n\\n- A tree would only be foldable - symmetric - if the left sub-tree leftNode is equivalent to the right sub-tree rightNode and left sub-tree rightNode is equivalent to right sub-tree leftNode.\\n- so we build isMirror function that takes two nodes the left sub-tree parent and the right sub-tree parent and start the comparison as mentioned above in the second point.\\n- If there is any failure for any tested condition the function will be terminated and return false so we don\\'t have to check any more, that\\'s because we are processing the tree level by level, so that\\'s why we will be using o(h) where is h is the height of the tree at worst case.\\n# Complexity\\n- Time complexity: O(n) where is n is the nodes number because we check every single node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h) where is h is the tree height.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(root == null) return true;\\n    return isMirror(root.left, root.right);\\n}; \\n\\nconst isMirror = (leftNode, rightNode) => {\\n    if(leftNode == null && rightNode == null) return true;\\n    if(leftNode == null || rightNode == null) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n   \\n    return isMirror(leftNode.left, rightNode.right) && isMirror(leftNode.right, rightNode.left);\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(root == null) return true;\\n    return isMirror(root.left, root.right);\\n}; \\n\\nconst isMirror = (leftNode, rightNode) => {\\n    if(leftNode == null && rightNode == null) return true;\\n    if(leftNode == null || rightNode == null) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n   \\n    return isMirror(leftNode.left, rightNode.right) && isMirror(leftNode.right, rightNode.left);\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445423,
                "title": "c-7ms-shortest-solution",
                "content": "This question is just an another part of checking two same trees.we treat both left and right subtrees as different. Here we will need to compare left value of one tree with right value of another tree.\\n```\\nclass Solution {\\nprivate:\\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left));\\n    }\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSameTree(root->left,root->right);\\n    }\\n};\\n```\\n**-->UPVOTE IF FOUND USEFUL OR LEARNED ANYTHING!!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left));\\n    }\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSameTree(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33342,
                "title": "7-lines-c-solution",
                "content": "/*\\nThe key is to traverse the left subtree with order root -> left -> right, \\nand the right subtree with order root -> right-> left\\n*/\\n\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if (!root) return true;\\n        return isSymmetric_helper(root->left, root->right);\\n    }\\n    bool isSymmetric_helper(TreeNode* root1, TreeNode* root2) {\\n        if (root1==NULL && root2==NULL) return true;\\n        if (root1==NULL || root2==NULL) return false;\\n        if (root1->val != root2->val) return false;\\n        return isSymmetric_helper(root1->left, root2->right) && isSymmetric_helper(root1->right, root2->left);\\n    }",
                "solutionTags": [],
                "code": "/*\\nThe key is to traverse the left subtree with order root -> left -> right, \\nand the right subtree with order root -> right-> left\\n*/\\n\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if (!root) return true;\\n        return isSymmetric_helper(root->left, root->right);\\n    }\\n    bool isSymmetric_helper(TreeNode* root1, TreeNode* root2) {\\n        if (root1==NULL && root2==NULL) return true;\\n        if (root1==NULL || root2==NULL) return false;\\n        if (root1->val != root2->val) return false;\\n        return isSymmetric_helper(root1->left, root2->right) && isSymmetric_helper(root1->right, root2->left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33352,
                "title": "a-simple-python-recursive-solution-o-n-60ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {boolean}\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n    \\n            return self.isSymmetricTree(root.left, root.right)\\n    \\n        def isSymmetricTree(self, node1, node2):\\n            if node1 and node2:\\n                return node1.val == node2.val and self.isSymmetricTree(node1.left, node2.right) and self.isSymmetricTree(node1.right, node2.left)\\n            else:\\n                return node1 == node2",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 33406,
                "title": "two-simple-accepted-java-solutions-recursion-and-iteration",
                "content": "The idea is simple. Traverse both on left an right branches of the root symmetricaly and check if the values are equal.\\n\\n\\nRecursion.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root == null ? true : symmetric(root.left, root.right);\\n    }\\n\\t\\n\\tpublic boolean symmetric(TreeNode left, TreeNode right) {\\n        if (left == null && right == null) {\\n        \\treturn true;\\n        } else if (left != null && right != null && left.val == right.val) {\\n        \\treturn symmetric(left.left, right.right) && symmetric(left.right, right.left);\\n        } else {\\n        \\treturn false;\\n        }\\n    }\\n\\n\\n\\nIteration.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null || (root.left == null && root.right == null)) return true;\\n        Stack<TreeNode> L = new Stack<TreeNode>();\\n        Stack<TreeNode> R = new Stack<TreeNode>();\\n        L.push(root.left);\\n        R.push(root.right);\\n        \\n        while(!L.isEmpty() && !R.isEmpty()) {\\n        \\tTreeNode left = L.pop();\\n        \\tTreeNode right = R.pop();\\n        \\tif (left == null && right == null) continue;\\n        \\tif (left != null && right != null && left.val == right.val) {\\n        \\t\\tL.push(left.left);\\n        \\t\\tR.push(right.right);\\n        \\t\\tL.push(left.right);\\n        \\t\\tR.push(right.left);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\treturn false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "The idea is simple. Traverse both on left an right branches of the root symmetricaly and check if the values are equal.\\n\\n\\nRecursion.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root == null ? true : symmetric(root.left, root.right);\\n    }\\n\\t\\n\\tpublic boolean symmetric(TreeNode left, TreeNode right) {\\n        if (left == null && right == null) {\\n        \\treturn true;\\n        } else if (left != null && right != null && left.val == right.val) {\\n        \\treturn symmetric(left.left, right.right) && symmetric(left.right, right.left);\\n        } else {\\n        \\treturn false;\\n        }\\n    }\\n\\n\\n\\nIteration.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null || (root.left == null && root.right == null)) return true;\\n        Stack<TreeNode> L = new Stack<TreeNode>();\\n        Stack<TreeNode> R = new Stack<TreeNode>();\\n        L.push(root.left);\\n        R.push(root.right);\\n        \\n        while(!L.isEmpty() && !R.isEmpty()) {\\n        \\tTreeNode left = L.pop();\\n        \\tTreeNode right = R.pop();\\n        \\tif (left == null && right == null) continue;\\n        \\tif (left != null && right != null && left.val == right.val) {\\n        \\t\\tL.push(left.left);\\n        \\t\\tR.push(right.right);\\n        \\t\\tL.push(left.right);\\n        \\t\\tR.push(right.left);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\treturn false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33417,
                "title": "my-16ms-c-solution",
                "content": "    \\n    bool DFS(TreeNode *left,TreeNode *right)\\n    {\\n        if(left == NULL || right == NULL)\\n            return left == right;\\n        return (left->val == right->val)&DFS(left->right,right->left)&DFS(left->left,right->right);\\n    }\\n    bool isSymmetric(TreeNode *root) {\\n        if(root == NULL)\\n            return true;\\n        return DFS(root->left,root->right);\\n    }",
                "solutionTags": [],
                "code": "    \\n    bool DFS(TreeNode *left,TreeNode *right)\\n    {\\n        if(left == NULL || right == NULL)\\n            return left == right;\\n        return (left->val == right->val)&DFS(left->right,right->left)&DFS(left->left,right->right);\\n    }\\n    bool isSymmetric(TreeNode *root) {\\n        if(root == NULL)\\n            return true;\\n        return DFS(root->left,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290155,
                "title": "day-72-with-diagram-iterative-and-recursive-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nWe need to validate only 3 conditions including base condition and recursively call to the function:\\n- If both \"leftRoot\" and \"rightRoot\" are null, return true\\n- If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n\\n![WhatsApp Image 2023-01-24 at 6.54.24 PM.jpeg](https://assets.leetcode.com/users/images/3ce67a24-c51f-4cff-a5ac-58425726b650_1674566690.8242106.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a function \"isTreeSymmetric\" that takes in two TreeNode pointers as inputs, \"leftRoot\" and \"rightRoot\"\\n2. If both \"leftRoot\" and \"rightRoot\" are null, return true\\n3. If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n4. If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n5. If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n6. Return true if both recursive calls return true, else return false\\n7. Define a function \"isSymmetric\" that takes in a TreeNode pointer \"root\" as input\\n8. Call \"isTreeSymmetric\" on the left child of \"root\" and the right child of \"root\" and return the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Iterative approach\\n// TC - O(n), where n is the number of nodes in the binary tree. This is because the code visits each node in the binary tree once, and the while loop iterates over all nodes in the worst-case scenario.\\n// SC - O(n), where n is the number of nodes in the binary tree. This is because the code uses a queue to store nodes in a level-by-level manner, and in the worst-case scenario, the queue will contain all the nodes of the binary tree. Therefore, the space required by the queue will be proportional to the number of nodes in the tree, leading to O(n) space complexity.\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if (root == nullptr)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root -> left);\\n        q.push(root -> right);\\n        while (!q.empty()) {\\n            TreeNode *leftRoot = q.front();\\n            q.pop();\\n            TreeNode *rightRoot = q.front();\\n            q.pop();\\n            if (leftRoot == nullptr && rightRoot == nullptr)\\n                continue;\\n            if ((leftRoot == nullptr && rightRoot != nullptr) || (leftRoot != nullptr && rightRoot == nullptr))\\n                return false;\\n            if (leftRoot -> val != rightRoot -> val)\\n                return false;\\n            q.push(leftRoot -> left);\\n            q.push(rightRoot -> right);\\n            q.push(leftRoot -> right);\\n            q.push(rightRoot -> left);\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the total number of nodes in the binary tree. This is because the solution visits each node once and compares its values with the corresponding symmetric node, thus the function isTreeSymmetric() is called on each node at most once. The time complexity of the isTreeSymmetric() function is O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric) and in the worst case it visits all nodes in the tree (when the tree is not symmetric).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, the height of the tree is equal to n, thus the space complexity becomes O(n). However, in the best case when the binary tree is perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n)).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n//Iterative approach\\n// TC - O(n), where n is the number of nodes in the binary tree. This is because the code visits each node in the binary tree once, and the while loop iterates over all nodes in the worst-case scenario.\\n// SC - O(n), where n is the number of nodes in the binary tree. This is because the code uses a queue to store nodes in a level-by-level manner, and in the worst-case scenario, the queue will contain all the nodes of the binary tree. Therefore, the space required by the queue will be proportional to the number of nodes in the tree, leading to O(n) space complexity.\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if (root == nullptr)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root -> left);\\n        q.push(root -> right);\\n        while (!q.empty()) {\\n            TreeNode *leftRoot = q.front();\\n            q.pop();\\n            TreeNode *rightRoot = q.front();\\n            q.pop();\\n            if (leftRoot == nullptr && rightRoot == nullptr)\\n                continue;\\n            if ((leftRoot == nullptr && rightRoot != nullptr) || (leftRoot != nullptr && rightRoot == nullptr))\\n                return false;\\n            if (leftRoot -> val != rightRoot -> val)\\n                return false;\\n            q.push(leftRoot -> left);\\n            q.push(rightRoot -> right);\\n            q.push(leftRoot -> right);\\n            q.push(rightRoot -> left);\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196119,
                "title": "easy-c-solution-dfs-beats-100-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Do preorder traversal in the left subtree (node-left-right) and preorder traversal in reverse manner (node-right-left) in the right subtree. \\n2. At any point, if we find any dissimilarity then the tree is not symmetric, otherwise it is symmetric.\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n  O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(TreeNode *root1, TreeNode *root2){\\n        if(root1==NULL && root2==NULL) return true;\\n        if(!(root1 && root2)) return false;\\n\\n        if(root1->val!=root2->val) return false;\\n        bool l=check(root1->left,root2->right);\\n        bool r=check(root1->right,root2->left);\\n        return l&&r;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left,root->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode *root1, TreeNode *root2){\\n        if(root1==NULL && root2==NULL) return true;\\n        if(!(root1 && root2)) return false;\\n\\n        if(root1->val!=root2->val) return false;\\n        bool l=check(root1->left,root2->right);\\n        bool r=check(root1->right,root2->left);\\n        return l&&r;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left,root->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059196,
                "title": "tree-100-beat-0ms-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool tra(TreeNode* root1,TreeNode* root2){\\n        if(root1==0&&root2==0){\\n            return true;\\n        }\\n        if(root1==0||root2==0||root1->val!=root2->val){\\n            return false;\\n        }\\n        return tra(root1->left,root2->right)&&tra(root1->right,root2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return tra(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool tra(TreeNode* root1,TreeNode* root2){\\n        if(root1==0&&root2==0){\\n            return true;\\n        }\\n        if(root1==0||root2==0||root1->val!=root2->val){\\n            return false;\\n        }\\n        return tra(root1->left,root2->right)&&tra(root1->right,root2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return tra(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023412,
                "title": "clean-and-easy-recursive-and-iterative-solutions",
                "content": "**Recursive**\\n\\n```\\nvar isSymmetric = function(root) {\\n    \\n    const helper = (node1, node2) => {\\n        if(node1 === null && node2 === null)\\n            return true;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            return helper(node1.left, node2.right) && helper(node1.right, node2.left);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return helper(root.left, root.right);\\n};\\n```\\n\\n**Iterative**\\n\\n```\\nvar isSymmetric = function(root) {\\n    \\n    const arr = [];\\n    \\n    arr.push([root.left, root.right]);\\n    \\n    while(arr.length) {\\n        let [node1, node2] = arr.pop();\\n        \\n        if(node1 === null && node2 === null)\\n            continue;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            arr.push([node1.left, node2.right]);\\n            arr.push([node1.right, node2.left]);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    \\n    const helper = (node1, node2) => {\\n        if(node1 === null && node2 === null)\\n            return true;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            return helper(node1.left, node2.right) && helper(node1.right, node2.left);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return helper(root.left, root.right);\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    \\n    const arr = [];\\n    \\n    arr.push([root.left, root.right]);\\n    \\n    while(arr.length) {\\n        let [node1, node2] = arr.pop();\\n        \\n        if(node1 === null && node2 === null)\\n            continue;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            arr.push([node1.left, node2.right]);\\n            arr.push([node1.right, node2.left]);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448819,
                "title": "recursive-and-iterative-js-versions",
                "content": "Recursive:\\n```\\nvar isSymmetric = function(root) {\\n/**\\n * Compares two TreeNode\\'s\\n * @param {TreeNode} root1\\n * @param {TreeNode} root2\\n * @return {boolean}\\n */\\n    function isEqual(root1, root2) {\\n        if (!root1 && !root2) return true;\\n        if (!root1 || !root2) return false;\\n        return root1.val === root2.val\\n            && isEqual(root1.left, root2.right)\\n            && isEqual(root1.right, root2.left);\\n    }\\n    if (!root) return true;\\n    return isEqual(root.left, root.right)\\n};\\n```\\n\\nIterative: \\n```\\nvar isSymmetric = function(root) {\\n    if (!root) return true;\\n    \\n    const stack = [root.left, root.right];\\n    while (stack.length) {\\n        const currLeft = stack.shift();\\n        const currRight = stack.shift();\\n        if (!currLeft && !currRight) continue;\\n        if ((!currLeft || !currRight) || currLeft.val !== currRight.val) return false;\\n        stack.push(currLeft.left, currRight.right, currLeft.right, currRight.left);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n/**\\n * Compares two TreeNode\\'s\\n * @param {TreeNode} root1\\n * @param {TreeNode} root2\\n * @return {boolean}\\n */\\n    function isEqual(root1, root2) {\\n        if (!root1 && !root2) return true;\\n        if (!root1 || !root2) return false;\\n        return root1.val === root2.val\\n            && isEqual(root1.left, root2.right)\\n            && isEqual(root1.right, root2.left);\\n    }\\n    if (!root) return true;\\n    return isEqual(root.left, root.right)\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    if (!root) return true;\\n    \\n    const stack = [root.left, root.right];\\n    while (stack.length) {\\n        const currLeft = stack.shift();\\n        const currRight = stack.shift();\\n        if (!currLeft && !currRight) continue;\\n        if ((!currLeft || !currRight) || currLeft.val !== currRight.val) return false;\\n        stack.push(currLeft.left, currRight.right, currLeft.right, currRight.left);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479794,
                "title": "python-3-simple-recursion-faster-than-97-and-less-memory-than-100",
                "content": "\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return True\\n        \\n        left=root.left\\n        right=root.right\\n        \\n        if not left and not right:\\n            return True\\n        \\n        def check(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if t1 and not t2:\\n                return False\\n            if not t1 and t2:\\n                return False\\n            if t1.val!=t2.val:\\n                return False\\n            return check(t1.left, t2.right) and check(t1.right, t2.left)\\n        \\n        return check(left, right)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return True\\n        \\n        left=root.left\\n        right=root.right\\n        \\n        if not left and not right:\\n            return True\\n        \\n        def check(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if t1 and not t2:\\n                return False\\n            if not t1 and t2:\\n                return False\\n            if t1.val!=t2.val:\\n                return False\\n            return check(t1.left, t2.right) and check(t1.right, t2.left)\\n        \\n        return check(left, right)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 183416,
                "title": "python-dfs",
                "content": "### 101.  Symmetric Tree\\n\\n\\u8FD9\\u9053\\u9898\\u5177\\u4F53\\u7684Recursion Rule\\u4E0D\\u662F\\u4F20\\u9012Root\\u672C\\u8EAB\\uFF0C\\u800C\\u662F\\u5BF9\\u4E24\\u4E2A\\u5B50\\u5B69\\u5B50\\u7684\\u6BD4\\u8F83\\uFF0C\\u6240\\u4EE5Helper\\u7684\\u53C2\\u6570\\u5B9A\\u4E49\\u4E3A`root.left` \\u548C `root.right`. \\u7136\\u540E\\u6839\\u636E\\u9898\\u76EE\\u7684\\u7279\\u6027\\uFF0C\\u5728\\u6BCF\\u4E00\\u5C42\\u5F80\\u4E0B\\u4F20\\u9012\\u4E4B\\u524D\\u8981\\u505A\\u6BD4\\u8F83\\uFF0C\\u6240\\u4EE5\\u662F`preorder`\\u7684\\u5199\\u6CD5\\uFF0C\\u5148\\u5199\\u6BD4\\u8F83\\u7684\\u51E0\\u79CD\\u683C\\u5F0F\\uFF0C\\u7136\\u540E\\u5728\\u505A\\u9012\\u5F52\\u3002\\u9012\\u5F52\\u5411\\u4E0A\\u8FD4\\u56DE\\u7684\\u53C2\\u6570\\u662F\\u4E00\\u4E2ABoolean\\u3002\\n\\n\\u65F6\\u95F4\\u590D\\u6742\\u5EA6 : O(N)\\n\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6 : O(N) or O(Height)\\n\\n```python\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.dfs_helper(root.left, root.right)\\n        \\n    \\n    def dfs_helper(self, n1, n2):\\n        if not n1 and not n2: return True\\n        if not n1 or not n2: return False\\n        if n1.val != n2.val: return False\\n        left = self.dfs_helper(n1.left, n2.right)\\n        right = self.dfs_helper(n1.right, n2.left)\\n        return left and right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.dfs_helper(root.left, root.right)\\n        \\n    \\n    def dfs_helper(self, n1, n2):\\n        if not n1 and not n2: return True\\n        if not n1 or not n2: return False\\n        if n1.val != n2.val: return False\\n        left = self.dfs_helper(n1.left, n2.right)\\n        right = self.dfs_helper(n1.right, n2.left)\\n        return left and right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33177,
                "title": "simple-and-easy-understand-recursive-and-iterative-python-solutions",
                "content": "recursive:\\n\\n```\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.helper(root.left, root.right)\\n\\n    def helper(self, left, right):\\n# first make sure left and right is not none\\n        if left and right: \\n            if left.val == right.val:\\n                return self.helper(left.left, right.right) and self.helper(left.right, right.left)\\n            else:\\n                return False\\n        else:\\n# otherwise,return left == right\\n            return left == right \\n```\\n\\niterative using stack:\\n\\n```\\n    def isSymmetric(self, root):\\n\\n        if not root: return True\\n    \\n        stack = [[root.left, root.right]]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            if node1 and node2: # make sure not None\\n                if node1.val != node2.val:\\n                    return False\\n                else:\\n                    stack.append([node1.left, node2.right])\\n                    stack.append([node1.right, node2.left])\\n            else:\\n                if node1 == node2:\\n                    continue\\n                else:\\n                    return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.helper(root.left, root.right)\\n\\n    def helper(self, left, right):\\n# first make sure left and right is not none\\n        if left and right: \\n            if left.val == right.val:\\n                return self.helper(left.left, right.right) and self.helper(left.right, right.left)\\n            else:\\n                return False\\n        else:\\n# otherwise,return left == right\\n            return left == right \\n```\n```\\n    def isSymmetric(self, root):\\n\\n        if not root: return True\\n    \\n        stack = [[root.left, root.right]]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            if node1 and node2: # make sure not None\\n                if node1.val != node2.val:\\n                    return False\\n                else:\\n                    stack.append([node1.left, node2.right])\\n                    stack.append([node1.right, node2.left])\\n            else:\\n                if node1 == node2:\\n                    continue\\n                else:\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 33260,
                "title": "easy-java-solution-with-comments",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        \\n        //Base casees: if root is null or only 1 node is present\\n        if(root==null || (root.left==null && root.right==null))\\n            return true;\\n            \\n        //if either subtree is empty return false\\n        if(root.left==null || root.right==null)\\n            return false;\\n            \\n        return Symmetric(root.left,root.right);\\n        \\n    }\\n    \\n    \\n    public boolean Symmetric(TreeNode node1, TreeNode node2)\\n    {\\n        //if both are null, return true\\n        if(node1==null && node2==null)\\n            return true;\\n            \\n        //if either one is null, return false\\n        if(node1==null || node2==null)\\n            return false;\\n        \\n        //if they both are equal, compare their children\\n        if(node1.val==node2.val)\\n        {\\n            return Symmetric(node1.left,node2.right) && Symmetric(node1.right,node2.left);\\n        }\\n        else\\n            return false;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        \\n        //Base casees: if root is null or only 1 node is present\\n        if(root==null || (root.left==null && root.right==null))\\n            return true;\\n            \\n        //if either subtree is empty return false\\n        if(root.left==null || root.right==null)\\n            return false;\\n            \\n        return Symmetric(root.left,root.right);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 33381,
                "title": "simple-java-recursive-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) return true;\\n            return isSymmetric(root.left, root.right);\\n        }\\n        \\n        // Returns whether tree 'left' is mirror of tree 'right'\\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            // Case 1: both are null - return true\\n            if (left == null && right == null) return true;\\n            \\n            // Case 2: one is null but not the other - return false\\n            if (left == null || right == null) return false;\\n            \\n            // Case 3: both are not null - check whether they're equal and left/right subtrees are mirrors\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) return true;\\n            return isSymmetric(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3291837,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n    }\\n\\n    bool isMirror(TreeNode* t1, TreeNode* t2) {\\n        if (t1 == nullptr && t2 == nullptr) {\\n            return true;\\n        }\\n        if (t1 == nullptr || t2 == nullptr) {\\n            return false;\\n        }\\n        return t1->val == t2->val && isMirror(t1->right, t2->left) && isMirror(t1->left, t2->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n    }\\n\\n    bool isMirror(TreeNode* t1, TreeNode* t2) {\\n        if (t1 == nullptr && t2 == nullptr) {\\n            return true;\\n        }\\n        if (t1 == nullptr || t2 == nullptr) {\\n            return false;\\n        }\\n        return t1->val == t2->val && isMirror(t1->right, t2->left) && isMirror(t1->left, t2->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290079,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSame(root, root)\\n    \\n    def isSame(self, n1, n2):\\n        if not n1 and not n2:\\n            return True\\n        elif not n1 or not n2:\\n            return False\\n        \\n        return n1.val == n2.val and self.isSame(n1.right, n2.left) and self.isSame(n1.left, n2.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSame(root, root)\\n    \\n    def isSame(self, n1, n2):\\n        if not n1 and not n2:\\n            return True\\n        elif not n1 or not n2:\\n            return False\\n        \\n        return n1.val == n2.val and self.isSame(n1.right, n2.left) and self.isSame(n1.left, n2.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189527,
                "title": "symmetric-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe isSymmetric function takes a binary tree root as input, and returns True if it is symmetric, and False otherwise.\\n\\nThe isMirror function checks whether two nodes node1 and node2 are mirrors of each other. It returns True if they are, and False otherwise.\\n\\nThe isSymmetric function checks whether the left and right subtrees of root are mirrors of each other, using the isMirror function. If they are, it returns True, and False otherwise.\\n\\nThe time complexity of this solution is O(n), where n is the number of nodes in the binary tree, since we visit each node once. The space complexity is O(h), where h is the height of the binary tree, since the depth of the recursive call stack is at most the height of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n    \\n    def isMirror(self, node1: TreeNode, node2: TreeNode) -> bool:\\n        if not node1 and not node2:\\n            return True\\n        if not node1 or not node2:\\n            return False\\n        if node1.val != node2.val:\\n            return False\\n        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n    \\n    def isMirror(self, node1: TreeNode, node2: TreeNode) -> bool:\\n        if not node1 and not node2:\\n            return True\\n        if not node1 or not node2:\\n            return False\\n        if node1.val != node2.val:\\n            return False\\n        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728716,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(r1,r2):\\n            if not r1 and not r2:\\n                return True\\n            if not r1 or not r2:\\n                return False\\n            return r1.val == r2.val and dfs(r1.left, r2.right) and dfs(r1.right, r2.left)\\n        return dfs(root.left, root.right) if root else True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(r1,r2):\\n            if not r1 and not r2:\\n                return True\\n            if not r1 or not r2:\\n                return False\\n            return r1.val == r2.val and dfs(r1.left, r2.right) and dfs(r1.right, r2.left)\\n        return dfs(root.left, root.right) if root else True",
                "codeTag": "Java"
            },
            {
                "id": 1937483,
                "title": "python-faster-than-98-8-with-explaination",
                "content": "# Please upvote if it helps\\n### Recursive Approach:\\n- Have to define a function which will receive two nodes which is P and Q\\n- If both p and q is None then, return True\\n- if p or q is none, then return False \\n\\t- Because it\\'s not symmetric if one has value and the other one is empty\\n- if p.val is not equal to q.val , then return False\\n- Return function(p.left, q.right) and function(p.right, q.left)\\n\\t- Because to check symmetric we have to check :\\n\\t\\t- if (leftOfLeft==rightOfRight) and (rightOfLeft==leftOfRgiht) is true then its symmetric\\n\\t\\t- otherwise its not.\\n\\t\\n- That\\'s all\\n\\nCode:\\n\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isMirror(p, q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            \\n            return isMirror(p.left, q.right) and isMirror(p.right, q.left)\\n        \\n        \\n        return isMirror(root.left, root.right)\\n        \\n```\\n\\n#### Leave a comment if you have any question.\\n![image](https://assets.leetcode.com/users/images/3dd47369-9bc2-4a35-8ccb-b6dc00dd0a1a_1649707786.1095674.png)\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isMirror(p, q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            \\n            return isMirror(p.left, q.right) and isMirror(p.right, q.left)\\n        \\n        \\n        return isMirror(root.left, root.right)\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1898293,
                "title": "my-python-recursive-solution",
                "content": "\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def compareSub(p, q):\\n            if p == None and q == None:\\n                return True\\n            if p == None or q == None:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            return compareSub(p.left, q.right) and compareSub(p.right, q.left)\\n        return compareSub(root, root)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def compareSub(p, q):\\n            if p == None and q == None:\\n                return True\\n            if p == None or q == None:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            return compareSub(p.left, q.right) and compareSub(p.right, q.left)\\n        return compareSub(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456554,
                "title": "python-dfs-clean-concise",
                "content": "```python\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            if root1 == None or root2 == None or root1.val != root2.val:\\n                return False\\n            \\n            return dfs(root1.right, root2.left) and dfs(root1.left, root2.right)\\n        \\n        return dfs(root.left, root.right)\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 1000` is number of nodes in the binary tree.\\n- Space: `O(H)`, where `H` is the height of the binary tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            if root1 == None or root2 == None or root1.val != root2.val:\\n                return False\\n            \\n            return dfs(root1.right, root2.left) and dfs(root1.left, root2.right)\\n        \\n        return dfs(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909732,
                "title": "python-concise-recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642604,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Symmetric Tree.\\nMemory Usage: 37.4 MB, less than 74.15% of Java online submissions for Symmetric Tree.\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || traverse(root.left,root.right);\\n    }\\n    private boolean traverse(TreeNode one,TreeNode two){\\n        if(one==null && two==null)return true;\\n        if(one==null || two==null)return false;\\n        if(one.val!=two.val)return false;\\n        boolean resl=traverse(one.left,two.right);\\n        if(!resl)return false;\\n        boolean resr=traverse(one.right,two.left);\\n        if(!resr)return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || traverse(root.left,root.right);\\n    }\\n    private boolean traverse(TreeNode one,TreeNode two){\\n        if(one==null && two==null)return true;\\n        if(one==null || two==null)return false;\\n        if(one.val!=two.val)return false;\\n        boolean resl=traverse(one.left,two.right);\\n        if(!resl)return false;\\n        boolean resr=traverse(one.right,two.left);\\n        if(!resr)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229212,
                "title": "swift-solution-beats-100",
                "content": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return isMirror(root, root)\\n    }\\n    func isMirror(_ t1:TreeNode?,_ t2:TreeNode?) ->Bool {\\n        if(t1 == nil && t2 == nil) {return true}\\n        if(t1 == nil || t2 == nil) {return false}\\n        return (t1!.val == t2!.val) &&\\n               isMirror(t1!.right,t2!.left) &&\\n               isMirror(t1!.left,t2!.right)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return isMirror(root, root)\\n    }\\n    func isMirror(_ t1:TreeNode?,_ t2:TreeNode?) ->Bool {\\n        if(t1 == nil && t2 == nil) {return true}\\n        if(t1 == nil || t2 == nil) {return false}\\n        return (t1!.val == t2!.val) &&\\n               isMirror(t1!.right,t2!.left) &&\\n               isMirror(t1!.left,t2!.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33386,
                "title": "share-3-methods-to-solve-this-problem-java",
                "content": "First.\\nWe can define a binary tree by mid-order and post-order or pre-order and mid-order, the mirror tree is same to the origin tree. So we can check these two trees' mid-order and post-order are all same?\\n\\n    public boolean isSymmetric(TreeNode root) {\\n            if (root==null)\\n                return true;\\n            return getMidOrderSeq(root).equals(getReMidOrderSeq(root))&&getPostOrderSeq(root).equals(getRePostOrderSeq(root));\\n        }\\n    \\n        public String getMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getMidOrderSeq(node.left) + node.val + getMidOrderSeq(node.right);\\n        }\\n        public String getReMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getReMidOrderSeq(node.right) + node.val + getReMidOrderSeq(node.left);\\n        }\\n        public String getPostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getPostOrderSeq(node.left) +getPostOrderSeq(node.right)+ node.val ;\\n        }\\n        public String getRePostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getRePostOrderSeq(node.right) +getRePostOrderSeq(node.left)+ node.val ;\\n        }\\n\\n\\nSecond. Normal recursion.\\n\\n     public boolean isSymmetric(TreeNode root) {\\n            if (root == null)\\n                return true;\\n            return isSymmetric(root, root);\\n    \\n        }\\n    \\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null || right == null) {\\n                return left == right;\\n            }\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n\\nThird. Iteration.\\n\\n    public boolean isSymmetricIter(TreeNode root) {\\n            if (root == null || (root.left == null && root.right == null))\\n                return true;\\n            Stack<TreeNode> leftStack = new Stack<>();\\n            Stack<TreeNode> rightStack = new Stack<>();\\n            leftStack.push(root.left);\\n            rightStack.push(root.right);\\n            while (!leftStack.isEmpty() && !rightStack.isEmpty()) {\\n                TreeNode left = leftStack.pop();\\n                TreeNode right = rightStack.pop();\\n                if (left == null && right == null) {\\n                    continue;\\n                }\\n                if (left == null || right == null)\\n                    return false;\\n                if (left.val != right.val)\\n                    return false;\\n                leftStack.push(left.left);\\n                rightStack.push(right.right);\\n                leftStack.push(left.right);\\n                rightStack.push(right.left);\\n            }\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "First.\\nWe can define a binary tree by mid-order and post-order or pre-order and mid-order, the mirror tree is same to the origin tree. So we can check these two trees' mid-order and post-order are all same?\\n\\n    public boolean isSymmetric(TreeNode root) {\\n            if (root==null)\\n                return true;\\n            return getMidOrderSeq(root).equals(getReMidOrderSeq(root))&&getPostOrderSeq(root).equals(getRePostOrderSeq(root));\\n        }\\n    \\n        public String getMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getMidOrderSeq(node.left) + node.val + getMidOrderSeq(node.right);\\n        }\\n        public String getReMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getReMidOrderSeq(node.right) + node.val + getReMidOrderSeq(node.left);\\n        }\\n        public String getPostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getPostOrderSeq(node.left) +getPostOrderSeq(node.right)+ node.val ;\\n        }\\n        public String getRePostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getRePostOrderSeq(node.right) +getRePostOrderSeq(node.left)+ node.val ;\\n        }\\n\\n\\nSecond. Normal recursion.\\n\\n     public boolean isSymmetric(TreeNode root) {\\n            if (root == null)\\n                return true;\\n            return isSymmetric(root, root);\\n    \\n        }\\n    \\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null || right == null) {\\n                return left == right;\\n            }\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n\\nThird. Iteration.\\n\\n    public boolean isSymmetricIter(TreeNode root) {\\n            if (root == null || (root.left == null && root.right == null))\\n                return true;\\n            Stack<TreeNode> leftStack = new Stack<>();\\n            Stack<TreeNode> rightStack = new Stack<>();\\n            leftStack.push(root.left);\\n            rightStack.push(root.right);\\n            while (!leftStack.isEmpty() && !rightStack.isEmpty()) {\\n                TreeNode left = leftStack.pop();\\n                TreeNode right = rightStack.pop();\\n                if (left == null && right == null) {\\n                    continue;\\n                }\\n                if (left == null || right == null)\\n                    return false;\\n                if (left.val != right.val)\\n                    return false;\\n                leftStack.push(left.left);\\n                rightStack.push(right.right);\\n                leftStack.push(left.right);\\n                rightStack.push(right.left);\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 33407,
                "title": "my-simple-c-recursive-solution-9ms",
                "content": "    class Solution {\\n    public:\\n        bool areSymmetricTrees(TreeNode *rootA, TreeNode *rootB){\\n            if( (!rootA) && (!rootB) )\\n            {\\n                return true;\\n            }\\n            else if( rootA && rootB )\\n            {\\n                return (rootA->val == rootB->val) && areSymmetricTrees(rootA->left, rootB->right)\\n                && areSymmetricTrees(rootB->left, rootA->right);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        bool isSymmetric(TreeNode *root) {\\n            if(!root)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return areSymmetricTrees(root->left, root->right);\\n            }\\n            \\n        }\\n    };\\n\\nA help function is defined to check if two trees are symmetric.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool areSymmetricTrees(TreeNode *rootA, TreeNode *rootB){\\n            if( (!rootA) && (!rootB) )\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33374,
                "title": "recusive-solution-for-symmetric-tree-is-it-an-optimal-solution-to-use-inordertraversal",
                "content": "The approach I have is:\\n1. get two vectors which saves both left and right sides of the root in inorderTraversal format.\\n2. compare the vectors to see if they are symmetric.\\nIt needs extra O(2n) space, not sure if this is an accepted solution. Or is there any better to solve this problem recursively.\\n\\n    /*recusive*/\\n    class inorderTraversal {\\n    public:\\n        vector<int> solution(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            vector <int> results;\\n    \\t\\tvector <int> rightResults;\\n    \\t\\tif(!root) return results;\\n    \\t\\tresults=solution(root->left);\\n            results.insert(results.end(),root->val);\\n    \\t\\trightResults=solution(root->right);\\n    \\t\\tif(!rightResults.empty())\\n    \\t\\t\\tresults.insert(results.end(),rightResults.begin(), rightResults.end());\\n        }\\n    };\\n    \\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            if(!root) return true;\\n    \\t\\tinorderTraversal instance;\\n    \\t\\tvector <int> leftResults=instance.solution(root->left);\\n    \\t\\tvector <int> rightResults=instance.solution(root->right);\\n    \\t\\tif(leftResults.size()!=rightResults.size())\\n    \\t\\t\\treturn false;\\n    \\t\\tint size=leftResults.size();\\n    \\t\\tif(!size) return true;\\n    \\n    \\t\\tfor(int i=0; i< size; i++)\\n    \\t\\t{\\n    \\t\\t\\tif(leftResults[i]!=rightResults[size-1-i])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            if(!root) return true;\\n    \\t\\tinorderTraversal instance;\\n    \\t\\tvector <int> leftResults=instance.solution(root->left);\\n    \\t\\tvector <int> rightResults=instance.solution(root->right);\\n    \\t\\tif(leftResults.size()!=rightResults.size())\\n    \\t\\t\\treturn false;\\n    \\t\\tint size=leftResults.size();\\n    \\t\\tif(!size) return true;\\n    \\n    \\t\\tfor(int i=0; i< size; i++)\\n    \\t\\t{\\n    \\t\\t\\tif(leftResults[i]!=rightResults[size-1-i])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3648117,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool c(TreeNode* left, TreeNode* right){\\n        if(!left || !right){\\n            return left==right;\\n        }\\n        if(left->val!=right->val)return false;\\n        return c(left->left,right->right) && c(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return c(root,root);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/bdc85d8b-0970-490c-afb7-cd6f07b58742_1686996931.7722983.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool c(TreeNode* left, TreeNode* right){\\n        if(!left || !right){\\n            return left==right;\\n        }\\n        if(left->val!=right->val)return false;\\n        return c(left->left,right->right) && c(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return c(root,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169564,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nbool myfunc(TreeNode* p,TreeNode* q)\\n{\\n    if(p==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(q==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(p->val!=q->val)\\n    {\\n        return false;\\n    }\\n    return myfunc(p->left,q->right)&&myfunc(p->right,q->left);\\n}\\n    bool isSymmetric(TreeNode* root) {\\n       return myfunc(root->left,root->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(left, right):\\n            if left is None and right is None:\\n                return True\\n            if left is None or right is None:\\n                return False\\n            if left.val != right.val:\\n                return False\\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\\n\\n        if root is None:\\n            return True\\n        else:\\n            return isMirror(root.left, root.right)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nbool myfunc(TreeNode* p,TreeNode* q)\\n{\\n    if(p==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(q==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(p->val!=q->val)\\n    {\\n        return false;\\n    }\\n    return myfunc(p->left,q->right)&&myfunc(p->right,q->left);\\n}\\n    bool isSymmetric(TreeNode* root) {\\n       return myfunc(root->left,root->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(left, right):\\n            if left is None and right is None:\\n                return True\\n            if left is None or right is None:\\n                return False\\n            if left.val != right.val:\\n                return False\\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\\n\\n        if root is None:\\n            return True\\n        else:\\n            return isMirror(root.left, root.right)\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003505,
                "title": "java-recursion-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean preOrder(TreeNode temp,TreeNode temp1){\\n        if(temp==null || temp1==null){\\n            return temp==temp1;\\n        }\\n        if(temp.val!=temp1.val) return false;\\n        \\n        return preOrder(temp.left,temp1.right) && preOrder(temp.right,temp1.left);\\n        \\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || preOrder(root.left,root.right); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean preOrder(TreeNode temp,TreeNode temp1){\\n        if(temp==null || temp1==null){\\n            return temp==temp1;\\n        }\\n        if(temp.val!=temp1.val) return false;\\n        \\n        return preOrder(temp.left,temp1.right) && preOrder(temp.right,temp1.left);\\n        \\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || preOrder(root.left,root.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888798,
                "title": "python3-beautiful-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw the problem I thought about a problem I solved recently: https://leetcode.com/problems/same-tree/description/. I copied my solution from the isSameTree submission and started thinking how it can help me solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMoving from the isSameTree solution.\\nLet\\'s imagine we have 2 subtrees: left and right ones.\\nTo solve the problem we will have to compare:\\n- left node of the left subtree to the right node of the right subtree\\n- right node of the left subtree to the left node of the right subtree\\n- repeat recursively for the child nodes\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSameTreeReverse(root.left, root.right)\\n\\n    def isSameTreeReverse(self, p, q):\\n        if p is None and q is None:\\n            return True\\n\\n        if p and q and p.val == q.val:\\n            return self.isSameTreeReverse(p.left, q.right) and self.isSameTreeReverse(p.right, q.left)\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSameTreeReverse(root.left, root.right)\\n\\n    def isSameTreeReverse(self, p, q):\\n        if p is None and q is None:\\n            return True\\n\\n        if p and q and p.val == q.val:\\n            return self.isSameTreeReverse(p.left, q.right) and self.isSameTreeReverse(p.right, q.left)\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765179,
                "title": "easy-c",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596242,
                "title": "c-fastest-recursive-o-n-easy-to-understand",
                "content": "**please upvote **\\n```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode* lroot, TreeNode* rroot){\\n        if (!lroot && !rroot) return true;\\n        else if (lroot && rroot){\\n            bool c = (lroot->val==rroot->val);\\n            if (c){\\n                bool a = solve(lroot->left, rroot->right);\\n                bool b = solve(lroot->right, rroot->left);\\n                return (a && b);\\n            }\\n            else return false;\\n        }\\n        else return false;\\n    }\\n \\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return solve(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode* lroot, TreeNode* rroot){\\n        if (!lroot && !rroot) return true;\\n        else if (lroot && rroot){\\n            bool c = (lroot->val==rroot->val);\\n            if (c){\\n                bool a = solve(lroot->left, rroot->right);\\n                bool b = solve(lroot->right, rroot->left);\\n                return (a && b);\\n            }\\n            else return false;\\n        }\\n        else return false;\\n    }\\n \\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return solve(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586852,
                "title": "python3-iterative-recursive-bfs-intuitive-neat",
                "content": "Iterative\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        L, R = [root], [root]\\n        while L or R:\\n            l, r = L.pop(), R.pop()\\n            if not (l or r):\\n                continue\\n            elif not (l and r):\\n                return False\\n            elif (l.val != r.val):\\n                return False\\n            L.append(l.right) \\n            L.append(l.left)\\n            R.append(r.left) \\n            R.append(r.right)\\n        return True\\n```\\nRecursive\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isSym(n1 = root, n2 = root):\\n            if not (n1 or n2):\\n                return True\\n            elif not (n1 and n2):\\n                return False\\n            elif n1.val != n2.val:\\n                return False\\n            return isSym(n1.left, n2.right) and isSym(n1.right, n2.left)\\n        return isSym()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        L, R = [root], [root]\\n        while L or R:\\n            l, r = L.pop(), R.pop()\\n            if not (l or r):\\n                continue\\n            elif not (l and r):\\n                return False\\n            elif (l.val != r.val):\\n                return False\\n            L.append(l.right) \\n            L.append(l.left)\\n            R.append(r.left) \\n            R.append(r.right)\\n        return True\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isSym(n1 = root, n2 = root):\\n            if not (n1 or n2):\\n                return True\\n            elif not (n1 and n2):\\n                return False\\n            elif n1.val != n2.val:\\n                return False\\n            return isSym(n1.left, n2.right) and isSym(n1.right, n2.left)\\n        return isSym()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498426,
                "title": "c-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //for symmetricity preorder and postorder should be same\\n    \\n    bool trav(TreeNode* root1, TreeNode* root2){\\n\\n        if(root1==NULL and root2==NULL)\\n            return 1;\\n        if( (root1!=NULL and root2==NULL) or (root1==NULL and root2!=NULL) )\\n            return 0;\\n        if(root1->val != root2->val)\\n            return 0;\\n        \\n        int side1 = trav(root1->left,root2->right);\\n        int side2 = trav(root1->right, root2->left);\\n        \\n        return side1&&side2; \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL)\\n            return 1;\\n        \\n        return trav(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //for symmetricity preorder and postorder should be same\\n    \\n    bool trav(TreeNode* root1, TreeNode* root2){\\n\\n        if(root1==NULL and root2==NULL)\\n            return 1;\\n        if( (root1!=NULL and root2==NULL) or (root1==NULL and root2!=NULL) )\\n            return 0;\\n        if(root1->val != root2->val)\\n            return 0;\\n        \\n        int side1 = trav(root1->left,root2->right);\\n        int side2 = trav(root1->right, root2->left);\\n        \\n        return side1&&side2; \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL)\\n            return 1;\\n        \\n        return trav(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625565,
                "title": "python-iterative-recursive",
                "content": "recursive\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tdef helper(l, r):\\n\\t\\t\\t\\tif not l and not r:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif l and r and l.val == r.val:\\n\\t\\t\\t\\t\\treturn helper(l.left, r.right) and helper(l.right, r.left)\\n\\n\\t\\t\\treturn helper(root, root)\\n\\t\\t\\t\\niterative\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tqueue = [(root, root)]\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tl, r = queue.pop(0)\\n\\t\\t\\t\\tif l is None and r is None:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tif l is None or r is None:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif l.val == r.val:\\n\\t\\t\\t\\t\\tqueue.append((l.left, r.right))\\n\\t\\t\\t\\t\\tqueue.append((l.right, r.left))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "recursive\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tdef helper(l, r):\\n\\t\\t\\t\\tif not l and not r:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif l and r and l.val == r.val:\\n\\t\\t\\t\\t\\treturn helper(l.left, r.right) and helper(l.right, r.left)\\n\\n\\t\\t\\treturn helper(root, root)\\n\\t\\t\\t\\niterative\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tqueue = [(root, root)]\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tl, r = queue.pop(0)\\n\\t\\t\\t\\tif l is None and r is None:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tif l is None or r is None:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif l.val == r.val:\\n\\t\\t\\t\\t\\tqueue.append((l.left, r.right))\\n\\t\\t\\t\\t\\tqueue.append((l.right, r.left))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 1474761,
                "title": "recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)",
                "codeTag": "Java"
            },
            {
                "id": 1283321,
                "title": "simple-c-recursive-and-iterative-solutions",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// M-1 : Recursive TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool mirror(TreeNode* node1, TreeNode* node2)\\n    {\\n        if(node1 == NULL && node2 == NULL) return true;\\n        if(node1 == NULL || node2 == NULL) return false;\\n        return node1->val == node2->val && mirror(node1->left, node2->right) && mirror(node1->right, node2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return mirror(root, root);\\n    }\\n};\\n// M-2 : Iterative TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root); q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* n1 = q.front(); q.pop();\\n            TreeNode* n2 = q.front(); q.pop();\\n            if(n1 == NULL && n2 == NULL) continue;\\n            if(n1 == NULL || n2 == NULL) return false;\\n            if(n1->val != n2->val) return false;\\n            q.push(n1->left);\\n            q.push(n2->right);\\n            q.push(n1->right);\\n            q.push(n2->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// M-1 : Recursive TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool mirror(TreeNode* node1, TreeNode* node2)\\n    {\\n        if(node1 == NULL && node2 == NULL) return true;\\n        if(node1 == NULL || node2 == NULL) return false;\\n        return node1->val == node2->val && mirror(node1->left, node2->right) && mirror(node1->right, node2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return mirror(root, root);\\n    }\\n};\\n// M-2 : Iterative TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root); q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* n1 = q.front(); q.pop();\\n            TreeNode* n2 = q.front(); q.pop();\\n            if(n1 == NULL && n2 == NULL) continue;\\n            if(n1 == NULL || n2 == NULL) return false;\\n            if(n1->val != n2->val) return false;\\n            q.push(n1->left);\\n            q.push(n2->right);\\n            q.push(n1->right);\\n            q.push(n2->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917388,
                "title": "c-recursive-76ms-faster-than-100",
                "content": "Runtime: 76 ms, faster than 100.00% of C# online submissions for Symmetric Tree.\\nMemory Usage: 25.7 MB, less than 50.29% of C# online submissions for Symmetric Tree.\\n```\\npublic class Solution {\\n    public bool IsSymmetric(TreeNode root) => CheckSymetry(root?.left, root?.right);\\n    \\n    private bool CheckSymetry(TreeNode left, TreeNode right)\\n    {\\n        if(left == null || right == null)\\n            return left?.val == right?.val;\\n        if(left.val != right.val)\\n            return false;\\n\\n        return CheckSymetry(left.left, right.right) && CheckSymetry(left.right, right.left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSymmetric(TreeNode root) => CheckSymetry(root?.left, root?.right);\\n    \\n    private bool CheckSymetry(TreeNode left, TreeNode right)\\n    {\\n        if(left == null || right == null)\\n            return left?.val == right?.val;\\n        if(left.val != right.val)\\n            return false;\\n\\n        return CheckSymetry(left.left, right.right) && CheckSymetry(left.right, right.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858855,
                "title": "c-bfs-palindrome-check-dfs-and-0ms",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Symmetric Tree.\\nMemory Usage: 16.7 MB, less than 21.66% of C++ online submissions for Symmetric Tree.**  \\n\\n**BFS**\\n```\\nclass Solution {\\npublic: \\n    bool isPalindrome(vector<int> &nums) { \\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i < j) { \\n            if(nums[i] != nums[j]) { \\n                return false;\\n            }  \\n            i++; \\n            j--;\\n        } \\n        return true;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n        if(root == NULL || (root->left == NULL && root->right == NULL)) { \\n            return true;\\n        } \\n        queue<TreeNode *> q; \\n        q.push(root); \\n        while(!q.empty()) {  \\n             vector<int> auxiliary; \\n             int n = q.size(); \\n             for(int i = 0; i < n; i++) { \\n                if(q.front()){ \\n                    q.push(q.front()->left); \\n                    q.push(q.front()->right);   \\n                    auxiliary.push_back(q.front()->val);\\n\\n                } \\n                else{ \\n                    auxiliary.push_back(-1);\\n                }  \\n                q.pop();  \\n                 \\n             }\\n             if(!isPalindrome(auxiliary)) { \\n                return false;\\n             }\\n        }\\n         return true;\\n    }\\n};\\n```  \\n\\n**DFS** \\n```\\nclass Solution {\\npublic: \\n    bool checkMirror(TreeNode *ldt,TreeNode *rdt) { \\n        if(!ldt && !rdt) return true; \\n        \\n        if((!ldt && rdt) || (!rdt && ldt)) return false;  \\n        \\n        return checkMirror(ldt->left,rdt->right) && checkMirror(ldt->right,rdt->left) && ldt->val == rdt->val;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n     \\n        if(!root) return true; \\n    \\n        return checkMirror(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPalindrome(vector<int> &nums) { \\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i < j) { \\n            if(nums[i] != nums[j]) { \\n                return false;\\n            }  \\n            i++; \\n            j--;\\n        } \\n        return true;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n        if(root == NULL || (root->left == NULL && root->right == NULL)) { \\n            return true;\\n        } \\n        queue<TreeNode *> q; \\n        q.push(root); \\n        while(!q.empty()) {  \\n             vector<int> auxiliary; \\n             int n = q.size(); \\n             for(int i = 0; i < n; i++) { \\n                if(q.front()){ \\n                    q.push(q.front()->left); \\n                    q.push(q.front()->right);   \\n                    auxiliary.push_back(q.front()->val);\\n\\n                } \\n                else{ \\n                    auxiliary.push_back(-1);\\n                }  \\n                q.pop();  \\n                 \\n             }\\n             if(!isPalindrome(auxiliary)) { \\n                return false;\\n             }\\n        }\\n         return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    bool checkMirror(TreeNode *ldt,TreeNode *rdt) { \\n        if(!ldt && !rdt) return true; \\n        \\n        if((!ldt && rdt) || (!rdt && ldt)) return false;  \\n        \\n        return checkMirror(ldt->left,rdt->right) && checkMirror(ldt->right,rdt->left) && ldt->val == rdt->val;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n     \\n        if(!root) return true; \\n    \\n        return checkMirror(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812630,
                "title": "javascript-solution-recursive-iterative-approach",
                "content": "**Recursive Approach**\\n\\n```\\nvar isSymmetric = function(root) {\\n    return isMirror(root, root);\\n    \\n    function isMirror(node1, node2) {\\n        // edge case\\n        if (node1 == null && node2 == null) return true;\\n        if (node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n**Iterative Approach**\\n\\n```\\nvar isSymmetric = function(root) {\\n    const queue = [];\\n    \\n    queue.push(root, root);\\n    \\n    while (queue.length > 0) {\\n        const node1 = queue.shift();\\n        const node2 = queue.shift();\\n        \\n        if (node1 == null && node2 == null) continue;\\n        if (node1 == null || node2 == null) return false;\\n        if (node1.val != node2.val) return false;\\n        \\n        queue.push(node1.left, node2.right);            \\n        queue.push(node1.right, node2.left);\\n    }\\n    \\n    return true;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    return isMirror(root, root);\\n    \\n    function isMirror(node1, node2) {\\n        // edge case\\n        if (node1 == null && node2 == null) return true;\\n        if (node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    const queue = [];\\n    \\n    queue.push(root, root);\\n    \\n    while (queue.length > 0) {\\n        const node1 = queue.shift();\\n        const node2 = queue.shift();\\n        \\n        if (node1 == null && node2 == null) continue;\\n        if (node1 == null || node2 == null) return false;\\n        if (node1.val != node2.val) return false;\\n        \\n        queue.push(node1.left, node2.right);            \\n        queue.push(node1.right, node2.left);\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758753,
                "title": "javascript-dfs-recursive-solution",
                "content": "Inspirted by @jeantimex [solution](https://leetcode.com/problems/symmetric-tree/discuss/33073/JavaScript-recursive-and-iterative-solutions).\\n```\\nvar isSymmetric = function(root) {\\n  if(!root) return true;\\n  return dfs(root.left, root.right);\\n};\\n\\nfunction dfs(s, t){\\n  if(!s && !t) return true;\\n  if(!s || !t) return false;\\n  if(s.val !== t.val) return false;\\n  \\n  return dfs(s.left, t.right) && dfs(s.right, t.left)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n  if(!root) return true;\\n  return dfs(root.left, root.right);\\n};\\n\\nfunction dfs(s, t){\\n  if(!s && !t) return true;\\n  if(!s || !t) return false;\\n  if(s.val !== t.val) return false;\\n  \\n  return dfs(s.left, t.right) && dfs(s.right, t.left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688627,
                "title": "go-recursive",
                "content": "```go\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    return visit(root.Left, root.Right)\\n}\\n\\nfunc visit(root1 *TreeNode, root2 *TreeNode) bool {\\n    if root1 == nil && root2 == nil {\\n        return true\\n    }\\n    \\n    if root1 == nil || root2 == nil {\\n        return false\\n    }\\n    \\n    if root1.Val != root2.Val {\\n        return false\\n    }\\n    \\n    return visit(root1.Right, root2.Left) && visit(root1.Left, root2.Right)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    return visit(root.Left, root.Right)\\n}\\n\\nfunc visit(root1 *TreeNode, root2 *TreeNode) bool {\\n    if root1 == nil && root2 == nil {\\n        return true\\n    }\\n    \\n    if root1 == nil || root2 == nil {\\n        return false\\n    }\\n    \\n    if root1.Val != root2.Val {\\n        return false\\n    }\\n    \\n    return visit(root1.Right, root2.Left) && visit(root1.Left, root2.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637497,
                "title": "java-python-iterative-recursive",
                "content": "```\\npublic boolean isSymmetric(TreeNode root) {\\n        if (root == null) return true;\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root.left);\\n        st.push(root.right);\\n        while (!st.isEmpty()) {\\n            TreeNode left = st.pop(), right = st.pop();\\n            if (left == null && right == null) continue;\\n            if (left == null || right == null || left.val != right.val) return false;\\n            st.push(left.right);\\n            st.push(right.left);\\n            st.push(right.right);\\n            st.push(left.left);\\n        }\\n        return true;\\n    }\\n```\\n\\n```\\ndef isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def helper(left,right):\\n            if right == None or left  ==  None:\\n                return right  ==  None and left ==  None\\n            return right.val == left.val and helper(left.left,right.right) and helper(left.right, right.left)\\n        \\n        if root == None:\\n            return True\\n        return helper(root.left, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSymmetric(TreeNode root) {\\n        if (root == null) return true;\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root.left);\\n        st.push(root.right);\\n        while (!st.isEmpty()) {\\n            TreeNode left = st.pop(), right = st.pop();\\n            if (left == null && right == null) continue;\\n            if (left == null || right == null || left.val != right.val) return false;\\n            st.push(left.right);\\n            st.push(right.left);\\n            st.push(right.right);\\n            st.push(left.left);\\n        }\\n        return true;\\n    }\\n```\n```\\ndef isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def helper(left,right):\\n            if right == None or left  ==  None:\\n                return right  ==  None and left ==  None\\n            return right.val == left.val and helper(left.left,right.right) and helper(left.right, right.left)\\n        \\n        if root == None:\\n            return True\\n        return helper(root.left, root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343964,
                "title": "rust-0ms",
                "content": "```\\n// https://github.com/wangyuntao/leetcode-rs\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        type Rn = Rc<RefCell<TreeNode>>;\\n\\n        fn f(p: Option<&Rn>, q: Option<&Rn>) -> bool {\\n            match (p, q) {\\n                (None, None) => true,\\n                (Some(p), Some(q)) => {\\n                    let p = p.borrow();\\n                    let q = q.borrow();\\n                    p.val == q.val\\n                        && f(p.left.as_ref(), q.right.as_ref())\\n                        && f(p.right.as_ref(), q.left.as_ref())\\n                }\\n                _ => false,\\n            }\\n        }\\n\\n        match root {\\n            None => true,\\n            Some(n) => {\\n                let n = n.borrow();\\n                f(n.left.as_ref(), n.right.as_ref())\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// https://github.com/wangyuntao/leetcode-rs\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        type Rn = Rc<RefCell<TreeNode>>;\\n\\n        fn f(p: Option<&Rn>, q: Option<&Rn>) -> bool {\\n            match (p, q) {\\n                (None, None) => true,\\n                (Some(p), Some(q)) => {\\n                    let p = p.borrow();\\n                    let q = q.borrow();\\n                    p.val == q.val\\n                        && f(p.left.as_ref(), q.right.as_ref())\\n                        && f(p.right.as_ref(), q.left.as_ref())\\n                }\\n                _ => false,\\n            }\\n        }\\n\\n        match root {\\n            None => true,\\n            Some(n) => {\\n                let n = n.borrow();\\n                f(n.left.as_ref(), n.right.as_ref())\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341522,
                "title": "js-dfs-solution",
                "content": "The key is to recognize the tree as two different tree. For the first tree, we go left -> right. For the second, we go right -> left.\\n\\n```\\nvar isSymmetric = function(root) {\\n    return helper(root, root)\\n};\\n\\nconst helper = function(p, q) {\\n    if (p == null && q == null)\\n        return true\\n    if (p == null || q == null)\\n        return false\\n    return p.val == q.val && helper(p.left, q.right) && helper(p.right, q.left)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    return helper(root, root)\\n};\\n\\nconst helper = function(p, q) {\\n    if (p == null && q == null)\\n        return true\\n    if (p == null || q == null)\\n        return false\\n    return p.val == q.val && helper(p.left, q.right) && helper(p.right, q.left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245871,
                "title": "simple-iterative-python-solution",
                "content": "Simple iterative Python solution.\\n\\n```       \\n        if not root:\\n            return True\\n        \\n        stack = [(root.left, root.right)]\\n     \\n        while stack:\\n            nodes = stack.pop()\\n\\t\\t\\t\\n            l, r = nodes\\n\\n            if l is None and r is None: \\n                continue  \\n            if l is None or r is None:\\n                return False\\n\\n            if l.val != r.val:  \\n                return False\\n\\n            stack.append((l.right,r.left))\\n            stack.append((l.left,r.right))\\n                \\n        return True\\n\\t\\t```",
                "solutionTags": [],
                "code": "```       \\n        if not root:\\n            return True\\n        \\n        stack = [(root.left, root.right)]\\n     \\n        while stack:\\n            nodes = stack.pop()\\n\\t\\t\\t\\n            l, r = nodes\\n\\n            if l is None and r is None: \\n                continue  \\n            if l is None or r is None:\\n                return False\\n\\n            if l.val != r.val:  \\n                return False\\n\\n            stack.append((l.right,r.left))\\n            stack.append((l.left,r.right))\\n                \\n        return True\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 33052,
                "title": "recursive-python-solution",
                "content": "Recursive Python Solution\\n```\\nclass Solution(object):\\n    \\n    def compare(self,rootleft,rootright):\\n        if rootleft == None or rootright == None:\\n            return rootleft==rootright\\n        return rootleft.val == rootright.val and self.compare(rootleft.left,rootright.right) and self.compare(rootleft.right,rootright.left)\\n    \\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.compare(root.left,root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def compare(self,rootleft,rootright):\\n        if rootleft == None or rootright == None:\\n            return rootleft==rootright\\n        return rootleft.val == rootright.val and self.compare(rootleft.left,rootright.right) and self.compare(rootleft.right,rootright.left)\\n    \\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.compare(root.left,root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33234,
                "title": "java-1ms-recursive-solution-and-2ms-iterative-solution",
                "content": "Recursive:\\n\\n        public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (root.left != null && root.right != null) {\\n    \\t\\t\\tif (root.left.val != root.right.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn isSymmetric(root.left, root.right);\\n    \\t}\\n    \\t\\n    \\tprivate boolean isSymmetric(TreeNode t1, TreeNode t2) {\\n    \\t\\tif (t1 == null && t2 == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (t1 == null || t2 == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tboolean isLeftSymmetric = isSymmetric(t1.left, t2.right);\\n    \\t\\tboolean isRightSymmetric = isSymmetric(t1.right, t2.left);\\n    \\t\\treturn (t1.val == t2.val) && isLeftSymmetric && isRightSymmetric;\\n    \\t}\\n\\nIterative:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tQueue<TreeNode> left = new LinkedList<>();\\n    \\t\\tQueue<TreeNode> right = new LinkedList<>();\\n    \\t\\tleft.add(root.left);\\n    \\t\\tright.add(root.right);\\n    \\t\\twhile(!left.isEmpty() && !right.isEmpty()) {\\n    \\t\\t\\tTreeNode l = left.poll();\\n    \\t\\t\\tTreeNode r = right.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tif (l == null && r == null)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (l == null || r == null)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tif (l.val != r.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.left);\\n    \\t\\t\\tright.add(r.right);\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.right);\\n    \\t\\t\\tright.add(r.left);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (left.isEmpty() && right.isEmpty())\\n    \\t\\t\\treturn true;\\n    \\t\\telse \\n    \\t\\t\\treturn false;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n        public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (root.left != null && root.right != null) {\\n    \\t\\t\\tif (root.left.val != root.right.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn isSymmetric(root.left, root.right);\\n    \\t}\\n    \\t\\n    \\tprivate boolean isSymmetric(TreeNode t1, TreeNode t2) {\\n    \\t\\tif (t1 == null && t2 == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (t1 == null || t2 == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tboolean isLeftSymmetric = isSymmetric(t1.left, t2.right);\\n    \\t\\tboolean isRightSymmetric = isSymmetric(t1.right, t2.left);\\n    \\t\\treturn (t1.val == t2.val) && isLeftSymmetric && isRightSymmetric;\\n    \\t}\\n\\nIterative:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tQueue<TreeNode> left = new LinkedList<>();\\n    \\t\\tQueue<TreeNode> right = new LinkedList<>();\\n    \\t\\tleft.add(root.left);\\n    \\t\\tright.add(root.right);\\n    \\t\\twhile(!left.isEmpty() && !right.isEmpty()) {\\n    \\t\\t\\tTreeNode l = left.poll();\\n    \\t\\t\\tTreeNode r = right.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tif (l == null && r == null)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (l == null || r == null)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tif (l.val != r.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.left);\\n    \\t\\t\\tright.add(r.right);\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.right);\\n    \\t\\t\\tright.add(r.left);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (left.isEmpty() && right.isEmpty())\\n    \\t\\t\\treturn true;\\n    \\t\\telse \\n    \\t\\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 33304,
                "title": "java-1m-simple-solution-with-recursion",
                "content": "public class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null) return true;\\n        return isSymmetric(root.left, root.right);\\n    }\\n    \\n    public boolean isSymmetric(TreeNode node1 , TreeNode node2){\\n        if(node1 == null && node2 == null) return true;\\n        if(node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val\\n               &&isSymmetric(node1.left, node2.right)\\n               && isSymmetric(node1.right,node2.left);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null) return true;\\n        return isSymmetric(root.left, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 33337,
                "title": "0ms-c-language-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     struct TreeNode *left;\\n     *     struct TreeNode *right;\\n     * };\\n     */\\n    \\n    bool checkNodes(struct TreeNode* a, struct TreeNode* b)\\n    {\\n        if(a == NULL && b == NULL)\\n        {\\n            return true;\\n        }\\n        \\n        if(a == NULL || b == NULL)\\n        {\\n            return false;\\n        }\\n        if(a->val != b->val)\\n        {\\n            return false;\\n        }\\n        return checkNodes(a->left, b->right) && checkNodes(a->right, b->left);\\n    }\\n    bool isSymmetric(struct TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return true;\\n        }\\n        return checkNodes(root->left, root->right);\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     struct TreeNode *left;\\n     *     struct TreeNode *right;\\n     * };\\n     */\\n    \\n    bool checkNodes(struct TreeNode* a, struct TreeNode* b)\\n    {\\n        if(a == NULL && b == NULL)\\n        {\\n            return true;\\n        }\\n        \\n        if(a == NULL || b == NULL)\\n        {\\n            return false;\\n        }\\n        if(a->val != b->val)\\n        {\\n            return false;\\n        }\\n        return checkNodes(a->left, b->right) && checkNodes(a->right, b->left);\\n    }\\n    bool isSymmetric(struct TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return true;\\n        }\\n        return checkNodes(root->left, root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33390,
                "title": "share-my-accepted-2-line-simple-recurion-solution-java",
                "content": "Recursively compare left.left with right.right and left.right, right.left.\\n  \\n    public static boolean isSymmetric(TreeNode root) {\\n    \\treturn isSymmetric(root, root);\\n    }\\n    \\n    public static boolean isSymmetric(TreeNode left, TreeNode right) {\\n        if(left == null || right == null) return left == right;\\n        return (left.val == right.val) && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Recursively compare left.left with right.right and left.right, right.left.\\n  \\n    public static boolean isSymmetric(TreeNode root) {\\n    \\treturn isSymmetric(root, root);\\n    }\\n    \\n    public static boolean isSymmetric(TreeNode left, TreeNode right) {\\n        if(left == null || right == null) return left == right;\\n        return (left.val == right.val) && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3291861,
                "title": "fast-explained-solution-c",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291856,
                "title": "fast-explained-solution-java-beats-100-submissions",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n**This JAVA solution beats 100% of all submissions:**\\n\\n``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291174,
                "title": "top-1-rare-approach",
                "content": "# ***`Ladies and gentlemen, distinguished guests, and esteemed colleagues, it is my utmost pleasure to address you today.`***\\n\\n*As we gather here,* ***I feel honored to share my passion for problem-solving and collaboration with individuals such as yourselves.*** \\n*Through my extensive experience and expertise,* ***I have learned that the key to success lies in forming connections with like-minded professionals who share a common vision for growth and development.***\\n#\\n*As we all know,* **[LinkedIn](https://www.linkedin.com/in/cucerdariancatalin/)** ***provides us*** *with a* ***unique*** ***opportunity to expand our networks*** *and form* ***meaningful connections*** *with individuals from all walks of life*.\\n`By connecting with me,` *you will have the chance to collaborate on complex* ***challenges,*** *share ***innovative*** ideas,* *and ***together,*** achieve professional and personal* ***[growth]().***\\n\\n`No matter your background or level of experience`, I ***[invite]()*** you to ***join me*** on this ***journey*** towards excellence. By ***working together*** and ***leveraging*** our diverse ***perspectives***,* `we can achieve what was once thought impossible.`\\n\\n*So, let us not hesitate to take the ***first step*** `towards a brighter future`. ***Reach out to me today***, and let us `START a conversation that will take us to new heights!`*\\n\\n# [\\uD83D\\uDE4F\\uD83C\\uDFFB Let\\'s connect & **SHARE** network on **LinkedIn**](https://www.linkedin.com/in/cucerdariancatalin/)\\n\\n# [\\uD83E\\uDDF3 Be part of **The Money Team\\xAE (TMT)**](https://www.linkedin.com/newsletters/7034097027214946304/)\\n\\n# [\\u23F3 Sharing Knowledge on **Medium**](https://medium.com/@cucerdariancatalin)\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(!root) return true;\\n    return symmetryChk(root.left , root.right);\\n};\\n    \\nconst symmetryChk = function (leftNode , rightNode) {\\n    if (!leftNode && !rightNode) return true;\\n    if(!leftNode || !rightNode) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n\\n    return (symmetryChk(leftNode.left , rightNode.right) && symmetryChk(leftNode.right , rightNode.left));\\n};\\n\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(!root) return true;\\n    return symmetryChk(root.left , root.right);\\n};\\n    \\nconst symmetryChk = function (leftNode , rightNode) {\\n    if (!leftNode && !rightNode) return true;\\n    if(!leftNode || !rightNode) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n\\n    return (symmetryChk(leftNode.left , rightNode.right) && symmetryChk(leftNode.right , rightNode.left));\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3291170,
                "title": "top-1-rare-approach",
                "content": "# ***`Ladies and gentlemen, distinguished guests, and esteemed colleagues, it is my utmost pleasure to address you today.`***\\n\\n*As we gather here,* ***I feel honored to share my passion for problem-solving and collaboration with individuals such as yourselves.*** \\n*Through my extensive experience and expertise,* ***I have learned that the key to success lies in forming connections with like-minded professionals who share a common vision for growth and development.***\\n#\\n*As we all know,* **[LinkedIn](https://www.linkedin.com/in/cucerdariancatalin/)** ***provides us*** *with a* ***unique*** ***opportunity to expand our networks*** *and form* ***meaningful connections*** *with individuals from all walks of life*.\\n`By connecting with me,` *you will have the chance to collaborate on complex* ***challenges,*** *share ***innovative*** ideas,* *and ***together,*** achieve professional and personal* ***[growth]().***\\n\\n`No matter your background or level of experience`, I ***[invite]()*** you to ***join me*** on this ***journey*** towards excellence. By ***working together*** and ***leveraging*** our diverse ***perspectives***,* `we can achieve what was once thought impossible.`\\n\\n*So, let us not hesitate to take the ***first step*** `towards a brighter future`. ***Reach out to me today***, and let us `START a conversation that will take us to new heights!`*\\n\\n# [\\uD83D\\uDE4F\\uD83C\\uDFFB Let\\'s connect & **SHARE** network on **LinkedIn**](https://www.linkedin.com/in/cucerdariancatalin/)\\n\\n# [\\uD83E\\uDDF3 Be part of **The Money Team\\xAE (TMT)**](https://www.linkedin.com/newsletters/7034097027214946304/)\\n\\n# [\\u23F3 Sharing Knowledge on **Medium**](https://medium.com/@cucerdariancatalin)\\n\\n\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290629,
                "title": "fast-easy-solution-java-c-explained-with-illustrations",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n**This JAVA solution beats 100% of all submissions:**\\n\\n``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```\\n\\nNo worries, I also got **C++** for you guys too:\\n\\nApprently this is the same code as the JAVA one but doesn\\'t beat 100% of all submissions - can you **tell why** in the comments?\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225162,
                "title": "best-o-n-solution",
                "content": "# Approach\\nPreorder traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSame(root->left, root->right);\\n    }\\nprivate:\\n    bool isSame(TreeNode* p, TreeNode* q) {\\n        if (!p && !q)\\n            return true;\\n        if (!p || !q)\\n            return false;   \\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSame(p->left, q->right);  \\n        bool r = isSame(p->right, q->left);  \\n        if (!l || !r)\\n            return false;\\n        return true;           \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSame(root->left, root->right);\\n    }\\nprivate:\\n    bool isSame(TreeNode* p, TreeNode* q) {\\n        if (!p && !q)\\n            return true;\\n        if (!p || !q)\\n            return false;   \\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSame(p->left, q->right);  \\n        bool r = isSame(p->right, q->left);  \\n        if (!l || !r)\\n            return false;\\n        return true;           \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859615,
                "title": "c-recursion-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode * left, TreeNode * right){\\n        if(right == NULL && left == NULL){\\n            return true;\\n        }\\n        if(left == NULL && right != NULL){\\n            return false;\\n        }\\n        if(left != NULL && right == NULL){\\n            return false;\\n        }\\n        if(right->val != left->val){\\n                return false;\\n        }\\n        \\n        return check(left->left,right->right) && check(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL){\\n            return true;\\n        }\\n        return check(root,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode * left, TreeNode * right){\\n        if(right == NULL && left == NULL){\\n            return true;\\n        }\\n        if(left == NULL && right != NULL){\\n            return false;\\n        }\\n        if(left != NULL && right == NULL){\\n            return false;\\n        }\\n        if(right->val != left->val){\\n                return false;\\n        }\\n        \\n        return check(left->left,right->right) && check(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL){\\n            return true;\\n        }\\n        return check(root,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812680,
                "title": "bfs-for-children",
                "content": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710270,
                "title": "c-1-line-answer-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* root1, TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL){\\n            return true;\\n        }\\n        if(root1 && root2 && root1->val == root2->val)\\n           return isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n        \\n        return false;\\n    }\\n    \\n\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* root1, TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL){\\n            return true;\\n        }\\n        if(root1 && root2 && root1->val == root2->val)\\n           return isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n        \\n        return false;\\n    }\\n    \\n\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674497,
                "title": "2-great-python-solutions",
                "content": "**DFS Recursive Solution**\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tdef checkSymmetry(lft, rght): # helper method\\n\\t\\tif lft and rght and lft.val == rght.val: # if both sides exist and have equal value\\n\\t\\t\\t# the left side on the left should equal the right side on the right\\n\\t\\t\\t# the right side on the left should equal the left side on the right\\n\\t\\t\\treturn checkSymmetry(lft.left,rght.right) and checkSymmetry(lft.right,rght.left) \\n\\t\\treturn not lft and not rght # if neither side exists, it is symmetric; if one side exists, it is not\\n\\treturn checkSymmetry(root.left, root.right) # check the left and the right are symmetric\\n```\\nThe key here is that the left side of the left subtree of ```root``` should be symmetric to the right side of the right subtree of ```root``` and the right side of the left subtree of ```root``` should be symmetric to the left side of the right subtree of ```root```. Using this relationship we can create a simple DFS recursive solution.\\n\\n**BFS Iterative Solution**\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tleftSide = collections.deque([root.left]) # bfs queue for the left side\\n\\trightSide = collections.deque([root.right]) # bfs queue for the right side\\n\\twhile leftSide and rightSide: # while both exist\\n\\t\\tleft = leftSide.popleft() # node on the left side\\n\\t\\tright = rightSide.popleft() # node on the right side\\n\\t\\tif left and right: # if both nodes exist\\n\\t\\t\\tif not left.val == right.val: # make sure they have the same value\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t# append the nodes in the next level in the opposite order to check for symmetry\\n\\t\\t\\tleftSide.append(left.left) \\n\\t\\t\\tleftSide.append(left.right)\\n\\t\\t\\trightSide.append(right.right)\\n\\t\\t\\trightSide.append(right.left)\\n\\t\\telif left or right: # if only one side has a node, it is not symmetric\\n\\t\\t\\treturn False\\n\\treturn not leftSide and not rightSide # make sure neither side has any nodes remaining\\n```\\nIn this solution we essentially find the level-order traversal of the left subtree and right subtree of ```root``` but we traverse them in opposite directions. If the traversals ever differ then we know that the tree is not symmetric, so we return ```False```. If we never encounter a difference, and neither side has nodes left, we return ```True```.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tdef checkSymmetry(lft, rght): # helper method\\n\\t\\tif lft and rght and lft.val == rght.val: # if both sides exist and have equal value\\n\\t\\t\\t# the left side on the left should equal the right side on the right\\n\\t\\t\\t# the right side on the left should equal the left side on the right\\n\\t\\t\\treturn checkSymmetry(lft.left,rght.right) and checkSymmetry(lft.right,rght.left) \\n\\t\\treturn not lft and not rght # if neither side exists, it is symmetric; if one side exists, it is not\\n\\treturn checkSymmetry(root.left, root.right) # check the left and the right are symmetric\\n```\n```root```\n```root```\n```root```\n```root```\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tleftSide = collections.deque([root.left]) # bfs queue for the left side\\n\\trightSide = collections.deque([root.right]) # bfs queue for the right side\\n\\twhile leftSide and rightSide: # while both exist\\n\\t\\tleft = leftSide.popleft() # node on the left side\\n\\t\\tright = rightSide.popleft() # node on the right side\\n\\t\\tif left and right: # if both nodes exist\\n\\t\\t\\tif not left.val == right.val: # make sure they have the same value\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t# append the nodes in the next level in the opposite order to check for symmetry\\n\\t\\t\\tleftSide.append(left.left) \\n\\t\\t\\tleftSide.append(left.right)\\n\\t\\t\\trightSide.append(right.right)\\n\\t\\t\\trightSide.append(right.left)\\n\\t\\telif left or right: # if only one side has a node, it is not symmetric\\n\\t\\t\\treturn False\\n\\treturn not leftSide and not rightSide # make sure neither side has any nodes remaining\\n```\n```root```\n```False```\n```True```",
                "codeTag": "Python3"
            },
            {
                "id": 2568119,
                "title": "97-80-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(node1, node2) {\\n    if(node2 === undefined) {\\n        node2 = node1.right;\\n        node1 = node1.left;\\n    }\\n    if (node1 === null && node2 === null) return true;  \\n    if (node1 === null || node2 === null || node1.val !== node2.val) return false;\\n    return isSymmetric(node1.left, node2.right) && isSymmetric(node1.right, node2.left);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(node1, node2) {\\n    if(node2 === undefined) {\\n        node2 = node1.right;\\n        node1 = node1.left;\\n    }\\n    if (node1 === null && node2 === null) return true;  \\n    if (node1 === null || node2 === null || node1.val !== node2.val) return false;\\n    return isSymmetric(node1.left, node2.right) && isSymmetric(node1.right, node2.left);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346923,
                "title": "c-solution-using-recursion-simple-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t//checking if the left subtree and right subtree are mirror images or not\\n    bool isMirror(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(root1==NULL && root2==NULL) //if both trees are empty\\n            return true;\\n        if(root1==NULL || root2==NULL) //if one of the trees is empty\\n            return false;\\n        return root1->val==root2->val && isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n    }\\n\\t\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root->left, root->right); //sending the left node and right node of the root to the isMirror function\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t//checking if the left subtree and right subtree are mirror images or not\\n    bool isMirror(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(root1==NULL && root2==NULL) //if both trees are empty\\n            return true;\\n        if(root1==NULL || root2==NULL) //if one of the trees is empty\\n            return false;\\n        return root1->val==root2->val && isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n    }\\n\\t\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root->left, root->right); //sending the left node and right node of the root to the isMirror function\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172540,
                "title": "python3-recursive-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    \\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if root==None:\\n            return True\\n        \\n        def getResult(left,right):\\n\\n            if left==None and right==None:\\n                return True\\n            if left==None or right==None or left.val != right.val:\\n                return False\\n\\n            return getResult(left.left,right.right) and getResult(left.right,right.left)\\n        \\n        return getResult(root.left,root.right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if root==None:\\n            return True\\n        \\n        def getResult(left,right):\\n\\n            if left==None and right==None:\\n                return True\\n            if left==None or right==None or left.val != right.val:\\n                return False\\n\\n            return getResult(left.left,right.right) and getResult(left.right,right.left)\\n        \\n        return getResult(root.left,root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008719,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic boolean isSymmetric(TreeNode root) {\\n    if(root==null)  return true;\\n    \\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    TreeNode left, right;\\n    if(root.left!=null){\\n        if(root.right==null) return false;\\n        stack.push(root.left);\\n        stack.push(root.right);\\n    }\\n    else if(root.right!=null){\\n        return false;\\n    }\\n        \\n    while(!stack.empty()){\\n        if(stack.size()%2!=0)   return false;\\n        right = stack.pop();\\n        left = stack.pop();\\n        if(right.val!=left.val) return false;\\n        \\n        if(left.left!=null){\\n            if(right.right==null)   return false;\\n            stack.push(left.left);\\n            stack.push(right.right);\\n        }\\n        else if(right.right!=null){\\n            return false;\\n        }\\n            \\n        if(left.right!=null){\\n            if(right.left==null)   return false;\\n            stack.push(left.right);\\n            stack.push(right.left);\\n        }\\n        else if(right.left!=null){\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun isSymmetric(root: TreeNode?): Boolean {\\n        if (root == null)\\n            return true\\n        return helper(root.left, root.right)\\n    }\\n    \\n    fun helper(root: TreeNode?, flip: TreeNode?): Boolean {\\n\\t\\t// Same but null\\n        if (root == null && flip == null)\\n            return true\\n        \\n\\t\\t// Only one is null. Easy out, but also prevents numerous null checks\\n        if (root == null || flip == null)\\n            return false\\n        \\n\\t\\t// Aren\\'t equal\\n        if (root.`val` != flip.`val`)\\n            return false\\n        \\n        return helper(root.left, flip.right) && helper(root.right, flip.left)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic boolean isSymmetric(TreeNode root) {\\n    if(root==null)  return true;\\n    \\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    TreeNode left, right;\\n    if(root.left!=null){\\n        if(root.right==null) return false;\\n        stack.push(root.left);\\n        stack.push(root.right);\\n    }\\n    else if(root.right!=null){\\n        return false;\\n    }\\n        \\n    while(!stack.empty()){\\n        if(stack.size()%2!=0)   return false;\\n        right = stack.pop();\\n        left = stack.pop();\\n        if(right.val!=left.val) return false;\\n        \\n        if(left.left!=null){\\n            if(right.right==null)   return false;\\n            stack.push(left.left);\\n            stack.push(right.right);\\n        }\\n        else if(right.right!=null){\\n            return false;\\n        }\\n            \\n        if(left.right!=null){\\n            if(right.left==null)   return false;\\n            stack.push(left.right);\\n            stack.push(right.left);\\n        }\\n        else if(right.left!=null){\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)\\n```\n```\\n```\n```\\n```\n```\\nar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun isSymmetric(root: TreeNode?): Boolean {\\n        if (root == null)\\n            return true\\n        return helper(root.left, root.right)\\n    }\\n    \\n    fun helper(root: TreeNode?, flip: TreeNode?): Boolean {\\n\\t\\t// Same but null\\n        if (root == null && flip == null)\\n            return true\\n        \\n\\t\\t// Only one is null. Easy out, but also prevents numerous null checks\\n        if (root == null || flip == null)\\n            return false\\n        \\n\\t\\t// Aren\\'t equal\\n        if (root.`val` != flip.`val`)\\n            return false\\n        \\n        return helper(root.left, flip.right) && helper(root.right, flip.left)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836696,
                "title": "c-2-approaches-recursive-iterative-o-n-time-easy-clean-code",
                "content": "**1. Recursive**\\n```\\nbool isSymmetric(TreeNode* l,TreeNode* r)\\n    {\\n        if(!l && !r)\\n            return 1;\\n        \\n        if(!l || !r || l->val!=r->val)\\n            return 0;\\n        \\n        return isSymmetric(l->left,r->right) && isSymmetric(l->right,r->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root)\\n            return 1;\\n        \\n        return isSymmetric(root->left,root->right);\\n    }\\n```\\n\\n**2. Iterative**\\n```\\nbool isSymmetric(TreeNode* root) {\\n        \\n        if(!root)\\n            return 1;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *l,*r;\\n            \\n            l=q.front();\\n            q.pop();\\n            \\n            r=q.front();\\n            q.pop();\\n            \\n            if(!l && !r)\\n                continue;\\n            \\n            if(!l || !r || l->val!=r->val)\\n                return 0;\\n            \\n            q.push(l->left);\\n            q.push(r->right);\\n            \\n            q.push(l->right);\\n            q.push(r->left);\\n        }\\n        return 1;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool isSymmetric(TreeNode* l,TreeNode* r)\\n    {\\n        if(!l && !r)\\n            return 1;\\n        \\n        if(!l || !r || l->val!=r->val)\\n            return 0;\\n        \\n        return isSymmetric(l->left,r->right) && isSymmetric(l->right,r->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root)\\n            return 1;\\n        \\n        return isSymmetric(root->left,root->right);\\n    }\\n```\n```\\nbool isSymmetric(TreeNode* root) {\\n        \\n        if(!root)\\n            return 1;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *l,*r;\\n            \\n            l=q.front();\\n            q.pop();\\n            \\n            r=q.front();\\n            q.pop();\\n            \\n            if(!l && !r)\\n                continue;\\n            \\n            if(!l || !r || l->val!=r->val)\\n                return 0;\\n            \\n            q.push(l->left);\\n            q.push(r->right);\\n            \\n            q.push(l->right);\\n            q.push(r->left);\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1780508,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 37 ms, faster than 65.77% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 14.1 MB, less than 61.59% of Python3 online submissions for Symmetric Tree.\\nclass Solution:\\n    def isSymmetric(self, root):\\n        return self.checkNodes(root.left, root.right)\\n\\n    def checkNodes(self, leftNode, rightNode):\\n        if leftNode == None and rightNode == None:\\n            result = True\\n        elif leftNode == None or rightNode == None:\\n            result = False\\n        else:\\n            if leftNode.val != rightNode.val:\\n                result = False\\n            else:\\n                result = self.checkNodes(leftNode.left, rightNode.right)\\n                if result:\\n                    result = self.checkNodes(leftNode.right, rightNode.left)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 37 ms, faster than 65.77% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 14.1 MB, less than 61.59% of Python3 online submissions for Symmetric Tree.\\nclass Solution:\\n    def isSymmetric(self, root):\\n        return self.checkNodes(root.left, root.right)\\n\\n    def checkNodes(self, leftNode, rightNode):\\n        if leftNode == None and rightNode == None:\\n            result = True\\n        elif leftNode == None or rightNode == None:\\n            result = False\\n        else:\\n            if leftNode.val != rightNode.val:\\n                result = False\\n            else:\\n                result = self.checkNodes(leftNode.left, rightNode.right)\\n                if result:\\n                    result = self.checkNodes(leftNode.right, rightNode.left)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774096,
                "title": "python-solution-with-clear-explanation-super-simple-faster-than-99-recursive-iterative",
                "content": "***For BFS problems, generally there are two approaches we can use, recursive and iterative ones.\\nSo we\\'ll talk about those two approaches in this post.***\\n\\n### **1. Recursively.**\\n\\n```\\n    def isSymmetric(self, root):\\n\\t\\n        # 1) recursively\\n        def same_tree(left, right):\\n            if (not left) and (not right):   # both None, good. Check other branches.\\n                continue\\n            elif (not left) or (not right):  # one is None and the other is not, not the same tree\\n                return False\\n            else:                            # both not None, check do a further check\\n                if (left.val != right.val):  # Different values stored, not the same tree\\n                    return False\\n                else:                        # Same values stored, good. \\n\\t\\t\\t\\t                             # Let\\'s check their child nodes\\n                    return same_tree(left.left, right.right) \\n                      and same_tree(left.right, right.left)\\n        \\n        if not root: return True\\n        return same_tree(root.left, root.right)\\n```\\n\\nFor the recusive approach, we need to **define a helper function** in most cases. \\nThat\\'s why I use the `same_tree` function here.\\nThen the work is basically just setting the conditions, which I described in details above in the code.\\n\\n**Performance:**\\n*Runtime: 11 ms, faster than 99.55% of Python online submissions for Symmetric Tree.\\nMemory Usage: 13.6 MB, less than 74.11% of Python online submissions for Symmetric Tree.*\\n\\n\\n### **2. Iteratively.**\\n\\n```\\n    def isSymmetric(self, root):\\n\\n        #2) Iteratively\\n        if not root:\\n            return True\\n        \\n        queue = collections.deque([(root.left, root.right)])\\n        while queue:\\n            left, right = queue.popleft()\\n            if (not left) and (not right):\\n                continue\\n            elif (not left) or (not right):\\n                return False\\n            else:\\n                if (left.val != right.val):\\n                    return False\\n                else:\\n                    queue.append((left.left, right.right))\\n                    queue.append((left.right, right.left))\\n        return True\\n```\\n\\nFor the iterative approach here, the main idea is that we **pair up the nodes that should have the same value**, and compare them and adding their childnodes as we looping through the whole tree.\\nNotice that we are using `collections.queue` here. `list` would work too, but `append()` and `pop()` for `collections.queue` is O(1) instead of O(n) for lists. \\nSo we are using queue here for better performance (especially when we are working on huge trees).\\nThe condition settings are the same as those in the recursive aproach, feel free to check it above in the first section.\\n\\n\\n***Hope you find this post helpful. Please upvote if you like it. Welcome for further discussions below!***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def isSymmetric(self, root):\\n\\t\\n        # 1) recursively\\n        def same_tree(left, right):\\n            if (not left) and (not right):   # both None, good. Check other branches.\\n                continue\\n            elif (not left) or (not right):  # one is None and the other is not, not the same tree\\n                return False\\n            else:                            # both not None, check do a further check\\n                if (left.val != right.val):  # Different values stored, not the same tree\\n                    return False\\n                else:                        # Same values stored, good. \\n\\t\\t\\t\\t                             # Let\\'s check their child nodes\\n                    return same_tree(left.left, right.right) \\n                      and same_tree(left.right, right.left)\\n        \\n        if not root: return True\\n        return same_tree(root.left, root.right)\\n```\n```\\n    def isSymmetric(self, root):\\n\\n        #2) Iteratively\\n        if not root:\\n            return True\\n        \\n        queue = collections.deque([(root.left, root.right)])\\n        while queue:\\n            left, right = queue.popleft()\\n            if (not left) and (not right):\\n                continue\\n            elif (not left) or (not right):\\n                return False\\n            else:\\n                if (left.val != right.val):\\n                    return False\\n                else:\\n                    queue.append((left.left, right.right))\\n                    queue.append((left.right, right.left))\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730254,
                "title": "python-3-recursive-preorder-traversal",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe handle base conditions first: \\n1. If first and second tree are both None, then they are symmetric.\\n2. If only 1 of them is None, they are asymmetric.\\n3. If the value of nodes in first and second are different, they are asymmetric.\\n\\nWe can combine all the asymmetric base cases in 1 if condition too.\\n\\nFrom the given example, we can see there are 2 subtrees that we are going to compare. We compare the left node of first tree with the right node of the second tree. Similarly, we compare the right node of first tree with the left node of the secod tree.\\n\\nAfter both the recursive calls return with the status of their subtrees, we return the status of current first and second trees to their parent node. Eventually the value bubbles up and we return the final result.\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n            \\n        def helper(firstTree, secondTree):\\n            if not firstTree and not secondTree:\\n                return True\\n                \\n            if not firstTree and secondTree:\\n                return False\\n            elif firstTree and not secondTree:\\n                return False\\n            elif firstTree.val != secondTree.val:\\n                return False\\n            \\n            mirror1 = helper(firstTree.left, secondTree.right)\\n            mirror2 = helper(firstTree.right, secondTree.left)\\n            return mirror1 and mirror2\\n        \\n        return helper(root.left, root.right)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n            \\n        def helper(firstTree, secondTree):\\n            if not firstTree and not secondTree:\\n                return True\\n                \\n            if not firstTree and secondTree:\\n                return False\\n            elif firstTree and not secondTree:\\n                return False\\n            elif firstTree.val != secondTree.val:\\n                return False\\n            \\n            mirror1 = helper(firstTree.left, secondTree.right)\\n            mirror2 = helper(firstTree.right, secondTree.left)\\n            return mirror1 and mirror2\\n        \\n        return helper(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586784,
                "title": "easy-to-learn-best-for-beginer-c",
                "content": "```\\nclass Solution {\\npublic:\\n \\n      //divide in two tree s lefttree ans righttree \\n    bool Compair(TreeNode* lefttree,TreeNode* righttree ){\\n        if(lefttree==NULL && righttree ==NULL)\\n        {\\n            return true;\\n        }\\n        if(lefttree==NULL || righttree ==NULL)\\n            \\n        {\\n            return false;\\n        }\\n        if(lefttree->val!=righttree ->val)\\n        {\\n            return false;\\n        }\\n        \\n\\t\\t//we check p left child with q right child and vice versa \\n        return Compair(lefttree->left,righttree ->right) && Compair(lefttree->right,righttree ->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n            \\n        return Compair(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n      //divide in two tree s lefttree ans righttree \\n    bool Compair(TreeNode* lefttree,TreeNode* righttree ){\\n        if(lefttree==NULL && righttree ==NULL)\\n        {\\n            return true;\\n        }\\n        if(lefttree==NULL || righttree ==NULL)\\n            \\n        {\\n            return false;\\n        }\\n        if(lefttree->val!=righttree ->val)\\n        {\\n            return false;\\n        }\\n        \\n\\t\\t//we check p left child with q right child and vice versa \\n        return Compair(lefttree->left,righttree ->right) && Compair(lefttree->right,righttree ->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n            \\n        return Compair(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540519,
                "title": "simple-python-recursive-and-iterative-solutions",
                "content": "**Both are O(n) time and space.**\\n**1}Recursive**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def isEqual(t1,t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2:return False\\n            if t1.val!=t2.val: return False\\n            inner=isEqual(t1.left,t2.right)\\n            outer=isEqual(t1.right,t2.left)\\n            \\n            return inner and outer\\n        return isEqual(root.left,root.right)\\n```\\n\\n**2)Iterative:**\\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n\\n \\n        level=[root]\\n        \\n        while level:\\n            nextlevel=[]\\n            currLevel=[]\\n            for node in level:\\n                if node.right:\\n                    nextlevel.append(node.right)\\n                    currLevel.append(node.right.val)\\n                else:\\n                    currLevel.append(\"Empty\")\\n                if node.left:    \\n                    nextlevel.append(node.left)\\n                    currLevel.append(node.left.val)\\n                else:\\n                    currLevel.append(\"Empty\")    \\n            if currLevel != currLevel[::-1]:\\n                return False\\n\\n            level=nextlevel\\n        return True   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def isEqual(t1,t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2:return False\\n            if t1.val!=t2.val: return False\\n            inner=isEqual(t1.left,t2.right)\\n            outer=isEqual(t1.right,t2.left)\\n            \\n            return inner and outer\\n        return isEqual(root.left,root.right)\\n```\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n\\n \\n        level=[root]\\n        \\n        while level:\\n            nextlevel=[]\\n            currLevel=[]\\n            for node in level:\\n                if node.right:\\n                    nextlevel.append(node.right)\\n                    currLevel.append(node.right.val)\\n                else:\\n                    currLevel.append(\"Empty\")\\n                if node.left:    \\n                    nextlevel.append(node.left)\\n                    currLevel.append(node.left.val)\\n                else:\\n                    currLevel.append(\"Empty\")    \\n            if currLevel != currLevel[::-1]:\\n                return False\\n\\n            level=nextlevel\\n        return True   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408213,
                "title": "python-easy-recursion-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef fun(root1, root2):\\n\\t\\t\\t\\tif root1 is None and root2 is None:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif root1 is None or root2 is None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\tx = fun(root1.left, root2.right)\\n\\t\\t\\t\\t\\ty = fun(root1.right, root2.left)\\n\\n\\t\\t\\t\\t\\tif x == True and y == True:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn False\\n\\n\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn fun(root, root)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef fun(root1, root2):\\n\\t\\t\\t\\tif root1 is None and root2 is None:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif root1 is None or root2 is None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\tx = fun(root1.left, root2.right)\\n\\t\\t\\t\\t\\ty = fun(root1.right, root2.left)\\n\\n\\t\\t\\t\\t\\tif x == True and y == True:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn False\\n\\n\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn fun(root, root)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1235596,
                "title": "c-simple-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode * lefft, TreeNode * rigght)\\n    {\\n        if(lefft==nullptr and rigght==nullptr)\\n            return true;\\n        if(lefft==nullptr or rigght==nullptr)\\n            return false;\\n        if(lefft->val!=rigght->val)\\n            return false;\\n        return check(lefft->left,rigght->right) and check(lefft->right, rigght->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==nullptr)\\n            return true;\\n        return check(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode * lefft, TreeNode * rigght)\\n    {\\n        if(lefft==nullptr and rigght==nullptr)\\n            return true;\\n        if(lefft==nullptr or rigght==nullptr)\\n            return false;\\n        if(lefft->val!=rigght->val)\\n            return false;\\n        return check(lefft->left,rigght->right) and check(lefft->right, rigght->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==nullptr)\\n            return true;\\n        return check(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229761,
                "title": "rust-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Symmetric Tree.\\nMemory Usage: 2.3 MB, less than 5.26% of Rust online submissions for Symmetric Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn compare(l: Option<Rc<RefCell<TreeNode>>>, r: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n            match (l, r) {\\n                (None, None) => true,\\n                (None, Some(n)) | (Some(n), None) => false,\\n                (Some(l), Some(r)) => {\\n                    if l.borrow().val != r.borrow().val {\\n                        return false;\\n                    }\\n                    return compare(l.borrow().left.clone(), r.borrow().right.clone())\\n                        && compare(l.borrow().right.clone(), r.borrow().left.clone())\\n                }\\n            }\\n        }\\n        match root {\\n            Some(r) => compare(r.borrow().left.clone(), r.borrow().right.clone()),\\n            None => true\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn compare(l: Option<Rc<RefCell<TreeNode>>>, r: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n            match (l, r) {\\n                (None, None) => true,\\n                (None, Some(n)) | (Some(n), None) => false,\\n                (Some(l), Some(r)) => {\\n                    if l.borrow().val != r.borrow().val {\\n                        return false;\\n                    }\\n                    return compare(l.borrow().left.clone(), r.borrow().right.clone())\\n                        && compare(l.borrow().right.clone(), r.borrow().left.clone())\\n                }\\n            }\\n        }\\n        match root {\\n            Some(r) => compare(r.borrow().left.clone(), r.borrow().right.clone()),\\n            None => true\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569663,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1831340,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1576379,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1753495,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1568924,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1634875,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830814,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1567526,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572756,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572521,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1569663,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1831340,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1576379,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1753495,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1568924,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1634875,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830814,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1567526,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572756,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572521,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830796,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1573878,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1569330,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1819220,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1741784,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1572325,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 2047496,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1927992,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1876529,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1831530,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1831247,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1831224,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1830925,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1739888,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1571214,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2072410,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2038685,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2037148,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2029936,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2007922,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1982668,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1980992,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1975188,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1966251,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1950587,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1930350,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1921348,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1905553,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1896306,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1894040,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1881616,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1881260,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1867453,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1863134,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1858893,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1852928,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1844478,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1840628,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1838364,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1834928,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1833080,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831816,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831576,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831529,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831516,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831509,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831318,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831153,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831144,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831075,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831058,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1831051,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830905,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830849,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830826,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830803,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830793,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1817539,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1771190,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1770161,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1759395,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1758489,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1758253,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1749894,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1741083,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1736561,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1728206,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1724579,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1707973,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1672775,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            }
        ]
    }
]