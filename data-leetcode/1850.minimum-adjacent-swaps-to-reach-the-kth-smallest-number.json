[
    {
        "title": "Minimum Distance to the Target Element",
        "question_content": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that&nbsp;abs(x)&nbsp;is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n\nExample 2:\n\nInput: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n\nExample 3:\n\nInput: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 104\n\t0 <= start < nums.length\n\ttarget is in nums.",
        "solutions": [
            {
                "id": 1186927,
                "title": "c-one-pass-optimization",
                "content": "As an optional optimization, we exit early if `res` cannot be improved anymore.\\n\\n\\n```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\\nAnother optimization is to initiate the search from the `start` position. It is potentially faster when the `target` is close to the `start`.\\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186947,
                "title": "clean-python-3-o-answer",
                "content": "Will be faster if `target` is cloese to `start`.\\n\\nTime: `O(answer)`, degrade to `O(N)` if target is in the head or tail of the given array.\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186832,
                "title": "python-1-line-solution",
                "content": "# **Explanation**\\nIterate all values and check if it equals to target.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186862,
                "title": "python3-linear-sweep",
                "content": "\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186825,
                "title": "c-java-self-explanatory",
                "content": "# c++\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# java\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186979,
                "title": "c-sequential-scan-two-pointer-approach",
                "content": "There are two ways to solve this problem.\\n\\n1. Doing a sequential traversal of array and updating the min(abs(start-i), min) whenever nums[i] == target.\\n2. Second is to use two pointers,  have two pointers starting from start and let them move in opposite directions. Whenever we reach the target, this is closest to start.\\n\\nCode for 2nd approach:\\n\\n```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187372,
                "title": "java-array-beats-100-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1188573,
                "title": "java-o-n-solution-using-stream",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186919,
                "title": "python-easy-to-undersand",
                "content": "Just in case, this code may be explained well for beginners.\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262476,
                "title": "c-one-pass-4-lines-of-code-only",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2965311,
                "title": "java-easy-solution-3-line-code",
                "content": "please upvote, if you like it.Thak you\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204659,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186800,
                "title": "python-2-simple-solutions-faster-than-100",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/407ccaaa-0b71-4b0f-a453-34a0a54e68bb_1619928523.5857952.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669607,
                "title": "100-beats-best-java-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914715,
                "title": "java-easy-peasy-solution",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825709,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2705184,
                "title": "o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589037,
                "title": "with-explanation-comments-time-8-ms-63-78-space-9-5-mb-96-11",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }\\n        \\n        //return the min absolute value of the two variables\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290930,
                "title": "python-for-beginners",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "solutionTags": [],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "codeTag": "Java"
            },
            {
                "id": 1200271,
                "title": "python-with-early-exit",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188277,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Enumeration"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653440,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used basic concept.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596152,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516534,
                "title": "easy-c-solution-in-o-n-time-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the index of \\'target\\', then find the minimum value if target - start.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413116,
                "title": "minimum-distance-to-the-target-element-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223288,
                "title": "java-runtime-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972643,
                "title": "fast-easy-js-solution",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823504,
                "title": "easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821922,
                "title": "java-beats-100-simple-easy",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626508,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551734,
                "title": "short-javascript-solution",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521585,
                "title": "python-minimum-distance-to-the-target-element-easy-understanding",
                "content": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "codeTag": "Java"
            },
            {
                "id": 2215549,
                "title": "c-2-lines-of-code-short-clean",
                "content": "![image](https://assets.leetcode.com/users/images/d3cf85cf-076a-4762-9722-d583db8daaae_1656541049.452096.png)\\n\\n**T->O(N) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1938581,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831075,
                "title": "o-n-java-simple-beats-100",
                "content": "We will do a two pointer approach, where the `left` and `right` pointer will be initialized to `start` index and we will move our two pointers in opposite direction to find the `target` as soon as we found the target we will just return the required result.\\n\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813450,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772913,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1687685,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637535,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596373,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584649,
                "title": "python-sol-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/76662b9f-96ad-4fdd-aa44-c0fa3e4b438b_1637237611.385875.png)\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538304,
                "title": "c-o-n-t-c-90-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }\\n        while(right<nums.size()){\\n            if(nums[right]==target) break;\\n            right++;\\n        }\\n          if(left<0 && right<nums.size()) return abs(right-start);\\n        else if(left>=0 && right>=nums.size()) return abs(left-start);\\n        return min(abs(left-start),abs(right-start));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1490609,
                "title": "c-easy-solution-using-only-loops-6-line-code",
                "content": "```\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION!!\\nclass Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }}\\n        sort(l.begin(),l.end());//SORTING\\n        \\n        return l[0];\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459507,
                "title": "c-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433500,
                "title": "c-easy-solution-2-pointer-approach",
                "content": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428868,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397435,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }\\n        }\\n        {\\n            for(i=s;i>=0;i--)\\n            {\\n               if(n[i]==t)\\n               {\\n                   k=Math.abs(i-s);\\n                   c=Math.min(c,k);\\n               }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388775,
                "title": "faster-than-92-05-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297195,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294967,
                "title": "simple",
                "content": "guys if you find solution usefull \\ndo upvote\\nand feel free to ask in the comment\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }\\n        return minn;\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283284,
                "title": "optimum-solution-java-version",
                "content": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277810,
                "title": "runtime-64-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "#### [](http://)Runtime: 64 ms, faster than 100.00% of JavaScript online submissions for Minimum Distance to the Target Element.\\n```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255146,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242840,
                "title": "two-pointer-approach-cpp-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234711,
                "title": "rust-linear-scan-to-high-low-pointers",
                "content": "\\n\\n<b>Problem List</b>\\n#High-LowPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_technique/n_pointers/by_pointer_amount/high_low_pointers.txt)\\n#LinearScan - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/linear_scan)\\n\\nHigh-Low Pointers Approach\\n\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\\n\\nLinear Scan Approach:\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220487,
                "title": "easy-to-understand-c-code-by-archit-garg",
                "content": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1218972,
                "title": "java-two-pointer",
                "content": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216412,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214397,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195213,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191675,
                "title": "c-4ms-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191643,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189619,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189571,
                "title": "faster-than-100-00",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188162,
                "title": "javascript-one-pass",
                "content": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187614,
                "title": "go-simple-solution",
                "content": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187500,
                "title": "python-3-simple-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186816,
                "title": "very-easy-one-pass-c-with-explanation",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(1)\\n\\n**Explanation**\\nInitialize ans variable with max value (INT_MAX)\\nIterate all values and check if it equals to target \\nIf it is equal to target update ans with min value between ans and abs(i-start)\\n\\n```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts and \\nIf you like the solution and explanation please **upvote** !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077026,
                "title": "easiest-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070431,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066542,
                "title": "python3-o-n-time-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBasic approach of finding min distance \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064536,
                "title": "basic-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059139,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044167,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040094,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030828,
                "title": "easy-understand-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012972,
                "title": "0ms-beats-100-00-of-users",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998759,
                "title": "minimum-distance-to-target-element-python-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989939,
                "title": "easy-java-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988036,
                "title": "c-bherry-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986689,
                "title": "beats-100-python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981603,
                "title": "c-simple-and-easy-solution",
                "content": "upvote if you like the solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976916,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n-worst-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976065,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975194,
                "title": "easist-way-for-this-problem",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968037,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962480,
                "title": "python-simple-and-faster-98-o-n-space-o-1-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942296,
                "title": "simple-3-line-code-tc-o-n-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923204,
                "title": "java-solution-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915781,
                "title": "beats-100-in-runtime-c",
                "content": "# Intuition\\nCheck every elemet from the right of start, find the shortest distance.\\n\\nGo back to start, and do the same thing for elements to the left of start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: 1 iteration over the array total\\n\\n- Space complexity:\\n$$O(1)$$ Local variables have a single value, regardless of size\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909354,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse a vector to store all the indexes of occurence of target.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885790,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884266,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858173,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850790,
                "title": "js-simple-solution-faster-than-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849736,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841825,
                "title": "easy-0ms-java-solution-beats-100-easypeasy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834521,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820844,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818638,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786167,
                "title": "easiest-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779411,
                "title": "java-easy-0-ms-fastest-don-t-think-complex",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764340,
                "title": "simple-and-most-basic-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the minimun distace variable whhich contains the maximum value \\nof integer range.\\ncreate a variable to strore the final result and initial it with 0 then interte from start to end of array and check the fisrt condition of arr[i]==t n then create int dist...so we can ccalculate the result at each iteration.\\nthen compare each dist with minimun value varible and assign the value to ans varible.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760836,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760446,
                "title": "easy-javascript-method",
                "content": "# Intuition\\nWe start at \\'start\\' position and we only need to search the left and right sides of it. \\n\\nThere are 3 situations\\n\\nLeft : a-i\\nRight : b+i\\nSelf : i=0\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748933,
                "title": "runtime-67-ms-beats-78-61-memory-16-5-mb-beats-66-75",
                "content": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3743586,
                "title": "easy-solution-o-n-linear-search",
                "content": "#\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725514,
                "title": "js-2pointer-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2-pointer approch\\nstart 2 pointers left and right from start\\nincrease right and decrese left untill target is found\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nworst case senario-O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721598,
                "title": "bfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708501,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708057,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696847,
                "title": "minimum-distance-to-the-target-element-easy-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695195,
                "title": "easiest-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685262,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3677025,
                "title": "easy-c-solution-beginner-friendly-approach-beats-92-in-both",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654430,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651434,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635641,
                "title": "java-solution-easy-understanding-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625410,
                "title": "100-faster-and-less-memory-im-lazy-so-i-write-what-i-want-w-o-thinking",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615602,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606023,
                "title": "c-tc-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600839,
                "title": "simple-approach-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596582,
                "title": "easiest-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591976,
                "title": "python-simple-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565334,
                "title": "java-easy",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533784,
                "title": "minimum-distance-solution",
                "content": "# Intuition\\nThis is an very simple question that involves iterating through the given list.\\n\\n# Approach\\nHere is a brief pseudocode:\\n<ul>\\n<li>Iterate over the list one element at a time</li>\\n<li>If the element is equal to target, subtract it and store the result.</li>\\n<li>Check the result with the previous results and see if the new result is smaller.</li>\\n<li>update the result and return it</li>\\n</ul>\\n\\n# Complexity\\n- Time complexity:\\n  This is a very easy question with a very basic approach. However, it took me 30 minutes because i couldn\\'t understand the question. Then after debugging i finally understood the question. So on average this should take about 1 minute to do, maybe less\\n\\n- Space complexity:\\n  I tried making the program use as much less memory as possible but it still takes a lot.\\n\\n# Code\\n```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520788,
                "title": "go-runtime-0-ms-memory-3-2-mb",
                "content": "# Code\\n```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516788,
                "title": "minimum-distance-java-solution-0ms-beats-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have given the target element and the element from which we have to start. \\nWe iterate through the array , check where our target value lies and calculate the minimum distance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declared two variables max and min which are initially initialised as the Integer.MAX_VALUE;\\n- Then we iterate through the array,  and whenever we encounter our target element we store it\\'s index to the max variable.\\n- Now to calculate the minimum distance between the index, we use the Math.min() function where the parameters are the min value itself alongwith the positive difference between the max variable value and the start value.\\n- We then return the min value.\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506789,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502241,
                "title": "100-easy-solution-using-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497874,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496479,
                "title": "easy-java-solution",
                "content": "`Please upvote if it helps you. Happy Coding!`\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494169,
                "title": "0ms-100-beats-clean-java-solution-beconsistent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484215,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483739,
                "title": "minimum-distance-to-the-target-element-easy-solution-with-few-lines-of-code",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }\\n              \\n\\n        }\\n        return smallval;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478521,
                "title": "with-math-library-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472603,
                "title": "java-expand-from-start-to-both-side-of-array-easy-to-understand-t-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470428,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460686,
                "title": "100-java-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457502,
                "title": "minimum-distance-javascript-o-n-51-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/1a408052-67c1-4cfb-b5f7-87ac9f96447f_1682515561.8084388.png)\\n\\n```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456482,
                "title": "python-basic-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448304,
                "title": "rust-functional-style-iterators",
                "content": "# Intuition\\nBasic implementation of the problem. Technically there are ways that you could reduce the number of iterations necessary by starting from the middle, but in practice iteration is just faster.\\n\\n# Approach\\niter(), well, iterates over the vector. Note that this is read-only so it\\'s actually iterating over &i32 instead of i32.\\n\\nenumerate() turns an iterator of &i32 into an iterator of (usize, &i32) where the first term is the zero-indexed position. **Note**: we have to enumerate before filtering so our index is relative to its original position.\\n\\nfilter() removes any irrelevant elements from the iterator.\\n\\nmap() throws out the &i32 term (we\\'re done with it after the filter), and converts from i: usize into the absolute value distance measure as an i32.\\n\\nAfter the map, we now have an iterator of distances to \"start\". We use min() to collapse the iterator into Option<i32>; note that it is an option because Rust thinks the iterator might be empty (i.e. no elements match target).\\n\\nBut we\\'re told this is impossible, so we can just unwrap() and call it a day.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n), we do one pass over nums.\\n\\n- Space complexity:\\nO(1), the iterator struct takes up a finite amount of space and there are no heap allocations.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436903,
                "title": "java-simple-solution-bruteforce-find-minimum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412410,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where n is the length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the length of nums\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402810,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396909,
                "title": "3-line-easy-java-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382703,
                "title": "c-bfs-from-start",
                "content": "No error checking since constraints say target must exist in vector.\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368450,
                "title": "solution-to-absolute-value-question-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first It was difficult to grasp what the question was trying to ask but i slowly and steadily understood the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is quite different compared to other solutions. I have initiated with an array in a for loop which stores the absolute values of \"i-start\" ONLY if the current value of vector is equal to the target we need (since there can be multiple values which match the target value but we want one which is CLOSEST to the index of \"start\" to minimize the absolute value). The loop runs and constantly stores the absolute values whenever it encounters one. Next, I have initiated another loop to check for the MINIMUM absolute value out of all absolute values to get a minimized solution.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358166,
                "title": "easy-5-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3354553,
                "title": "java-easiest-solution",
                "content": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850808,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            },
            {
                "id": 1799174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Splitting a String Into Descending Consecutive Values",
        "question_content": "<p>You are given a string <code>s</code> that consists of only digits.</p>\n\n<p>Check if we can split <code>s</code> into <strong>two or more non-empty substrings</strong> such that the <strong>numerical values</strong> of the substrings are in <strong>descending order</strong> and the <strong>difference</strong> between numerical values of every two <strong>adjacent</strong> <strong>substrings</strong> is equal to <code>1</code>.</p>\n\n<ul>\n\t<li>For example, the string <code>s = &quot;0090089&quot;</code> can be split into <code>[&quot;0090&quot;, &quot;089&quot;]</code> with numerical values <code>[90,89]</code>. The values are in descending order and adjacent values differ by <code>1</code>, so this way is valid.</li>\n\t<li>Another example, the string <code>s = &quot;001&quot;</code> can be split into <code>[&quot;0&quot;, &quot;01&quot;]</code>, <code>[&quot;00&quot;, &quot;1&quot;]</code>, or <code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>. However all the ways are invalid because they have numerical values <code>[0,1]</code>, <code>[0,1]</code>, and <code>[0,0,1]</code> respectively, all of which are not in descending order.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to split</em> <code>s</code> <em>as described above</em><em>, or </em><code>false</code><em> otherwise.</em></p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1234&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;050043&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s can be split into [&quot;05&quot;, &quot;004&quot;, &quot;3&quot;] with numerical values [5,4,3].\nThe values are in descending order with adjacent values differing by 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;9080701&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186814,
                "title": "java-backtracking",
                "content": "Here, we find the first number/prefixes(where previous is null) and then search in remaining string if numbers are in descending order.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186795,
                "title": "c-backtracking-solution-o-n-2-and-time-complexity-analytics",
                "content": "\\n#### Time complexity\\nO(N ^ 2). even though we use back-tracking here, it is obvious that the upper-bound complexity of this solution is N^2, in the for loop `for(int i = idx; i < s.size(); i++) `, there is only one chance to go into next `dfs` function, so it is linear complexity O(N) for every iteration. so it is O(N ^ 2), if you don\\'t believe this, you can add a counter in the for loop and see what is the value of the counter, it is smaller than(close to) N^2.\\n\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186896,
                "title": "java-brute-force-recursion-step-by-step-with-detailed-explanation",
                "content": "**Please Upvote ! if you found useful, so it helps others to find it. Thank you, I tried to explain in as depth as possible. Enjoy!**\\n\\n**Approach 1: Brute Force**\\n\\nSo my idea was to hop **i** digits at the time, if we reach to the end that means we found our answer. \\n**What do i mean by hop?**\\nEx: \"000908760\" \\n\\ti = 1 -> \"0009\" then \"08\" then \"07\" then \"6\" then \"0\" (It will find single digits) i.e 9..8..6..0\\n\\ti = 2 -> \"00090\" then \"87\" then \"60\" (it will find double digits) i.e 90..87..60\\n\\tSo if we reach till End that means we got our answer and return true\\n\\t\\n**Tricky part of this problem**\\n*   **Zeros:** I considered the number after intial 0\\'s i.e 00007 -> 7\\n*  **Gap of 1:** so to check that convert the number to long and subtract with prev itteration and diff should be 1\\n* \\t**Edge case** 001: We check if prev is Long.max value that means this is the first digit and should not return true even we reach till end\\n* \\t **Edge Case** 1009897: here if our i = 2 10..98..97 if i=3 then i=100..989..7 so using variable \"width\" to check if number is 10..100..10000 or power of 10 next number we search is i width shorter so if we find 100 we are nowlooking for 2 digit number instead of 3\\n\\nUsing long because there\\'s a test case which int cannot parse\\nHope it makes sense comment if you have any question.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\\n\\n\\n**Approach 2 DFS**\\n\\nSimply we start and keep finding the next substring(long) such that curr - next = 1 and the end if we reach to the last index we check if we found atleast 2 long\\nEx: \"9998\" -> 9..99..98\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186963,
                "title": "c-check-all-lengths",
                "content": "> Update: added a shorter solution that avoids copying strings. The original solution (as embarrassing as it is) is below just for the reference.\\n \\nThis problem was hard to implement for me. I got hidden WA, and spent a while chasing it down. Turns out, I had a problem with the \"1000999\" test case when the first number is longer than the half of the string.\\n \\n#### Simplified Solution\\nWell this is way simpler than the original solution, but I could not come up with it during the contest. Still a long road ahead to practice.\\n \\nFew important points:\\n- The very first loop does not go all the way to the end - to make sure we have at least one split.\\n- Limit `num` to avoid overflow.\\n \\n```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\\n\\n#### Original Solution\\nAnyhow, the idea is to iterate through possible number lengths (from `1` to `nums.size() / 2 + 1`), get the first number, and recursively check if we can find decreasing numbers in the rest of the string.\\n\\nTo make it simple, we first trim leading zeros from our string. We create bunch of copies by using `substr()`, but it\\'s tolerable as our string is limited to 20 characters.\\n\\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186813,
                "title": "c-python-recursive-backtracking-solution-explained-w-comments",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe need to iterate over all possible substrings for each splits. \\n\\nIf a split gives value equal to **`previous split - 1`**, then continue trying to split for remaining index. Otherwise, try increasing the length of split and check again.\\n\\nIf you reach the last index and there are more than 1 splits, return true. Otherwise return false.\\n\\n**C++**\\n\\nFor C++, you need to handle overflows . For this purpose, I have use *`try...catch`* block in the below solution -\\n\\n```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186831,
                "title": "c-simple-recursive-solution",
                "content": "Transfer to long long int and compare\\n\\n```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186812,
                "title": "java-backtracking-100-runtime",
                "content": "Backtracking problem -\\n\\nHint from the constraints  1 <= s.length <= 20\\n\\nWhen the size is less, we can generate all possible combinations and decide\\n\\n# ** backTrack( String s, int index, long prevNumber, int count )**\\n\\nRecursionVirtualization - \\n\\n![image](https://assets.leetcode.com/users/images/9429e601-cc1f-4b41-8269-b99584f12388_1620252266.1658697.gif)\\n\\nRecursion Tree -\\n\\n![image](https://assets.leetcode.com/users/images/14a7f94d-cc9d-4403-be10-0d5debd30c55_1620252278.9633133.png)\\n\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\\nIf we were asked for actual sequence then slight modification to the above code , cList contains the actual sequence \\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186808,
                "title": "python-backtracking-solution",
                "content": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434966,
                "title": "c-simple-c-code",
                "content": "\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188541,
                "title": "simple-python-3",
                "content": "This solution adds a default paramater to the given function to avoid having to define a dfs function inside the existing function.\\n\\n```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662405,
                "title": "simple-python-solution-dfs",
                "content": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1191740,
                "title": "simple-basic-backtracking-solution-bf-faster-than-70-c-solution-c",
                "content": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2923088,
                "title": "java-runtime-0-ms-beats-100-easy-to-understand",
                "content": "# please up-vote:)\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\\nthis line: ```nextVal == 0? 0 : nextVal - 1``` \\nis for handling cases like \"20010000\" with trailing zeros.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\n```nextVal == 0? 0 : nextVal - 1```",
                "codeTag": "Java"
            },
            {
                "id": 2726640,
                "title": "python-3-9-lines-dfs-slices-t-m-100-74",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```\\n[https://leetcode.com/submissions/detail/826781820/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194674,
                "title": "100-faster-cpp-solution-backtracking-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194544,
                "title": "c-greedy-method-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.9 MB, less than 78.87% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n\\n```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190201,
                "title": "simple-recursion-do-take-care-of-overflow",
                "content": "If you know recursion well then you know how easy it was to come up with simple recursive logic, just one line - \"Make the first number and check and buil on it\"\\nBut were you able to manage the Overflows !?\\n\\n**Hint for recursion :**\\n* start building the very first number from string and check if it is possible to complete the sequence , (make previous number from remaining string)\\n* isPossible function takes few parameters ( string s, currIndex i, targetNumber)\\n* if index has reached the end then return true as we have finished the string successfully\\n* if we have made the number then call for recursion again from next index and targetNumber-1\\n\\n**-> points to remember** \\n1. make sure that you are managing the overflows, if at any point your firstNumber or currNumber becomes greater than 10^11 then return false as maxLength Constraints is given to be 20 characters\\n```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187660,
                "title": "python-recursive-with-my-intuition",
                "content": "Intuition\\n\\n1.  Given a string \"050043\"\\n2.  Find a 1st possible number (05) with the string \"050043\"\\n3.  Call dfs() function to see if there is a number 5\\n4.  If so, then find the next number \"004\" (which is smaller than 5 by 1) and \"0043\" & continue to call dfs() until the end\\n5.  If 3 and \"3\" are the same and it\\'s the last string, set ans = True\\n* Use the level for edge cases, since 100 => True but 00 => False (maybe it\\'s the last test case)\\n\\nMy approach solved 172 out of 173 test cases and failed for the last one.\\nThe most tricky part of this problem for me was how to handle zeros because they can either (1) form a part of numbers or (2) just sit there as leading or trailing zeros.\\n* (1) 200100 => True [2,1] , 10110099 => True [101,100,99]\\n* (2) 1000 => True [1,0] , 00 => False\\n* (3) 10100010099 => True [101,100,99] (mixed with (1) and (2) cases)\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786073,
                "title": "backtracking-in-python",
                "content": "Split the input string `s` into possible pieces, and check recursively when it\\'s 1 smaller than the previous value.\\nNote that the string must be split into two or more pieces, so I added an argument `parts` to manage the number of split pieces.\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720660,
                "title": "java-post-my-one-pass-dfs-solution-with-pruning-0ms-runtime-beat-100",
                "content": "Post my 0ms runtime solution.\\n\\nThe idea is to generate a starting number so that we don\\'t need to backtrack, and the target number can also be used for tree pruning.\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187926,
                "title": "python-beat-100-super-simple",
                "content": "Recursion logic:\\n- if the last number is x, then we need to check if the string contains a number x - 1 after x, if we found a number ,we increment the count and make sure we can at least find 2 substring\\n\\nEdge cases:\\n - numbers with leading zero, need not to count the zeros,  in python, simply do **len(str(num))**\\n```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1187486,
                "title": "java-recursion-beats-100-0ms-t-c-o-2-n-s-c-o-n",
                "content": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1186878,
                "title": "python-3-backtracking",
                "content": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3223985,
                "title": "python3-easiest-solution-beats-85-users-simplest-backtracking",
                "content": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256113,
                "title": "c-java-python-easy-and-clean-backtracking",
                "content": "**C++**\\n\\n```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```\\n\\nTime: `O(2^n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227555,
                "title": "java-backtracking-easy-to-understand-4ms",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202698,
                "title": "c-backtracking-0ms-simple-solution",
                "content": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195215,
                "title": "python3-dfs-memo",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190158,
                "title": "easy-c-solution",
                "content": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188655,
                "title": "backtracking-o-n-2-self-evident",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187320,
                "title": "c-recursion-with-condition-of-all-possible-substrings",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186928,
                "title": "c-try-all-splits-that-has-diff-1-with-custom-diff-method",
                "content": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\\n\\nHowever, since there is requirement of atleast two string so max valid string length = 10, which easily fit into long and ignore otherwise.\\n\\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357528,
                "title": "python-backtracking-solutions-2-branches-vs-n-branches",
                "content": "Solution 1: Path from source to node represents a candidate split of the string. Each node has two branches -- either include the current char in the split or don\\'t include and start a new split. Prune unnecessary paths by checking if the condition of consecutive and descending is maintained. Time complexity -- O(2^N) but in practice much faster due to pruning and early return once we find a valid split.\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\\n\\nSolution 2: Each node has `n` branches denoting where to split the string `s[i:]` into two substrings. Time complexity is O(N^N) but in practice much faster due to pruning. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291155,
                "title": "1849-splitting-a-string-into-descending-consecutive-values",
                "content": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "codeTag": "Java"
            },
            {
                "id": 3127835,
                "title": "python-simple-dfs",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938172,
                "title": "python3-beats-95-87-with-o-n-2-solution",
                "content": "**Intuition**\\n        1.Assume all prefixes(all substrings starting from index 0) as first number\\n        2.Assign the first number as curr and find a number(next substring) greater than by 1 next to it\\n        3.if we can reach the end of the string return True at least theres is one possible case\\n        4.edge case string with a lot of zeros at the ending ... in this case if previous is one return True\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2728029,
                "title": "runtime-0-ms-faster-than-100-00-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2639488,
                "title": "simple-backtracking-solution-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077769,
                "title": "backtracking-explain",
                "content": "# Backtracking\\n\\n> from brute force step by step optimize\\n\\nOne picture is worth a thousand words.\\n\\n![image](https://assets.leetcode.com/users/images/fe3ec39b-79bf-408b-9843-08d513194b0b_1653619479.069864.png)\\n\\n\\n## 1. Solution1 Brute force DFS\\n\\nUse DFS generate all possible split substrings and check to descend.\\n\\n````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n````\\n\\n## 2. Optimize solution 1\\n\\nBecause solution 1 generates all possible substrings, there are many substrings\\nis not descend, so we drop this substring.\\n\\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n```\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015681,
                "title": "javascript-concise-faster-than-100",
                "content": "Explanantion:\\nCreate a recursive function that accepts the following parameters:\\nprev: the prev number, initialised as null\\ni: the current starting index\\ncount: the count of numbers we identify from the string so far\\n\\nEach recursion, we aim to identify a substring that can be translated to a number that satisfies the criteria (i.e. number === prev-1), if that is possible, we recursively call the function split, until we reach the end of the string. \\n```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996679,
                "title": "javascript-backtracking-dfs-very-simple",
                "content": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973743,
                "title": "python-dfs-backtracking-simple-solution",
                "content": "DFS:\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\\n\\nBacktracking:\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926166,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915438,
                "title": "simple-solution-in-java-elegant-and-concise-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740505,
                "title": "python-clean-recursive-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1723386,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string str=s.substr(0,i+1);\\n            long long int val=stoll(str);\\n            if(val>99999999999) // According to question, there should be atleast 2 substrings, that means atleast 2 values.\\n                break;          // The max length of string is 20 which means the length of max val of any substring shouldn\\'t be more than 10 \\n            if(prev==-1)\\n            {\\n                fun(s.substr(i+1),val,count+1);\\n            }\\n            else\\n            {\\n                if(val>=prev)\\n                    break;\\n                if((prev-val)==1)\\n                {\\n                    fun(s.substr(i+1),val,count+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool splitString(string s) { \\n        fun(s,-1,0); // s -> input string \\n        return ans;  // -1 -> previous value of the substring\\n    }                // 0 -> count to track number of substrings included\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428460,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327432,
                "title": "simple-backtracking-solution",
                "content": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218541,
                "title": "c-backtracking-100-faster-small",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203431,
                "title": "python-clean-backtracking-4-liner",
                "content": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```\\n\\n1. Added extra optional **parameter**, or create another function.\\n2. Split strings into left(**current number**), right (recurse)\\n    a. if num is None (First function call), range(1, len(s)) to guarantees it has at least 2 parts.\\n    b. else, only recurse when **current number** is same as **parameter**. (base is when string is empty)\\n\\t",
                "solutionTags": [],
                "code": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1188141,
                "title": "python-100",
                "content": "***Topic::\\nDynamic Programming\\nOwing to a really small string size (20), we split the string into tuples containing the current substring, the ending index(j) and the starting index(i) with a span of j - i + 1.\\nFor example, \"50049048\" is processed into\\n(5, 0, 0), (50, 1, 0), (500, 2, 0), (5004, 3, 0), (50049, 4, 0), (500490, 5, 0), (5004904, 6, 0), (50049048, 7, 0), (0, 0, 1), (00, 1, 1), ...\\nNow all you have to do is to check whether there exits a subsequence (a1, b1, c1),(a2, b2, c2), etc.. that matches the constraints below :: \\ni)    a1 - a2 = a2 - a3 = a3 - a4 = ... = 1 (strictly decreasing)\\nii)   b1 = c2 - 1, b2 = c3 - 1, b3 = c4 - 1, ... (the ending index of a former substring has to be 1 less than the starting index of the next substring)\\niii)  bn = len(s) - 1 (the last substring has to terminate at the very end)\\niv)   n is not equal to 1 (since we want to split s into atleast two such substrings)\\nNow, this problem clearly boils down to a O(n^2) dynamic programming problem, which is nothing but a clever brute force! Do consider upvoting if you like the explanation. Thanks.***\\n```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188042,
                "title": "python3-recursion-solution-for-reference",
                "content": "The question looks like permuations and split problem at first sight but if we dig into details strings is a bad way to deal with the problem since it consumes conversion. If we use the digit conversion method as below, it will help faster. \\n\\n1234 = (10** 3 * 1) + (10 ** 2 * 2) + (10**1 * 3) + (10 ** 0 * 4)) = 1000 + 200 + 30 + 4\\n\\nThe below variant uses recursion and moves forward only when it finds a value just 1 more than the base value. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```\\n#Runtime: 32 ms, faster than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.\\n#Memory Usage: 14.5 MB, less than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187861,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187566,
                "title": "c-very-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186930,
                "title": "javascript-dp-with-explanation-o-n-2",
                "content": "For example:\\n`dp[i]`  = a set of last values that can be totally split = \\n- at least including one integer value from `s[i] to s[n-1]`\\n- other valid value which has a `j, j>=i+1, that s[i ... j-1] === dp[j] + 1`\\n\\nFinal condition: `dp[0].size>1`, since we want to split at least 2 nums.\\n\\n**For example:**\\n```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\\n**JavaScript code:**\\n\\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186917,
                "title": "c-solution-using-simple-recursion",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186879,
                "title": "js-easy-recursion",
                "content": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186875,
                "title": "python-3-top-down-dp",
                "content": "Time: `O(N^3)`\\nSpace: `O(N)`\\n```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186852,
                "title": "python-dfs-backtracking-solution",
                "content": "Python DFS+backtracking solution\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186788,
                "title": "watch-out-for-trailing-zeros-like-100-no-recursion-o-n-2",
                "content": "\\u201C100\\u201D returns true as it can split into [\\u201C1\\u201D, \\u201C00\\u201D], wasted a lot of time during contest\\u2026\\n\\nIterative\\nFind next correct number, if reach the end of string then return True\\ni.e. 9897\\nthe code will first try 1 digit numbers: 9,8,9 -> wrong\\nthen try 2 digit numbers: 98, 97 -> correct\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186787,
                "title": "c-recursive-backtracking-faster-than-70-memory-less-than-80",
                "content": "Solved this problem using recursion. \\nThe helper recursive function is helper(input string, current index of the string, the last number that was made).\\nI would check whether the next digits of the number that is going to be created is one integer less than the last number, if so, I would update the last number and continue.\\nThe base conditions would determine the return statements.\\nAlso, used a lot of ```stod``` (string to double) function. Check it out! It is a cool function :P\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        return helper(s,0,-1);\\n    }\\n    bool helper (string & s , int ind , double last){\\n        // Base return cases\\n        if (ind >=s.size()){\\n            if (last==-1 ||  last==stod(s)){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\t\\t// Check if the number to be created is the first number ever \\n        if (last == -1){\\n            for (int i = 1; i<=s.size()-ind; i++){\\n                if (helper(s,i,stod(s.substr(0,i)))){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\t\\t// Check for the next numbers to be created\\n        for (int i = 1; i<=s.size()-ind; i++){\\n            if ( (double)last - stod(s.substr(ind,i)) == 1){\\n                if (helper(s,ind+i,stod(s.substr(ind,i)))){\\n                    return true;\\n                }\\n            }\\n            if ( (double)last - stod(s.substr(ind,i)) < 1 ){\\n                break;\\n            }\\n        }\\n\\t\\t// If we exit last loop, we should return false since we couldn\\'t create a number!\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```stod```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068930,
                "title": "easy-explanation-beats-100",
                "content": "start building the current number, and make sure you go ahead in the recursion if and only if you are just 1 smaller than the previous number, and make sure you take atleast 2 step(i.e dividing in atleast 2 numbers).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990780,
                "title": "easy-solution-using-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982510,
                "title": "recursive-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962338,
                "title": "python-backtracking-easy-solution",
                "content": "Code should be easy to understand\\n`start` is the starting index of `last`\\nfor example `s = \"050043\"`\\n`start` is 0, `end` is 3, `last = s[start:end+1]`, which is 5\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933574,
                "title": "python-95-simple-and-detailed-code-dfs",
                "content": "# Intuition\\nThe main idea of solving this problem is this idea of \"chunking\" your input string into every possible substring all the while keeping track of the remaining part of the string. These chunks of possible solution and remaining will be passed into futher recursive calls.\\n\\nI.E. take the string \"05004\" which should return true.\\nWe want to split this into every possible substring\\nChunk | Remaining\\n0     |  5004\\n05    |  004\\n050   |  04\\n0500  |  4\\n05004 |  _\\n\\nWe then \"bound/bind\" when we make futher recursive calls. In this case, we want each valid substring chunk to have a difference of 1.\\n\\nThus the current \"chunk\" we have becomes the previous value we pass into the recursive call. *This makes more sense when reading the code*\\n# Approach\\n*In-depth comments in the code*\\n\\n# Complexity\\n- Time complexity:\\n    The time complexity is O(2^N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The recursive function dfs(prev, remaining) explores all possible splits of the input string.\\nIn the worst case, each character can be a part of a split or not, leading to 2 possibilities per character.\\nSince you\\'re exploring all possible combinations of splits, the number of recursive calls grows exponentially with the length of the input string.\\n\\n- Space complexity:\\nThe space complexity of your code is O(N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The space used by the recursion stack is directly proportional to the depth of recursion.\\nSince the maximum depth of recursion is determined by the length of the input string, the space complexity is O(N).\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931564,
                "title": "o-n-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a string of digits and need to split it into substrings such that the substrings are in descending order with a difference of 1 between the values that the adjacent substrings represent.\\n\\nUse backtracking to explore all possible splits and check if it is valid. A split is valid if the resulting substring values are in descending order and the difference is 1 i.e substring2 is 1 less than substring1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- define a helper function for backtracking\\nbacktrack(current index, current partitions, previous substring value)\\n    - if the current index is the last, we have considered all digits, and check if we were able to split the string i.e current partitions >= 2\\n    - for each next digit including the current index digit\\n    - get the current substring value\\n    - if the previous substring value is greater or the difference between the previous and current is 1, backtrack to explore whether we can make another split. Return true if we can\\n    - if the loop completes without returning true, we can\\'t make any split, return false\\n- start backtracking from the first digit at index 0 and return the result\\n\\n# Complexity\\n- Time complexity: O(recursion breadth) \\u2192 O(calls at each levele ^ total levels) \\u2192 O(n$^n$) but the program runs much faster due to pruning \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(recursion stack) \\u2192 O(recursion depth/levels) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905802,
                "title": "virendra-keshri-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751353,
                "title": "using-front-partitioning",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713139,
                "title": "elegant-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691119,
                "title": "python-backtracking",
                "content": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "codeTag": "Java"
            },
            {
                "id": 3652789,
                "title": "java-easier-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*2^n)$$\\n\\n- Space complexity: $$O(n*2^n)$$\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602258,
                "title": "python3-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580108,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490389,
                "title": "c-recursive-solution-o-n-2",
                "content": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410090,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Check if every digit segments are in decreasing order and differ by one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n# Complexity\\n- Time complexity: O(n^2)/n! (?)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403221,
                "title": "splitting-a-string-into-descending-consecutive-values-leetcode-java-solution-by-priyanka",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecusive, Backtracking approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396087,
                "title": "c-recursive-brute-force-string-subtraction-and-comparison-code-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387724,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383493,
                "title": "0ms-c-backtracking",
                "content": "\\n```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3365569,
                "title": "python-backtracking-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304423,
                "title": "c-solution-fast-solution-easy-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207625,
                "title": "typescript-recursion",
                "content": "# Code\\n```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182788,
                "title": "c",
                "content": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166077,
                "title": "79-ms",
                "content": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3161849,
                "title": "python-backtracking-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3161164,
                "title": "backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148183,
                "title": "slow-scala-dfs-with-foldleft-and-memoizations",
                "content": "# Code\\n```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3109263,
                "title": "go-beats-100-runtime-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$ (n=s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3103709,
                "title": "c-concise-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103473,
                "title": "java-easy-updated-top-voted-solution-beats-100",
                "content": "I could not finish my code and looked discussion. I saw @vikrant_pc \\' s java solution which was top voted. I changed it a little bit to make it faster and easier to understand. Hope this helps somebody else!\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n`if(previous != null && previous < current) return false;`  this avoids a lot of unnecessary conditions. Like if current =10 and prev = 5 , there is no way you can return true because eventually we want it to be decreasing.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099338,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084934,
                "title": "on-time-on-space-0ms-my-fastest-solution-explained",
                "content": "\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084556,
                "title": "easy-to-understand-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074532,
                "title": "python-short-dfs-solution",
                "content": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3026296,
                "title": "java-dfs-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960365,
                "title": "python-top-down-dp-o-n-3",
                "content": "\\n# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958847,
                "title": "hardcoded",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHardcode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHardcoded, but be ware of the cringe edgecases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) as the size of string is 20 at max\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932480,
                "title": "java-rec-big-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898689,
                "title": "c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867636,
                "title": "c-backtracking-palindromic-partitioning-follow-up",
                "content": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812513,
                "title": "python-backtracking",
                "content": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2736181,
                "title": "greedy-intuition-c-explained-in-hindi",
                "content": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2730767,
                "title": "strip-zeros-to-make-your-life-easy-python",
                "content": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "solutionTags": [],
                "code": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2704048,
                "title": "js-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681403,
                "title": "python-backtracking-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660476,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634916,
                "title": "c-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\tbool res=false;\\n\\t\\t\\t\\twhile(x<n-1&&s[x]==\\'0\\'&&s[x+1]==\\'0\\') x++;\\n\\t\\t\\t\\tfor(int i=x;i<min(x+10,n);i++) {\\n\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\t\\tif(val==LONG_MAX||val-stol(str)==1) {\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tres=res||recur(stol(str),i+1);\\n\\t\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t};\\n\\t\\t\\treturn recur(LONG_MAX,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2632013,
                "title": "clear-python-dfs-with-comments",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619890,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573352,
                "title": "golang-simple-backtracking-solution",
                "content": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569971,
                "title": "simple-java-backtracking-solution",
                "content": "```\\n/**\\n * time complexity : O(N^2)\\n * space complexity: O(N)\\n */\\n\\nclass Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}\\n\\n\\tprivate boolean backTrack(long last, int j) {\\n\\n\\t\\tif (j == s.length()) // found it\\n\\t\\t\\treturn true;\\n\\n\\t\\tlong cur = 0l;\\n\\n\\t\\tfor (int i = j; i < s.length(); i++) {\\n\\n\\t\\t\\tcur = cur * 10 + (s.charAt(i) - \\'0\\'); // add current char\\n\\n\\t\\t\\tif (cur > 10000000000L || last == -1 && i + 1 == s.length()) // will make overflow || found only one substring\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tif ((last == -1 || last - cur == 1) && backTrack(cur, i + 1)) // first substring || difference between last,cur numbers is 1\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2556816,
                "title": "c-recoursion",
                "content": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507858,
                "title": "rust-recursion",
                "content": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457579,
                "title": "c-solution-backtracking",
                "content": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n**Time:** O(N^2), \\n**Space:** O(N) for recursion call stack",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2442835,
                "title": "java-recursion-and-backtracking-explained-tc-sc-explained",
                "content": "// This is a classic recursion question\\n// Each time we FORM a number and then RECURSIVELY check if the \"remianing substring\" and this \"number\" satisfies ALL the rules, otherwise keep appending the  rest of the chars from string to this number\\n\\n// TC : O(N^2); N = s.length()\\n// SC : O(N); recursion stack\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424344,
                "title": "python-backtrack-clean",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "codeTag": "Java"
            },
            {
                "id": 2419111,
                "title": "ruby-backtracing",
                "content": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2384619,
                "title": "typescript-100",
                "content": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/660dedc7-e7f9-4bad-bcf3-7b4d5724fb63_1659729260.4821222.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370716,
                "title": "python-3-dfs-short-and-concise",
                "content": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 2353252,
                "title": "c-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353193,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305778,
                "title": "elegant-c-faster-than-100",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305679,
                "title": "java-backtracking-with-try-catch-for-parselong-d",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299660,
                "title": "backtracking-python-easy",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279891,
                "title": "javascript-fast-simple-memory-efficient-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211155,
                "title": "c-backtracking-4ms",
                "content": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152720,
                "title": "backtracking-solution-for-java-with-comments",
                "content": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112950,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071939,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035755,
                "title": "java-backtracking-with-binary-search",
                "content": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010385,
                "title": "go-backtracking-solution",
                "content": "This question is similar to https://leetcode.com/problems/palindrome-partitioning/\\n\\nAt each iteration, we check if the comb is valid, and recursively call the next index if it is.\\n\\nAt the base case, we set result to true if length is more than 1.\\n\\n```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003042,
                "title": "java-short-backtracking",
                "content": "We check all possible combinations and backtrack whenever the current combo couldn\\'t be valid.\\n\\nDue to max length being 20, it technically can overflow at length 19 and produce incorrect result when comparing to the string at length 20, but it passes the test cases still without the check.\\n```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921014,
                "title": "c-recursive-with-pruning-faster-that-100",
                "content": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918162,
                "title": "python-backtracking-best-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898913,
                "title": "javascript-solution-backtracking",
                "content": "I forgoed using the parseInt() method to trim off the leading zero and converting the string to an actual integer.\\n\\n```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889311,
                "title": "js-solution-backtracking",
                "content": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1875910,
                "title": "python-solution-recursion-backtrack-suitable-comments",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859427,
                "title": "python-recursion-no-explanation-faster-than-90-83",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```\\nRuntime: 35 ms\\nMemory: 13.9 MB\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837563,
                "title": "slow-but-easy-solution",
                "content": "I know the below solution is not so **fast** but I have applied my backtracking template and after many TLE\\'s it is working just fine so that\\'s why I am sharing it.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812599,
                "title": "dfs-easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782553,
                "title": "c-0ms-100-simple-dfs",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.8 MB, less than 98.02% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763932,
                "title": "simple-javascript-solution",
                "content": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760702,
                "title": "java-o-n-2-dfs",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756906,
                "title": "100-runtime-cpp-backtracking-try-catch",
                "content": "Using backtracking and bailing out if current number is greater than my digit where we split previously.\\n\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool helper(string& s, int i, string d) {\\n        long long digit = 0;\\n        long long curr = 0;\\n        try {\\n            digit = stoll(d);\\n            curr = digit - stoll(s.substr(i));\\n            if(curr == 1) return true;\\n        }\\n        catch(...) {return false;};\\n        for(int j = i; j < s.size(); j++) {\\n            curr = digit - stoll(s.substr(i, j-i+1));\\n            if(curr <= 0) return false;\\n            if(curr == 1) {\\n                return helper(s, j+1, s.substr(i, j-i+1));\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755227,
                "title": "python3-recursive-solution-with-a-helper-function-24ms-beats-99-24",
                "content": "Took me some time to debug since I was passing j instead of j - (k+1) in the recursion. Not very elegant at all, I know, but it still is pretty efficient.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733322,
                "title": "c-backtracking-solution-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        } else {\\n            for(int i=0;i<s.size();i++){\\n                long double num=stold(s.substr(0,i+1));\\n                if(curr.empty() or curr.back()-num==1.0){\\n                    curr.push_back(num);\\n                    if(backtrack(s.substr(i+1),curr)){\\n                        return true;\\n                    }\\n                    curr.pop_back();\\n                }\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    bool splitString(string s) {\\n        vector<long double>curr;\\n        return backtrack(s,curr);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718922,
                "title": "python-backtracking",
                "content": "It seems there is no better way than the bruteforce recursion with complexity of `O(N^2)` (Analysis: https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/1186795/C%2B%2B-Backtracking-solution.-O(N-2)-and-time-complexity-analytics)\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680034,
                "title": "python-memo-dp-100-runtime",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659591,
                "title": "go-brute",
                "content": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1949318,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1921544,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1986785,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "question_content": "<p>You are given a string <code>num</code>, representing a large integer, and an integer <code>k</code>.</p>\n\n<p>We call some integer <strong>wonderful</strong> if it is a <strong>permutation</strong> of the digits in <code>num</code> and is <strong>greater in value</strong> than <code>num</code>. There can be many wonderful integers. However, we only care about the <strong>smallest-valued</strong> ones.</p>\n\n<ul>\n\t<li>For example, when <code>num = &quot;5489355142&quot;</code>:\n\n\t<ul>\n\t\t<li>The 1<sup>st</sup> smallest wonderful integer is <code>&quot;5489355214&quot;</code>.</li>\n\t\t<li>The 2<sup>nd</sup> smallest wonderful integer is <code>&quot;5489355241&quot;</code>.</li>\n\t\t<li>The 3<sup>rd</sup> smallest wonderful integer is <code>&quot;5489355412&quot;</code>.</li>\n\t\t<li>The 4<sup>th</sup> smallest wonderful integer is <code>&quot;5489355421&quot;</code>.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the <strong>minimum number of adjacent digit swaps</strong> that needs to be applied to </em><code>num</code><em> to reach the </em><code>k<sup>th</sup></code><em><strong> smallest wonderful</strong> integer</em>.</p>\n\n<p>The tests are generated in such a way that <code>k<sup>th</sup></code>&nbsp;smallest wonderful integer exists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;5489355142&quot;, k = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;5489355421&quot;. To get this number:\n- Swap index 7 with index 8: &quot;5489355<u>14</u>2&quot; -&gt; &quot;5489355<u>41</u>2&quot;\n- Swap index 8 with index 9: &quot;54893554<u>12</u>&quot; -&gt; &quot;54893554<u>21</u>&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;11112&quot;, k = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;21111&quot;. To get this number:\n- Swap index 3 with index 4: &quot;111<u>12</u>&quot; -&gt; &quot;111<u>21</u>&quot;\n- Swap index 2 with index 3: &quot;11<u>12</u>1&quot; -&gt; &quot;11<u>21</u>1&quot;\n- Swap index 1 with index 2: &quot;1<u>12</u>11&quot; -&gt; &quot;1<u>21</u>11&quot;\n- Swap index 0 with index 1: &quot;<u>12</u>111&quot; -&gt; &quot;<u>21</u>111&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;00123&quot;, k = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The 1<sup>st</sup> smallest wonderful number is &quot;00132&quot;. To get this number:\n- Swap index 3 with index 4: &quot;001<u>23</u>&quot; -&gt; &quot;001<u>32</u>&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>num</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186818,
                "title": "c-simple-solution-using-next-permutation",
                "content": "We\\'ll first find out kth permutation using next_permutation function.\\n\\n```\\noriginal: 5489355142 and kth-permutation: 5489355421\\n```\\n\\n**CATCH : Just find the min no. of steps to make original == kth-permutation  \\uD83D\\uDC40**\\n```\\nclass Solution {\\npublic:\\n    \\n    // GREEDY APPROACH\\n    // min steps to make strings equal\\n    \\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        int i = 0, j = 0;\\n        int result = 0;\\n  \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};\\n```\\n\\n**Qn: WHY IS GREEDY APPROACH WORKING HERE?**\\n\\nFirst, we are not doing anything if the characters are at their original place.  \\n\\nSecond, Since we are bringing character to its original position (if it was not), that was the minimum effort (steps) we will have to put in since there is no other way of bringing it to original position **with only adjacent swaps.**\\n\\nAnd now we can apply same thing to the rest of the string. Plus we are swapping end to start, which shifts characters towards the end, and ultimately close to their original position, *because everything before that is already in their original position.*\\n\\nPS - I did it quickly, please let me know in comments if something seems off or not understandable. Thanks!",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\noriginal: 5489355142 and kth-permutation: 5489355421\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // GREEDY APPROACH\\n    // min steps to make strings equal\\n    \\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        int i = 0, j = 0;\\n        int result = 0;\\n  \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187098,
                "title": "next-permutation-adjacent-swapping",
                "content": "My 1st Google onsite interview question.\\n\\nAlgorithm:\\n\\t1. We use the *nextPermutation* to find the kth target permutation\\n\\t2. We use *countSteps* to count how many steps we need to perform to reach that kth permutation. \\n\\n**Java:**\\n\\n```\\n    public int getMinSwaps(String num, int k) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < k; i++) {\\n            nextPermutation(arr);\\n        }\\n        char[] ori = num.toCharArray();\\n        return CountSteps(ori, arr, arr.length);\\n    }\\n    \\n    public void nextPermutation(char[] nums) {\\n        if (nums.length == 0) return;\\n        int len = nums.length;\\n        for (int i = len - 1; i >= 1; i--) {\\n            if (nums[i] > nums[i - 1]) {\\n                reverse(nums, i);\\n                for (int j = i; j < len; j++) {\\n                    if (nums[j] > nums[i - 1]) {\\n                        swap(nums, i - 1, j);\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        reverse(nums, 0);\\n    }\\n    \\n    public void reverse(char[] nums, int i) {\\n        int j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(char[] nums, int i, int j) {\\n        char temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp; \\n    }\\n    \\n    private int CountSteps(char []s1, char[] s2, int size) {\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < size) {\\n            j = i;\\n\\n            while (s1[j] != s2[i]) {\\n                j += 1;\\n            }\\n            while (i < j) {\\n                swap(s1, j, j - 1);\\n                j -= 1;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n```\\n\\n**C++:**\\n```\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target(num);\\n        for (int i = 0; i < k; ++i)\\n            next_permutation(target.begin(), target.end());\\n        int res = 0, n = num.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (num[i] != target[i]) {\\n                int j = i + 1;\\n                while (num[j] != target[i])\\n                    j++;\\n                for (; j > i; --j)\\n                    swap(num[j], num[j - 1]), res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMinSwaps(String num, int k) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < k; i++) {\\n            nextPermutation(arr);\\n        }\\n        char[] ori = num.toCharArray();\\n        return CountSteps(ori, arr, arr.length);\\n    }\\n    \\n    public void nextPermutation(char[] nums) {\\n        if (nums.length == 0) return;\\n        int len = nums.length;\\n        for (int i = len - 1; i >= 1; i--) {\\n            if (nums[i] > nums[i - 1]) {\\n                reverse(nums, i);\\n                for (int j = i; j < len; j++) {\\n                    if (nums[j] > nums[i - 1]) {\\n                        swap(nums, i - 1, j);\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        reverse(nums, 0);\\n    }\\n    \\n    public void reverse(char[] nums, int i) {\\n        int j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(char[] nums, int i, int j) {\\n        char temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp; \\n    }\\n    \\n    private int CountSteps(char []s1, char[] s2, int size) {\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < size) {\\n            j = i;\\n\\n            while (s1[j] != s2[i]) {\\n                j += 1;\\n            }\\n            while (i < j) {\\n                swap(s1, j, j - 1);\\n                j -= 1;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target(num);\\n        for (int i = 0; i < k; ++i)\\n            next_permutation(target.begin(), target.end());\\n        int res = 0, n = num.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (num[i] != target[i]) {\\n                int j = i + 1;\\n                while (num[j] != target[i])\\n                    j++;\\n                for (; j > i; --j)\\n                    swap(num[j], num[j - 1]), res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186823,
                "title": "python-3-brute-force",
                "content": "Time: `O(N^2 + N * K)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def nxt_perm(num: list) -> list:\\n            i = n - 1\\n            while i > 0 and num[i-1] >= num[i]:\\n                i -= 1\\n            j = i\\n            while j < n and num[i-1] < num[j]:\\n                j += 1\\n            num[i-1], num[j-1] = num[j-1], num[i-1]\\n            num[i:] = num[i:][::-1] # credit to @ye15, reduce time from nlogn to n\\n            return num\\n\\n        n = len(num)\\n        nxt_k_num = list(num)\\n        for _ in range(k):\\n            nxt_k_num = nxt_perm(nxt_k_num)\\n\\n        ans = 0\\n        num = list(num)\\n        for i in range(n):\\n            j = i\\n            while j < n and nxt_k_num[i] != num[j]:\\n                j += 1\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def nxt_perm(num: list) -> list:\\n            i = n - 1\\n            while i > 0 and num[i-1] >= num[i]:\\n                i -= 1\\n            j = i\\n            while j < n and num[i-1] < num[j]:\\n                j += 1\\n            num[i-1], num[j-1] = num[j-1], num[i-1]\\n            num[i:] = num[i:][::-1] # credit to @ye15, reduce time from nlogn to n\\n            return num\\n\\n        n = len(num)\\n        nxt_k_num = list(num)\\n        for _ in range(k):\\n            nxt_k_num = nxt_perm(nxt_k_num)\\n\\n        ans = 0\\n        num = list(num)\\n        for i in range(n):\\n            j = i\\n            while j < n and nxt_k_num[i] != num[j]:\\n                j += 1\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186921,
                "title": "c-next-permutation",
                "content": "We use STL to permute our string k times. Then, we compare the orignal and permuted string. When we see a mismatch, we locate the needed character in the permuted string, add the distance to it. Finally, we shift the permuted string accordingly.\\n\\n```cpp\\nint getMinSwaps(string n, int k) {\\n    string n1 = n;\\n    int res = 0;\\n    while (--k >= 0)\\n        next_permutation(begin(n1), end(n1));\\n    for (auto i = 0; i < n.size(); ++i) {\\n        if (n[i] != n1[i]) {\\n            for (auto j = i + 1; j < n.size(); ++j) {\\n                if (n[i] == n1[j]) {\\n                    res += j - i;\\n                    n1 = n1.substr(0, i + 1) + n1.substr(i, j - i) + n1.substr(j + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getMinSwaps(string n, int k) {\\n    string n1 = n;\\n    int res = 0;\\n    while (--k >= 0)\\n        next_permutation(begin(n1), end(n1));\\n    for (auto i = 0; i < n.size(); ++i) {\\n        if (n[i] != n1[i]) {\\n            for (auto j = i + 1; j < n.size(); ++j) {\\n                if (n[i] == n1[j]) {\\n                    res += j - i;\\n                    n1 = n1.substr(0, i + 1) + n1.substr(i, j - i) + n1.substr(j + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206569,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        //store index \\n        int[] number = new int[n];\\n        for(int i = 0; i < n; i++){\\n            int digit = num.charAt(i) - \\'0\\';\\n            number[i] = digit;\\n        }\\n        \\n        //compute kth smallest number\\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\\n        \\n        return getMinSwaps(number, kthSmallestNumber);\\n    }\\n    \\n    private int[] getKthSmallestNumber(int[] nums, int k){\\n        while(k --> 0){\\n            computeNextPermutation(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void computeNextPermutation(int[] nums){\\n        int n = nums.length;\\n        int i = n - 2;\\n        \\n        //find first index from last which value smaller than next element \\n        while(i >= 0 && nums[i] >= nums[i + 1]){\\n            i--;\\n        }\\n        \\n\\n        if(i >= 0){\\n            //find index which is just greater than that index value (e.g i)\\n            int j = n - 1;\\n            while(j > i && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        \\n        //sort all element which index greater than <i>\\n        Arrays.sort(nums, i + 1, n);\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            //ignore, as it already in correct position, no need for swap\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            //find the coorect position\\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            //swift to correct position\\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        //store index \\n        int[] number = new int[n];\\n        for(int i = 0; i < n; i++){\\n            int digit = num.charAt(i) - \\'0\\';\\n            number[i] = digit;\\n        }\\n        \\n        //compute kth smallest number\\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\\n        \\n        return getMinSwaps(number, kthSmallestNumber);\\n    }\\n    \\n    private int[] getKthSmallestNumber(int[] nums, int k){\\n        while(k --> 0){\\n            computeNextPermutation(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void computeNextPermutation(int[] nums){\\n        int n = nums.length;\\n        int i = n - 2;\\n        \\n        //find first index from last which value smaller than next element \\n        while(i >= 0 && nums[i] >= nums[i + 1]){\\n            i--;\\n        }\\n        \\n\\n        if(i >= 0){\\n            //find index which is just greater than that index value (e.g i)\\n            int j = n - 1;\\n            while(j > i && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        \\n        //sort all element which index greater than <i>\\n        Arrays.sort(nums, i + 1, n);\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            //ignore, as it already in correct position, no need for swap\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            //find the coorect position\\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            //swift to correct position\\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186910,
                "title": "clean-java",
                "content": "With the helper method from 31. next permutation. \\nhttps://leetcode.com/problems/next-permutation/ \\nwe can use brute force to calculate the minimal adjacent swap to make 2 arrays equal\\n```\\n    public int getMinSwaps(String num, int k) {\\n        int N = num.length();\\n        int[] origin = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        for (int i = 0; i < num.length(); i++) {\\n            nums[i] = num.charAt(i) - \\'0\\';\\n            origin[i] = num.charAt(i) - \\'0\\';\\n        }\\n        while (k-- > 0) nextPermutation(nums);\\n        int res = 0;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] != origin[i]) {\\n                int j = i;\\n                while (nums[j] != origin[i]) j++;\\n                for (int x = j; x > i; x--) {\\n                    swap(nums, x, x - 1);\\n                    res++;\\n                }\\n            }\\n        return res;\\n    }\\n    public void nextPermutation(int[] nums) {\\n        if (nums.length <= 1) return;\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--; \\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (j > i && nums[j] <= nums[i]) j--; \\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1, nums.length - 1);\\n    }\\n    private void reverse(int[] nums, int left, int right) {\\n        while (left < right)\\n            swap(nums, left++, right--);\\n    }\\n    private void swap (int[] nums, int i, int j) {\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMinSwaps(String num, int k) {\\n        int N = num.length();\\n        int[] origin = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        for (int i = 0; i < num.length(); i++) {\\n            nums[i] = num.charAt(i) - \\'0\\';\\n            origin[i] = num.charAt(i) - \\'0\\';\\n        }\\n        while (k-- > 0) nextPermutation(nums);\\n        int res = 0;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] != origin[i]) {\\n                int j = i;\\n                while (nums[j] != origin[i]) j++;\\n                for (int x = j; x > i; x--) {\\n                    swap(nums, x, x - 1);\\n                    res++;\\n                }\\n            }\\n        return res;\\n    }\\n    public void nextPermutation(int[] nums) {\\n        if (nums.length <= 1) return;\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--; \\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (j > i && nums[j] <= nums[i]) j--; \\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1, nums.length - 1);\\n    }\\n    private void reverse(int[] nums, int left, int right) {\\n        while (left < right)\\n            swap(nums, left++, right--);\\n    }\\n    private void swap (int[] nums, int i, int j) {\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186887,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        orig = num.copy()\\n        \\n        for _ in range(k): \\n            for i in reversed(range(len(num)-1)): \\n                if num[i] < num[i+1]: \\n                    ii = i+1 \\n                    while ii < len(num) and num[i] < num[ii]: ii += 1\\n                    num[i], num[ii-1] = num[ii-1], num[i]\\n                    lo, hi = i+1, len(num)-1\\n                    while lo < hi: \\n                        num[lo], num[hi] = num[hi], num[lo]\\n                        lo += 1\\n                        hi -= 1\\n                    break \\n        \\n        ans = 0\\n        for i in range(len(num)): \\n            ii = i\\n            while orig[i] != num[i]: \\n                ans += 1\\n                ii += 1\\n                num[i], num[ii] = num[ii], num[i]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        orig = num.copy()\\n        \\n        for _ in range(k): \\n            for i in reversed(range(len(num)-1)): \\n                if num[i] < num[i+1]: \\n                    ii = i+1 \\n                    while ii < len(num) and num[i] < num[ii]: ii += 1\\n                    num[i], num[ii-1] = num[ii-1], num[i]\\n                    lo, hi = i+1, len(num)-1\\n                    while lo < hi: \\n                        num[lo], num[hi] = num[hi], num[lo]\\n                        lo += 1\\n                        hi -= 1\\n                    break \\n        \\n        ans = 0\\n        for i in range(len(num)): \\n            ii = i\\n            while orig[i] != num[i]: \\n                ans += 1\\n                ii += 1\\n                num[i], num[ii] = num[ii], num[i]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910886,
                "title": "c-intuitions-commented-next-permuatation-explained-clearly",
                "content": "```\\n  int getMinSwaps(string num, int k) {\\n\\n       int n=num.size();\\n        string x = num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        \\n        int ans=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(num[i]!=x[i])\\n              {\\n                  // as we know we have to check the swappings , its original position \\n                  // will be somewhere to the right in original string num as compared \\n                  // to permutated string x, so find it out and swap one by one \\n                  // makes it to its newly permutataed position in  original string \\n                  // swap one by one just makes it to position as it in permuated string\\n                  \\n                  int j=i+1 ;// j will be moving in original string\\n                      \\n                      while(num[j]!=x[i])\\n                      {\\n                          j++;\\n                      }\\n                  \\n                     // now we find it out at some jth index where the (value x[i]  )exists in original string  at index j in string num\\n                  // its time to swap now \\n                  \\n                  while(j>i)\\n                  {\\n                      swap(num[j] , num[j-1]);\\n                      j--;\\n                      ans++;\\n                  }\\n                  \\n                  \\n              }\\n          }\\n        \\n        \\n        return ans;\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n  int getMinSwaps(string num, int k) {\\n\\n       int n=num.size();\\n        string x = num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        \\n        int ans=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(num[i]!=x[i])\\n              {\\n                  // as we know we have to check the swappings , its original position \\n                  // will be somewhere to the right in original string num as compared \\n                  // to permutated string x, so find it out and swap one by one \\n                  // makes it to its newly permutataed position in  original string \\n                  // swap one by one just makes it to position as it in permuated string\\n                  \\n                  int j=i+1 ;// j will be moving in original string\\n                      \\n                      while(num[j]!=x[i])\\n                      {\\n                          j++;\\n                      }\\n                  \\n                     // now we find it out at some jth index where the (value x[i]  )exists in original string  at index j in string num\\n                  // its time to swap now \\n                  \\n                  while(j>i)\\n                  {\\n                      swap(num[j] , num[j-1]);\\n                      j--;\\n                      ans++;\\n                  }\\n                  \\n                  \\n              }\\n          }\\n        \\n        \\n        return ans;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190281,
                "title": "explanation-for-adjacent-swapping",
                "content": "There are a lot of great explaination for the next permutation, but I did not found a proof for the correctness of the minimum adjacent swapping. So I spent some time thinking about it and shared my thought. Correct me if it is wrong.\\n\\nHere is my code for count minimum swapping to get `dest` from `src`. The main idea is to go through `dest`, comparing the `dest[i]` with `src[i]`, if they are not the same, find the nearest `src[j]` at right that equals to `dest[i]` and swap `j - i` times to make `src[i] == dest[i]`. Finally, we will convert `src` to `dest` and the number of swapping is minimum.\\n```\\n    private int count(int[] dest, int[] src) {\\n        int count = 0;\\n        for (int i = 0; i < dest.length; i++) {\\n            if (dest[i] != src[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (dest[i] == src[j]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1); // swap  src[k] with src[k - 1]\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nTo prove its correctness, we need the conception [**Inversion Number**](https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics)), basically the number of pairs out of their natural order. Here we can let the `dest` define the natual order, and by adjacent swapping, we can reduce the inversion number of `src`. While `inv(src) = inv(dest) = 0`, two permutation are the same:\\n```\\nsrc = 42135\\ndest = 45132\\n2 shows before 1, 3, 5\\n1 shows before 5\\n3 shows before 5\\nSo, inv(src) = 3 + 1 + 1 = 5\\n```\\n\\nThen we can find that each adjacent swapping can reduce `inv(src)` by 1 at most:\\n```\\n...left chunk, i, j, right chunk...\\n```\\nSwapping `i` and `j` only affect the order between themselves, the inversion number can be increased by 1(destroy the natural order), decreased by 1(become natural order) or doesn\\'t change(i == j). After swapping, `i, j` are still behind the left chunk, in front of the right chunk. Hence, to convert `src` to `dest`, we need at least `inv(src)` adjacent swapping.\\nIn above greedy strategy, everytime `src[i] != dest[i]`, we will find the `src[j] == dest[i], j > i`. Every element from `src[i]` to `src[j - 1]`  is in inverse order with `src[j]`. So, each adjacent swapping always reduces the `inv(src)` by 1, e.g:\\n```\\n42135 -> 45213, 3 adjacent swappings, and reduce the inversion number by 3.\\n```\\nNote: since we always find the nearest target element, so we won\\'t waste swapping on identical elements, e.g:\\n```\\n4, 2, 1, 5_1, 3,  5_2 -> 4, 5_1, 5_2, 2, 1, 3, here 5_1 and 5_2 are both 5, just added a suffix to differentiate them.\\nStategy 1: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_1, 2, 1, 3, 5_2  ->  4, 5_1, 5_2, 2, 1, 3;                          2 + 3 = 5 swap\\nStategy 2: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_2, 2, 1, 5_1, 3  ->  4, 5_2, 5_1, 2, 1, 3;                          4 + 2 = 6 swap\\n```\\nIn above example, stategy2 wasted a swapping when move `5_2` to the correct position.\\n\\nSince every swapping reduces the inversion number by 1, the number of swapping in this strategy is exactly `inv(src)`, which is also the possible minimum number of swapping. Therefore, this strategy is optimal.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    private int count(int[] dest, int[] src) {\\n        int count = 0;\\n        for (int i = 0; i < dest.length; i++) {\\n            if (dest[i] != src[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (dest[i] == src[j]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1); // swap  src[k] with src[k - 1]\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\nsrc = 42135\\ndest = 45132\\n2 shows before 1, 3, 5\\n1 shows before 5\\n3 shows before 5\\nSo, inv(src) = 3 + 1 + 1 = 5\\n```\n```\\n...left chunk, i, j, right chunk...\\n```\n```\\n42135 -> 45213, 3 adjacent swappings, and reduce the inversion number by 3.\\n```\n```\\n4, 2, 1, 5_1, 3,  5_2 -> 4, 5_1, 5_2, 2, 1, 3, here 5_1 and 5_2 are both 5, just added a suffix to differentiate them.\\nStategy 1: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_1, 2, 1, 3, 5_2  ->  4, 5_1, 5_2, 2, 1, 3;                          2 + 3 = 5 swap\\nStategy 2: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_2, 2, 1, 5_1, 3  ->  4, 5_2, 5_1, 2, 1, 3;                          4 + 2 = 6 swap\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186790,
                "title": "c-next-permutation-solution-greedy",
                "content": "\\n#### Idea\\n- use C++ next_permutation to get the k-th permutation.\\n- start from the last element(j) and find the closest char(i) which is equal to it. and swap the adjacent elements from i to j. each step we apply ans += 1\\n\\n#### Complexity\\n- Time O(n^2)\\n- Space O(n)\\n\\n#### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string src = num;\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        for(int i = num.size() - 1; i >= 0; i--) {\\n            int j = i;\\n            while(src[j] != num[i])--j;\\n            for(int l = j; l < i; l++) {\\n                swap(src[l], src[l + 1]);\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string src = num;\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        for(int i = num.size() - 1; i >= 0; i--) {\\n            int j = i;\\n            while(src[j] != num[i])--j;\\n            for(int l = j; l < i; l++) {\\n                swap(src[l], src[l + 1]);\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262666,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=x[i])\\n            {\\n                int j=i+1;\\n                while(s[j]!=x[i])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=x[i])\\n            {\\n                int j=i+1;\\n                while(s[j]!=x[i])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186837,
                "title": "python-3-permutation-simulation",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n        # 1: get the kth value\\n        # 2: count the steps to swap\\n        \\n        def get_swap_count(nums, nums0) -> int:\\n            count = 0\\n            for i in range(len(nums)):\\n                if nums[i] != nums0[i]:\\n                    \\n                    index = i + 1\\n                    while nums0[index] != nums[i]:\\n                        index += 1\\n\\n                    # print(i, index)\\n                    while index != i:\\n                        nums0[index], nums0[index-1] = nums0[index-1], nums0[index]\\n                        #print(\"after swap: \", (\"\").join(nums0))\\n                        count += 1\\n                        index -= 1\\n            return count\\n            \\n            \\n        \\n        def get_next_smart_num(nums) -> str:\\n            # find the rightest one to swap\\n            i = len(nums) - 2\\n            while i > 0 and int(nums[i]) >= int(nums[i+1]):\\n                i -= 1\\n            \\n            #print(\"first digit need to swap: \", nums[i])\\n            \\n            j = len(nums) - 1\\n            while int(nums[j]) <= int(nums[i]):\\n                j -= 1\\n            \\n            #print(\"second digit need to swap with first one: \", nums[j])\\n            \\n            # swap i an j\\n            nums[i], nums[j] = nums[j], nums[i]\\n            #print(\"after swapped: \", (\"\").join(nums))\\n            \\n            # we need to sort all digit after i\\n            nums = nums[:i+1] + sorted(nums[i+1:])\\n            #print(\"after sorted: \", (\"\").join(nums))\\n            \\n            return nums\\n        \\n        #print(\"original: \", num)\\n        nums = [c for c in num]\\n        nums0 = [c for c in num]\\n        for i in range(k):\\n            nums = get_next_smart_num(nums)\\n            #print(\"{}-th smart num is: {}\".format(i+1, (\"\").join(nums)))\\n            \\n        \\n        return get_swap_count(nums, nums0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n        # 1: get the kth value\\n        # 2: count the steps to swap\\n        \\n        def get_swap_count(nums, nums0) -> int:\\n            count = 0\\n            for i in range(len(nums)):\\n                if nums[i] != nums0[i]:\\n                    \\n                    index = i + 1\\n                    while nums0[index] != nums[i]:\\n                        index += 1\\n\\n                    # print(i, index)\\n                    while index != i:\\n                        nums0[index], nums0[index-1] = nums0[index-1], nums0[index]\\n                        #print(\"after swap: \", (\"\").join(nums0))\\n                        count += 1\\n                        index -= 1\\n            return count\\n            \\n            \\n        \\n        def get_next_smart_num(nums) -> str:\\n            # find the rightest one to swap\\n            i = len(nums) - 2\\n            while i > 0 and int(nums[i]) >= int(nums[i+1]):\\n                i -= 1\\n            \\n            #print(\"first digit need to swap: \", nums[i])\\n            \\n            j = len(nums) - 1\\n            while int(nums[j]) <= int(nums[i]):\\n                j -= 1\\n            \\n            #print(\"second digit need to swap with first one: \", nums[j])\\n            \\n            # swap i an j\\n            nums[i], nums[j] = nums[j], nums[i]\\n            #print(\"after swapped: \", (\"\").join(nums))\\n            \\n            # we need to sort all digit after i\\n            nums = nums[:i+1] + sorted(nums[i+1:])\\n            #print(\"after sorted: \", (\"\").join(nums))\\n            \\n            return nums\\n        \\n        #print(\"original: \", num)\\n        nums = [c for c in num]\\n        nums0 = [c for c in num]\\n        for i in range(k):\\n            nums = get_next_smart_num(nums)\\n            #print(\"{}-th smart num is: {}\".format(i+1, (\"\").join(nums)))\\n            \\n        \\n        return get_swap_count(nums, nums0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186993,
                "title": "c-next-permutation-with-idea-from-insertion-sort",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target = num;\\n        while(k--) next_permutation(begin(target), end(target));\\n        int res = 0, pos = 0;\\n        while(num != target) {\\n            if(num[pos] != target[pos]) {\\n                int find = target.find(num[pos], pos);\\n                while(find != pos) {\\n                    swap(target[find], target[find - 1]);\\n                    res++;\\n                    find--;\\n                }\\n            } \\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target = num;\\n        while(k--) next_permutation(begin(target), end(target));\\n        int res = 0, pos = 0;\\n        while(num != target) {\\n            if(num[pos] != target[pos]) {\\n                int find = target.find(num[pos], pos);\\n                while(find != pos) {\\n                    swap(target[find], target[find - 1]);\\n                    res++;\\n                    find--;\\n                }\\n            } \\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186972,
                "title": "c-next-permutation-count-inversions-simple",
                "content": "```\\nint countInv(vector<int>& arr, int n)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (arr[i] > arr[j])\\n                  count++;\\n \\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string next = num;\\n        while(k--){\\n            next_permutation(next.begin(),next.end());\\n        }\\n        vector<deque<int>> digits(10);\\n        for (int i =0;i<n;i++){\\n            digits[num[i]-\\'0\\'].push_back(i);\\n        }\\n        vector<int> arr;\\n        for (int i =0;i<n;i++){\\n            arr.push_back(digits[next[i]-\\'0\\'].front());\\n             digits[next[i]-\\'0\\'].pop_front();\\n        }\\n        return countInv(arr,(int)arr.size());\\n    }",
                "solutionTags": [],
                "code": "```\\nint countInv(vector<int>& arr, int n)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (arr[i] > arr[j])\\n                  count++;\\n \\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string next = num;\\n        while(k--){\\n            next_permutation(next.begin(),next.end());\\n        }\\n        vector<deque<int>> digits(10);\\n        for (int i =0;i<n;i++){\\n            digits[num[i]-\\'0\\'].push_back(i);\\n        }\\n        vector<int> arr;\\n        for (int i =0;i<n;i++){\\n            arr.push_back(digits[next[i]-\\'0\\'].front());\\n             digits[next[i]-\\'0\\'].pop_front();\\n        }\\n        return countInv(arr,(int)arr.size());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1218613,
                "title": "c-1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) \\n            next_permutation(perm.begin(), perm.end()); \\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[++ii]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) {\\n            for (int i = perm.size()-1; i > 0; --i) {\\n                if (perm[i-1] < perm[i]) {\\n                    int ii = i, j = perm.size()-1; \\n                    for (; ii < perm.size() && perm[i-1] < perm[ii]; ++ii); \\n                    swap(perm[i-1], perm[ii-1]); \\n                    while (i < j) swap(perm[i++], perm[j--]); \\n                    break; \\n                } \\n            }\\n        }\\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[ii++]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) \\n            next_permutation(perm.begin(), perm.end()); \\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[++ii]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) {\\n            for (int i = perm.size()-1; i > 0; --i) {\\n                if (perm[i-1] < perm[i]) {\\n                    int ii = i, j = perm.size()-1; \\n                    for (; ii < perm.size() && perm[i-1] < perm[ii]; ++ii); \\n                    swap(perm[i-1], perm[ii-1]); \\n                    while (i < j) swap(perm[i++], perm[j--]); \\n                    break; \\n                } \\n            }\\n        }\\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[ii++]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195404,
                "title": "the-fastest-100-python-solution-52ms-60ms",
                "content": "Rather than doing `k` iterations of `next_permutation`, we can find the permutation number of `num`. That is out of all permutations of the digits in `num` where does this one fall. E.g. for `num` is `213`, all permutations of `1`, `2`, and `3`, in order, are:\\n\\n`123`\\n`132`\\n`213` <- the `2`th permutation\\n`231`\\n`312`\\n`321`\\n\\nNow that we know the `p`, the permutation number of `num` (in this case it\\'s `2`), we need to find the `p+k`th permutation of `1`, `2`, and `3`.\\n\\nBoth, `permutation_num` and `ith_permutation` can be done mathematically, though special care must be taken to account for duplicities of digits.\\n\\nActually, what I\\'ve done below with my code is a bit more clever than what I described above, though the above would certainly work, what I\\'ve done is faster: Instead of finding the permutation number of the entire `num`, I expand `num` from the back, computing at each turn, `p` the permutation number of `str(num)[L:]` and also `P` the total number of possible permutations of the digits in `str(num)[L:]`. I decrement `L` until I have reached a `p` and `P` s.t. `p + k < P`, then I can stop expanding. Now I just need to find the `p+k`th permutation of `str(num)[L:]`. At the end I compare `str(num)[L:]` and `ith_permutation(str(num)[L:], p+k)` to find the min number of adjacent swaps.\\n\\n```\\n# By joseville\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        A = str(num)\\n        \"\"\"\\n        Given a permutation `A`, find the permutation that is `k` positions after `A`.\\n        \"\"\"\\n        L = len(A) - 1\\n        N = 1\\n        C = Counter(A[L:])\\n        O = [A[L]]\\n\\n        F = 1\\n        PCF = 1\\n\\n        P = F // PCF # num of `N`-permutations of `A[L:]`\\n        p = 0\\n        L -= 1\\n        while L >= 0 and p + k >= P:\\n            b = A[L]\\n            C[b] += 1\\n            PCF *= C[b]\\n\\n            p_prev = 0\\n            j = bisect_left(O, b)\\n            if j == len(O) or O[j] != b:\\n                O.insert(j, b)\\n            for i in range(j):\\n                a = O[i]\\n                Ca = C[a]\\n                p_prev += (F * Ca) // PCF\\n\\n            N += 1\\n            F *= N\\n\\n            P = F // PCF\\n            p += p_prev\\n            L -= 1\\n\\n        if p + k >= P:\\n            return None\\n\\n        L += 1\\n        F //= N\\n        perm = []\\n        perm_num = 0\\n        PERM_NUM = p + k\\n        while perm_num != PERM_NUM:\\n            for i in range(len(O)):\\n                a = O[i]\\n                Ca = C[a]\\n\\n                # num of `N`-permutations starting with `a`\\n                a_perms = (F * Ca) // PCF\\n                if (pn := perm_num + a_perms) <= PERM_NUM:\\n                    perm_num = pn\\n                    continue\\n                if pn == PERM_NUM:\\n                    perm_num = PERM_NUM\\n                    i += 1\\n                    a = O[i]\\n                N -= 1\\n                F //= N\\n                PCF //= C[a]\\n                perm.append(a)\\n                C[a] -= 1\\n                if not C[a]:\\n                    # del C[a]\\n                    O.pop(i)\\n                break\\n\\n        # perm_num == PERM_NUM\\n\\n        # traverse the remaining elements in increasing order\\n        # appending them to ans\\n        for a in O:\\n            perm += [a] * C[a]\\n\\n        perm_plus_k = perm\\n        swaps = 0\\n        for i in range(len(perm)):\\n            swaps += (j := perm_plus_k.index(A[L+i]))\\n            perm_plus_k.pop(j)\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\n# By joseville\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        A = str(num)\\n        \"\"\"\\n        Given a permutation `A`, find the permutation that is `k` positions after `A`.\\n        \"\"\"\\n        L = len(A) - 1\\n        N = 1\\n        C = Counter(A[L:])\\n        O = [A[L]]\\n\\n        F = 1\\n        PCF = 1\\n\\n        P = F // PCF # num of `N`-permutations of `A[L:]`\\n        p = 0\\n        L -= 1\\n        while L >= 0 and p + k >= P:\\n            b = A[L]\\n            C[b] += 1\\n            PCF *= C[b]\\n\\n            p_prev = 0\\n            j = bisect_left(O, b)\\n            if j == len(O) or O[j] != b:\\n                O.insert(j, b)\\n            for i in range(j):\\n                a = O[i]\\n                Ca = C[a]\\n                p_prev += (F * Ca) // PCF\\n\\n            N += 1\\n            F *= N\\n\\n            P = F // PCF\\n            p += p_prev\\n            L -= 1\\n\\n        if p + k >= P:\\n            return None\\n\\n        L += 1\\n        F //= N\\n        perm = []\\n        perm_num = 0\\n        PERM_NUM = p + k\\n        while perm_num != PERM_NUM:\\n            for i in range(len(O)):\\n                a = O[i]\\n                Ca = C[a]\\n\\n                # num of `N`-permutations starting with `a`\\n                a_perms = (F * Ca) // PCF\\n                if (pn := perm_num + a_perms) <= PERM_NUM:\\n                    perm_num = pn\\n                    continue\\n                if pn == PERM_NUM:\\n                    perm_num = PERM_NUM\\n                    i += 1\\n                    a = O[i]\\n                N -= 1\\n                F //= N\\n                PCF //= C[a]\\n                perm.append(a)\\n                C[a] -= 1\\n                if not C[a]:\\n                    # del C[a]\\n                    O.pop(i)\\n                break\\n\\n        # perm_num == PERM_NUM\\n\\n        # traverse the remaining elements in increasing order\\n        # appending them to ans\\n        for a in O:\\n            perm += [a] * C[a]\\n\\n        perm_plus_k = perm\\n        swaps = 0\\n        for i in range(len(perm)):\\n            swaps += (j := perm_plus_k.index(A[L+i]))\\n            perm_plus_k.pop(j)\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927080,
                "title": "c-faster-than-95-two-pointer-greedy-very-easy-approach-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s = num;\\n\\n        int res = 0;\\n\\n        while(k--) next_permutation(s.begin(),s.end());\\n\\n    \\n        for(int i = 0; i < num.size(); ++i)\\n        {\\n            if(num[i] != s[i])\\n            {\\n               int j = i + 1;\\n\\n               while(num[j] != s[i]) j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   res++;\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s = num;\\n\\n        int res = 0;\\n\\n        while(k--) next_permutation(s.begin(),s.end());\\n\\n    \\n        for(int i = 0; i < num.size(); ++i)\\n        {\\n            if(num[i] != s[i])\\n            {\\n               int j = i + 1;\\n\\n               while(num[j] != s[i]) j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   res++;\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602968,
                "title": "not-so-easy-but-understandable-python-solution-explained",
                "content": "This is a difficult question so lets understand it in parts:\\n1. Finding the next permutation: Its explained over here: https://leetcode.com/problems/next-permutation/discuss/2602889/Simple-python-solution-with-comments-or-O(n)-or-Explained\\n\\n2. Finding the number of swaps: Once we get the proper permutation, we compare every index between the original and the permuation. If we find any mismatch in a given index, we try to make the permutation equal to the original, so we find the index in the permutation where the original number exists at a given position and pop it and insert it in the current index. The difference between this found index and the current index is the number of swaps needed, so we add it to the answer. We repeat it untill we get back the original string.\\n\\nUpvote if you understood the logic :)\\n\\n```\\nclass Solution:\\n    def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2\\n\\n            while i > -1 and nums[i] >= nums[i + 1]:\\n                i -= 1\\n\\n            j = len(nums) - 1\\n\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n\\n            nums[i], nums[j] = nums[j], nums[i]\\n            nums[i + 1:] = reversed(nums[i + 1:])\\n            return nums\\n\\n        nums = list(orig)\\n        res = None\\n\\n        for _ in range(k):\\n            res = nextPermutation(nums)\\n\\n        ans = i = 0\\n\\t\\t# finding the number of swaps needed\\n        while i < len(res) - 1:\\n            if res[i] != orig[i]:\\n                index = res.index(orig[i], i + 1)\\n                res.insert(i, res.pop(index))\\n                ans += index - i\\n\\n            i += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2\\n\\n            while i > -1 and nums[i] >= nums[i + 1]:\\n                i -= 1\\n\\n            j = len(nums) - 1\\n\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n\\n            nums[i], nums[j] = nums[j], nums[i]\\n            nums[i + 1:] = reversed(nums[i + 1:])\\n            return nums\\n\\n        nums = list(orig)\\n        res = None\\n\\n        for _ in range(k):\\n            res = nextPermutation(nums)\\n\\n        ans = i = 0\\n\\t\\t# finding the number of swaps needed\\n        while i < len(res) - 1:\\n            if res[i] != orig[i]:\\n                index = res.index(orig[i], i + 1)\\n                res.insert(i, res.pop(index))\\n                ans += index - i\\n\\n            i += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126764,
                "title": "easy-cpp-code-explained-line-by-line-cpp-adjacent-swap-logic",
                "content": "```\\nclass Solution {\\n    void nextpermut(string &s)\\n    {\\n        int i = s.size()-1;\\n        int k,l;\\n        //find first element less than its next from the last\\n        for(k=s.size()-2;k>=0;k--)\\n        {\\n            if(s[k]<s[k+1]) break;\\n        }\\n        if (k < 0) return ;\\n        \\n        //find first element which is greater than the element found from the last\\n        for(l=s.size()-1;l>k;l--)\\n        {\\n            if(s[k]<s[l]) break;\\n        }\\n        swap(s[k], s[l]);\\n        reverse(s.begin()+k+1, s.end());\\n        \\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s=num;        \\n        while(k--)\\n        {\\n            nextpermut(s);\\n        }\\n        int count=0;\\n        int i=0,j=0;\\n        while(i<num.size() and j<num.size())\\n        {\\n            if(num[i]!=s[i])\\n            {\\n                int c=j;\\n                //finding element where can we perform swap\\n                while(s[c]!=num[i] and c<num.size())\\n                {\\n                    c++;\\n                    count++;\\n                }\\n                //making the swaps \\n                while(c!=j) {\\n                    swap(s[c],s[c-1]);\\n                    c--;\\n                }\\n                \\n            }\\n            i++;\\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    void nextpermut(string &s)\\n    {\\n        int i = s.size()-1;\\n        int k,l;\\n        //find first element less than its next from the last\\n        for(k=s.size()-2;k>=0;k--)\\n        {\\n            if(s[k]<s[k+1]) break;\\n        }\\n        if (k < 0) return ;\\n        \\n        //find first element which is greater than the element found from the last\\n        for(l=s.size()-1;l>k;l--)\\n        {\\n            if(s[k]<s[l]) break;\\n        }\\n        swap(s[k], s[l]);\\n        reverse(s.begin()+k+1, s.end());\\n        \\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s=num;        \\n        while(k--)\\n        {\\n            nextpermut(s);\\n        }\\n        int count=0;\\n        int i=0,j=0;\\n        while(i<num.size() and j<num.size())\\n        {\\n            if(num[i]!=s[i])\\n            {\\n                int c=j;\\n                //finding element where can we perform swap\\n                while(s[c]!=num[i] and c<num.size())\\n                {\\n                    c++;\\n                    count++;\\n                }\\n                //making the swaps \\n                while(c!=j) {\\n                    swap(s[c],s[c-1]);\\n                    c--;\\n                }\\n                \\n            }\\n            i++;\\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509907,
                "title": "easy-to-understand-with-explanation",
                "content": "**Prerequisites : The next_permutation() function in C++ STL. This function basically changes the string or array to the next greater permutation of the current state.**\\n\\nWe use the next_permutation function on the string k times. Once we have the kth permutation, all we have to do it to count the number of swaps. \\n* For this we use two pointer i and j, and at any instance where num[i] != src[j], we increase the value of j until num[i] == src[j].\\n* Then we have to perform the swapsif the adj elements until j == i and simultaneously count the number of swaps too.\\n**This is the greedy approach for this question**\\n\\n**Time Complexity : O(N * N)**\\n**Space Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\nPlease do upvote if you like the explanation.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1467322,
                "title": "python-3-permutation-brute-force-explanation",
                "content": "### Explanation\\n- Essentailly [31. Next Permutation](https://leetcode.com/problems/next-permutation/) + Brute Force on finding swaps\\n- See below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def next_permutation(nums):\\n            small = len(nums) - 2\\n            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 # find last place there is an increase\\n            if small == -1: nums.reverse()                                # mono-decrease\\n            else:\\n                next_larger = small+1\\n                for i in range(len(nums)-1, small, -1):\\n                    # find smallest number larger than `nums[small]` from right side of `small`, \\n                    #   if there are same value, take the most right one\\n                    if nums[small] < nums[i]: next_larger = i; break\\n                nums[small], nums[next_larger] = nums[next_larger], nums[small]\\n                start = small+1\\n                nums[start:] = nums[start:][::-1]\\n            return nums\\n\\n        origin, num = list(num), list(num)\\n        for _ in range(k):                    # O(n*k)\\n            num = next_permutation(num)\\n        ans, n = 0, len(origin)\\n        for i in range(n):                    # O(n*n)\\n            j = num.index(origin[i], i)\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def next_permutation(nums):\\n            small = len(nums) - 2\\n            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 # find last place there is an increase\\n            if small == -1: nums.reverse()                                # mono-decrease\\n            else:\\n                next_larger = small+1\\n                for i in range(len(nums)-1, small, -1):\\n                    # find smallest number larger than `nums[small]` from right side of `small`, \\n                    #   if there are same value, take the most right one\\n                    if nums[small] < nums[i]: next_larger = i; break\\n                nums[small], nums[next_larger] = nums[next_larger], nums[small]\\n                start = small+1\\n                nums[start:] = nums[start:][::-1]\\n            return nums\\n\\n        origin, num = list(num), list(num)\\n        for _ in range(k):                    # O(n*k)\\n            num = next_permutation(num)\\n        ans, n = 0, len(origin)\\n        for i in range(n):                    # O(n*n)\\n            j = num.index(origin[i], i)\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188352,
                "title": "javascript-next-permutation-w-explanation",
                "content": "```javascript\\nvar getMinSwaps = function(num, k) {\\n    \\n    const digits = [...num]\\n    const len = digits.length;\\n    \\n    // helper function to swap elements in digits in place\\n    const swap = (i, j) => [digits[i], digits[j]] = [digits[j], digits[i]]\\n    \\n    // helper function to reverse elements in digits from i to the end of digits\\n    const reverse = (i) => {\\n        for (let j = len - 1; i < j; ++i && --j) {\\n            swap(i, j);\\n        }\\n    }\\n    \\n    // helper to get the next smallest permutation for digits\\n    const nextPermutation = () => {\\n        // from right to left, find the first decreasing index\\n        // in digits and store it as i\\n        let i = len - 2;\\n        while (digits[i] >= digits[i + 1]) {\\n            i--;\\n        }\\n        \\n        // from right to left, find the first index in digits\\n        // that is greater than element at i\\n        let j = len - 1;\\n        while (digits[j] <= digits[i]) {\\n            j--;\\n        }\\n        \\n        // swap the 2 elements at i and j\\n        swap(i, j);\\n        // reverse all elements after i because we know that\\n        // all elements after i are in ascending order\\n        // from right to left\\n        reverse(i + 1);\\n    }\\n    \\n    // find the next permutation k times\\n    for (let i = 0; i < k; i++) {\\n        nextPermutation();\\n    }\\n\\n    // find out how many swaps it will take to get to the\\n    // kth permutation by finding out how many swaps\\n    // it takes to put digits back to its original state\\n    let numSwaps = 0;\\n    for (let i = 0; i < len; i++) {\\n        let j = i;\\n        // find the first element in digits to matches\\n        // num[i] and hold its place at j\\n        while (num[i] !== digits[j]) {\\n            j++;\\n        }\\n        \\n        // move the element at j to i while counting the\\n        // number of swaps\\n        while (i < j) {\\n            swap(j, j - 1);\\n            numSwaps++;\\n            j--;\\n        }\\n    }\\n    return numSwaps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getMinSwaps = function(num, k) {\\n    \\n    const digits = [...num]\\n    const len = digits.length;\\n    \\n    // helper function to swap elements in digits in place\\n    const swap = (i, j) => [digits[i], digits[j]] = [digits[j], digits[i]]\\n    \\n    // helper function to reverse elements in digits from i to the end of digits\\n    const reverse = (i) => {\\n        for (let j = len - 1; i < j; ++i && --j) {\\n            swap(i, j);\\n        }\\n    }\\n    \\n    // helper to get the next smallest permutation for digits\\n    const nextPermutation = () => {\\n        // from right to left, find the first decreasing index\\n        // in digits and store it as i\\n        let i = len - 2;\\n        while (digits[i] >= digits[i + 1]) {\\n            i--;\\n        }\\n        \\n        // from right to left, find the first index in digits\\n        // that is greater than element at i\\n        let j = len - 1;\\n        while (digits[j] <= digits[i]) {\\n            j--;\\n        }\\n        \\n        // swap the 2 elements at i and j\\n        swap(i, j);\\n        // reverse all elements after i because we know that\\n        // all elements after i are in ascending order\\n        // from right to left\\n        reverse(i + 1);\\n    }\\n    \\n    // find the next permutation k times\\n    for (let i = 0; i < k; i++) {\\n        nextPermutation();\\n    }\\n\\n    // find out how many swaps it will take to get to the\\n    // kth permutation by finding out how many swaps\\n    // it takes to put digits back to its original state\\n    let numSwaps = 0;\\n    for (let i = 0; i < len; i++) {\\n        let j = i;\\n        // find the first element in digits to matches\\n        // num[i] and hold its place at j\\n        while (num[i] !== digits[j]) {\\n            j++;\\n        }\\n        \\n        // move the element at j to i while counting the\\n        // number of swaps\\n        while (i < j) {\\n            swap(j, j - 1);\\n            numSwaps++;\\n            j--;\\n        }\\n    }\\n    return numSwaps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186968,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef getMinSwaps(self, num: str, k: int) -> int:\\n\\t\\t\\tnums = list(num)\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tl = -1\\n\\t\\t\\t\\tfor j in range(len(nums) - 2, -1, -1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[j + 1]:\\n\\t\\t\\t\\t\\t\\tl = j\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif l == -1:\\n\\t\\t\\t\\t\\tnums.reverse()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = len(nums) - 1\\n\\t\\t\\t\\t\\tfor j in range(len(nums) - 1, -1, -1):\\n\\t\\t\\t\\t\\t\\tif nums[j] > nums[l]:\\n\\t\\t\\t\\t\\t\\t\\tnums[l], nums[j] = nums[j], nums[l]\\n\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\twhile l < r:\\n\\t\\t\\t\\t\\t\\t\\t\\tnums[l], nums[r] = nums[r], nums[l]\\n\\t\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] != num[i]:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < len(nums) and nums[i] != num[j]:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres += j - i\\n\\t\\t\\t\\t\\tnum = num[:i] + num[j] + num[i:j] + num[j + 1:]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef getMinSwaps(self, num: str, k: int) -> int:\\n\\t\\t\\tnums = list(num)\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tl = -1\\n\\t\\t\\t\\tfor j in range(len(nums) - 2, -1, -1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[j + 1]:\\n\\t\\t\\t\\t\\t\\tl = j\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif l == -1:\\n\\t\\t\\t\\t\\tnums.reverse()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = len(nums) - 1\\n\\t\\t\\t\\t\\tfor j in range(len(nums) - 1, -1, -1):\\n\\t\\t\\t\\t\\t\\tif nums[j] > nums[l]:\\n\\t\\t\\t\\t\\t\\t\\tnums[l], nums[j] = nums[j], nums[l]\\n\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\twhile l < r:\\n\\t\\t\\t\\t\\t\\t\\t\\tnums[l], nums[r] = nums[r], nums[l]\\n\\t\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] != num[i]:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < len(nums) and nums[i] != num[j]:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres += j - i\\n\\t\\t\\t\\t\\tnum = num[:i] + num[j] + num[i:j] + num[j + 1:]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 3170241,
                "title": "c-greedy-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought to solve this problem is to use a greedy algorithm. We can keep track of the number of swaps we need to make by looping through the two strings and swapping any characters that are out of order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a greedy algorithm. We will loop through both strings and keep track of the number of swaps we need to make. To do this, we will compare the characters of each string and swap any that are out of order. We will continue this loop until all the characters are in the correct order.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while (k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] == s[i]) continue;\\n            for (int j = i + 1; j < num.size(); j++) {\\n                if (num[j] == s[i]) {\\n                    ans += j - i;\\n                    while (j > i) {\\n                        swap(num[j], num[j - 1]);\\n                        j--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while (k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] == s[i]) continue;\\n            for (int j = i + 1; j < num.size(); j++) {\\n                if (num[j] == s[i]) {\\n                    ans += j - i;\\n                    while (j > i) {\\n                        swap(num[j], num[j - 1]);\\n                        j--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2209103,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        return this.sol(num,k);\\n    }\\n    public int sol(String s,int k) {\\n        char[] array = s.toCharArray();\\n        for(int i =0; i< k;i++) {\\n            s = new String(this.nextPermuatation(s));\\n        }\\n        int count =0;\\n        char[] arrayor = s.toCharArray();\\n        int  i =0,j =0;\\n        while(i <= s.length() - 1) {\\n            if(arrayor[i] == array[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                char temp  = arrayor[i];\\n                while(array[j] != temp && j <= s.length() - 1) {\\n                    j++;\\n                }\\n                while(j >= (i + 1)) {\\n                    char tmp = array[j];\\n                    array[j] = array[j - 1];\\n                    array[j - 1] = tmp;\\n                    j--;\\n                    count = count + 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public char[] nextPermuatation(String s) {\\n        char[] chararray = s.toCharArray();\\n        int i;\\n        for(i  =s.length() - 1;i >= 1;i--) {\\n            if(chararray[i - 1] - \\'0\\' < chararray[i] - \\'0\\') {\\n                break;\\n            }\\n        }\\n        if(i > 0) {\\n            int storer = i - 1;\\n            int great = chararray.length - 1;\\n            for(int j = chararray.length - 1;j > storer;j--) {\\n                if(chararray[j] > chararray[storer]) {\\n                    great = j;\\n                    break;\\n                }\\n            }\\n            char temp = chararray[storer];\\n            chararray[storer] = chararray[great];\\n            chararray[great] = temp;\\n            int lower = storer + 1;\\n            int higher = chararray.length - 1;\\n            while(lower < higher) {\\n                char e = chararray[lower];\\n                chararray[lower] = chararray[higher];\\n                chararray[higher] = e;\\n                lower++;\\n                higher--;\\n            }\\n        }\\n        return chararray;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        return this.sol(num,k);\\n    }\\n    public int sol(String s,int k) {\\n        char[] array = s.toCharArray();\\n        for(int i =0; i< k;i++) {\\n            s = new String(this.nextPermuatation(s));\\n        }\\n        int count =0;\\n        char[] arrayor = s.toCharArray();\\n        int  i =0,j =0;\\n        while(i <= s.length() - 1) {\\n            if(arrayor[i] == array[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                char temp  = arrayor[i];\\n                while(array[j] != temp && j <= s.length() - 1) {\\n                    j++;\\n                }\\n                while(j >= (i + 1)) {\\n                    char tmp = array[j];\\n                    array[j] = array[j - 1];\\n                    array[j - 1] = tmp;\\n                    j--;\\n                    count = count + 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public char[] nextPermuatation(String s) {\\n        char[] chararray = s.toCharArray();\\n        int i;\\n        for(i  =s.length() - 1;i >= 1;i--) {\\n            if(chararray[i - 1] - \\'0\\' < chararray[i] - \\'0\\') {\\n                break;\\n            }\\n        }\\n        if(i > 0) {\\n            int storer = i - 1;\\n            int great = chararray.length - 1;\\n            for(int j = chararray.length - 1;j > storer;j--) {\\n                if(chararray[j] > chararray[storer]) {\\n                    great = j;\\n                    break;\\n                }\\n            }\\n            char temp = chararray[storer];\\n            chararray[storer] = chararray[great];\\n            chararray[great] = temp;\\n            int lower = storer + 1;\\n            int higher = chararray.length - 1;\\n            while(lower < higher) {\\n                char e = chararray[lower];\\n                chararray[lower] = chararray[higher];\\n                chararray[higher] = e;\\n                lower++;\\n                higher--;\\n            }\\n        }\\n        return chararray;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975125,
                "title": "easy-solution-using-c",
                "content": "```\\n\\n``\\n`class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1954087,
                "title": "java-easy-solution",
                "content": "### **Used next Permutation Problem to solve this one.**\\n#### next Permutation Problem Link : https://leetcode.com/problems/next-permutation/\\n\\n\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums=new int[num.length()];\\n        int[] org=new int[num.length()];\\n        \\n        for(int i=0;i<num.length();i++){\\n            int e=Character.getNumericValue(num.charAt(i));\\n            nums[i]=e;\\n            org[i]=e;\\n        }\\n        \\n        while(k!=0){\\n        nextPermutation(nums);\\n         k--;   \\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n             \\n            if(nums[i]!=org[i]){\\n                int j=0;\\n                for(j=i+1;j<nums.length;j++)\\n                    if(org[j]==nums[i])\\n                        break;\\n             \\n                while(j>0 && j!=i){\\n                    swap(org,j,j-1);\\n                    ans++;\\n                    j--;\\n                }\\n                \\n            }\\n            \\n  \\n    }\\n           \\n      return ans;    \\n\\n    }\\n    \\n    \\npublic void nextPermutation(int[] nums) {\\n        \\n        if(nums.length<=1)\\n            return;\\n         \\n        int j=nums.length-2;\\n       while(j>=0 && nums[j]>=nums[j+1])\\n           j--;\\n        \\n        if(j>=0){\\n        int k=nums.length-1;\\n        while(nums[j]>=nums[k])\\n            k--;\\n    \\n        swap(nums,j,k);\\n        \\n        }\\n        \\n        reverse(nums,j+1,nums.length-1);\\n    \\n      \\n    }\\n    \\n    public void swap(int[] nums,int j,int k){\\n        int temp=nums[j];\\n            nums[j]=nums[k];\\n            nums[k]=temp;\\n    }\\n    \\n    public void reverse(int[] nums,int i,int j){\\n        while(i<=j){\\n            swap(nums,i,j);\\n                i++;\\n                j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums=new int[num.length()];\\n        int[] org=new int[num.length()];\\n        \\n        for(int i=0;i<num.length();i++){\\n            int e=Character.getNumericValue(num.charAt(i));\\n            nums[i]=e;\\n            org[i]=e;\\n        }\\n        \\n        while(k!=0){\\n        nextPermutation(nums);\\n         k--;   \\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n             \\n            if(nums[i]!=org[i]){\\n                int j=0;\\n                for(j=i+1;j<nums.length;j++)\\n                    if(org[j]==nums[i])\\n                        break;\\n             \\n                while(j>0 && j!=i){\\n                    swap(org,j,j-1);\\n                    ans++;\\n                    j--;\\n                }\\n                \\n            }\\n            \\n  \\n    }\\n           \\n      return ans;    \\n\\n    }\\n    \\n    \\npublic void nextPermutation(int[] nums) {\\n        \\n        if(nums.length<=1)\\n            return;\\n         \\n        int j=nums.length-2;\\n       while(j>=0 && nums[j]>=nums[j+1])\\n           j--;\\n        \\n        if(j>=0){\\n        int k=nums.length-1;\\n        while(nums[j]>=nums[k])\\n            k--;\\n    \\n        swap(nums,j,k);\\n        \\n        }\\n        \\n        reverse(nums,j+1,nums.length-1);\\n    \\n      \\n    }\\n    \\n    public void swap(int[] nums,int j,int k){\\n        int temp=nums[j];\\n            nums[j]=nums[k];\\n            nums[k]=temp;\\n    }\\n    \\n    public void reverse(int[] nums,int i,int j){\\n        while(i<=j){\\n            swap(nums,i,j);\\n                i++;\\n                j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928733,
                "title": "python-using-next-perm-with-explanation",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        #find kth\\n\\t\\ttarget=num\\n        for i in range(k):\\n            target=self.next_perm(target)\\n        \\n\\t\\t#count step\\n        res=0\\n        num=list(num)\\n        for i in range(len(num)):\\n            if num[i]!=target[i]:\\n                j=i\\n\\t\\t\\t\\t#num[j]==target[i]\\n                while num[j]!=target[i]:\\n                    j+=1\\n\\t\\t\\t\\t#swap (j-i) times\\n                while j>i:\\n                    num[j-1],num[j]=num[j],num[j-1]\\n                    res+=1\\n                    j-=1\\n        return res                    \\n        \\n    def next_perm(self,num):\\n        num=list(num)\\n        \\n        # find first non-ascending digit num[i-1] from right to left\\n        i=len(num)-1\\n        while i>0 and num[i-1]>=num[i]:\\n            i-=1\\n            \\n        # find first larger digit num[j] from right to left\\n        if i>0:\\n            for j in range(len(num)-1,i-1,-1):\\n                if num[j]>num[i-1]:\\n                    break        \\n        #swap\\n        num[i-1],num[j]=num[j],num[i-1]\\n        \\n        #reverse\\n        return \\'\\'.join(num[:i]+sorted(num[i:]))             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        #find kth\\n\\t\\ttarget=num\\n        for i in range(k):\\n            target=self.next_perm(target)\\n        \\n\\t\\t#count step\\n        res=0\\n        num=list(num)\\n        for i in range(len(num)):\\n            if num[i]!=target[i]:\\n                j=i\\n\\t\\t\\t\\t#num[j]==target[i]\\n                while num[j]!=target[i]:\\n                    j+=1\\n\\t\\t\\t\\t#swap (j-i) times\\n                while j>i:\\n                    num[j-1],num[j]=num[j],num[j-1]\\n                    res+=1\\n                    j-=1\\n        return res                    \\n        \\n    def next_perm(self,num):\\n        num=list(num)\\n        \\n        # find first non-ascending digit num[i-1] from right to left\\n        i=len(num)-1\\n        while i>0 and num[i-1]>=num[i]:\\n            i-=1\\n            \\n        # find first larger digit num[j] from right to left\\n        if i>0:\\n            for j in range(len(num)-1,i-1,-1):\\n                if num[j]>num[i-1]:\\n                    break        \\n        #swap\\n        num[i-1],num[j]=num[j],num[i-1]\\n        \\n        #reverse\\n        return \\'\\'.join(num[:i]+sorted(num[i:]))             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870500,
                "title": "c-nextpermutation-adjacent-swaps",
                "content": "**Approach**\\n\\n***Step 1***\\nwe will find the kth permutation by simply by finding the nextPermutation k times or by simply using the STL function given\\n\\n***Step 2***\\nnow we will find the adjacent swaps needed by comparing the original and permutated string\\nwe compare both the string and try to bring all the characters in the permutated string to the same index as in the original string by performing swaps\\n\\n--if nums[i] != dupl[j]\\nthen we find nums[i] in dupl string\\nnow we bring the character in dupl string to the ith index by swapping with adjacent elements and keep the count of swaps\\nwe repeat these steps till we reach the last index\\n**Code**\\n```\\nint getMinSwaps(string &nums, int k) {\\n        \\n        string dupl = kthPerm(nums,k);\\n        \\n        int n = nums.size();\\n        \\n        \\n        //adjacent swaps\\n        int j=0,swaps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            j=i;\\n            \\n            while(nums[i]!=dupl[j])\\n                j++;\\n            \\n            while(i<j)\\n            {\\n                swap(dupl[j],dupl[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            \\n        }\\n        return swaps;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nint getMinSwaps(string &nums, int k) {\\n        \\n        string dupl = kthPerm(nums,k);\\n        \\n        int n = nums.size();\\n        \\n        \\n        //adjacent swaps\\n        int j=0,swaps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            j=i;\\n            \\n            while(nums[i]!=dupl[j])\\n                j++;\\n            \\n            while(i<j)\\n            {\\n                swap(dupl[j],dupl[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            \\n        }\\n        return swaps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833927,
                "title": "simple-c-solution-next-permutation",
                "content": "# Approach:- \\n1.) First we will find the Kth largest permutation of the given string.\\n2.) we will calculate no. of swaps required to make original string to our ans string.\\n\\n**Approach to calculate minimum no. of swaps:-** \\nUse two pointers i and j for first and second strings respectively. Initialise i and j to 0. \\nIterate over the first string and find the position j such that s1[j] = s2[i] by incrementing the value to j. Keep on swapping the adjacent elements j and j \\u2013 1 and decrement j until it is greater than i. \\nNow the ith element of the first string is equal to the second string, hence increment the value of i. \\nThis technique will give the minimum number of steps as there are zero unnecessary swaps.\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        \\n        string ans = s;\\n        // Calculating Kth next permutation\\n        for(int i=0; i<k; i++) next_permutation(ans.begin(), ans.end());\\n        \\n        int count = 0;\\n        int i = 0, n = s.length();\\n        // Calculating swaps to convert string s to string ans\\n        while(i < n) {\\n            int j = i;\\n            while(s[j] != ans[i]) j++;\\n            while(i < j) {\\n                swap(s[j], s[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote it if you find it useful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        \\n        string ans = s;\\n        // Calculating Kth next permutation\\n        for(int i=0; i<k; i++) next_permutation(ans.begin(), ans.end());\\n        \\n        int count = 0;\\n        int i = 0, n = s.length();\\n        // Calculating swaps to convert string s to string ans\\n        while(i < n) {\\n            int j = i;\\n            while(s[j] != ans[i]) j++;\\n            while(i < j) {\\n                swap(s[j], s[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819177,
                "title": "c-simple-solution-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n          string p_String = num; \\n        while (k--) {\\n            next_permutation(p_String.begin(), p_String.end()); \\n        }\\n    \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != p_String[i]) {\\n                ++ans; \\n                swap(p_String[i], p_String[ii++]); \\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n          string p_String = num; \\n        while (k--) {\\n            next_permutation(p_String.begin(), p_String.end()); \\n        }\\n    \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != p_String[i]) {\\n                ++ans; \\n                swap(p_String[i], p_String[ii++]); \\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814110,
                "title": "c-easy-to-understand-simple-solution-using-next-permutation-o-n-2",
                "content": "Firstly, we find the next kth permutation using next_permutation which is an inbuilt function .\\nThen , we think greedily and try to put every digit to its correct position and count the swaps needed for each and place the digit in front and similarly traverse for the rest of the digits.\\n\\ne.g. we have num=1234 , k=5\\nthen the required number will be 1432\\nthen after first iteration it will remain the same as 1==1\\non 2!=4 we will count 2 swaps and put 4 in its correct position then num becomes 1423.. similarly we will do for the upcoming digits.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n       string a=num;\\n        int c=0;\\n        while(k--)\\n        {\\n          next_permutation(num.begin(),num.end());       //finding next kth permutation\\n        }\\n        int j;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]!=num[i])\\n            {\\n                for( j=i+1;j<a.length();j++)\\n                {\\n                     c++;                   // counting how much ahead the current digit is from its required position\\n                    if(num[i]==a[j])\\n                    {\\n                        break;\\n                    }\\n                }\\n                char t=a[j];\\n                for(int k=j-1;k>=i;k--) \\n                {\\n                    a[k+1]=a[k];                             //placing the digit to its correct position\\n                }\\n                a[i]=t;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\tThe above solution requires O(n^2) time...\\n\\tFeel free to comment below if you have any doubt :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n       string a=num;\\n        int c=0;\\n        while(k--)\\n        {\\n          next_permutation(num.begin(),num.end());       //finding next kth permutation\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1804193,
                "title": "c-next-permutation-and-greedy-swapping",
                "content": "\\t\\t\\tnext_permutation(s.begin(), s.end()) gives the next string which comes in the dictionary oder\\n            after the string s\\n            so for the kth smallest wonderful string, we have to go k places next\\n\\n            and then after that, we just have to find the minimum number of adjacent swaps required\\n            to convert the string nums to the string target (this can be done using two pointer method)\\n\\n            lets say we have to convert 3 4 5 -> 4 5 3\\n\\n            nums\\n            i\\n            3 4 5\\n\\n            target\\n            j\\n            4 5 3\\n            keep advancing j till you nums[i] and nums[j] become different\\n\\n            nums\\n            i\\n            3 4 5\\n\\n            target\\n                j\\n            4 5 3\\n\\n            now keep swapping to bring the guy at j to the position i in the target\\n\\n                j                      j                      j\\n            4 5 3 --> (swap and j--) 4 3 5 --> (swap and j--) 3 4 5\\n            now move i forward\\n\\n\\n            try one yourself by doing the dry run\\n\\n            3 4 5 --> 5 4 3\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string nums, int k) {\\n        \\n        // we want the kth smallest wonderful string first\\n\\n        string target = nums;\\n        while (k--) next_permutation(target.begin(), target.end());\\n\\n        int i = 0, j = 0;\\n        int len = nums.length();\\n\\n        while (i < len &&  nums[i] == target[j]) {\\n            i++; j++;\\n        }\\n        int swapCount = 0;\\n\\n        while (i < len) {\\n            j = i;\\n            while (j < len && nums[i] != target[j]) j++;\\n            while (j > i) {\\n                swap(target[j], target[j - 1]);\\n                j--; swapCount++;\\n            } i++;\\n\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string nums, int k) {\\n        \\n        // we want the kth smallest wonderful string first\\n\\n        string target = nums;\\n        while (k--) next_permutation(target.begin(), target.end());\\n\\n        int i = 0, j = 0;\\n        int len = nums.length();\\n\\n        while (i < len &&  nums[i] == target[j]) {\\n            i++; j++;\\n        }\\n        int swapCount = 0;\\n\\n        while (i < len) {\\n            j = i;\\n            while (j < len && nums[i] != target[j]) j++;\\n            while (j > i) {\\n                swap(target[j], target[j - 1]);\\n                j--; swapCount++;\\n            } i++;\\n\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641101,
                "title": "python-solution-with-explaination",
                "content": "Basically, we need to implement 2 algorithms here:\\n1. Get the next permutation.\\n2. Find the minimum adjacent swap to transfrom one string to another.\\n\\n```python\\nclass Solution:\\n    def next_permutation(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        returns the next permutation\\n        \"\"\"    \\n        # the size is 1, no next permutation\\n        if len(nums) == 1:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # search the first decrease\\n        found_i = False\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                found_i = True\\n                break\\n                \\n        # it\\'s sorted, no next permutation\\n        if not found_i:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # use the minimum among those greater than nums[i] for swapping\\n        to_swap = i + 1\\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i] and nums[j] < nums[to_swap]:\\n                to_swap = j\\n        nums[i], nums[to_swap] = nums[to_swap], nums[i]\\n        \\n        # sort the rest part to minimize it\\n        nums[i+1:] = sorted(nums[i+1:])\\n        return nums    \\n    \\n    def minimum_swap(self, s1: List[str], s2: List[str]) -> int:\\n        \"\"\"\\n        returns the minimum number of swaps\\n        \"\"\"        \\n        ret = 0\\n        p1, p2 = 0, 0\\n        while p2 < len(s2):\\n            if s1[p1] == s2[p2]:\\n                p1 += 1\\n                p2 += 1\\n            # not same, keep increasing p1 to get the target\\n            else:\\n                while True:\\n                    p1 += 1\\n                    if s1[p1] == s2[p2]:\\n                        ret += p1 - p2\\n                        # move s1[p1] to s1[p2], push the rest ahead\\n                        s1[p2:p1+1] = [s1[p1]] + s1[p2:p1]\\n                        break\\n                p2 += 1\\n                p1 = p2\\n        \\n        return ret\\n        \\n    \\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \"\"\"\\n        1. find the k-th next permutation\\n        2. find the num of swaps to take.\\n        \"\"\"\\n        origin = [x for x in num]\\n        target = [int(x) for x in num]\\n        \\n        # get the k-th next permutation\\n        for i in range(k):\\n            target = self.next_permutation(target)\\n\\n        # get the minimum swap\\n        target = [str(x) for x in target]\\n        return self.minimum_swap(origin, target)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def next_permutation(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        returns the next permutation\\n        \"\"\"    \\n        # the size is 1, no next permutation\\n        if len(nums) == 1:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # search the first decrease\\n        found_i = False\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                found_i = True\\n                break\\n                \\n        # it\\'s sorted, no next permutation\\n        if not found_i:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # use the minimum among those greater than nums[i] for swapping\\n        to_swap = i + 1\\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i] and nums[j] < nums[to_swap]:\\n                to_swap = j\\n        nums[i], nums[to_swap] = nums[to_swap], nums[i]\\n        \\n        # sort the rest part to minimize it\\n        nums[i+1:] = sorted(nums[i+1:])\\n        return nums    \\n    \\n    def minimum_swap(self, s1: List[str], s2: List[str]) -> int:\\n        \"\"\"\\n        returns the minimum number of swaps\\n        \"\"\"        \\n        ret = 0\\n        p1, p2 = 0, 0\\n        while p2 < len(s2):\\n            if s1[p1] == s2[p2]:\\n                p1 += 1\\n                p2 += 1\\n            # not same, keep increasing p1 to get the target\\n            else:\\n                while True:\\n                    p1 += 1\\n                    if s1[p1] == s2[p2]:\\n                        ret += p1 - p2\\n                        # move s1[p1] to s1[p2], push the rest ahead\\n                        s1[p2:p1+1] = [s1[p1]] + s1[p2:p1]\\n                        break\\n                p2 += 1\\n                p1 = p2\\n        \\n        return ret\\n        \\n    \\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \"\"\"\\n        1. find the k-th next permutation\\n        2. find the num of swaps to take.\\n        \"\"\"\\n        origin = [x for x in num]\\n        target = [int(x) for x in num]\\n        \\n        # get the k-th next permutation\\n        for i in range(k):\\n            target = self.next_permutation(target)\\n\\n        # get the minimum swap\\n        target = [str(x) for x in target]\\n        return self.minimum_swap(origin, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533970,
                "title": "c-solution-using-next-permutation-explained",
                "content": "First get the kth smallest using next_permutation.\\nCounting adjacent swaps:\\nIn a for loop, keep checking if `s[i]==t[i]`. In case `s[i]!=t[i]`, go ahead and find the index of that character in the `string t`. Now we need to bring that character to index i by swapping only adjacent characters. Do that in a while loop and keep incrementing the final answer.\\n```\\nint getMinSwaps(string s, int k) {\\n        int n = s.size();\\n        string t = s;\\n        while(k--)\\n            next_permutation(t.begin(),t.end());\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] != t[i])\\n            {\\n                int j=i+1;\\n                while(j<n && t[j] != s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(t[j],t[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMinSwaps(string s, int k) {\\n        int n = s.size();\\n        string t = s;\\n        while(k--)\\n            next_permutation(t.begin(),t.end());\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] != t[i])\\n            {\\n                int j=i+1;\\n                while(j<n && t[j] != s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(t[j],t[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466245,
                "title": "c-solution-with-comments-and-idea",
                "content": "\\n        //Idea is that find the next permutation for \"k\" times and then after that swap the\\n\\t\\t//characters untill the original string and permutation\\n\\t\\t//become equal and everytime u swap increment the count and once the strings become\\n\\t\\t//equal return count.\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        string res=num;\\n        for(int i=0;i<k;i++) next_permutation(num.begin(),num.end());\\n        int swap_count=0;\\n        for(int i=0;i<res.length();i++){\\n            if(res[i]!=num[i]){\\n                int start=i+1;   // search from i+1 index\\n                while(res[i]!=num[start]) start++;    //find the index to swap \\n                while(i!=start){\\n                    swap(num[start],num[start-1]);    // swap untill the characters are at same index\\n                    start--;\\n                    swap_count++;\\n                }\\n            }\\n        }\\n        return swap_count;\\n    }\\n}; \\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n        //Idea is that find the next permutation for \"k\" times and then after that swap the\\n\\t\\t//characters untill the original string and permutation\\n\\t\\t//become equal and everytime u swap increment the count and once the strings become\\n\\t\\t//equal return count.\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        string res=num;\\n        for(int i=0;i<k;i++) next_permutation(num.begin(),num.end());\\n        int swap_count=0;\\n        for(int i=0;i<res.length();i++){\\n            if(res[i]!=num[i]){\\n                int start=i+1;   // search from i+1 index\\n                while(res[i]!=num[start]) start++;    //find the index to swap \\n                while(i!=start){\\n                    swap(num[start],num[start-1]);    // swap untill the characters are at same index\\n                    start--;\\n                    swap_count++;\\n                }\\n            }\\n        }\\n        return swap_count;\\n    }\\n}; \\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1436453,
                "title": "python-a-bit-long-but-clear-comments",
                "content": "Split the issue into two parts\\n1. Find the number of kth smallest, this is same problem with leetcode  https://leetcode.com/problems/next-permutation/\\n2. Check how many steps needed to make the two numbers same. Use greedy\\nEg:  \\noriginal number:     $$$@=&=&=**\\ntarget number:       $$$=&&==@**\\nHow can you make them same: From the position which the number is different, always choose the cheaper cost(the nearest same character) to swap.\\n\\n$$$@=&=&=**  => $$$=@&=&=**  => $$$=&@=&=**  =>$$$=&&@==** => $$$=&&=@=** => $$$=&&==@**\\n\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target = [int(c) for c in list(num)]\\n        while k > 0:\\n            self.nextPermutation(target)\\n            k -= 1\\n        return self.minSwap([int(c) for c in list(num)], target)\\n\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        if n > 1:\\n            flag = False  # flag to check whether there is element exist that <\\n            for i in range(n - 1, -1, -1):\\n                if i >= 1 and nums[i - 1] < nums[i]:\\n                    flag = True\\n                    break\\n            if not flag:  # nums is descending order\\n                self.reverseList(nums, 0, n - 1)\\n            else:\\n                for j in range(n - 1, i - 1, -1):  # find first element bigger than i - 1 and swap\\n                    if nums[j] > nums[i - 1]:\\n                        break\\n                nums[i - 1], nums[j] = nums[j], nums[i - 1]\\n                self.reverseList(nums, i, n - 1)\\n\\n    def reverseList(self, nums, start, end) -> None:\\n        if end >= start + 1:\\n            i, j = start, end\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                j -= 1\\n\\n    def minSwap(self, origin, target) -> int:  # get the min swap steps to reach from origin to target\\n        if origin == target:\\n            return 0\\n        \\n        ans = 0\\n        org, tag = deque(origin), deque(target)\\n        while tag:\\n            while tag and org[0] == tag[0]:  # check from left, if elements are same pop\\n                org.popleft()\\n                tag.popleft()\\n\\n            if not tag:  # if tag is empty, no swap needed\\n                return ans\\n            else:  # tag differs from org                  \\n                for i in range(1, len(org)): # search in the orginal list from index 1 to find the nearest\\n                    if org[i] == tag[0]:                        \\n                        break  # find the same character\\n                for j in range(i - 1, -1, -1):  # move the characters in org, one by one\\n                    org[j + 1] = org[j]\\n                    ans += 1  # for each move, add 1 to ans\\n                org[0] = tag[0]\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target = [int(c) for c in list(num)]\\n        while k > 0:\\n            self.nextPermutation(target)\\n            k -= 1\\n        return self.minSwap([int(c) for c in list(num)], target)\\n\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        if n > 1:\\n            flag = False  # flag to check whether there is element exist that <\\n            for i in range(n - 1, -1, -1):\\n                if i >= 1 and nums[i - 1] < nums[i]:\\n                    flag = True\\n                    break\\n            if not flag:  # nums is descending order\\n                self.reverseList(nums, 0, n - 1)\\n            else:\\n                for j in range(n - 1, i - 1, -1):  # find first element bigger than i - 1 and swap\\n                    if nums[j] > nums[i - 1]:\\n                        break\\n                nums[i - 1], nums[j] = nums[j], nums[i - 1]\\n                self.reverseList(nums, i, n - 1)\\n\\n    def reverseList(self, nums, start, end) -> None:\\n        if end >= start + 1:\\n            i, j = start, end\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                j -= 1\\n\\n    def minSwap(self, origin, target) -> int:  # get the min swap steps to reach from origin to target\\n        if origin == target:\\n            return 0\\n        \\n        ans = 0\\n        org, tag = deque(origin), deque(target)\\n        while tag:\\n            while tag and org[0] == tag[0]:  # check from left, if elements are same pop\\n                org.popleft()\\n                tag.popleft()\\n\\n            if not tag:  # if tag is empty, no swap needed\\n                return ans\\n            else:  # tag differs from org                  \\n                for i in range(1, len(org)): # search in the orginal list from index 1 to find the nearest\\n                    if org[i] == tag[0]:                        \\n                        break  # find the same character\\n                for j in range(i - 1, -1, -1):  # move the characters in org, one by one\\n                    org[j + 1] = org[j]\\n                    ans += 1  # for each move, add 1 to ans\\n                org[0] = tag[0]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428734,
                "title": "c",
                "content": "```\\n\\n```public:\\n    int solve(string temp,string s)\\n    {\\n        int count=0,j;\\n        for(int i=0;i<temp.length();i++)\\n        {\\n            if(temp[i]!=s[i])\\n            {\\n                j=i+1;\\n                while(temp[i]!=s[j])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    count++;\\n                    swap(s[j-1],s[j]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k>0&&next_permutation(s.begin(),s.end()))\\n        {\\n            k--;\\n        }\\n        return solve(s,num);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379338,
                "title": "c-without-using-inbuilt-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void permutation(string &arr){\\n        int n = arr.size();\\n        int i;\\n        for(i = n-2;i>=0;i--){\\n            if(arr[i] < arr[i+1])\\n                break;\\n        }\\n        //it is guaranteed that a valid next permutation exists\\n        int j;\\n        for(j=n-1;j>i;j--){\\n            if(arr[j]>arr[i]) \\n                break;\\n        }\\n        swap(arr[i] , arr[j]);\\n        reverse(arr.begin() + i + 1 , arr.end());\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string val = num;\\n        while(k--)\\n            permutation(val);\\n        int ans = 0 , n = num.length();\\n\\t\\t//now compare num and val to find minimum number of adjancent swappings\\n\\t\\t//for each num[i] move it to its corresponding position in \\'val\\' by swapping adjacent elements.\\n\\t\\t//Count each such swap\\n        for(int i=0;i<n;i++){\\n            if(num[i] != val[i]) {\\n                int j = i+1;\\n                while(num[j] != val[i]) \\n                    j++;\\n                while(i<j) {\\n                    swap(num[j] , num[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void permutation(string &arr){\\n        int n = arr.size();\\n        int i;\\n        for(i = n-2;i>=0;i--){\\n            if(arr[i] < arr[i+1])\\n                break;\\n        }\\n        //it is guaranteed that a valid next permutation exists\\n        int j;\\n        for(j=n-1;j>i;j--){\\n            if(arr[j]>arr[i]) \\n                break;\\n        }\\n        swap(arr[i] , arr[j]);\\n        reverse(arr.begin() + i + 1 , arr.end());\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string val = num;\\n        while(k--)\\n            permutation(val);\\n        int ans = 0 , n = num.length();\\n\\t\\t//now compare num and val to find minimum number of adjancent swappings\\n\\t\\t//for each num[i] move it to its corresponding position in \\'val\\' by swapping adjacent elements.\\n\\t\\t//Count each such swap\\n        for(int i=0;i<n;i++){\\n            if(num[i] != val[i]) {\\n                int j = i+1;\\n                while(num[j] != val[i]) \\n                    j++;\\n                while(i<j) {\\n                    swap(num[j] , num[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282568,
                "title": "python-solution-skipping-factorials",
                "content": "\\tclass Solution(object):\\n\\t\\tdef getMinSwaps(self, num, k):\\n\\t\\t\\tn=len(num)\\n\\t\\t\\tdp={1:1}\\n\\t\\t\\tdpindex={}\\n\\t\\t\\tdef findPermutation(num,k,n):\\n\\t\\t\\t\\td={num[n-1]:1}\\n\\t\\t\\t\\tfor i in range(n-2,-1,-1):\\n\\t\\t\\t\\t\\tcurrent=num[i]\\n\\t\\t\\t\\t\\tif(current not in d):\\n\\t\\t\\t\\t\\t\\td[current]=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\td[current]+=1\\n\\t\\t\\t\\t\\tif(current<num[i+1]):\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tcurrent=num[i]    \\n\\t\\t\\t\\tfor j in range(n-1,i,-1):\\n\\t\\t\\t\\t\\tif(k==0):\\n\\t\\t\\t\\t\\t\\treturn num\\n\\t\\t\\t\\t\\tif(current<num[j]):\\n\\t\\t\\t\\t\\t\\tnum[i]=num[j]\\n\\t\\t\\t\\t\\t\\tnum[j]=current\\n\\t\\t\\t\\t\\t\\ttotal=1\\n\\t\\t\\t\\t\\t\\td[num[i]]-=1\\n\\t\\t\\t\\t\\t\\tfor z in d.values():\\n\\t\\t\\t\\t\\t\\t\\tif(z>1):\\n\\t\\t\\t\\t\\t\\t\\t\\ttotal*=factorial(z)\\n\\n\\t\\t\\t\\t\\t\\tfact=factorial(n-i-1)\\n\\t\\t\\t\\t\\t\\tfact=fact/total\\n\\t\\t\\t\\t\\t\\tif(fact==1 and k>1):\\n\\t\\t\\t\\t\\t\\t\\treturn findPermutation(num,k-1,n)\\n\\n\\t\\t\\t\\t\\t\\tif(fact<=k):\\n\\t\\t\\t\\t\\t\\t\\tk=k-fact\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tsnum=list(num)\\n\\t\\t\\t\\t\\t\\t\\tindex=i+1\\n\\t\\t\\t\\t\\t\\t\\tk=k-1\\n\\t\\t\\t\\t\\t\\t\\tfor m in range(n-1,i,-1):\\n\\t\\t\\t\\t\\t\\t\\t\\tnum[m]=snum[index]\\n\\t\\t\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\t\\treturn findPermutation(num,k,n)\\n\\n\\t\\t\\tdef factorial(number):\\n\\t\\t\\t\\tif(number in dp):\\n\\t\\t\\t\\t\\treturn dp[number]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans=number*factorial(number-1)\\n\\t\\t\\t\\t\\tdp[number]=ans\\n\\t\\t\\t\\t\\treturn ans\\n\\n\\n\\t\\t\\tdef findSwaps(inlist,z,index,n,swapCount):\\n\\t\\t\\t\\tif(index==n):\\n\\t\\t\\t\\t\\treturn swapCount\\n\\t\\t\\t\\tcurrent=inlist[index]\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tfor i in range(index,n):\\n\\t\\t\\t\\t\\tif(current==z[i]):\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\tfor j in range(i,index,-1):\\n\\t\\t\\t\\t\\t\\t\\ttemp=z[j-1]\\n\\t\\t\\t\\t\\t\\t\\tz[j-1]=z[j]\\n\\t\\t\\t\\t\\t\\t\\tz[j]=temp\\n\\t\\t\\t\\t\\t\\t\\tswapCount+=1\\n\\t\\t\\t\\t\\t\\treturn findSwaps(inlist,z,index+1,n,swapCount)\\n\\t\\t\\t\\tif(flag):\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tintlist=[]\\n\\t\\t\\tfor char in num:\\n\\t\\t\\t\\tintlist.append(int(char))\\n\\n\\t\\t\\tinlist=list(intlist)\\n\\t\\t\\tz=findPermutation(intlist,k,n)\\n\\t\\t\\tans=findSwaps(inlist,z,0,len(inlist),0)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef getMinSwaps(self, num, k):\\n\\t\\t\\tn=len(num)\\n\\t\\t\\tdp={1:1}",
                "codeTag": "Java"
            },
            {
                "id": 1231992,
                "title": "c-easy-solution-90-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string ll=num;\\n        while(k!=0)\\n        {\\n            next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<ll.size()-1;i++)\\n        {\\n            if(ll[i]!=num[i])\\n            {\\n                int j=i+1;\\n                while(j<ll.size() && num[i]!=ll[j])\\n                {\\n                    j++;\\n                }\\n                ans+=j-i;\\n                ll.insert(ll.begin()+i,num[i]);\\n                ll.erase(ll.begin()+j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string ll=num;\\n        while(k!=0)\\n        {\\n            next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<ll.size()-1;i++)\\n        {\\n            if(ll[i]!=num[i])\\n            {\\n                int j=i+1;\\n                while(j<ll.size() && num[i]!=ll[j])\\n                {\\n                    j++;\\n                }\\n                ans+=j-i;\\n                ll.insert(ll.begin()+i,num[i]);\\n                ll.erase(ll.begin()+j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204627,
                "title": "c-cpp-max-k-n-2-complexity",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        int arr[num.size()];\\n        string store = num;\\n        \\n        for(int i = 0; i < k; ++i){ //k!\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i = 0; i < num.size(); ++i){\\n            for(int j = 0; j < store.size(); ++j){ //n^2\\n                if(num[i] == store[j]){\\n                    arr[j] = i;\\n                    store[j] = \\'.\\';\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int inv_count = 0;\\n        multiset<int> mset;\\n        mset.insert(arr[num.size()-1]);\\n        //Finding inversion count\\n\\t\\t\\n        for(int i = num.size()-2; i >= 0; --i){//nlongn\\n            if(arr[i] > *mset.begin()){\\n                auto it = mset.begin();\\n                while(it != mset.end() and *it < arr[i]){\\n                    inv_count++, it++;\\n                }\\n            }\\n            mset.insert(arr[i]);\\n        }\\n        \\n        return inv_count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        int arr[num.size()];\\n        string store = num;\\n        \\n        for(int i = 0; i < k; ++i){ //k!\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1202160,
                "title": "python-permutation-indexchange",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num, k):\\n        \\n        def permutation(num,k):\\n            num=list(num)\\n            for i in range(k):\\n                j= len(num)-2\\n                while j>=0 and num[j]>=num[j+1]:\\n                    j-=1\\n                k= len(num)-1\\n                while num[k] <= num[j]:\\n                    k-=1\\n                \\n                num[k],num[j] = num[j],num[k]\\n                num=num[:j+1]+sorted(num[j+1:])\\n            return num\\n                \\n\\n        def indexcount(main,perm):\\n\\n            n = len(main)\\n            cnt=0\\n            for i in range(n):\\n                \\n                if main[i] != perm[i]:\\n                    \\n                    tmp = i+1\\n                    while main[i]!=perm[tmp]:\\n                        tmp+=1\\n\\n                    while i!=tmp:\\n                        perm[tmp], perm[tmp-1] = perm[tmp-1],perm[tmp]\\n                        tmp-=1\\n                        cnt+=1\\n\\n            return cnt\\n\\n        return indexcount(list(num),permutation(num,k))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num, k):\\n        \\n        def permutation(num,k):\\n            num=list(num)\\n            for i in range(k):\\n                j= len(num)-2\\n                while j>=0 and num[j]>=num[j+1]:\\n                    j-=1\\n                k= len(num)-1\\n                while num[k] <= num[j]:\\n                    k-=1\\n                \\n                num[k],num[j] = num[j],num[k]\\n                num=num[:j+1]+sorted(num[j+1:])\\n            return num\\n                \\n\\n        def indexcount(main,perm):\\n\\n            n = len(main)\\n            cnt=0\\n            for i in range(n):\\n                \\n                if main[i] != perm[i]:\\n                    \\n                    tmp = i+1\\n                    while main[i]!=perm[tmp]:\\n                        tmp+=1\\n\\n                    while i!=tmp:\\n                        perm[tmp], perm[tmp-1] = perm[tmp-1],perm[tmp]\\n                        tmp-=1\\n                        cnt+=1\\n\\n            return cnt\\n\\n        return indexcount(list(num),permutation(num,k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194245,
                "title": "simple-c-o-n-2-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        vector<int> nums;\\n        for (int i = 0; i < num.length(); i++)  nums.push_back(num[i] - \\'0\\');\\n        vector<int> temp = nums;\\n        int count = 0, len = nums.size();\\n        \\n        while (k--) {\\n            bool flag = false;\\n            for (int i = len - 1;  i >= 0; i--) {\\n                if ((i >= 1) && nums[i - 1] < nums[i]) {\\n                    i = i - 1;\\n                    flag = true;\\n                }\\n                if (flag) {\\n                    int maxi, idx;\\n                    maxi = nums[i + 1];\\n                    idx = i + 1;\\n                    for (int j = i + 1; j < len; j++) {\\n                        if (nums[j] > nums[i] && (maxi >= nums[j])) {\\n                            maxi = nums[j];\\n                            idx = j;\\n                        }   \\n                    }\\n                        swap(nums[i], nums[idx]);\\n                        sort(nums.begin() + i + 1, nums.end());\\n                        break;\\n                }\\n                flag = false;\\n            }\\n        }\\n        \\n        int id = 0;\\n        for (; id < nums.size(); id++) {\\n            if (temp[id] != nums[id])   break;\\n        }\\n        \\n        for (int i = id; i < nums.size(); i++) {\\n            //cout << nums[i] << endl;\\n            vector<int> :: iterator it = find(temp.begin() + i, temp.end(), nums[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, nums[id]);\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        vector<int> nums;\\n        for (int i = 0; i < num.length(); i++)  nums.push_back(num[i] - \\'0\\');\\n        vector<int> temp = nums;\\n        int count = 0, len = nums.size();\\n        \\n        while (k--) {\\n            bool flag = false;\\n            for (int i = len - 1;  i >= 0; i--) {\\n                if ((i >= 1) && nums[i - 1] < nums[i]) {\\n                    i = i - 1;\\n                    flag = true;\\n                }\\n                if (flag) {\\n                    int maxi, idx;\\n                    maxi = nums[i + 1];\\n                    idx = i + 1;\\n                    for (int j = i + 1; j < len; j++) {\\n                        if (nums[j] > nums[i] && (maxi >= nums[j])) {\\n                            maxi = nums[j];\\n                            idx = j;\\n                        }   \\n                    }\\n                        swap(nums[i], nums[idx]);\\n                        sort(nums.begin() + i + 1, nums.end());\\n                        break;\\n                }\\n                flag = false;\\n            }\\n        }\\n        \\n        int id = 0;\\n        for (; id < nums.size(); id++) {\\n            if (temp[id] != nums[id])   break;\\n        }\\n        \\n        for (int i = id; i < nums.size(); i++) {\\n            //cout << nums[i] << endl;\\n            vector<int> :: iterator it = find(temp.begin() + i, temp.end(), nums[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, nums[id]);\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191938,
                "title": "java-mathematical-solution",
                "content": "**Idea:**\\nRather than popular approach of \"next permutation\", I\\'m thinking about **\"next set of permutation\"**. It\\'s acually matematical problem to be solved. \\n\\nLet\\'s get started with \"49872\".\\n\\nWhat\\'s the next permutation\\uFF1F \\n72498\\n\\nHow do we get it? \\n1. We scan from right to left(2->7->8->9), and find the first digit which is less than its right(9->4)\\n2. Now we know we need to replace 4, but with what?\\n3. Replacement is the the least digit that is strictly greater than 4, which is 7\\n\\n**[Key question]** How many permutations are started with \"7\", then?\\nThe motivation is if the **number(n)** of permutation is less than k, we know target permutation can\\'t be started with 7. Thus, we skip to **next set of permutation** started with 8. Otherwise, we can be sure first digit is 7. Then do the same thing recursively.\\n\\nHow to calculate the number(n)?\\nAs I said, it\\'s time to test your math. \\n\\n72498?\\nn=**P**(4,4)=4!=24. Great!\\n724498?\\nn=**P**(5,5)/**P**(2,2) = 5!/2! = 60, where **P**(2,2) represents duplicate of 4\\n722449988?\\nn=**P**(8,8)/(**P**(2,2)***P**(2,2)***P**(2,2)***P**(2,2)) = 8!/(2!*2!*2!*2!)\\n\\nTherefore, we need Map to store digit and it\\'s frequence. Meawhile, it\\'s better to sort digit, so that it\\'s easier to get 7, 8, 9.\\nIn short, we need to TreeMap :)\\n\\nAbout Swap.\\nIt\\'s greedy algorithm core. Others have introduced that, we can skip it.\\n\\n\\n```\\nimport java.util.NavigableMap;\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int leftNum = 0;\\n        int left = 0;\\n\\t\\t//Get \"4\", and initialize map to be\\n\\t\\t//{2=1, 4=1, 7=1, 8=1, 9=1}\\n        for(int i=s.length()-1;i>=0;i--){\\n            int num=s.charAt(i)-\\'0\\';\\n            add(map, num);\\n            if(s.charAt(i-1)<s.charAt(i)){\\n                leftNum=s.charAt(i-1)-\\'0\\';\\n                left = i-1;\\n                add(map, leftNum);\\n                break;\\n            }\\n        }\\n        String res = helper(s.substring(0,left), map, k, leftNum);\\n        return count(s, res);\\n        \\n    }\\n    private String helper(String s, TreeMap<Integer, Integer> map, int k, int leftNum){\\n\\t\\t//Get sub map whose keys are greater than 4. {7=1, 8=1, 9=1}\\n        NavigableMap<Integer, Integer> tailMap = map.tailMap(leftNum, false);\\n        List<Integer> candidates = tailMap.keySet().stream().collect(Collectors.toList());\\n        for(int candidate:candidates){\\n\\t\\t    //if we get started with 7, we need to reduce 7\\'s frequence by 1.\\n            remove(map, candidate);\\n            int size = getSize(map);\\n            if(k>size){\\n                k-=size;\\n                add(map, candidate);\\n            }\\n            else if(k<size){\\n                char ch = (char)(candidate+\\'0\\');\\n                return helper(s+ch, map, k, -1);\\n            }\\n            else{\\n                char ch = (char)(candidate+\\'0\\');\\n                String part = \"\";\\n                for(Entry<Integer, Integer> e:map.entrySet()){\\n                    for(int i=0;i<e.getValue();i++){\\n                        part = e.getKey()+ part;\\n                    }\\n                }\\n                return s+ch+part;\\n            }\\n        }\\n\\t\\t// If we don\\'t find target, that means we need to move one more digit left\\n\\t\\t// 49872 -> *49872\\n        int num=s.charAt(s.length()-1)-\\'0\\';\\n        add(map, num);\\n        return helper(s.substring(0,s.length()-1), map, k, num);\\n    }\\n    private void add(TreeMap<Integer, Integer> map, int key){\\n        map.put(key, map.getOrDefault(key, 0)+1);\\n    }\\n    private void remove(TreeMap<Integer, Integer> map, int key){\\n        int value = map.get(key);\\n        if(value==1){\\n            map.remove(key);\\n        }\\n        else{\\n            map.put(key,value-1);\\n        }\\n    }\\n    \\n    private int getSize(TreeMap<Integer, Integer> map){\\n        int num = 0;\\n        PriorityQueue<Integer> denominator = new PriorityQueue<>();\\n\\t\\t/*\\n\\t\\t* This is the tricky part, it\\'s impossible to calculate factory of large number, like 80!\\n\\t\\t* So my approach is to store all factors in advance, and divide numerator as soon as possible to avoid overflow.\\n\\t\\t*/\\n        for(int value: map.values()){\\n            num+=value;\\n            for(int i=2;i<=value;i++){\\n                denominator.add(i);\\n            }\\n        }\\n        int res = 1;\\n        for(int i=1;i<=num;i++){\\n            res*=i;\\n            while(!denominator.isEmpty() && res % denominator.peek()==0){\\n                int key = denominator.poll();\\n                res/= key;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\n    private int count(String s, String t){\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n        int cur = 0;\\n        int n = s.length();\\n        int res = 0;\\n        while(cur<n){\\n\\t\\t\\t/*\\n\\t\\t\\t*  43578965\\n\\t\\t\\t*  43596857\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t*/\\n            while(cur<n && c1[cur]==c2[cur]){\\n                cur++;\\n            }\\n            if(cur>=n){\\n                break;\\n            }\\n            char last = c2[cur];\\n\\t\\t\\t/*\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 79658\\n\\t\\t\\t*/\\n            for(int below = cur+1; below<n; below++){\\n                char tmp = c2[below];\\n                c2[below]=last;\\n                last = tmp;\\n                if(tmp==c1[cur]){\\n                    res+=below-cur;\\n                    c2[cur]=tmp;\\n                    break;\\n                }\\n            }\\n            cur++;\\n        }\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nimport java.util.NavigableMap;\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int leftNum = 0;\\n        int left = 0;\\n\\t\\t//Get \"4\", and initialize map to be\\n\\t\\t//{2=1, 4=1, 7=1, 8=1, 9=1}\\n        for(int i=s.length()-1;i>=0;i--){\\n            int num=s.charAt(i)-\\'0\\';\\n            add(map, num);\\n            if(s.charAt(i-1)<s.charAt(i)){\\n                leftNum=s.charAt(i-1)-\\'0\\';\\n                left = i-1;\\n                add(map, leftNum);\\n                break;\\n            }\\n        }\\n        String res = helper(s.substring(0,left), map, k, leftNum);\\n        return count(s, res);\\n        \\n    }\\n    private String helper(String s, TreeMap<Integer, Integer> map, int k, int leftNum){\\n\\t\\t//Get sub map whose keys are greater than 4. {7=1, 8=1, 9=1}\\n        NavigableMap<Integer, Integer> tailMap = map.tailMap(leftNum, false);\\n        List<Integer> candidates = tailMap.keySet().stream().collect(Collectors.toList());\\n        for(int candidate:candidates){\\n\\t\\t    //if we get started with 7, we need to reduce 7\\'s frequence by 1.\\n            remove(map, candidate);\\n            int size = getSize(map);\\n            if(k>size){\\n                k-=size;\\n                add(map, candidate);\\n            }\\n            else if(k<size){\\n                char ch = (char)(candidate+\\'0\\');\\n                return helper(s+ch, map, k, -1);\\n            }\\n            else{\\n                char ch = (char)(candidate+\\'0\\');\\n                String part = \"\";\\n                for(Entry<Integer, Integer> e:map.entrySet()){\\n                    for(int i=0;i<e.getValue();i++){\\n                        part = e.getKey()+ part;\\n                    }\\n                }\\n                return s+ch+part;\\n            }\\n        }\\n\\t\\t// If we don\\'t find target, that means we need to move one more digit left\\n\\t\\t// 49872 -> *49872\\n        int num=s.charAt(s.length()-1)-\\'0\\';\\n        add(map, num);\\n        return helper(s.substring(0,s.length()-1), map, k, num);\\n    }\\n    private void add(TreeMap<Integer, Integer> map, int key){\\n        map.put(key, map.getOrDefault(key, 0)+1);\\n    }\\n    private void remove(TreeMap<Integer, Integer> map, int key){\\n        int value = map.get(key);\\n        if(value==1){\\n            map.remove(key);\\n        }\\n        else{\\n            map.put(key,value-1);\\n        }\\n    }\\n    \\n    private int getSize(TreeMap<Integer, Integer> map){\\n        int num = 0;\\n        PriorityQueue<Integer> denominator = new PriorityQueue<>();\\n\\t\\t/*\\n\\t\\t* This is the tricky part, it\\'s impossible to calculate factory of large number, like 80!\\n\\t\\t* So my approach is to store all factors in advance, and divide numerator as soon as possible to avoid overflow.\\n\\t\\t*/\\n        for(int value: map.values()){\\n            num+=value;\\n            for(int i=2;i<=value;i++){\\n                denominator.add(i);\\n            }\\n        }\\n        int res = 1;\\n        for(int i=1;i<=num;i++){\\n            res*=i;\\n            while(!denominator.isEmpty() && res % denominator.peek()==0){\\n                int key = denominator.poll();\\n                res/= key;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\n    private int count(String s, String t){\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n        int cur = 0;\\n        int n = s.length();\\n        int res = 0;\\n        while(cur<n){\\n\\t\\t\\t/*\\n\\t\\t\\t*  43578965\\n\\t\\t\\t*  43596857\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t*/\\n            while(cur<n && c1[cur]==c2[cur]){\\n                cur++;\\n            }\\n            if(cur>=n){\\n                break;\\n            }\\n            char last = c2[cur];\\n\\t\\t\\t/*\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 79658\\n\\t\\t\\t*/\\n            for(int below = cur+1; below<n; below++){\\n                char tmp = c2[below];\\n                c2[below]=last;\\n                last = tmp;\\n                if(tmp==c1[cur]){\\n                    res+=below-cur;\\n                    c2[cur]=tmp;\\n                    break;\\n                }\\n            }\\n            cur++;\\n        }\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188425,
                "title": "java-next-permutation-greedy-beats-95",
                "content": "This problem can be broken into 2 parts\\n1. Find the permutation (see https://leetcode.com/problems/next-permutation/)\\n\\t2. And my solution with explanation: https://leetcode.com/problems/next-permutation/discuss/1188189/java-provided-on-solution-with-comments\\n2. Find the minimal number of swaps\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        int[] nums = toArray(s);\\n        \\n        while (k > 0) {\\n            k--;\\n            nextPermutation(nums);\\n        }\\n        \\n        // find minimal count of swap\\n        int count = 0;\\n        final int[] original = toArray(s);\\n        for (int i = 0; i < original.length; i++) {\\n            if (original[i] == nums[i]) {\\n                continue;\\n            }\\n            \\n            // find a equal num in nums[i + 1:]\\n            int j = i + 1;\\n            while (original[i] != nums[j]) {\\n                j++;\\n            }\\n            \\n            // swap j all the way to i\\n            while (i < j) {\\n                swap(nums, j - 1, j);\\n                j--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\tvoid nextPermutation(int[] num) {\\n        if (num.length <= 1) {\\n            return;\\n        }\\n        \\n        // check if all descending order\\n        int i = num.length - 2;\\n        while (i >= 0 && num[i] >= num[i + 1]) {\\n            i--;\\n        }\\n        \\n        if (i >= 0) {\\n            // find the first number > i\\n            int j = num.length - 1;\\n            while (i < j && num[i] >= num[j]) {\\n                j--;\\n            }\\n            swap(num, i, j);\\n        }\\n        \\n        reverse(num, i + 1);\\n    }\\n    \\n    void reverse(int[] num, int start) {\\n        int i = start, j = num.length - 1;\\n        while (i < j) {\\n            swap(num, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void swap(int[] num, int i, int j) {\\n        int tmp = num[i];\\n        num[i] = num[j];\\n        num[j] = tmp;\\n    }\\n        \\n    int[] toArray(String s) {\\n        int[] nums = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            nums[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        int[] nums = toArray(s);\\n        \\n        while (k > 0) {\\n            k--;\\n            nextPermutation(nums);\\n        }\\n        \\n        // find minimal count of swap\\n        int count = 0;\\n        final int[] original = toArray(s);\\n        for (int i = 0; i < original.length; i++) {\\n            if (original[i] == nums[i]) {\\n                continue;\\n            }\\n            \\n            // find a equal num in nums[i + 1:]\\n            int j = i + 1;\\n            while (original[i] != nums[j]) {\\n                j++;\\n            }\\n            \\n            // swap j all the way to i\\n            while (i < j) {\\n                swap(nums, j - 1, j);\\n                j--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\tvoid nextPermutation(int[] num) {\\n        if (num.length <= 1) {\\n            return;\\n        }\\n        \\n        // check if all descending order\\n        int i = num.length - 2;\\n        while (i >= 0 && num[i] >= num[i + 1]) {\\n            i--;\\n        }\\n        \\n        if (i >= 0) {\\n            // find the first number > i\\n            int j = num.length - 1;\\n            while (i < j && num[i] >= num[j]) {\\n                j--;\\n            }\\n            swap(num, i, j);\\n        }\\n        \\n        reverse(num, i + 1);\\n    }\\n    \\n    void reverse(int[] num, int start) {\\n        int i = start, j = num.length - 1;\\n        while (i < j) {\\n            swap(num, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void swap(int[] num, int i, int j) {\\n        int tmp = num[i];\\n        num[i] = num[j];\\n        num[j] = tmp;\\n    }\\n        \\n    int[] toArray(String s) {\\n        int[] nums = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            nums[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187071,
                "title": "java-o-nk-next-permutation-o-nlogn-min-adjacent-swaps-to-align-two-permutations",
                "content": "## Step 1: repeate finding next greater permutaiton k times to find k-th smallest wonderful number.\\nTo find next greater permutation see, https://leetcode.com/problems/next-permutation/\\nTime `O(Nk)`, space `O(1)`\\n\\n## Step 2: find the minimum adjacent swaps required to make two permutations A and B identical.\\n1. Create integer array `X` where `X[i]` is the smallest index of remaining `A[i]` in B, i.e. `X[i] = j` where `B[j] == A[i]` and `j` is as small as possible.\\nTo do that, we can put B\\'s element to index mapping into a `Map<Character, Queue<Integer>>`, and iterate over `A[i]` to dequeue the smallest index in `map.get(A[i])`\\n2. Count number of inverted pairs in X, this can be done similar to merge sort in `O(NlogN)` time.\\nTime `O(NlogN)`, space O(N)\\n    \\nOverall time complexity is `O(N(k + logN))`, space `O(N)`\\n\\n\\n```java\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        // find k-th smallest wonderful number\\n        String s = num;\\n        for (int i = 0; i < k; i++) {\\n            s = nextGreaterPermutation(s);\\n        }\\n        return getMinSwaps(num, s);\\n    }\\n    \\n    private String nextGreaterPermutation(String num) {\\n        char[] A = num.toCharArray();\\n        // Find last i so that A[i] < A[i + 1]\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) {\\n            i--;\\n        }\\n\\n        // swap A[i] with the smallest A[j] > A[i] where j > i\\n        int j = i;\\n        while (j + 1 < A.length && A[j + 1] > A[i]) {\\n            j++;\\n        }\\n        swap(A, i, j);\\n        // sort A[i+1:-1]\\n        reverse(A, i + 1, A.length - 1);\\n        return String.valueOf(A);\\n    }\\n    \\n    private void swap(char[] c, int i, int j) {\\n        char tmp = c[i];\\n        c[i] = c[j];\\n        c[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            swap(c, start++, end--);\\n        }\\n    }\\n    \\n    // Count minimum number of adjacent swaps needed to make two permutations identical\\n    private int getMinSwaps(String a, String b) {\\n        int N = a.length();\\n        Map<Character, Queue<Integer>> charToBIdx = new HashMap<>();\\n        for (int j = 0; j < N; j++) {\\n            charToBIdx.computeIfAbsent(b.charAt(j), ignored -> new LinkedList<>()).offer(j);\\n        }\\n        \\n        int[] X = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            X[i] = charToBIdx.get(a.charAt(i)).poll();\\n        }\\n        return getMinSwapsToSort(X, 0, N - 1);\\n    }\\n    \\n    // sort A[start...end] and return minimum adjacent swaps required\\n    private int getMinSwapsToSort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int res = getMinSwapsToSort(A, start, mid) + getMinSwapsToSort(A, mid + 1, end);\\n\\n        // Two pointer count inverted pairs between left and right sorted subarrays\\n        int[] left = Arrays.copyOfRange(A, start, mid + 1);\\n        int[] right = Arrays.copyOfRange(A, mid + 1, end + 1);\\n        int l = 0;\\n        int r = 0;\\n        int i = start;\\n        while (l < left.length || r < right.length) {\\n            if (r >= right.length || l < left.length && left[l] <= right[r]) {\\n                res += r; // numbers in the right subarray that\\'s smaller than A[l] is equal to the steps r pointer\\n                // has advanced\\n                A[i++] = left[l++];\\n            } else {\\n                A[i++] = right[r++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        // find k-th smallest wonderful number\\n        String s = num;\\n        for (int i = 0; i < k; i++) {\\n            s = nextGreaterPermutation(s);\\n        }\\n        return getMinSwaps(num, s);\\n    }\\n    \\n    private String nextGreaterPermutation(String num) {\\n        char[] A = num.toCharArray();\\n        // Find last i so that A[i] < A[i + 1]\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) {\\n            i--;\\n        }\\n\\n        // swap A[i] with the smallest A[j] > A[i] where j > i\\n        int j = i;\\n        while (j + 1 < A.length && A[j + 1] > A[i]) {\\n            j++;\\n        }\\n        swap(A, i, j);\\n        // sort A[i+1:-1]\\n        reverse(A, i + 1, A.length - 1);\\n        return String.valueOf(A);\\n    }\\n    \\n    private void swap(char[] c, int i, int j) {\\n        char tmp = c[i];\\n        c[i] = c[j];\\n        c[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            swap(c, start++, end--);\\n        }\\n    }\\n    \\n    // Count minimum number of adjacent swaps needed to make two permutations identical\\n    private int getMinSwaps(String a, String b) {\\n        int N = a.length();\\n        Map<Character, Queue<Integer>> charToBIdx = new HashMap<>();\\n        for (int j = 0; j < N; j++) {\\n            charToBIdx.computeIfAbsent(b.charAt(j), ignored -> new LinkedList<>()).offer(j);\\n        }\\n        \\n        int[] X = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            X[i] = charToBIdx.get(a.charAt(i)).poll();\\n        }\\n        return getMinSwapsToSort(X, 0, N - 1);\\n    }\\n    \\n    // sort A[start...end] and return minimum adjacent swaps required\\n    private int getMinSwapsToSort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int res = getMinSwapsToSort(A, start, mid) + getMinSwapsToSort(A, mid + 1, end);\\n\\n        // Two pointer count inverted pairs between left and right sorted subarrays\\n        int[] left = Arrays.copyOfRange(A, start, mid + 1);\\n        int[] right = Arrays.copyOfRange(A, mid + 1, end + 1);\\n        int l = 0;\\n        int r = 0;\\n        int i = start;\\n        while (l < left.length || r < right.length) {\\n            if (r >= right.length || l < left.length && left[l] <= right[r]) {\\n                res += r; // numbers in the right subarray that\\'s smaller than A[l] is equal to the steps r pointer\\n                // has advanced\\n                A[i++] = left[l++];\\n            } else {\\n                A[i++] = right[r++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186850,
                "title": "python-3-with-next-permutation",
                "content": "Use next_permutation to find the target, then compute the number of swaps directly.\\n```\\ndef next_perm(s):\\n    for i in range(len(s)-2, -1, -1):\\n        if s[i]<s[i+1]:\\n            for j in range(i, len(s)):\\n                if j+1 < len(s) and s[j+1] <= s[i]:\\n                    break\\n            return s[:i] + s[j] + \\'\\'.join(sorted([s[k] for k in range(i, len(s)) if k != j]))\\n    return sorted(s)\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target_num = num\\n        for _ in range(k):\\n            target_num = next_perm(target_num)\\n                \\n        target = list(target_num)\\n        cur = list(num)\\n        swaps = 0\\n        for i in range(len(cur)):\\n            if target[i] == cur[i]: continue\\n                \\n            for j in range(i, len(num)):\\n                if cur[j] == target[i]:\\n                    swaps += j-i\\n                    cur = cur[:i] + [cur[j]] + [cur[x] for x in range(i, len(num)) if x!=j]\\n                    break\\n        return swaps\\n ```",
                "solutionTags": [],
                "code": "```\\ndef next_perm(s):\\n    for i in range(len(s)-2, -1, -1):\\n        if s[i]<s[i+1]:\\n            for j in range(i, len(s)):\\n                if j+1 < len(s) and s[j+1] <= s[i]:\\n                    break\\n            return s[:i] + s[j] + \\'\\'.join(sorted([s[k] for k in range(i, len(s)) if k != j]))\\n    return sorted(s)\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target_num = num\\n        for _ in range(k):\\n            target_num = next_perm(target_num)\\n                \\n        target = list(target_num)\\n        cur = list(num)\\n        swaps = 0\\n        for i in range(len(cur)):\\n            if target[i] == cur[i]: continue\\n                \\n            for j in range(i, len(num)):\\n                if cur[j] == target[i]:\\n                    swaps += j-i\\n                    cur = cur[:i] + [cur[j]] + [cur[x] for x in range(i, len(num)) if x!=j]\\n                    break\\n        return swaps\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3944570,
                "title": "c-2-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void swap(string &a,int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n    void reverse(string &a,int s,int e){\\n        while(s<=e){\\n            swap(a,s,e);\\n            s++;e--;\\n        }\\n    }\\n    void nextPermutation(string &a) {\\n        int n=a.size();\\n        //from the right find the first pair where a[i]<a[i+1]\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<a[i+1]) break;\\n        }\\n        if(i<0){\\n            reverse(a,0,n-1);\\n            return;\\n        } \\n        //swap a[i] with number just larger than it from right part\\n        int j;\\n        for(j=n-1;j>=i;j--){\\n            if(a[j]>a[i]){\\n                swap(a,i,j);\\n                break;\\n            }   \\n        }\\n        //reverse the right part \\n        reverse(a,i+1,n-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int count=0;\\n        string next=num;\\n        //next permutation of given number\\n        while(k--){\\n            nextPermutation(next);\\n        }\\n        //i points to num and next\\n        //k is used to find the mismatched character in next\\n        //num:  0 5 9\\n        //next: 9 5 0(k)\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=next[i]){\\n                int k=i+1;\\n                while(next[k]!=num[i])  k++;\\n                while(k>i){\\n                    swap(next,k,k-1);\\n                    count++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//0 5 9\\n//0 9 5\\n//5 0 9\\n//5 9 0\\n//9 0 5\\n//9 5 0  --ans: 3\\n\\n//0 0 1 2 3\\n//0 0 1 3 2  --ans: 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(string &a,int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n    void reverse(string &a,int s,int e){\\n        while(s<=e){\\n            swap(a,s,e);\\n            s++;e--;\\n        }\\n    }\\n    void nextPermutation(string &a) {\\n        int n=a.size();\\n        //from the right find the first pair where a[i]<a[i+1]\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<a[i+1]) break;\\n        }\\n        if(i<0){\\n            reverse(a,0,n-1);\\n            return;\\n        } \\n        //swap a[i] with number just larger than it from right part\\n        int j;\\n        for(j=n-1;j>=i;j--){\\n            if(a[j]>a[i]){\\n                swap(a,i,j);\\n                break;\\n            }   \\n        }\\n        //reverse the right part \\n        reverse(a,i+1,n-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int count=0;\\n        string next=num;\\n        //next permutation of given number\\n        while(k--){\\n            nextPermutation(next);\\n        }\\n        //i points to num and next\\n        //k is used to find the mismatched character in next\\n        //num:  0 5 9\\n        //next: 9 5 0(k)\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=next[i]){\\n                int k=i+1;\\n                while(next[k]!=num[i])  k++;\\n                while(k>i){\\n                    swap(next,k,k-1);\\n                    count++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//0 5 9\\n//0 9 5\\n//5 0 9\\n//5 9 0\\n//9 0 5\\n//9 5 0  --ans: 3\\n\\n//0 0 1 2 3\\n//0 0 1 3 2  --ans: 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885034,
                "title": "solution-using-next-permutation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      string temp  = num;\\n      int count  = 0;\\n      while( count != k )\\n      {\\n          int ind = -1;\\n          int n = num.size();\\n          for( int i = n-1; i >=0; i-- )\\n          {\\n            if( num[i] < num[i+1] )\\n            {\\n                ind = i;\\n                break;\\n            }\\n          }\\n          if( ind == -1)  reverse( num.begin(), num.end());\\n          for( int i = n-1; i>=ind; i-- )\\n          {\\n              if( num[i] > num[ind] )\\n              {\\n                  swap( num[i],num[ind] );\\n                  break;\\n              }\\n          }\\n          reverse( num.begin()+ind+1, num.end());\\n          count++;\\n      } \\n      for ( int i = 0; i<num.size(); i++ )\\n      {\\n          cout<<num[i];\\n      }\\n      \\n      int ans = 0;\\n      for( int i = 0; i < num.size(); i++ )\\n      {\\n          if(num[i] != temp[i])\\n          {\\n              int j = i+1;\\n              while( num[j] != temp[i] ) j++;\\n              while( j>i )\\n              {\\n                  swap( num[j],num[j-1] );\\n                  ans++;\\n                  j--;\\n              }\\n          }\\n      }\\n     return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      string temp  = num;\\n      int count  = 0;\\n      while( count != k )\\n      {\\n          int ind = -1;\\n          int n = num.size();\\n          for( int i = n-1; i >=0; i-- )\\n          {\\n            if( num[i] < num[i+1] )\\n            {\\n                ind = i;\\n                break;\\n            }\\n          }\\n          if( ind == -1)  reverse( num.begin(), num.end());\\n          for( int i = n-1; i>=ind; i-- )\\n          {\\n              if( num[i] > num[ind] )\\n              {\\n                  swap( num[i],num[ind] );\\n                  break;\\n              }\\n          }\\n          reverse( num.begin()+ind+1, num.end());\\n          count++;\\n      } \\n      for ( int i = 0; i<num.size(); i++ )\\n      {\\n          cout<<num[i];\\n      }\\n      \\n      int ans = 0;\\n      for( int i = 0; i < num.size(); i++ )\\n      {\\n          if(num[i] != temp[i])\\n          {\\n              int j = i+1;\\n              while( num[j] != temp[i] ) j++;\\n              while( j>i )\\n              {\\n                  swap( num[j],num[j-1] );\\n                  ans++;\\n                  j--;\\n              }\\n          }\\n      }\\n     return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3863684,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp = num;\\n        while(k>0){\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!=temp[i]){\\n                int j = i+1;\\n                while(num[i]!=temp[j] and j<num.size()) j++;\\n                while(j>i){\\n                    swap(temp[j], temp[j-1]);\\n                    j--;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp = num;\\n        while(k>0){\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!=temp[i]){\\n                int j = i+1;\\n                while(num[i]!=temp[j] and j<num.size()) j++;\\n                while(j>i){\\n                    swap(temp[j], temp[j-1]);\\n                    j--;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818894,
                "title": "my-solution",
                "content": "**1. Use the function `std::next_permutation`**\\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target.begin(), target.end());\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Implement the function `std::next_permutation` manually**\\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target);\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void next_permutation(string &num) {\\n    const int n = static_cast<int>(num.size());\\n    int p = n - 2;\\n    for (; p > -1 && num[p] >= num[p + 1]; --p) {\\n    }\\n    int q = n - 1;\\n    for (; num[p] >= num[q]; --q) {\\n    }\\n    swap(num[p], num[q]);\\n    reverse(num.begin() + p + 1, num.end());\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target.begin(), target.end());\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target);\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void next_permutation(string &num) {\\n    const int n = static_cast<int>(num.size());\\n    int p = n - 2;\\n    for (; p > -1 && num[p] >= num[p + 1]; --p) {\\n    }\\n    int q = n - 1;\\n    for (; num[p] >= num[q]; --q) {\\n    }\\n    swap(num[p], num[q]);\\n    reverse(num.begin() + p + 1, num.end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783808,
                "title": "greedy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n\\n        #Generate Kth smallest number\\n        arr = [*num]\\n        for _ in range(k):\\n            brr = [arr.pop()]\\n            while arr[-1] >= brr[-1]:\\n                brr.append(arr.pop())\\n            i = bisect(brr, arr[-1])\\n            arr[-1], brr[i] = brr[i], arr[-1]\\n            arr += brr\\n        \\n        #Calculate adjacent swaps\\n        count = 0\\n        for item in num:\\n            i = arr.index(item)\\n            count += i\\n            arr.pop(i)\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n\\n        #Generate Kth smallest number\\n        arr = [*num]\\n        for _ in range(k):\\n            brr = [arr.pop()]\\n            while arr[-1] >= brr[-1]:\\n                brr.append(arr.pop())\\n            i = bisect(brr, arr[-1])\\n            arr[-1], brr[i] = brr[i], arr[-1]\\n            arr += brr\\n        \\n        #Calculate adjacent swaps\\n        count = 0\\n        for item in num:\\n            i = arr.index(item)\\n            count += i\\n            arr.pop(i)\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777773,
                "title": "next-permutation",
                "content": "**time: `O(N*(N+k))`; space: `O(N)`**\\n```\\nclass Solution\\n{\\n    bool nextPermutation(string& n)\\n    {\\n        int i(size(n)-1);\\n        for( ; i and n[i-1]>=n[i]; --i);\\n        if(auto j=i)\\n        {\\n            for( ; j<size(n) and n[j]>n[i-1]; ++j);\\n            swap(n[i-1], n[j-1]);\\n            reverse(begin(n)+i, end(n));\\n        }\\n        else return false;\\n        return true;\\n    }\\npublic:   \\n    int getMinSwaps(string n, int k)\\n    {\\n        auto N = n;\\n        for( ; k--; nextPermutation(n));\\n        int out{};\\n        for(int i{}; i<size(N); ++i)\\n        {   \\n            int j{i};\\n            for( ; j<size(n) and n[j]!=N[i]; ++j);\\n            for( ; i<j; swap(n[j-1], n[j]), --j, ++out);\\n        }\\n        return out;\\n    }\\n};\\n```\\n**Similar problems:**\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/discuss/3694713/next_permutation)\\n[31. Next Permutation](https://leetcode.com/problems/next-permutation/discuss/3415522/U-turn-(findswapreverse))\\n[1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number](https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/discuss/3777773/next_permutation)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    bool nextPermutation(string& n)\\n    {\\n        int i(size(n)-1);\\n        for( ; i and n[i-1]>=n[i]; --i);\\n        if(auto j=i)\\n        {\\n            for( ; j<size(n) and n[j]>n[i-1]; ++j);\\n            swap(n[i-1], n[j-1]);\\n            reverse(begin(n)+i, end(n));\\n        }\\n        else return false;\\n        return true;\\n    }\\npublic:   \\n    int getMinSwaps(string n, int k)\\n    {\\n        auto N = n;\\n        for( ; k--; nextPermutation(n));\\n        int out{};\\n        for(int i{}; i<size(N); ++i)\\n        {   \\n            int j{i};\\n            for( ; j<size(n) and n[j]!=N[i]; ++j);\\n            for( ; i<j; swap(n[j-1], n[j]), --j, ++out);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756049,
                "title": "java-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }\\n        reverse(arr,i+1,arr.length-1);\\n    }\\n\\n    void swap(char[]arr,int i,int j){\\n        char ch = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = ch;\\n    }\\n\\n    void reverse(char[]arr,int i,int j){\\n        while(i < j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int getMinSwaps(String num, int k) {\\n        n = num.length();\\n        char[]arr = num.toCharArray();\\n        char[]res = num.toCharArray();\\n\\n        for(int i = 0;i < k;i++)\\n            nextPermutation(res);\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            int j = i;\\n            while(arr[j] != res[i])\\n                j++;\\n            while(j > i){\\n                swap(arr,j,j-1);\\n                j--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }\\n        reverse(arr,i+1,arr.length-1);\\n    }\\n\\n    void swap(char[]arr,int i,int j){\\n        char ch = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = ch;\\n    }\\n\\n    void reverse(char[]arr,int i,int j){\\n        while(i < j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int getMinSwaps(String num, int k) {\\n        n = num.length();\\n        char[]arr = num.toCharArray();\\n        char[]res = num.toCharArray();\\n\\n        for(int i = 0;i < k;i++)\\n            nextPermutation(res);\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            int j = i;\\n            while(arr[j] != res[i])\\n                j++;\\n            while(j > i){\\n                swap(arr,j,j-1);\\n                j--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719877,
                "title": "java-soln-using-next-permutation",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int len = num.length();\\n        int[] nums = new int[len];\\n        int[] original = new int[len];\\n        \\n        int idx = 0;\\n        for(char c : num.toCharArray()) {\\n            int digit = (int) (c - \\'0\\');\\n            nums[idx] = digit;\\n            original[idx] = digit;\\n            idx++;\\n        }\\n        \\n        while (k != 0) {\\n            nextPermutation(nums);\\n            k--;\\n        }\\n        \\n        int minSwaps = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] != original[i]) {\\n                int j = i + 1;\\n                while (j < len) {\\n                    if(original[j] == nums[i]) {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                \\n                while(j > 0 && j != i) {\\n                    swap(original, j, j - 1);\\n                    minSwaps++;\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int len = num.length();\\n        int[] nums = new int[len];\\n        int[] original = new int[len];\\n        \\n        int idx = 0;\\n        for(char c : num.toCharArray()) {\\n            int digit = (int) (c - \\'0\\');\\n            nums[idx] = digit;\\n            original[idx] = digit;\\n            idx++;\\n        }\\n        \\n        while (k != 0) {\\n            nextPermutation(nums);\\n            k--;\\n        }\\n        \\n        int minSwaps = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] != original[i]) {\\n                int j = i + 1;\\n                while (j < len) {\\n                    if(original[j] == nums[i]) {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                \\n                while(j > 0 && j != i) {\\n                    swap(original, j, j - 1);\\n                    minSwaps++;\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627616,
                "title": "c-next-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)  next_permutation(x.begin(),x.end());\\n        \\n        int cnt=0,j;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            j=i;\\n            while(s[j]!=x[i]){ j++; }\\n\\n            while(j>i){\\n            swap(s[j],s[j-1]);\\n            j--,cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)  next_permutation(x.begin(),x.end());\\n        \\n        int cnt=0,j;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            j=i;\\n            while(s[j]!=x[i]){ j++; }\\n\\n            while(j>i){\\n            swap(s[j],s[j-1]);\\n            j--,cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622612,
                "title": "javascript-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601884,
                "title": "without-using-next-permutation-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is like a follow-up to the classic \"Next Permutation\" problem.\\nIf you haven\\'t solved \"Next Permutation\" yet, I would you recommend you to try it:\\n[https://leetcode.com/problems/next-permutation/]()\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssuming you have followed the \"Next Permutation\" approach k times. We come to the swapping part.\\nIt is efficient to simply use the greedy swapping as our time complexity is not hindered by it and also it is very easy to implement.\\n\\nSimply, whenever you encounter mismatching elements in the two strings, keep a pointer at that element in string 2 and move a pointer on string 1 until you reach the string 2\\'s element in string 1. Then keep swapping the adjacent elements till the initial pointer\\'s position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) to store a copy of the kth permutation of given number string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minswaps(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int ctr=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            if(s1[i]!=s2[i])\\n            {\\n                int j=i;\\n                while(s1[j]!=s2[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(s1[j], s1[j-1]);\\n                    j--;\\n                    ctr++;\\n                }   \\n            }\\n            i++;\\n        }\\n\\n        return ctr;\\n    }\\n    int getMinSwaps(string num, int k) \\n    {\\n        string arr=num;\\n        int N=arr.size();\\n        while(k--)\\n        {\\n            int index=-1;\\n            for(int i=N-1; i>=1; i--)\\n            {\\n                if(arr[i]>arr[i-1])\\n                {\\n                    index=i-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(index!=-1)\\n            {\\n                int p=index+1;\\n                for(int i=index+1; i<N; i++)\\n                {\\n                    if(arr[i]>arr[index])\\n                    {\\n                        if(arr[i]<arr[p])\\n                            p=i;\\n                    }\\n                }\\n                \\n                int t=arr[index];\\n                arr[index]=arr[p];\\n                arr[p]=t;\\n            }\\n            \\n            index++;\\n            sort(arr.begin()+index, arr.end());\\n        }\\n        \\n        return minswaps(num, arr);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minswaps(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int ctr=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            if(s1[i]!=s2[i])\\n            {\\n                int j=i;\\n                while(s1[j]!=s2[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(s1[j], s1[j-1]);\\n                    j--;\\n                    ctr++;\\n                }   \\n            }\\n            i++;\\n        }\\n\\n        return ctr;\\n    }\\n    int getMinSwaps(string num, int k) \\n    {\\n        string arr=num;\\n        int N=arr.size();\\n        while(k--)\\n        {\\n            int index=-1;\\n            for(int i=N-1; i>=1; i--)\\n            {\\n                if(arr[i]>arr[i-1])\\n                {\\n                    index=i-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(index!=-1)\\n            {\\n                int p=index+1;\\n                for(int i=index+1; i<N; i++)\\n                {\\n                    if(arr[i]>arr[index])\\n                    {\\n                        if(arr[i]<arr[p])\\n                            p=i;\\n                    }\\n                }\\n                \\n                int t=arr[index];\\n                arr[index]=arr[p];\\n                arr[p]=t;\\n            }\\n            \\n            index++;\\n            sort(arr.begin()+index, arr.end());\\n        }\\n        \\n        return minswaps(num, arr);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465665,
                "title": "simple-and-easy-solution-to-understand-c-solution-greedy",
                "content": "# Intuition\\n**Prerequiste** : **NEXT PERMUTATION**\\nhttps://leetcode.com/problems/next-permutation/\\nIf You Didn\\'t Solve Next Permutation Problem Solve It First.\\nIf We Carefully Observe The Example Explained In the description On Question ,The Next Smallest Beautiful String Is The Next Permutation Of The String . \\nSo For Kth Smallest String We Need To Find The Next  Kth permutaion Of Current String\\n# Approach\\nUsing kthperm Function Generating Next K Permutations After That And  Finding The Required Number Of Swaps Using Original String And permuted String In a Brute Force Manner.\\n# Complexity\\n- Time complexity:\\nO(K * N) - For Generating Permutations\\nO(N * N) - In Worst Case For Finding Number Of Swaps.\\nTotal : O(K * N + N * N) ===> O(N * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void reverse(string &arr,int i,int j)\\n     {\\n         while(i<j) swap(arr[i++],arr[j--]);\\n     }\\n     void kthperm(string &arr,int k,int n)\\n     {\\n         if(k==0) return;\\n         int ind=-1;\\n         for(int i=n-2;i>=0;i--)\\n         {\\n             if(arr[i+1]>arr[i])\\n             {\\n                 ind=i;\\n                 break;\\n             }\\n         }\\n             if(ind==-1)\\n             {\\n                 reverse(arr,0,n-1);\\n                 return;\\n             }\\n             for(int i=n-1;i>ind;i--)\\n             {\\n                 if(arr[i]>arr[ind])\\n                 {\\n                     swap(arr[i],arr[ind]);\\n                     break;\\n                 }\\n             }\\n             reverse(arr,ind+1,n-1);\\n             \\n             kthperm(arr,k-1,n);\\n             return;\\n         \\n     }\\n   \\n    int getMinSwaps(string num, int k) {\\n        string arr=\"\";\\n        int i=0,n=0;\\n        for(char &a:num)\\n        {\\n            arr+=a;\\n            n++;\\n        }  \\n        kthperm(arr,k,n);\\n        while(arr[i]==num[i]&&i<n) i++;\\n        int swaps=0,j;\\n        while(i<n)\\n        {\\n            j=i;\\n            while(arr[j]!=num[i]&&j<n) j++;\\n            while(j>i)\\n            {\\n                swap(arr[j],arr[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            if(arr==num) break;\\n            i++;\\n        }\\n         return swaps;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void reverse(string &arr,int i,int j)\\n     {\\n         while(i<j) swap(arr[i++],arr[j--]);\\n     }\\n     void kthperm(string &arr,int k,int n)\\n     {\\n         if(k==0) return;\\n         int ind=-1;\\n         for(int i=n-2;i>=0;i--)\\n         {\\n             if(arr[i+1]>arr[i])\\n             {\\n                 ind=i;\\n                 break;\\n             }\\n         }\\n             if(ind==-1)\\n             {\\n                 reverse(arr,0,n-1);\\n                 return;\\n             }\\n             for(int i=n-1;i>ind;i--)\\n             {\\n                 if(arr[i]>arr[ind])\\n                 {\\n                     swap(arr[i],arr[ind]);\\n                     break;\\n                 }\\n             }\\n             reverse(arr,ind+1,n-1);\\n             \\n             kthperm(arr,k-1,n);\\n             return;\\n         \\n     }\\n   \\n    int getMinSwaps(string num, int k) {\\n        string arr=\"\";\\n        int i=0,n=0;\\n        for(char &a:num)\\n        {\\n            arr+=a;\\n            n++;\\n        }  \\n        kthperm(arr,k,n);\\n        while(arr[i]==num[i]&&i<n) i++;\\n        int swaps=0,j;\\n        while(i<n)\\n        {\\n            j=i;\\n            while(arr[j]!=num[i]&&j<n) j++;\\n            while(j>i)\\n            {\\n                swap(arr[j],arr[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            if(arr==num) break;\\n            i++;\\n        }\\n         return swaps;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450977,
                "title": "next-greater-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def findGreatest(nums):\\n            nums = list(nums)\\n            # 1 find pivot\\n            pivot = None\\n            for i in range(len(nums) - 1, 0, -1):\\n                if nums[i] > nums[i - 1]:\\n                    pivot = i - 1\\n                    break\\n            # 2 swap with pivot if larger than pivot\\n            for i in range(len(nums) - 1, pivot, -1):\\n                if nums[i] > nums[pivot]:\\n                    nums[i], nums[pivot] = nums[pivot], nums[i]\\n                    break\\n            # 3 reverse nums after pivot\\n            nums[pivot +1: ] = nums[pivot +1: ][::-1]\\n            return \\'\\'.join(nums)\\n            \\n        origin = list(num[::])\\n        for i in range(k):\\n            num = findGreatest(num)\\n        # swap adjacent greedy\\n        ans, n = 0, len(num)\\n        for i in range(n):\\n            j = origin.index(num[i], i)\\n            ans += j - i\\n            origin[i:j+1] = [origin[j]] + origin[i:j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def findGreatest(nums):\\n            nums = list(nums)\\n            # 1 find pivot\\n            pivot = None\\n            for i in range(len(nums) - 1, 0, -1):\\n                if nums[i] > nums[i - 1]:\\n                    pivot = i - 1\\n                    break\\n            # 2 swap with pivot if larger than pivot\\n            for i in range(len(nums) - 1, pivot, -1):\\n                if nums[i] > nums[pivot]:\\n                    nums[i], nums[pivot] = nums[pivot], nums[i]\\n                    break\\n            # 3 reverse nums after pivot\\n            nums[pivot +1: ] = nums[pivot +1: ][::-1]\\n            return \\'\\'.join(nums)\\n            \\n        origin = list(num[::])\\n        for i in range(k):\\n            num = findGreatest(num)\\n        # swap adjacent greedy\\n        ans, n = 0, len(num)\\n        for i in range(n):\\n            j = origin.index(num[i], i)\\n            ans += j - i\\n            origin[i:j+1] = [origin[j]] + origin[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443596,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char c[]=num.toCharArray();\\n        int count=0;\\n        while(count<k)\\n        {\\n           ArrayList<Character> l=new ArrayList<Character>();\\n           HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n            h.put(c[c.length-1],c.length-1);\\n            l.add(c[c.length-1]);\\n            int index=0;\\n            for(int i=c.length-2;i>=0;i--)\\n            {\\n                if(!h.containsKey(c[i]))\\n                {\\n                    h.put(c[i],i);\\n                    if(l.size()==1)\\n                    {\\n                        if(l.get(0)>c[i])\\n                        {\\n                            l.add(0,c[i]);\\n                            index=0;\\n                        }\\n                        else\\n                        {\\n                            l.add(c[i]);\\n                            index=1;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        int low=0,high=l.size()-1;\\n                        while(low<=high)\\n                        {\\n                            int mid=(low+high)/2;\\n                            if(l.get(mid)<c[i])\\n                            {\\n                                index=mid+1;\\n                                low=mid+1;\\n                            }\\n                            else\\n                            {\\n                                index=mid;\\n                                high=mid-1;\\n                            }\\n                        }\\n                        l.add(index,c[i]);\\n                    }\\n                    \\n                }\\n                if(c[i]<c[i+1])\\n                {\\n                    int currentElementIndex=l.indexOf(c[i]); // in ArrayList l\\n                    char nextGreaterElement=l.get(currentElementIndex+1);\\n                    int nextGreaterElement_Index=h.get(nextGreaterElement);\\n                    char temp=c[i];\\n                    c[i]=c[nextGreaterElement_Index];\\n                    c[nextGreaterElement_Index]=temp;\\n                    Arrays.sort(c,i+1,c.length);\\n                    break;\\n                }\\n            }\\n            count++;\\n        }\\n        ArrayList<Character> l=new ArrayList<Character>();\\n        for(int i=0;i<c.length;i++)\\n        {\\n            l.add(c[i]);\\n        }\\n        char ch[]=num.toCharArray();\\n        int result=0;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]!=l.get(i))\\n            {\\n                int r=-1;\\n               for(int j=i+1;j<c.length;j++)\\n               {\\n                   if(l.get(j)==ch[i])\\n                   {\\n                        r=j;\\n                        break;\\n                   }\\n               }\\n               result+=(r-i);\\n               l.remove(r);\\n               l.add(i,ch[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char c[]=num.toCharArray();\\n        int count=0;\\n        while(count<k)\\n        {\\n           ArrayList<Character> l=new ArrayList<Character>();\\n           HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n            h.put(c[c.length-1],c.length-1);\\n            l.add(c[c.length-1]);\\n            int index=0;\\n            for(int i=c.length-2;i>=0;i--)\\n            {\\n                if(!h.containsKey(c[i]))\\n                {\\n                    h.put(c[i],i);\\n                    if(l.size()==1)\\n                    {\\n                        if(l.get(0)>c[i])\\n                        {\\n                            l.add(0,c[i]);\\n                            index=0;\\n                        }\\n                        else\\n                        {\\n                            l.add(c[i]);\\n                            index=1;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        int low=0,high=l.size()-1;\\n                        while(low<=high)\\n                        {\\n                            int mid=(low+high)/2;\\n                            if(l.get(mid)<c[i])\\n                            {\\n                                index=mid+1;\\n                                low=mid+1;\\n                            }\\n                            else\\n                            {\\n                                index=mid;\\n                                high=mid-1;\\n                            }\\n                        }\\n                        l.add(index,c[i]);\\n                    }\\n                    \\n                }\\n                if(c[i]<c[i+1])\\n                {\\n                    int currentElementIndex=l.indexOf(c[i]); // in ArrayList l\\n                    char nextGreaterElement=l.get(currentElementIndex+1);\\n                    int nextGreaterElement_Index=h.get(nextGreaterElement);\\n                    char temp=c[i];\\n                    c[i]=c[nextGreaterElement_Index];\\n                    c[nextGreaterElement_Index]=temp;\\n                    Arrays.sort(c,i+1,c.length);\\n                    break;\\n                }\\n            }\\n            count++;\\n        }\\n        ArrayList<Character> l=new ArrayList<Character>();\\n        for(int i=0;i<c.length;i++)\\n        {\\n            l.add(c[i]);\\n        }\\n        char ch[]=num.toCharArray();\\n        int result=0;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]!=l.get(i))\\n            {\\n                int r=-1;\\n               for(int j=i+1;j<c.length;j++)\\n               {\\n                   if(l.get(j)==ch[i])\\n                   {\\n                        r=j;\\n                        break;\\n                   }\\n               }\\n               result+=(r-i);\\n               l.remove(r);\\n               l.add(i,ch[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432614,
                "title": "java-next-permutation-of-c-implementation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] a = num.toCharArray();\\n        int res = 0;\\n        while (k-- > 0)\\n            next(a);\\n        char[] b = num.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            int j = i;\\n            while (b[j] != a[i]) j++;\\n            while (j > i) {\\n                swap(b, j, j - 1);\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void next(char[] a) {\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i] >= a[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = a.length - 1;\\n            while (a[j] <= a[i]) j--;\\n            swap(a, i, j);\\n        }\\n        reverse(a, i + 1, a.length - 1);\\n    }\\n\\n    void swap(char[] a, int i, int j) {\\n        char t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n\\n    void reverse(char[] a, int i, int j) {\\n        while (i < j) {\\n            swap(a, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] a = num.toCharArray();\\n        int res = 0;\\n        while (k-- > 0)\\n            next(a);\\n        char[] b = num.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            int j = i;\\n            while (b[j] != a[i]) j++;\\n            while (j > i) {\\n                swap(b, j, j - 1);\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void next(char[] a) {\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i] >= a[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = a.length - 1;\\n            while (a[j] <= a[i]) j--;\\n            swap(a, i, j);\\n        }\\n        reverse(a, i + 1, a.length - 1);\\n    }\\n\\n    void swap(char[] a, int i, int j) {\\n        char t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n\\n    void reverse(char[] a, int i, int j) {\\n        while (i < j) {\\n            swap(a, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414796,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string copy = num;\\n        while (k-- > 0) next_permutation(copy.begin(), copy.end());\\n        int ans = 0;\\n        for (int f = 0, s = 0; f < num.size(); ++f){\\n            while (copy[s] == \\'#\\') ++s;\\n            if (num[f] != copy[s]){\\n                int dif = 1, ind = s;\\n                while (copy[++ind] != num[f]) dif += copy[ind] != \\'#\\';\\n                ans += dif;\\n                copy[ind] = \\'#\\';\\n            }\\n            else ++s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string copy = num;\\n        while (k-- > 0) next_permutation(copy.begin(), copy.end());\\n        int ans = 0;\\n        for (int f = 0, s = 0; f < num.size(); ++f){\\n            while (copy[s] == \\'#\\') ++s;\\n            if (num[f] != copy[s]){\\n                int dif = 1, ind = s;\\n                while (copy[++ind] != num[f]) dif += copy[ind] != \\'#\\';\\n                ans += dif;\\n                copy[ind] = \\'#\\';\\n            }\\n            else ++s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394818,
                "title": "two-pointer-swaping",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n\\n        string s=num;\\n        int c=0;\\n        \\n        for(int i=0;i<k;i++)\\n            next_permutation(num.begin(),num.end());\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int j=i+1;\\n\\n                while(num[j] != s[i]) \\n                j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   c++;\\n                   j--;\\n               }\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n\\n        string s=num;\\n        int c=0;\\n        \\n        for(int i=0;i<k;i++)\\n            next_permutation(num.begin(),num.end());\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int j=i+1;\\n\\n                while(num[j] != s[i]) \\n                j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   c++;\\n                   j--;\\n               }\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301884,
                "title": "next-permutation-with-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums = new int[num.length()];\\n        int[] original = new int[num.length()];\\n        int index = 0;\\n\\n        for (char ch : num.toCharArray()) {\\n            nums[index] = ch - \\'0\\';\\n            original[index++] = ch - \\'0\\';\\n        }\\n\\n        while (k-- > 0) {\\n            nextPermutation(nums);\\n        }\\n        int ans = 0;\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            // Meaning swap happened    \\n            if (nums[i] != original[i]) {\\n                int anchor = i;\\n                \\n                while (nums[anchor] != original[i]) {\\n                    anchor++;\\n                }\\n                while (anchor > i) {\\n                    swap(nums, anchor, anchor - 1);\\n                    ans++;\\n                    anchor--;\\n                }       \\n            }\\n        }\\n        return ans;\\n    }\\n    // next greater permutation\\n    private void nextPermutation(int[] arr) {\\n        int index = arr.length - 2;\\n\\n        while (index >= 0 && arr[index] >= arr[index + 1]) {\\n            index--;\\n        }\\n        int justGreaterThanEqualToIndex = binarySearchJustGreaterThanEqualTo(arr, index + 1, arr[index]);\\n        swap(arr, index, justGreaterThanEqualToIndex);\\n        reverse(arr, index + 1);\\n    }\\n\\n    private int binarySearchJustGreaterThanEqualTo(int[] arr, int index, int target) {\\n        int lo = index;\\n        int hi = arr.length - 1;\\n        int ans = index;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if(arr[pivot] > target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void swap(int[] arr, int x, int y) {\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int index) {\\n        int eIndex = arr.length - 1;\\n\\n        while (index < eIndex) {\\n            swap(arr, index++, eIndex--);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums = new int[num.length()];\\n        int[] original = new int[num.length()];\\n        int index = 0;\\n\\n        for (char ch : num.toCharArray()) {\\n            nums[index] = ch - \\'0\\';\\n            original[index++] = ch - \\'0\\';\\n        }\\n\\n        while (k-- > 0) {\\n            nextPermutation(nums);\\n        }\\n        int ans = 0;\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            // Meaning swap happened    \\n            if (nums[i] != original[i]) {\\n                int anchor = i;\\n                \\n                while (nums[anchor] != original[i]) {\\n                    anchor++;\\n                }\\n                while (anchor > i) {\\n                    swap(nums, anchor, anchor - 1);\\n                    ans++;\\n                    anchor--;\\n                }       \\n            }\\n        }\\n        return ans;\\n    }\\n    // next greater permutation\\n    private void nextPermutation(int[] arr) {\\n        int index = arr.length - 2;\\n\\n        while (index >= 0 && arr[index] >= arr[index + 1]) {\\n            index--;\\n        }\\n        int justGreaterThanEqualToIndex = binarySearchJustGreaterThanEqualTo(arr, index + 1, arr[index]);\\n        swap(arr, index, justGreaterThanEqualToIndex);\\n        reverse(arr, index + 1);\\n    }\\n\\n    private int binarySearchJustGreaterThanEqualTo(int[] arr, int index, int target) {\\n        int lo = index;\\n        int hi = arr.length - 1;\\n        int ans = index;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if(arr[pivot] > target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void swap(int[] arr, int x, int y) {\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int index) {\\n        int eIndex = arr.length - 1;\\n\\n        while (index < eIndex) {\\n            swap(arr, index++, eIndex--);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299912,
                "title": "c-simple-stl-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n         string s = num;\\n        int ans=0;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int a=0;\\n                int j;\\n                for( j=i+1;j<s.length();j++)\\n                {\\n                    if(num[i]==s[j])\\n                    {\\n                     break;\\n                    }\\n                        \\n                }\\n                ans+=j-i;\\n                \\n                while(j-1>=i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n         string s = num;\\n        int ans=0;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int a=0;\\n                int j;\\n                for( j=i+1;j<s.length();j++)\\n                {\\n                    if(num[i]==s[j])\\n                    {\\n                     break;\\n                    }\\n                        \\n                }\\n                ans+=j-i;\\n                \\n                while(j-1>=i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277952,
                "title": "c-simple-solution-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        //finding kth smallest number that is kth next permutation(next permutation is the next largest number)\\n        while(k--){\\n            next_permutation(s.begin(), s.end()); //finding \\n        }\\n        int minSwaps = 0; //for counting the number of swaps\\n        //traversing in the nums\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!= s[i]){ //if the digits of new string are not in their actual position, we need to find their position in the original array.\\n                int j = i+1; //for finding the index of the current digit of s in the right of the nums\\n                while(num[j]!=s[i])j++; //we will keep incrementing j until we find it\\'s actual position.\\n                //as soon as we find the actual position we need to swap them\\n                \\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    j--;\\n                    minSwaps++;\\n                    \\n                }\\n            }\\n        }\\n        return minSwaps;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        //finding kth smallest number that is kth next permutation(next permutation is the next largest number)\\n        while(k--){\\n            next_permutation(s.begin(), s.end()); //finding \\n        }\\n        int minSwaps = 0; //for counting the number of swaps\\n        //traversing in the nums\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!= s[i]){ //if the digits of new string are not in their actual position, we need to find their position in the original array.\\n                int j = i+1; //for finding the index of the current digit of s in the right of the nums\\n                while(num[j]!=s[i])j++; //we will keep incrementing j until we find it\\'s actual position.\\n                //as soon as we find the actual position we need to swap them\\n                \\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    j--;\\n                    minSwaps++;\\n                    \\n                }\\n            }\\n        }\\n        return minSwaps;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276492,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n\\n        func wond(_ num: String = num, _ k: Int = k) -> String {\\n\\n            guard k != 0 else { return num }\\n\\n            var n = num.index(before: num.endIndex)\\n            var p = num.index(before: n)\\n\\n            while num[p] >= num[n] {\\n                n = p\\n                p = num.index(before: p)\\n            }\\n\\n            let ch = num[p...].sorted()\\n            let fi = ch.firstIndex(where: { $0 > num[p] })!\\n\\n            var rep = ch\\n            rep.remove(at: fi)\\n            rep.insert(ch[fi], at: 0)\\n\\n            return wond(num[..<p] + String(rep), k - 1)\\n        }\\n\\n        let target = wond()\\n        let d = target.indices.first(where: { target[$0] != num[$0] })!\\n\\n        var suf1 = num[d...].map { $0 }\\n        var suf2 = target[d...].map { $0 }\\n\\n        var res = 0\\n\\n        while suf1 != suf2 {\\n            let i = suf1.indices.first(where: { suf1[$0] != suf2[$0] })!\\n\\n            suf1.removeFirst(i)\\n            suf2.removeFirst(i)\\n\\n            let j = suf1.firstIndex(of: suf2[0])!\\n\\n            suf1.remove(at: j)\\n            suf1.insert(suf2[0], at: 0)\\n\\n            res += j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n\\n        func wond(_ num: String = num, _ k: Int = k) -> String {\\n\\n            guard k != 0 else { return num }\\n\\n            var n = num.index(before: num.endIndex)\\n            var p = num.index(before: n)\\n\\n            while num[p] >= num[n] {\\n                n = p\\n                p = num.index(before: p)\\n            }\\n\\n            let ch = num[p...].sorted()\\n            let fi = ch.firstIndex(where: { $0 > num[p] })!\\n\\n            var rep = ch\\n            rep.remove(at: fi)\\n            rep.insert(ch[fi], at: 0)\\n\\n            return wond(num[..<p] + String(rep), k - 1)\\n        }\\n\\n        let target = wond()\\n        let d = target.indices.first(where: { target[$0] != num[$0] })!\\n\\n        var suf1 = num[d...].map { $0 }\\n        var suf2 = target[d...].map { $0 }\\n\\n        var res = 0\\n\\n        while suf1 != suf2 {\\n            let i = suf1.indices.first(where: { suf1[$0] != suf2[$0] })!\\n\\n            suf1.removeFirst(i)\\n            suf2.removeFirst(i)\\n\\n            let j = suf1.firstIndex(of: suf2[0])!\\n\\n            suf1.remove(at: j)\\n            suf1.insert(suf2[0], at: 0)\\n\\n            res += j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263173,
                "title": "using-next-permutation",
                "content": "# First use next_permutation function to find the kth smallest string.\\n# After that traverse in both the string and count the no of swaps of adjacent characters.\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n=num.length(), i=0;\\n        string target(num);\\n        while(next_permutation(target.begin(),target.end()) && i!=k-1){\\n            i++;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(num[i]!=target[i]){\\n                int j=i+1;\\n                while(num[j]!=target[i]){\\n                    j++;\\n                }\\n                for(;j>i;--j){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                }\\n            }\\n        } \\n        return count;   \\n    }\\n};\\n```\\n# Upvote GUYs",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n=num.length(), i=0;\\n        string target(num);\\n        while(next_permutation(target.begin(),target.end()) && i!=k-1){\\n            i++;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(num[i]!=target[i]){\\n                int j=i+1;\\n                while(num[j]!=target[i]){\\n                    j++;\\n                }\\n                for(;j>i;--j){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                }\\n            }\\n        } \\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245050,
                "title": "c-easy-code",
                "content": "\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string t=s;\\n        while(k--) next_permutation(begin(s), end(s));\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]==t[i]) continue;\\n\\n            for(int j=t.find(s[i],i); j>i; j--) {\\n                swap(t[j],t[j-1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string t=s;\\n        while(k--) next_permutation(begin(s), end(s));\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]==t[i]) continue;\\n\\n            for(int j=t.find(s[i],i); j>i; j--) {\\n                swap(t[j],t[j-1]);\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3225946,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        auto t = s;\\n        while(k--) next_permutation(begin(t), end(t));\\n        int res = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[i]) continue;\\n            for(int j = t.find(s[i], i); j>i; j--){\\n                swap(t[j], t[j-1]);\\n                res++;\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        auto t = s;\\n        while(k--) next_permutation(begin(t), end(t));\\n        int res = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[i]) continue;\\n            for(int j = t.find(s[i], i); j>i; j--){\\n                swap(t[j], t[j-1]);\\n                res++;\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221108,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        fn nxt_perm(num: &[char]) -> Vec<char> {\\n            let mut num = num.to_vec();\\n            let n = num.len() as i32;\\n            let mut i = n - 1;\\n            while i > 0 && num[(i - 1) as usize] >= num[i as usize] {\\n                i -= 1;\\n            }\\n            let mut j = i;\\n            while j < n && num[(i - 1) as usize] < num[j as usize] {\\n                j += 1;\\n            }\\n            num.swap((i - 1) as usize, (j - 1) as usize);\\n            num[i as usize..].reverse();\\n            num\\n        }\\n\\n        let mut nxt_k_num = num.chars().collect::<Vec<char>>();\\n        let n = nxt_k_num.len();\\n        for _ in 0..k {\\n            nxt_k_num = nxt_perm(&nxt_k_num);\\n        }\\n        let mut ans = 0;\\n        let mut num = num.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            let mut j = i;\\n            while j < n && nxt_k_num[i] != num[j] {\\n                j += 1;\\n            }\\n            ans += (j - i) as i32;\\n            num[i..=j].rotate_right(1);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        fn nxt_perm(num: &[char]) -> Vec<char> {\\n            let mut num = num.to_vec();\\n            let n = num.len() as i32;\\n            let mut i = n - 1;\\n            while i > 0 && num[(i - 1) as usize] >= num[i as usize] {\\n                i -= 1;\\n            }\\n            let mut j = i;\\n            while j < n && num[(i - 1) as usize] < num[j as usize] {\\n                j += 1;\\n            }\\n            num.swap((i - 1) as usize, (j - 1) as usize);\\n            num[i as usize..].reverse();\\n            num\\n        }\\n\\n        let mut nxt_k_num = num.chars().collect::<Vec<char>>();\\n        let n = nxt_k_num.len();\\n        for _ in 0..k {\\n            nxt_k_num = nxt_perm(&nxt_k_num);\\n        }\\n        let mut ans = 0;\\n        let mut num = num.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            let mut j = i;\\n            while j < n && nxt_k_num[i] != num[j] {\\n                j += 1;\\n            }\\n            ans += (j - i) as i32;\\n            num[i..=j].rotate_right(1);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137229,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        int ans = 0;\\n        do{\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }while(k );\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]!=s[i]){\\n                int j = i + 1;\\n                while(num[j] != s[i]) j++;\\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        int ans = 0;\\n        do{\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }while(k );\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]!=s[i]){\\n                int j = i + 1;\\n                while(num[j] != s[i]) j++;\\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102791,
                "title": "golang-greedy",
                "content": "# Code\\n```\\nfunc min_step(original string, num []byte) int {\\n    var ans int = 0\\n    var n int = len(original)\\n    for i := 0; i < n; i++ {\\n        j := i\\n        for num[j] != original[i] {j++}\\n        for i < j {\\n            num[j], num[j - 1] = num[j - 1], num[j]\\n            j--\\n            ans++\\n        }\\n    }\\n    return ans\\n}\\nfunc getMinSwaps(original string, k int) int {\\n    num := []byte(original)\\n    fmt.Println(num)\\n    var i, j int\\n    var n int = len(num)\\n    for ;k > 0; k-- {\\n        for i = n - 2; i >= 0; i-- {\\n            if num[i] < num[i + 1] {break}\\n        }\\n        for j = n - 1; j > i; j-- {\\n            if num[j] > num[i] {break}\\n        }\\n        num[i], num[j] = num[j], num[i]\\n        for p, q := i + 1, n - 1; p < q; p, q = p + 1, q - 1 {\\n            num[p], num[q] = num[q], num[p]\\n        }\\n    }\\n    return min_step(original, num)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc min_step(original string, num []byte) int {\\n    var ans int = 0\\n    var n int = len(original)\\n    for i := 0; i < n; i++ {\\n        j := i\\n        for num[j] != original[i] {j++}\\n        for i < j {\\n            num[j], num[j - 1] = num[j - 1], num[j]\\n            j--\\n            ans++\\n        }\\n    }\\n    return ans\\n}\\nfunc getMinSwaps(original string, k int) int {\\n    num := []byte(original)\\n    fmt.Println(num)\\n    var i, j int\\n    var n int = len(num)\\n    for ;k > 0; k-- {\\n        for i = n - 2; i >= 0; i-- {\\n            if num[i] < num[i + 1] {break}\\n        }\\n        for j = n - 1; j > i; j-- {\\n            if num[j] > num[i] {break}\\n        }\\n        num[i], num[j] = num[j], num[i]\\n        for p, q := i + 1, n - 1; p < q; p, q = p + 1, q - 1 {\\n            num[p], num[q] = num[q], num[p]\\n        }\\n    }\\n    return min_step(original, num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102720,
                "title": "c-greedy",
                "content": "# Code\\n```\\nclass Solution {\\n    int min_step(string &original, string &num) {\\n        int ans = 0, n = original.size();\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(num[j] != original[i]) j++;\\n            while(i < j) {\\n                swap(num[j], num[j - 1]);\\n                j--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        int i, j, n = num.size();\\n        while(k--) {\\n            for(i = n - 2; i >= 0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j = n - 1; j > i; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        return min_step(original, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int min_step(string &original, string &num) {\\n        int ans = 0, n = original.size();\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(num[j] != original[i]) j++;\\n            while(i < j) {\\n                swap(num[j], num[j - 1]);\\n                j--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        int i, j, n = num.size();\\n        while(k--) {\\n            for(i = n - 2; i >= 0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j = n - 1; j > i; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        return min_step(original, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999661,
                "title": "java-using-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] cnum = num.toCharArray();\\n        int right = cnum.length - 1;\\n        while (k > 0) {\\n            right = cnum.length - 1;\\n            TreeMap<Character, Integer> numberLine = new TreeMap<>();\\n            while (right > 0) {\\n                numberLine.put(cnum[right], numberLine.getOrDefault(cnum[right], 0) + 1);\\n                if (cnum[right - 1] < cnum[right]) {\\n                    char next = numberLine.ceilingKey((char)(cnum[right - 1] + 1));\\n                    numberLine.put(next, numberLine.get(next) - 1);\\n                    if (numberLine.get(next) == 0) numberLine.remove(next);\\n                    numberLine.put(cnum[right - 1], numberLine.getOrDefault(cnum[right - 1], 0) + 1);\\n                    cnum[right - 1] = next;\\n                    for (char ch : numberLine.keySet()) {\\n                        int n = numberLine.get(ch);\\n                        while (n > 0) {\\n                           cnum[right++] = ch;\\n                           n--;\\n                        }\\n                    }\\n                    break;\\n                }\\n                right--;\\n            }\\n            k--;\\n        }\\n        char[] src = num.toCharArray();\\n        char[] dest = cnum;\\n        return count(src, dest);\\n    }\\n    \\n    private int count(char[] src, char[] dest) {\\n        int count = 0;\\n        for (int i = 0; i < src.length; i++) {\\n            if (src[i] != dest[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (src[j] == dest[i]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1);\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void swap(char[] src, int i, int j) {\\n        char temp = src[i];\\n        src[i] = src[j];\\n        src[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] cnum = num.toCharArray();\\n        int right = cnum.length - 1;\\n        while (k > 0) {\\n            right = cnum.length - 1;\\n            TreeMap<Character, Integer> numberLine = new TreeMap<>();\\n            while (right > 0) {\\n                numberLine.put(cnum[right], numberLine.getOrDefault(cnum[right], 0) + 1);\\n                if (cnum[right - 1] < cnum[right]) {\\n                    char next = numberLine.ceilingKey((char)(cnum[right - 1] + 1));\\n                    numberLine.put(next, numberLine.get(next) - 1);\\n                    if (numberLine.get(next) == 0) numberLine.remove(next);\\n                    numberLine.put(cnum[right - 1], numberLine.getOrDefault(cnum[right - 1], 0) + 1);\\n                    cnum[right - 1] = next;\\n                    for (char ch : numberLine.keySet()) {\\n                        int n = numberLine.get(ch);\\n                        while (n > 0) {\\n                           cnum[right++] = ch;\\n                           n--;\\n                        }\\n                    }\\n                    break;\\n                }\\n                right--;\\n            }\\n            k--;\\n        }\\n        char[] src = num.toCharArray();\\n        char[] dest = cnum;\\n        return count(src, dest);\\n    }\\n    \\n    private int count(char[] src, char[] dest) {\\n        int count = 0;\\n        for (int i = 0; i < src.length; i++) {\\n            if (src[i] != dest[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (src[j] == dest[i]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1);\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void swap(char[] src, int i, int j) {\\n        char temp = src[i];\\n        src[i] = src[j];\\n        src[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969422,
                "title": "python-next-permutation-min-adj-swaps",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        def nextPerm(num):\\n            n = len(num)\\n            j = n - 1\\n            while j and num[j-1] >= num[j]:\\n                j -= 1\\n            pivot = num[j-1]\\n            k = j\\n            for i in range(j,n):\\n                if num[i] > pivot and num[i] < num[k]:\\n                    k = i\\n            num[j-1], num[k] = num[k], num[j-1]\\n            num[j:] = sorted(num[j:])\\n            return num\\n        org = num[:]\\n        while k > 0:\\n            num = nextPerm(num)\\n            k -= 1\\n        res = 0\\n        for i in range(len(num)):\\n            j = num.index(org[i], i)\\n            res += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return res\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        def nextPerm(num):\\n            n = len(num)\\n            j = n - 1\\n            while j and num[j-1] >= num[j]:\\n                j -= 1\\n            pivot = num[j-1]\\n            k = j\\n            for i in range(j,n):\\n                if num[i] > pivot and num[i] < num[k]:\\n                    k = i\\n            num[j-1], num[k] = num[k], num[j-1]\\n            num[j:] = sorted(num[j:])\\n            return num\\n        org = num[:]\\n        while k > 0:\\n            num = nextPerm(num)\\n            k -= 1\\n        res = 0\\n        for i in range(len(num)):\\n            j = num.index(org[i], i)\\n            res += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return res\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893412,
                "title": "c-94-51-faster-simple-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int getMinSwaps(string num, int k) {\\n        ll n=num.length(),answer=0;\\n        string temp=num;\\n        while(k--){\\n            next_permutation(temp.begin(),temp.end());\\n        }\\n        for(ll i=0,j=0;i<n && j<n;j++,i++){\\n            if(num[i]==temp[j]){\\n                continue;\\n            }\\n            else{\\n                ll k;\\n                for(k=i+1;k<n;k++){\\n                    if(num[k]==temp[j]){\\n                        break;\\n                    }\\n                }\\n                for(k;k>i;k--){\\n                    answer++;\\n                    swap(num[k],num[k-1]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int getMinSwaps(string num, int k) {\\n        ll n=num.length(),answer=0;\\n        string temp=num;\\n        while(k--){\\n            next_permutation(temp.begin(),temp.end());\\n        }\\n        for(ll i=0,j=0;i<n && j<n;j++,i++){\\n            if(num[i]==temp[j]){\\n                continue;\\n            }\\n            else{\\n                ll k;\\n                for(k=i+1;k<n;k++){\\n                    if(num[k]==temp[j]){\\n                        break;\\n                    }\\n                }\\n                for(k;k>i;k--){\\n                    answer++;\\n                    swap(num[k],num[k-1]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782765,
                "title": "python-follow-up-on-the-next-permutation-for-pythoner",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int):\\n        def next_perm(num):\\n            n, j = len(num), 0\\n            for i in range(n - 2, -1, -1):\\n                if num[i] < num[i + 1]:\\n                    j = i\\n                    break\\n            for i in range(n - 1, j, -1):\\n                if num[i] > num[j]:\\n                    return num[:j] + num[i] + (num[j + 1: i] + num[j] + num[i + 1:])[::-1]\\n                \\n        def next_k_perm(num, k):\\n            if k == 0: return num\\n            return next_k_perm(next_perm(num), k - 1)\\n        \\n        tar, n, ans = next_k_perm(num, k), len(num), 0\\n        for i in range(n):\\n            if num[i] != tar[i]:\\n                for j in range(i + 1, n):\\n                    if num[j] == tar[i]:\\n                        ans += j - i\\n                        num = num[:i] + num[j] + num[i: j] + num[j + 1:]\\n                        break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int):\\n        def next_perm(num):\\n            n, j = len(num), 0\\n            for i in range(n - 2, -1, -1):\\n                if num[i] < num[i + 1]:\\n                    j = i\\n                    break\\n            for i in range(n - 1, j, -1):\\n                if num[i] > num[j]:\\n                    return num[:j] + num[i] + (num[j + 1: i] + num[j] + num[i + 1:])[::-1]\\n                \\n        def next_k_perm(num, k):\\n            if k == 0: return num\\n            return next_k_perm(next_perm(num), k - 1)\\n        \\n        tar, n, ans = next_k_perm(num, k), len(num), 0\\n        for i in range(n):\\n            if num[i] != tar[i]:\\n                for j in range(i + 1, n):\\n                    if num[j] == tar[i]:\\n                        ans += j - i\\n                        num = num[:i] + num[j] + num[i: j] + num[j + 1:]\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753604,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // step : 1\\n    // find kth Permutation\\n    // step : 2\\n    // counts adj swaps\\n    \\n    void NextPermutation(string &s){\\n        int n = s.size();\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(s[i] < s[i + 1]){\\n                int val = s[i];\\n                int si = i + 1 , ei = n - 1 , x= 0;\\n                while(si <= ei){\\n                    int mid = (si + ei)/2;\\n                    if(s[mid] == val){\\n                        ei = mid - 1;\\n                    }\\n                    else if(s[mid] > val){\\n                        x = mid;\\n                        si = mid + 1;\\n                    }\\n                    else{\\n                        ei = mid - 1;\\n                    }\\n                }\\n                swap(s[i] , s[x]);\\n                reverse(s.begin() + i + 1 , s.end());\\n                return;\\n            }\\n        }\\n    }\\n    \\n    int getMinSwaps(string s, int k) {\\n        string s1 = s;\\n        while(k>0){\\n            NextPermutation(s);\\n            k--;\\n        }\\n        string s2 = s;\\n        \\n        int n = s1.size();\\n        int i = n - 1 , j = n - 1;\\n        \\n        int ans = 0; \\n        \\n        while(i >= 0){\\n            while(s2[j]!=s1[i]) j--;\\n            while(j + 1 < n){\\n                swap(s2[j] , s2[j+1]);\\n                ans++;\\n                j++;\\n            }\\n            i--;\\n            j = i;\\n            n--;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // step : 1\\n    // find kth Permutation\\n    // step : 2\\n    // counts adj swaps\\n    \\n    void NextPermutation(string &s){\\n        int n = s.size();\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(s[i] < s[i + 1]){\\n                int val = s[i];\\n                int si = i + 1 , ei = n - 1 , x= 0;\\n                while(si <= ei){\\n                    int mid = (si + ei)/2;\\n                    if(s[mid] == val){\\n                        ei = mid - 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2635844,
                "title": "python-next-permutation-greedy-swap-from-target-to-original-num",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n       \\n        def next_permutation(nums):\\n            for i in range(len(nums) - 2, -1, -1):\\n                if nums[i] < nums[i + 1]:\\n                    for k in range(len(nums) - 1, i, -1):\\n                        if nums[k] > nums[i]:\\n                            nums[i], nums[k] = nums[k], nums[i]\\n                            l = i+1\\n                            r = len(nums)-1\\n                            while l < r:\\n                                nums[l], nums[r] = nums[r], nums[l]\\n                                l+=1\\n                                r-=1\\n                            break\\n                    break\\n            else:\\n                nums.reverse()\\n   \\n        num = [int(i) for i in num]\\n        target = list(num)\\n        for _ in range(k):\\n            next_permutation(target)\\n\\n        \\n        ans = 0\\n        j = 0\\n        for i in range(len(num)):\\n            j = i\\n           \\n            while num[i] != target[j]:\\n                j+=1\\n            while i < j:\\n                target[j], target[j-1] = target[j-1], target[j]\\n                j-=1\\n                ans +=1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n       \\n        def next_permutation(nums):\\n            for i in range(len(nums) - 2, -1, -1):\\n                if nums[i] < nums[i + 1]:\\n                    for k in range(len(nums) - 1, i, -1):\\n                        if nums[k] > nums[i]:\\n                            nums[i], nums[k] = nums[k], nums[i]\\n                            l = i+1\\n                            r = len(nums)-1\\n                            while l < r:\\n                                nums[l], nums[r] = nums[r], nums[l]\\n                                l+=1\\n                                r-=1\\n                            break\\n                    break\\n            else:\\n                nums.reverse()\\n   \\n        num = [int(i) for i in num]\\n        target = list(num)\\n        for _ in range(k):\\n            next_permutation(target)\\n\\n        \\n        ans = 0\\n        j = 0\\n        for i in range(len(num)):\\n            j = i\\n           \\n            while num[i] != target[j]:\\n                j+=1\\n            while i < j:\\n                target[j], target[j-1] = target[j-1], target[j]\\n                j-=1\\n                ans +=1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610355,
                "title": "python-solution-beats-80",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        numCopy, ans = num, 0\\n        num, numCopy = list(num), list(numCopy)\\n        while k:\\n            left, right = len(num) - 2, len(num) - 1\\n            while left >= 0:\\n                if num[left] < num[left + 1]:  \\n                    break\\n                left -= 1\\n            while right >= 0:\\n                if num[left] < num[right]:\\n                    break\\n                right -= 1\\n            num[left], num[right] = num[right], num[left]\\n            num = num[:left + 1] + list(reversed(num[left + 1:]))\\n            k -= 1\\n        for i in range(len(num)):\\n            if numCopy[i] != num[i]:\\n                j = i\\n                while(numCopy[i] != num[j]): j += 1\\n                while j > i:\\n                    num[j], num[j - 1] = num[j - 1], num[j]\\n                    j -= 1\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        numCopy, ans = num, 0\\n        num, numCopy = list(num), list(numCopy)\\n        while k:\\n            left, right = len(num) - 2, len(num) - 1\\n            while left >= 0:\\n                if num[left] < num[left + 1]:  \\n                    break\\n                left -= 1\\n            while right >= 0:\\n                if num[left] < num[right]:\\n                    break\\n                right -= 1\\n            num[left], num[right] = num[right], num[left]\\n            num = num[:left + 1] + list(reversed(num[left + 1:]))\\n            k -= 1\\n        for i in range(len(num)):\\n            if numCopy[i] != num[i]:\\n                j = i\\n                while(numCopy[i] != num[j]): j += 1\\n                while j > i:\\n                    num[j], num[j - 1] = num[j - 1], num[j]\\n                    j -= 1\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606048,
                "title": "short-concise-c",
                "content": "# Without STL\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) {\\n            int i, j;\\n            for(i=num.size()-2; i>=0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j=num.size()-1; i>=0; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```\\n\\n# Using STL\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) next_permutation(num.begin(), num.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) {\\n            int i, j;\\n            for(i=num.size()-2; i>=0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j=num.size()-1; i>=0; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) next_permutation(num.begin(), num.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563658,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.size();\\n        int swaps=0;\\n\\n        int i=0, j=0;\\n        while(i<n)\\n        {\\n            if(s[i]!=num[j])\\n            {\\n                while(j<n and num[j]!=s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(num[j-1],num[j]);\\n                    swaps++;\\n                    j--;\\n                }                  \\n                \\n            }\\n            \\n                i++;\\n                j++;\\n            \\n        }\\n        return swaps;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.size();\\n        int swaps=0;\\n\\n        int i=0, j=0;\\n        while(i<n)\\n        {\\n            if(s[i]!=num[j])\\n            {\\n                while(j<n and num[j]!=s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(num[j-1],num[j]);\\n                    swaps++;\\n                    j--;\\n                }                  \\n                \\n            }\\n            \\n                i++;\\n                j++;\\n            \\n        }\\n        return swaps;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561656,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(char*)a - *(char*)b;\\n}\\n\\n//\\n//next Permutation\\nvoid nextPermutation(char* nums, int numsSize){\\n\\n    for(int i = numsSize - 2 ; i >= 0; i--){\\n        if(nums[i] < nums[i + 1]){\\n            qsort(&nums[i+1], numsSize-(i+1), sizeof(char), cmpfunc);\\n            for(int j = i+1; j < numsSize; j++){\\n                if(nums[j] > nums[i]){\\n                    char temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;   \\n                    return;\\n                }\\n            }      \\n        }\\n    }\\n    \\n    qsort(nums, numsSize, sizeof(char), cmpfunc);\\n}\\n\\n//\\n//main function\\nint getMinSwaps(char * num, int k){\\n    int len = strlen(num);\\n    char* copy = malloc( (len+1) * sizeof(char));\\n    char* temp = malloc( (len+1) * sizeof(char));\\n    copy[len] = \\'\\\\0\\';\\n    strcpy(copy, num);\\n    \\n    //>>> produce kth number to \"char* copy\" \\n    for(int i = 0; i < k; i++){\\n        nextPermutation(copy, len);\\n    }\\n    //<<<<<\\n    \\n    //>>>> begin count swap times\\n    int ans = 0;\\n    for(int i = 0; i < len; i++){\\n        if(copy[i] == num[i])\\n            continue;\\n        for(int j = i+1; j < len; j++){\\n            if(copy[i] == num[j]){\\n                strncpy(temp, &num[i] , j-i);\\n                strncpy(&num[i+1], temp , j-i);\\n                num[i] = copy[i];   \\n                ans += (j-i) ;\\n                break;\\n            }\\n        }\\n    }\\n    //<<<<<\\n    \\n    free(copy);\\n    free(temp);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(char*)a - *(char*)b;\\n}\\n\\n//\\n//next Permutation\\nvoid nextPermutation(char* nums, int numsSize){\\n\\n    for(int i = numsSize - 2 ; i >= 0; i--){\\n        if(nums[i] < nums[i + 1]){\\n            qsort(&nums[i+1], numsSize-(i+1), sizeof(char), cmpfunc);\\n            for(int j = i+1; j < numsSize; j++){\\n                if(nums[j] > nums[i]){\\n                    char temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;   \\n                    return;\\n                }\\n            }      \\n        }\\n    }\\n    \\n    qsort(nums, numsSize, sizeof(char), cmpfunc);\\n}\\n\\n//\\n//main function\\nint getMinSwaps(char * num, int k){\\n    int len = strlen(num);\\n    char* copy = malloc( (len+1) * sizeof(char));\\n    char* temp = malloc( (len+1) * sizeof(char));\\n    copy[len] = \\'\\\\0\\';\\n    strcpy(copy, num);\\n    \\n    //>>> produce kth number to \"char* copy\" \\n    for(int i = 0; i < k; i++){\\n        nextPermutation(copy, len);\\n    }\\n    //<<<<<\\n    \\n    //>>>> begin count swap times\\n    int ans = 0;\\n    for(int i = 0; i < len; i++){\\n        if(copy[i] == num[i])\\n            continue;\\n        for(int j = i+1; j < len; j++){\\n            if(copy[i] == num[j]){\\n                strncpy(temp, &num[i] , j-i);\\n                strncpy(&num[i+1], temp , j-i);\\n                num[i] = copy[i];   \\n                ans += (j-i) ;\\n                break;\\n            }\\n        }\\n    }\\n    //<<<<<\\n    \\n    free(copy);\\n    free(temp);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557849,
                "title": "c-greedy-next-permutation",
                "content": "```\\n/*\\n\\nmin no of adjacent digit swaps to find kth smallest number ?\\n\\nnext permutation is always just greater number\\n\\nso \\n\\nans= min no of adjacent swaps to make the given string equals to its next kth permutation\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n       string need=num;\\n        \\n        \\n        while(k--){   // O(k)\\n            next_permutation(need.begin(),need.end());  // O(n)\\n        }\\n        \\n        \\n        return find(num,need);\\n        \\n    }\\n    \\n    \\n    \\n  int find(string s1,string s2){\\n\\n    // s1=>s2\\n\\n    int n=s1.size();\\n\\n    int i=0;\\n\\n    int count=0;\\n\\n    while(i<n){\\n\\n       if(s2[i]!=s1[i]){\\n        int k=i;\\n          while(i<n && s2[k]!=s1[i]){\\n            i++;\\n          }\\n          int j=i-1;\\n\\n          while(j>=k){\\n             swap(s1[i],s1[j]);\\n             i--,j--;\\n             count++;\\n          }\\n          i=k+1;\\n       }\\n       else\\n        i++;\\n    }\\n\\n      \\n      return count;\\n   // cout<<count<<\" \"<<s1<<\" \"<<s2;\\n\\n  }\\n\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n       string need=num;\\n        \\n        \\n        while(k--){   // O(k)\\n            next_permutation(need.begin(),need.end());  // O(n)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557348,
                "title": "c-simple-and-clean-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nint getMinSwaps(string num, int k) \\n    {\\n        string temp=num;\\n        int count=0;\\n        while(k)\\n        {\\n            next_permutation(temp.begin(),temp.end());\\n            k--;\\n        }\\n        int i=0,j;\\n        while(i<num.size())\\n        {\\n            j=i;\\n            while(num[j] != temp[i])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(num[j],num[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nint getMinSwaps(string num, int k) \\n    {\\n        string temp=num;\\n        int count=0;\\n        while(k)\\n        {\\n            next_permutation(temp.begin(),temp.end());\\n            k--;\\n        }\\n        int i=0,j;\\n        while(i<num.size())\\n        {\\n            j=i;\\n            while(num[j] != temp[i])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(num[j],num[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2547368,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp=num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int i=0;\\n        int count=0;\\n        while(i<temp.size()){\\n            if(temp==num){\\n                return count;\\n            }\\n            if(temp[i]!=num[i]){\\n                int j=i+1;\\n                while(num[j]!=temp[i]){\\n                    j++;\\n                }\\n                while(j>i){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                    j--;\\n                }\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp=num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int i=0;\\n        int count=0;\\n        while(i<temp.size()){\\n            if(temp==num){\\n                return count;\\n            }\\n            if(temp[i]!=num[i]){\\n                int j=i+1;\\n                while(num[j]!=temp[i]){\\n                    j++;\\n                }\\n                while(j>i){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                    j--;\\n                }\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517335,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string n, int k) \\n    {\\n        string n1=n;\\n        while(k--)\\n        {\\n            next_permutation(n1.begin(),n1.end());\\n        }\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<n.size())\\n        {\\n            j=i;\\n            while(n[i]!=n1[j])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(n1[j],n1[j-1]);\\n                ans++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string n, int k) \\n    {\\n        string n1=n;\\n        while(k--)\\n        {\\n            next_permutation(n1.begin(),n1.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2497680,
                "title": "python3-100-63ms-very-fast-skip-next-perm",
                "content": "The question can be seperated to two part:\\n1. **get_k_next**: find the k-next permuation `num2`\\n2.  **get_swap** :compare the `num2` and `num` and find the min swap.\\n\\n## Simulate Adjacent Swapping\\nThe second part can be solved by simulate the swap and count, like following. The complexity is **O(N+swaps)**(worst **O(N^2)**)\\n```\\ndef get_swap(li1,li2):\\n\\tn,res = len(li1),0\\n\\tfor i in range(n):\\n\\t\\tj = i\\n\\t\\twhile li2[i]!=li1[j]:\\n\\t\\t\\tj += 1\\n\\t\\tres += (j-i)\\n\\t\\twhile j>i:\\n\\t\\t\\tli1[j],li1[j-1] = li1[j-1],li1[j]\\n\\t\\t\\tj -= 1\\n\\treturn res\\n```\\n\\n## Next-Permutation and Skip-Next-Permutation\\nFor the first part, there are two ways. \\n### Next Permutation \\n1. The first way is to find the next permutation and do it for k time. The complexity is **O(KN)**:\\n```\\nfrom bisect import bisect\\ndef next_perm(li):\\n\\tbuf = []\\n\\twhile li:\\n\\t\\te = li.pop()\\n\\t\\tif not buf or buf[-1]<=e:\\n\\t\\t\\tbuf.append(e)\\n\\t\\telse:\\n\\t\\t\\tind = bisect(buf,e)\\n\\t\\t\\te,buf[ind] = buf[ind],e\\n\\t\\t\\treturn li + [e] + buf\\n\\ndef get_k_next(num, k=k):\\n\\tfor _ in range(k):\\n\\t\\tnum = next_perm(num)\\n\\treturn num\\n```\\n### Skip Next Permutation\\n2. The second way is to calculate the possible number of wonderful permutations for current digit, skip those permutations if k is not reached, otherwise go to the next digit and calculate the again (need two turn, logics are slightly different).  \\n* \\tThe code also needs to calculate according to [Permutations of multisets](https://en.wikipedia.org/wiki/Permutation). The `get_fact` function do the calculation and optimize for this problem that k is much smaller than the possible number of permuation.\\n![image](https://assets.leetcode.com/users/images/a67fb4da-fb8d-4848-9852-5a6967eab94b_1661725841.6515608.png)\\n* The complexity is roughly **O(N+KlogK)**.\\n\\n```\\ndef get_fact(li,limit):\\n\\tres,total = 1,sum(li)\\n\\tli = sorted([e for e in li if e],reverse = True)\\n\\tif not li: \\n\\t\\treturn 0\\n\\twhile len(li)!=1:\\n\\t\\tn = li[-1]\\n\\t\\tli[-1] -= 1\\n\\t\\tif n==1:\\n\\t\\t\\tli.pop()\\n\\t\\tres = res*total//n\\n\\t\\ttotal -= 1\\n\\t\\tif res>limit:\\n\\t\\t\\treturn None\\n\\treturn res\\n\\ndef get_k_next(num, k=k):\\n\\tct,f = [0]*10,True\\n\\twhile num and f:\\n\\t\\tdig = int(num.pop())\\n\\t\\tct[dig] += 1\\n\\t\\tfor j in range(dig+1,10):\\n\\t\\t\\tif ct[j]>0:\\n\\t\\t\\t\\tct[j] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tf = False\\n\\t\\t\\t\\t\\tnum.append(str(j))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[j] += 1    \\n\\twhile k!=c:\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif ct[i]>0:\\n\\t\\t\\t\\tct[i] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tnum.append(str(i))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[i] += 1\\n\\n\\tfor i in range(9,-1,-1):\\n\\t\\tif ct[i]>0:\\n\\t\\t\\tnum += [str(i)]*ct[i]\\n\\treturn num\\n```\\n\\n### Comparison and Summary\\nThe runtime comparision is like the screenshot. The second one beats 100% and is tens of times faster than other top rank submissions. However, the code and its logic are slightly complex and may not be suitable for interview.\\n![image](https://assets.leetcode.com/users/images/0937a857-8328-45fb-9ac3-de998106548e_1661726440.5405748.png)\\n![image](https://assets.leetcode.com/users/images/208bdef5-0f23-49cb-a321-b3d8d141ffa6_1661726540.5652432.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef get_swap(li1,li2):\\n\\tn,res = len(li1),0\\n\\tfor i in range(n):\\n\\t\\tj = i\\n\\t\\twhile li2[i]!=li1[j]:\\n\\t\\t\\tj += 1\\n\\t\\tres += (j-i)\\n\\t\\twhile j>i:\\n\\t\\t\\tli1[j],li1[j-1] = li1[j-1],li1[j]\\n\\t\\t\\tj -= 1\\n\\treturn res\\n```\n```\\nfrom bisect import bisect\\ndef next_perm(li):\\n\\tbuf = []\\n\\twhile li:\\n\\t\\te = li.pop()\\n\\t\\tif not buf or buf[-1]<=e:\\n\\t\\t\\tbuf.append(e)\\n\\t\\telse:\\n\\t\\t\\tind = bisect(buf,e)\\n\\t\\t\\te,buf[ind] = buf[ind],e\\n\\t\\t\\treturn li + [e] + buf\\n\\ndef get_k_next(num, k=k):\\n\\tfor _ in range(k):\\n\\t\\tnum = next_perm(num)\\n\\treturn num\\n```\n```\\ndef get_fact(li,limit):\\n\\tres,total = 1,sum(li)\\n\\tli = sorted([e for e in li if e],reverse = True)\\n\\tif not li: \\n\\t\\treturn 0\\n\\twhile len(li)!=1:\\n\\t\\tn = li[-1]\\n\\t\\tli[-1] -= 1\\n\\t\\tif n==1:\\n\\t\\t\\tli.pop()\\n\\t\\tres = res*total//n\\n\\t\\ttotal -= 1\\n\\t\\tif res>limit:\\n\\t\\t\\treturn None\\n\\treturn res\\n\\ndef get_k_next(num, k=k):\\n\\tct,f = [0]*10,True\\n\\twhile num and f:\\n\\t\\tdig = int(num.pop())\\n\\t\\tct[dig] += 1\\n\\t\\tfor j in range(dig+1,10):\\n\\t\\t\\tif ct[j]>0:\\n\\t\\t\\t\\tct[j] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tf = False\\n\\t\\t\\t\\t\\tnum.append(str(j))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[j] += 1    \\n\\twhile k!=c:\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif ct[i]>0:\\n\\t\\t\\t\\tct[i] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tnum.append(str(i))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[i] += 1\\n\\n\\tfor i in range(9,-1,-1):\\n\\t\\tif ct[i]>0:\\n\\t\\t\\tnum += [str(i)]*ct[i]\\n\\treturn num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2447297,
                "title": "clean-java-code-two-pointers",
                "content": "```\\npublic class MinSwaps {\\n    public int getMinSwaps(String num, int k) {\\n        if(num == null || num.length() == 0) return 0;\\n\\n\\n        int[] nums = Arrays.stream(num.chars().toArray())\\n                .map(Character::getNumericValue)\\n                .toArray();\\n\\n        int[] kthSmallest = nextPermutation(nums.clone(), k);\\n\\n        return countSteps(nums, kthSmallest);\\n    }\\n\\n    /**\\n     * Count the number of steps required to make second array back to the first array\\n     * @param first\\n     * @param second\\n     * @return\\n     */\\n    private int countSteps(int[] first, int[] second) {\\n        int i = 0, j = 0;\\n        int result = 0;\\n\\n        int len = first.length;\\n        while(i < len){\\n            j = i;\\n\\n            while(j < len && second[j] != first[i]){\\n                j++;\\n            }\\n\\n            // This will make the second array back to the original one.\\n            // while doing so, we\\'ll keep track of how many times we are doing this to reach the original\\n            // In simple words, bring the number at j-th position to i-th position.\\n            while(i < j){\\n                swap(second, j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int[] nextPermutation(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return new int[]{};\\n\\n        int n = nums.length;\\n\\n        while(k-- > 0) {\\n\\n            //Step 1: Find the breach\\n            int i = n - 2;\\n            while(i >= 0 && nums[i] >= nums[i + 1]) {\\n                i--;\\n            }\\n\\n            //Step 2: Find the next larger element than the current i\\n            if(i >= 0) { // for 5 4 3 2 1 (all in descending order), i will go to -1\\n                int j = n - 1;\\n                while(j >= 0 && nums[j] <= nums[i]) {\\n                    j--;\\n                }\\n                swap(nums, i, j);\\n            }\\n\\n            //Step 3: Reverse the sub-array starting from i + 1\\n            reverse(nums, i + 1, n - 1);\\n\\n        }\\n\\n        return nums;\\n    }\\n\\n    private void swap(int[] arr, int l, int r) {\\n        int temp = arr[l];\\n        arr[l] = arr[r];\\n        arr[r] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int l, int r) {\\n        while(l <= r) {\\n            swap(arr, l, r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class MinSwaps {\\n    public int getMinSwaps(String num, int k) {\\n        if(num == null || num.length() == 0) return 0;\\n\\n\\n        int[] nums = Arrays.stream(num.chars().toArray())\\n                .map(Character::getNumericValue)\\n                .toArray();\\n\\n        int[] kthSmallest = nextPermutation(nums.clone(), k);\\n\\n        return countSteps(nums, kthSmallest);\\n    }\\n\\n    /**\\n     * Count the number of steps required to make second array back to the first array\\n     * @param first\\n     * @param second\\n     * @return\\n     */\\n    private int countSteps(int[] first, int[] second) {\\n        int i = 0, j = 0;\\n        int result = 0;\\n\\n        int len = first.length;\\n        while(i < len){\\n            j = i;\\n\\n            while(j < len && second[j] != first[i]){\\n                j++;\\n            }\\n\\n            // This will make the second array back to the original one.\\n            // while doing so, we\\'ll keep track of how many times we are doing this to reach the original\\n            // In simple words, bring the number at j-th position to i-th position.\\n            while(i < j){\\n                swap(second, j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int[] nextPermutation(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return new int[]{};\\n\\n        int n = nums.length;\\n\\n        while(k-- > 0) {\\n\\n            //Step 1: Find the breach\\n            int i = n - 2;\\n            while(i >= 0 && nums[i] >= nums[i + 1]) {\\n                i--;\\n            }\\n\\n            //Step 2: Find the next larger element than the current i\\n            if(i >= 0) { // for 5 4 3 2 1 (all in descending order), i will go to -1\\n                int j = n - 1;\\n                while(j >= 0 && nums[j] <= nums[i]) {\\n                    j--;\\n                }\\n                swap(nums, i, j);\\n            }\\n\\n            //Step 3: Reverse the sub-array starting from i + 1\\n            reverse(nums, i + 1, n - 1);\\n\\n        }\\n\\n        return nums;\\n    }\\n\\n    private void swap(int[] arr, int l, int r) {\\n        int temp = arr[l];\\n        arr[l] = arr[r];\\n        arr[r] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int l, int r) {\\n        while(l <= r) {\\n            swap(arr, l, r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2446553,
                "title": "clean-java-code-easy-to-understand-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n          int n =num.length();\\n        int [] org = new int [n];\\n        int [] nums = new int [n];\\n        for(int i =0;i<n;i++){\\n            org[i]=Character.getNumericValue(num.charAt(i));\\n            nums[i]=Character.getNumericValue(num.charAt(i));\\n        }\\n        while(k>=1){\\n            newPermutation(nums,n);\\n                k--;\\n        }\\n        int ans =0;\\n        \\n        \\n        for(int each :nums){\\n            System.out.print(each);\\n        }\\n         \\n        // below calculating min no of adjacent swaps required\\n         \\n    int i =0;\\n   for( i =0;i<n;i++){\\n       \\n       if(org[i]!=nums[i]){\\n           \\n           int j =0;\\n           for(j =i+1;j<n;j++){\\n               if(nums[i]==org[j])\\n                   break;\\n           }\\n           while(j>0 && j!=i)\\n           {\\n               swap(org,j-1,j);\\n                   ans++;\\n               j--;\\n           }\\n       }\\n       \\n       \\n   }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    private void newPermutation(int [] nums,int n  ){\\n        \\n        if(nums.length==1)\\n            return ;\\n        int first =n-2;\\n        while(first>=0 && nums[first]>=nums[first+1])\\n            first--;\\n        if(first<0)\\n            return ;\\n        int second =n-1;\\n        while(first<second && nums[first]>=nums[second])\\n            second --;\\n        swap(nums,first,second);\\n            \\n            reverse(nums,first+1,n );\\n    }\\n    private void swap(int [] nums,int i ,int j){\\n        if(i==j)\\n            return ;\\n        int temp =nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    private void reverse(int [] nums ,int i,int n ){\\n        int j =n-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n          int n =num.length();\\n        int [] org = new int [n];\\n        int [] nums = new int [n];\\n        for(int i =0;i<n;i++){\\n            org[i]=Character.getNumericValue(num.charAt(i));\\n            nums[i]=Character.getNumericValue(num.charAt(i));\\n        }\\n        while(k>=1){\\n            newPermutation(nums,n);\\n                k--;\\n        }\\n        int ans =0;\\n        \\n        \\n        for(int each :nums){\\n            System.out.print(each);\\n        }\\n         \\n        // below calculating min no of adjacent swaps required\\n         \\n    int i =0;\\n   for( i =0;i<n;i++){\\n       \\n       if(org[i]!=nums[i]){\\n           \\n           int j =0;\\n           for(j =i+1;j<n;j++){\\n               if(nums[i]==org[j])\\n                   break;\\n           }\\n           while(j>0 && j!=i)\\n           {\\n               swap(org,j-1,j);\\n                   ans++;\\n               j--;\\n           }\\n       }\\n       \\n       \\n   }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    private void newPermutation(int [] nums,int n  ){\\n        \\n        if(nums.length==1)\\n            return ;\\n        int first =n-2;\\n        while(first>=0 && nums[first]>=nums[first+1])\\n            first--;\\n        if(first<0)\\n            return ;\\n        int second =n-1;\\n        while(first<second && nums[first]>=nums[second])\\n            second --;\\n        swap(nums,first,second);\\n            \\n            reverse(nums,first+1,n );\\n    }\\n    private void swap(int [] nums,int i ,int j){\\n        if(i==j)\\n            return ;\\n        int temp =nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    private void reverse(int [] nums ,int i,int n ){\\n        int j =n-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409205,
                "title": "c-simple-solution-using-next-permutation",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406308,
                "title": "wrote-my-own-permutation-function-but-it-gives-me-tle-why",
                "content": "I used my own permutation function rather than using C++ in-built `next_permutation` method, I am unable to understand, how can I optimise my function. The snippet of the same is given below. Please help here.\\nThanks in advance.\\n```\\nvoid getKthNextPermutation(string&num,int size,int k){\\n        while(k--){\\n    \\n\\t\\t\\tint i = size-2;\\n            multiset<char>sArr={num[size-1]};\\n            \\n            while(i>=0){\\n                \\n                if(num[i]>=num[i+1]){\\n                    sArr.insert(num[i]);\\n                }\\n                else{\\n                    \\n                    auto it = upper_bound(sArr.begin(),sArr.end(),num[i]);\\n                    auto val = *it;\\n                    sArr.erase(it);\\n                    sArr.insert(num[i]);\\n                    num[i] = val;\\n                    i++;\\n                    \\n                    auto itt = sArr.begin();\\n                    \\n                    while(itt!=sArr.end()){\\n                        num[i] = *itt;\\n                        itt++;\\n                        i++;\\n                    }\\n                    break;\\n                }\\n                i--;\\n            }\\n        }\\n    }\\n```\\n**NOTE :** The string `num` above is passed by reference and no copy of it is being created. I have used a multi set to maintain next possible value with which `num[i]` can be replaced with , if the upper_bound of `num[i]` is not found the number from right to left already occur in an increasing sequence and next permutation cannot be determined.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid getKthNextPermutation(string&num,int size,int k){\\n        while(k--){\\n    \\n\\t\\t\\tint i = size-2;\\n            multiset<char>sArr={num[size-1]};\\n            \\n            while(i>=0){\\n                \\n                if(num[i]>=num[i+1]){\\n                    sArr.insert(num[i]);\\n                }\\n                else{\\n                    \\n                    auto it = upper_bound(sArr.begin(),sArr.end(),num[i]);\\n                    auto val = *it;\\n                    sArr.erase(it);\\n                    sArr.insert(num[i]);\\n                    num[i] = val;\\n                    i++;\\n                    \\n                    auto itt = sArr.begin();\\n                    \\n                    while(itt!=sArr.end()){\\n                        num[i] = *itt;\\n                        itt++;\\n                        i++;\\n                    }\\n                    break;\\n                }\\n                i--;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346681,
                "title": "javascript-faster-than-100-commented",
                "content": "Thanks to @hqz3 for swapping logic.\\n![image](https://assets.leetcode.com/users/images/d11c6e1e-3841-4bd3-9bea-677e1c578c4e_1659025707.732035.png)\\n\\n\\tvar getMinSwaps = function(num, k) {\\n    let nextPermutation = (nums) => {// Permutation Calculator\\n        let i,j;\\n        //start from right and find the index where value is more than its succeeding value\\n        for(i = nums.length - 2; nums[i]>=nums[i+1] && i>=0; i--);\\n        //if no such value is present i = -1, already max permutation, next would me min permutation\\n        if(i>=0){\\n            //find an index from right where value is greater than value at i\\n            for(j = nums.length -1; nums[j]<=nums[i]; j--);\\n            //swap these index values\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n        }\\n        i++;\\n        j = nums.length - 1;\\n        while(i<j){//reverse the array after index i, to get next permutation\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n            i++;\\n            j--;\\n        }\\n    }\\n    let arr = num.split(\\'\\').map((x) => parseInt(x,10));\\n    while(k>0){//find kth permutation in place\\n         nextPermutation(arr);\\n         k--;\\n    }\\n    num = num.split(\\'\\').map((x) => parseInt(x));\\n    \\n    //Swapping Logic\\n    let count = 0;\\n    for(let i=0; i<num.length; i++){\\n        if(num[i]!=arr[i]){//where the two numbers dont match\\n            let j= (i+1);\\n            while(num[j]!=arr[i] && j<num.length) j++;//find actual value in num array\\n            count+= j-i;//add the difference of indices as these are the number of swaps needed\\n            num.splice(j, 1);//replace the value in array\\n            num.splice(i, 0, arr[i]);\\n        }\\n    }\\n    return count;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "Thanks to @hqz3 for swapping logic.\\n![image](https://assets.leetcode.com/users/images/d11c6e1e-3841-4bd3-9bea-677e1c578c4e_1659025707.732035.png)\\n\\n\\tvar getMinSwaps = function(num, k) {\\n    let nextPermutation = (nums) => {// Permutation Calculator\\n        let i,j;\\n        //start from right and find the index where value is more than its succeeding value\\n        for(i = nums.length - 2; nums[i]>=nums[i+1] && i>=0; i--);\\n        //if no such value is present i = -1, already max permutation, next would me min permutation\\n        if(i>=0){\\n            //find an index from right where value is greater than value at i\\n            for(j = nums.length -1; nums[j]<=nums[i]; j--);\\n            //swap these index values\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n        }\\n        i++;\\n        j = nums.length - 1;\\n        while(i<j){//reverse the array after index i, to get next permutation\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n            i++;\\n            j--;\\n        }\\n    }\\n    let arr = num.split(\\'\\').map((x) => parseInt(x,10));\\n    while(k>0){//find kth permutation in place\\n         nextPermutation(arr);\\n         k--;\\n    }\\n    num = num.split(\\'\\').map((x) => parseInt(x));\\n    \\n    //Swapping Logic\\n    let count = 0;\\n    for(let i=0; i<num.length; i++){\\n        if(num[i]!=arr[i]){//where the two numbers dont match\\n            let j= (i+1);\\n            while(num[j]!=arr[i] && j<num.length) j++;//find actual value in num array\\n            count+= j-i;//add the difference of indices as these are the number of swaps needed\\n            num.splice(j, 1);//replace the value in array\\n            num.splice(i, 0, arr[i]);\\n        }\\n    }\\n    return count;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2289650,
                "title": "using-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string a , string b){\\n        int i =a.length()-1;\\n        int j= a.length()-1;\\n        int ans=0;\\n        while(i>=0){\\n            if(a[i]==b[j]){i--;j--;}\\n            else{\\n             \\n                int l = i;\\n                while(l>0 and a[l]!=b[j])l--;\\n                \\n                \\n                for(int m=l;m<i;m++){\\n                    swap(a[m],a[m+1]);\\n                    ans++;\\n                }\\n                \\n                i--;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string original =num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n       return  solve(original,num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string a , string b){\\n        int i =a.length()-1;\\n        int j= a.length()-1;\\n        int ans=0;\\n        while(i>=0){\\n            if(a[i]==b[j]){i--;j--;}\\n            else{\\n             \\n                int l = i;\\n                while(l>0 and a[l]!=b[j])l--;\\n                \\n                \\n                for(int m=l;m<i;m++){\\n                    swap(a[m],a[m+1]);\\n                    ans++;\\n                }\\n                \\n                i--;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string original =num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n       return  solve(original,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249426,
                "title": "permutation-function-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2242966,
                "title": "c-simple-solution-using-next-permutation",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t=num;\\n        while(k)\\n        {\\n            bool f=next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        string temp,org;\\n        \\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=t[i]){\\n                \\n                temp=num.substr(i);\\n                org=t.substr(i);\\n                break;\\n            }\\n            \\n            \\n        }\\n      \\n            n=org.size();\\n            int ans=0;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            while(temp[j]!=org[i])j++;\\n            ans+=j-i;\\n            while(j!=i){\\n                swap(temp[j-1],temp[j]);\\n                j--;\\n            \\n            }\\n            i++;\\n            \\n        }\\n        \\n        \\n        \\n       \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t=num;\\n        while(k)\\n        {\\n            bool f=next_permutation(num.begin(),num.end());\\n            k--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2193920,
                "title": "1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      int l=num.length();\\n      string s=num;\\n        \\n        while(k--)\\n        next_permutation(num.begin(),num.end());\\n        \\n            \\n        \\n   \\n     int ct=0;\\n       \\n        for(int i=0;i<num.length();i++)\\n        {\\n            \\n            if(num[i]!=s[i])\\n            {  int j=i+1;\\n                for(j=i+1;j<num.length();j++)\\n                {\\n                    \\n                    if(num[i]==s[j])\\n                        break;\\n                }\\n                \\n             \\n              for(int l=j;l>i;l--)\\n              {\\n                  ct++;\\n                  swap(s[l],s[l-1]);\\n              }\\n            }\\n            \\n        }\\n            \\n   return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      int l=num.length();\\n      string s=num;\\n        \\n        while(k--)\\n        next_permutation(num.begin(),num.end());\\n        \\n            \\n        \\n   \\n     int ct=0;\\n       \\n        for(int i=0;i<num.length();i++)\\n        {\\n            \\n            if(num[i]!=s[i])\\n            {  int j=i+1;\\n                for(j=i+1;j<num.length();j++)\\n                {\\n                    \\n                    if(num[i]==s[j])\\n                        break;\\n                }\\n                \\n             \\n              for(int l=j;l>i;l--)\\n              {\\n                  ct++;\\n                  swap(s[l],s[l-1]);\\n              }\\n            }\\n            \\n        }\\n            \\n   return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180061,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        char[] characters = num.ToCharArray();\\n        for (int index = 0; index < k; index++)\\n        {\\n            NextPermutation();\\n        }\\n\\n        return GetNumberOfSwaps();\\n\\n        void NextPermutation()\\n        {\\n            int n = characters.Length;\\n            for (int left = n - 2; left >= 0; left--)\\n            {\\n                if (characters[left] >= characters[left + 1]) continue;\\n\\n                int right = n - 1;\\n                while (characters[right] <= characters[left])\\n                {\\n                    right--;\\n                }\\n\\n                (characters[left], characters[right]) = (characters[right], characters[left]);\\n                Array.Reverse(characters, left + 1, n - left - 1);\\n                return;\\n            }\\n        }\\n\\n        int GetNumberOfSwaps()\\n        {\\n            int numberOfSwaps = 0;\\n            for (int left = 0; left < num.Length; left++)\\n            {\\n                int right = left;\\n                while (num[left] != characters[right])\\n                {\\n                    right++;\\n                }\\n\\n                while (right != left)\\n                {\\n                    (characters[right - 1], characters[right]) = (characters[right], characters[right - 1]);\\n                    right--;\\n                    numberOfSwaps++;\\n                }\\n            }\\n\\n            return numberOfSwaps;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        char[] characters = num.ToCharArray();\\n        for (int index = 0; index < k; index++)\\n        {\\n            NextPermutation();\\n        }\\n\\n        return GetNumberOfSwaps();\\n\\n        void NextPermutation()\\n        {\\n            int n = characters.Length;\\n            for (int left = n - 2; left >= 0; left--)\\n            {\\n                if (characters[left] >= characters[left + 1]) continue;\\n\\n                int right = n - 1;\\n                while (characters[right] <= characters[left])\\n                {\\n                    right--;\\n                }\\n\\n                (characters[left], characters[right]) = (characters[right], characters[left]);\\n                Array.Reverse(characters, left + 1, n - left - 1);\\n                return;\\n            }\\n        }\\n\\n        int GetNumberOfSwaps()\\n        {\\n            int numberOfSwaps = 0;\\n            for (int left = 0; left < num.Length; left++)\\n            {\\n                int right = left;\\n                while (num[left] != characters[right])\\n                {\\n                    right++;\\n                }\\n\\n                while (right != left)\\n                {\\n                    (characters[right - 1], characters[right]) = (characters[right], characters[right - 1]);\\n                    right--;\\n                    numberOfSwaps++;\\n                }\\n            }\\n\\n            return numberOfSwaps;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169186,
                "title": "c-easy-approach",
                "content": "````\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n    int minSteps(string s1, string s2){\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        \\n        int size=s1.length();\\n        \\n        while(i<size){\\n            j=i;\\n            while(s1[j]!=s2[i])j++;\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n        }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1993754,
                "title": "rust-next-permute",
                "content": "```rust\\n\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        let mut original: Vec<_> = num.into_bytes();\\n        let mut permute = original.clone();\\n\\n        for _ in 0..k {\\n            Self::next_permutation(&mut permute);\\n        }\\n\\n        let mut res = 0;\\n\\n        for i in 0..original.len() {\\n            if original[i] == permute[i] {\\n                continue;\\n            }\\n\\n            let mut j = i + 1;\\n            while original[j] != permute[j] {\\n                j += 1;\\n            }\\n\\n            while j > i {\\n                original.swap(j - 1, j);\\n                j -= 1;\\n                res += 1;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn next_permutation(chars: &mut Vec<u8>) {\\n        let mut index = chars.len() - 1;\\n        while index > 0 {\\n            if chars[index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            index -= 1;\\n        }\\n\\n        let mut swap_index = chars.len() - 1;\\n        while swap_index >= index {\\n            if chars[swap_index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            swap_index -= 1;\\n        }\\n\\n        chars.swap(index - 1, swap_index);\\n        chars[index..].reverse();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        let mut original: Vec<_> = num.into_bytes();\\n        let mut permute = original.clone();\\n\\n        for _ in 0..k {\\n            Self::next_permutation(&mut permute);\\n        }\\n\\n        let mut res = 0;\\n\\n        for i in 0..original.len() {\\n            if original[i] == permute[i] {\\n                continue;\\n            }\\n\\n            let mut j = i + 1;\\n            while original[j] != permute[j] {\\n                j += 1;\\n            }\\n\\n            while j > i {\\n                original.swap(j - 1, j);\\n                j -= 1;\\n                res += 1;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn next_permutation(chars: &mut Vec<u8>) {\\n        let mut index = chars.len() - 1;\\n        while index > 0 {\\n            if chars[index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            index -= 1;\\n        }\\n\\n        let mut swap_index = chars.len() - 1;\\n        while swap_index >= index {\\n            if chars[swap_index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            swap_index -= 1;\\n        }\\n\\n        chars.swap(index - 1, swap_index);\\n        chars[index..].reverse();\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911755,
                "title": "javascript-iterative-91-time-64-space",
                "content": "```\\nvar getMinSwaps = function(num, k) {\\n    let digits = [...num];\\n    const swap = (idx1, idx2) => {\\n        [digits[idx1], digits[idx2]] = [digits[idx2], digits[idx1]];\\n    }\\n    \\n    // Find the next wonderful permutation.\\n    function permutation() {\\n        for (let i = digits.length - 1; i >= 1; i--) {\\n            // Find the first i that is greater than i - 1.\\n            // When that i is found, this means all digits from i to the end are in descending order.\\n            if (digits[i] > digits[i - 1]) {\\n                // Swap the i - 1 digit with the smallest digit larger than i - 1 (see below).\\n                swap(i - 1, nextLarger(i, digits[i - 1]));\\n                reverse(i, digits.length - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    // Since all digits from idx onwards are in descending order, \\n\\t// find and return the index of the last number that is greater than the currentVal (which represents the value of i - 1).\\n    const nextLarger = (idx, currentVal) => {\\n        let nextLargerIdx = idx;\\n        for (let i = idx; i < digits.length; i++) {\\n            if (digits[i] > currentVal) {\\n                nextLargerIdx = i;\\n            } else break;\\n        }\\n        return nextLargerIdx;\\n    }\\n    \\n    // Once nextLarger is found, swap i - 1 with the nextLarger index. \\n    // This way, the new i - 1 value is guaranteed to be the next smallest digit larger than the old i - 1 value.\\n    // Moreover, the rest of the array from i to the end is still in descending order.\\n    // Now reverse the rest of the array so that it will be in ascending order.\\n    const reverse = (start, end) => {\\n        while (start < end) {\\n            swap(start, end);\\n            start++, end--;\\n        }\\n    }\\n    \\n    // Find the next wonderful permutation k times.\\n    while (k--) permutation();\\n\\n    // Count the number of swaps.\\n    let swapCount = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        if (num[i] != digits[i]) {\\n            let j = i;\\n            while (num[i] != digits[j]) j++;\\n            while (i < j) {\\n                swap(j, j - 1);\\n                j--;\\n                swapCount++;\\n            }\\n        }\\n    }\\n    return swapCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    let digits = [...num];\\n    const swap = (idx1, idx2) => {\\n        [digits[idx1], digits[idx2]] = [digits[idx2], digits[idx1]];\\n    }\\n    \\n    // Find the next wonderful permutation.\\n    function permutation() {\\n        for (let i = digits.length - 1; i >= 1; i--) {\\n            // Find the first i that is greater than i - 1.\\n            // When that i is found, this means all digits from i to the end are in descending order.\\n            if (digits[i] > digits[i - 1]) {\\n                // Swap the i - 1 digit with the smallest digit larger than i - 1 (see below).\\n                swap(i - 1, nextLarger(i, digits[i - 1]));\\n                reverse(i, digits.length - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    // Since all digits from idx onwards are in descending order, \\n\\t// find and return the index of the last number that is greater than the currentVal (which represents the value of i - 1).\\n    const nextLarger = (idx, currentVal) => {\\n        let nextLargerIdx = idx;\\n        for (let i = idx; i < digits.length; i++) {\\n            if (digits[i] > currentVal) {\\n                nextLargerIdx = i;\\n            } else break;\\n        }\\n        return nextLargerIdx;\\n    }\\n    \\n    // Once nextLarger is found, swap i - 1 with the nextLarger index. \\n    // This way, the new i - 1 value is guaranteed to be the next smallest digit larger than the old i - 1 value.\\n    // Moreover, the rest of the array from i to the end is still in descending order.\\n    // Now reverse the rest of the array so that it will be in ascending order.\\n    const reverse = (start, end) => {\\n        while (start < end) {\\n            swap(start, end);\\n            start++, end--;\\n        }\\n    }\\n    \\n    // Find the next wonderful permutation k times.\\n    while (k--) permutation();\\n\\n    // Count the number of swaps.\\n    let swapCount = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        if (num[i] != digits[i]) {\\n            let j = i;\\n            while (num[i] != digits[j]) j++;\\n            while (i < j) {\\n                swap(j, j - 1);\\n                j--;\\n                swapCount++;\\n            }\\n        }\\n    }\\n    return swapCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903965,
                "title": "c-using-stl",
                "content": "class Solution {\\npublic:\\n\\n    int getMinSwaps(string s, int k) {\\n        string res=s;\\n        while(k--)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=i;\\n            if(res[i]!=s[j])\\n            {\\n                while(res[i]!=s[j])i++;\\n                while(i>j)\\n                {\\n                    swap(res[i],res[i-1]);\\n                        i--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int getMinSwaps(string s, int k) {\\n        string res=s;\\n        while(k--)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901038,
                "title": "javascript-solution-next-permutation",
                "content": "Initially, I was thinking of BFS. However, after looking at the first hint, I used what I learned from the Next Permutation problem to create the kth smallest wonderful number. Then, I compared the digits to the original number and if there was a mismatch, I initiated necessary the swaps and tallied up the total count of swaps.\\n\\n\\n```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900524,
                "title": "simple-c-with-explanation",
                "content": "```\\nclass Solution {\\n  public:\\n    int getMinSwaps(string num, int k) {\\n      string after = num;\\n      while (k--)\\n        nextPermutation(after);\\n      int ret = 0;\\n      while (num != after) {\\n        for (int i = 0; i < num.size(); i++) {\\n          if (num[i] == after[i]) // found not match pos\\n            continue;\\n          for (int j = i+1; j < num.size(); j++) {\\n            // move num[j] backward to num[i], finish one\\n            if (num[j] == after[i]) {\\n              for (int m = j; m > i; m--) {\\n                ret++;\\n                swap(num[m], num[m-1]);\\n              }\\n              break;\\n            }\\n          }\\n          break;\\n        }\\n      }\\n      return ret;\\n    }\\n\\n    void nextPermutation(string& num) {\\n      int i = num.size()-1;\\n      while (i > 0 && num[i-1] >= num[i])\\n        i--;\\n      for (int j = num.size()-1; i > 0 && j >= 0; j--) {\\n        if (num[j] > num[i-1]) {\\n          swap(num[j], num[i-1]);\\n          break;\\n        }\\n      }\\n      reverse(num.begin()+i, num.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n    int getMinSwaps(string num, int k) {\\n      string after = num;\\n      while (k--)\\n        nextPermutation(after);\\n      int ret = 0;\\n      while (num != after) {\\n        for (int i = 0; i < num.size(); i++) {\\n          if (num[i] == after[i]) // found not match pos\\n            continue;\\n          for (int j = i+1; j < num.size(); j++) {\\n            // move num[j] backward to num[i], finish one\\n            if (num[j] == after[i]) {\\n              for (int m = j; m > i; m--) {\\n                ret++;\\n                swap(num[m], num[m-1]);\\n              }\\n              break;\\n            }\\n          }\\n          break;\\n        }\\n      }\\n      return ret;\\n    }\\n\\n    void nextPermutation(string& num) {\\n      int i = num.size()-1;\\n      while (i > 0 && num[i-1] >= num[i])\\n        i--;\\n      for (int j = num.size()-1; i > 0 && j >= 0; j--) {\\n        if (num[j] > num[i-1]) {\\n          swap(num[j], num[i-1]);\\n          break;\\n        }\\n      }\\n      reverse(num.begin()+i, num.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892991,
                "title": "c-next-permutation-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string &num, int k) {\\n        //permutation question \\n        int ans = 0 ;\\n        string orginal = num ;\\n        do{\\n            bool bl = next_permutation(begin(num),end(num));\\n        }while(--k); \\n        \\n        for(int idx = num.size()-1;idx>=0;--idx){\\n            int start = -1 ;\\n            for(int i = 0 ; i <= idx ;++i) if(orginal[i] == num[idx]) start = i ;\\n            while(start < num.size()-1 and orginal[idx] != num[idx]){\\n                ++ans ;\\n                swap(orginal[start],orginal[start+1]);\\n                ++start ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string &num, int k) {\\n        //permutation question \\n        int ans = 0 ;\\n        string orginal = num ;\\n        do{\\n            bool bl = next_permutation(begin(num),end(num));\\n        }while(--k); \\n        \\n        for(int idx = num.size()-1;idx>=0;--idx){\\n            int start = -1 ;\\n            for(int i = 0 ; i <= idx ;++i) if(orginal[i] == num[idx]) start = i ;\\n            while(start < num.size()-1 and orginal[idx] != num[idx]){\\n                ++ans ;\\n                swap(orginal[start],orginal[start+1]);\\n                ++start ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803043,
                "title": "single-pass-approach-java",
                "content": "before this solution check this out -> https://leetcode.com/problems/next-permutation/\\n\\n```\\n\\tchar[] numbers;\\n    int len;\\n    \\n    public int getMinSwaps(String num, int k) {\\n    \\n        if(num == null || num.length() == 0 || k == 0){\\n            return 0;\\n        }\\n        \\n        len = num.length();\\n        numbers = num.toCharArray();\\n        \\n        nextPermutation(k);\\n        \\n        return countSteps(num);\\n    }\\n    \\n    void nextPermutation(int k){\\n        \\n        for(int p = 0; p < k; p++){\\n            \\n            int i = len - 2;\\n            \\n            while(i >= 0 && numbers[i] >= numbers[i+1]){\\n                i--;\\n            }\\n            \\n            if(i >= 0){\\n                int j = len - 1;\\n                while(numbers[i] >= numbers[j]){\\n                    j--;\\n                }\\n                swap(i, j);\\n            }\\n            \\n            reverse(i + 1);\\n        }\\n    }\\n    \\n    int countSteps(String num){\\n        \\n        int i = 0, j = 0;\\n        int result = 0;\\n        \\n        while(i < len){\\n            j = i;\\n            \\n            while(j < len && numbers[j] != num.charAt(i)){\\n                j++;\\n            }\\n            \\n            while(i < j){\\n                swap(j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    void reverse(int start){\\n        int s = start, e = len - 1;\\n        while(s < e){\\n            swap(s, e);\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    void swap(int a, int b){\\n        if(a == b){\\n            return;\\n        }\\n        char tmp = numbers[a];\\n        numbers[a] = numbers[b];\\n        numbers[b]= tmp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tchar[] numbers;\\n    int len;\\n    \\n    public int getMinSwaps(String num, int k) {\\n    \\n        if(num == null || num.length() == 0 || k == 0){\\n            return 0;\\n        }\\n        \\n        len = num.length();\\n        numbers = num.toCharArray();\\n        \\n        nextPermutation(k);\\n        \\n        return countSteps(num);\\n    }\\n    \\n    void nextPermutation(int k){\\n        \\n        for(int p = 0; p < k; p++){\\n            \\n            int i = len - 2;\\n            \\n            while(i >= 0 && numbers[i] >= numbers[i+1]){\\n                i--;\\n            }\\n            \\n            if(i >= 0){\\n                int j = len - 1;\\n                while(numbers[i] >= numbers[j]){\\n                    j--;\\n                }\\n                swap(i, j);\\n            }\\n            \\n            reverse(i + 1);\\n        }\\n    }\\n    \\n    int countSteps(String num){\\n        \\n        int i = 0, j = 0;\\n        int result = 0;\\n        \\n        while(i < len){\\n            j = i;\\n            \\n            while(j < len && numbers[j] != num.charAt(i)){\\n                j++;\\n            }\\n            \\n            while(i < j){\\n                swap(j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    void reverse(int start){\\n        int s = start, e = len - 1;\\n        while(s < e){\\n            swap(s, e);\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    void swap(int a, int b){\\n        if(a == b){\\n            return;\\n        }\\n        char tmp = numbers[a];\\n        numbers[a] = numbers[b];\\n        numbers[b]= tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1794646,
                "title": "c-24ms-95-simple-easy-small",
                "content": "Runtime: 24 ms, faster than 94.95% of C++ online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\nMemory Usage: 6.5 MB, less than 75.47% of C++ online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\n```\\nclass Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n    string s = num;\\n    int ans = 0;\\n    while(k--) next_permutation(s.begin(), s.end());\\n    \\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(s[i] != num[i]){\\n        int j = i + 1;\\n        while(s[j] != num[i]) j++;\\n        ans += j - i;\\n        while(j-- != i) swap(s[j], s[j+1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n    string s = num;\\n    int ans = 0;\\n    while(k--) next_permutation(s.begin(), s.end());\\n    \\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(s[i] != num[i]){\\n        int j = i + 1;\\n        while(s[j] != num[i]) j++;\\n        ans += j - i;\\n        while(j-- != i) swap(s[j], s[j+1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763834,
                "title": "c-75-faster-sol-using-next-permutation",
                "content": "class Solution {\\npublic:\\n```\\n    int getMinSwaps(string num, int k) {\\n        vector<int>org;\\n        vector<int>dup;\\n        int sum=0;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            org.push_back(num[i]);\\n        }\\n        for(int i=0;i<org.size();i++)\\n        {\\n            dup.push_back(org[i]);\\n        }\\n        while(k)\\n        {\\n            next_permutation(org.begin(),org.end());\\n            k--;\\n        }\\n       for(int i=0;i<org.size();i++)\\n       {\\n           if(org[i]==dup[i])\\n               continue;\\n           else{\\n               int j=i+1;\\n               while(org[i]!=dup[i]){\\n                   swap(dup[i],dup[j]);\\n                   j++;\\n                   sum++;\\n               }\\n           }\\n       }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int getMinSwaps(string num, int k) {\\n        vector<int>org;\\n        vector<int>dup;\\n        int sum=0;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            org.push_back(num[i]);\\n        }\\n        for(int i=0;i<org.size();i++)\\n        {\\n            dup.push_back(org[i]);\\n        }\\n        while(k)\\n        {\\n            next_permutation(org.begin(),org.end());\\n            k--;\\n        }\\n       for(int i=0;i<org.size();i++)\\n       {\\n           if(org[i]==dup[i])\\n               continue;\\n           else{\\n               int j=i+1;\\n               while(org[i]!=dup[i]){\\n                   swap(dup[i],dup[j]);\\n                   j++;\\n                   sum++;\\n               }\\n           }\\n       }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762127,
                "title": "using-next-permutation-c-brute-force",
                "content": "class Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n       \\n\\t   string t = num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n        int c = 0;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=t[i]){\\n                int j = i;\\n                while(t[j]!=num[i]) j++;\\n                while(t[i]!=num[i]){\\n                    swap(t[j],t[j-1]);\\n                    c++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n       \\n\\t   string t = num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1700251,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.length();\\n        string temp = num;\\n        \\n        while(k--) {\\n            int id = n - 2;\\n            char prev = num[n - 1];\\n            map<char, int> mp;\\n            mp[prev] = n - 1;\\n            while (id >= 0 && prev <= num[id]) {\\n                //cout << id << \":\" << num[id] << endl;\\n                mp[num[id]] = id;\\n                prev = num[id];\\n                id--;\\n            }\\n            auto it = mp.upper_bound(num[id]);\\n            swap(num[id], num[it->second]);\\n            sort(num.begin() + id + 1, num.end());\\n            //cout << k << \":\" << num << endl;\\n        }\\n        \\n        int id = 0, count = 0;\\n        for (; id < num.length(); id++) {\\n            if (temp[id] != num[id])   break;\\n        }\\n        \\n        for (int i = id; i < num.size(); i++) {\\n            //cout << nums[i] << endl;\\n            auto it = find(temp.begin() + i, temp.end(), num[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, num[id]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.length();\\n        string temp = num;\\n        \\n        while(k--) {\\n            int id = n - 2;\\n            char prev = num[n - 1];\\n            map<char, int> mp;\\n            mp[prev] = n - 1;\\n            while (id >= 0 && prev <= num[id]) {\\n                //cout << id << \":\" << num[id] << endl;\\n                mp[num[id]] = id;\\n                prev = num[id];\\n                id--;\\n            }\\n            auto it = mp.upper_bound(num[id]);\\n            swap(num[id], num[it->second]);\\n            sort(num.begin() + id + 1, num.end());\\n            //cout << k << \":\" << num << endl;\\n        }\\n        \\n        int id = 0, count = 0;\\n        for (; id < num.length(); id++) {\\n            if (temp[id] != num[id])   break;\\n        }\\n        \\n        for (int i = id; i < num.size(); i++) {\\n            //cout << nums[i] << endl;\\n            auto it = find(temp.begin() + i, temp.end(), num[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, num[id]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1678899,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        int n=s.size();\\n        string str=s;\\n        int count=0;\\n        while(k--) next_permutation(s.begin(),s.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=str[i]){\\n                int j=i+1;\\n                while(n>j and s[i]!=str[j]) j++;\\n                \\n                while(j>i){\\n                    swap(str[j],str[--j]); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        int n=s.size();\\n        string str=s;\\n        int count=0;\\n        while(k--) next_permutation(s.begin(),s.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=str[i]){\\n                int j=i+1;\\n                while(n>j and s[i]!=str[j]) j++;\\n                \\n                while(j>i){\\n                    swap(str[j],str[--j]); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659637,
                "title": "go-brute",
                "content": "```\\nfunc getMinSwaps(num string, k int) int {\\n    old := num\\n    for k > 0 {\\n        num = next(num)\\n        k--\\n    }\\n    return swap(old, num)\\n}\\n\\nfunc next(s string) string {\\n    var res []byte\\n    var list []byte\\n    for i := len(s) - 1; i >= 1; i-- {\\n        list = append(list, s[i])\\n        if s[i] > s[i - 1] {\\n            list = append(list, s[i - 1])\\n            res = []byte(s[:i - 1])\\n            sort.Slice(list, func(i int, j int) bool {\\n                return list[i] < list[j]\\n            })\\n            \\n            tar := sort.Search(len(list), func(j int) bool {\\n                return list[j] > s[i - 1]\\n            })\\n            res = append(res, list[tar])\\n            res = append(res, list[:tar]...)\\n            res = append(res, list[tar + 1:]...)\\n            break\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc swap(a string, b string) int {\\n    for i := 0; i < len(a); i++ {\\n        if a[i] != b[i] {\\n            for j := i + 1; j < len(b); j++ {\\n                if b[j] == a[i] {\\n                    return j - i + swap(a[i + 1:], b[i:j] + b[j + 1:])\\n                }\\n            }\\n        }\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinSwaps(num string, k int) int {\\n    old := num\\n    for k > 0 {\\n        num = next(num)\\n        k--\\n    }\\n    return swap(old, num)\\n}\\n\\nfunc next(s string) string {\\n    var res []byte\\n    var list []byte\\n    for i := len(s) - 1; i >= 1; i-- {\\n        list = append(list, s[i])\\n        if s[i] > s[i - 1] {\\n            list = append(list, s[i - 1])\\n            res = []byte(s[:i - 1])\\n            sort.Slice(list, func(i int, j int) bool {\\n                return list[i] < list[j]\\n            })\\n            \\n            tar := sort.Search(len(list), func(j int) bool {\\n                return list[j] > s[i - 1]\\n            })\\n            res = append(res, list[tar])\\n            res = append(res, list[:tar]...)\\n            res = append(res, list[tar + 1:]...)\\n            break\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc swap(a string, b string) int {\\n    for i := 0; i < len(a); i++ {\\n        if a[i] != b[i] {\\n            for j := i + 1; j < len(b); j++ {\\n                if b[j] == a[i] {\\n                    return j - i + swap(a[i + 1:], b[i:j] + b[j + 1:])\\n                }\\n            }\\n        }\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653031,
                "title": "c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        //next permutation is alwys greater than the previous one\\n        //e.g. first permutation = 12345 -> last perm 54321\\n        string original=num;\\n        while(k--) next_permutation(num.begin(),num.end());\\n        \\n        //bring every element from initial position to desired position\\n        int count=0;\\n        for(int j=0;j<num.size();j++)\\n        {\\n            if(num[j]!=original[j])\\n            {\\n                int i=j;\\n                while(original[i]!=num[j]) i++;\\n                while(num[j]!=original[j])\\n                {\\n                    swap(original[i],original[i-1]);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        //next permutation is alwys greater than the previous one\\n        //e.g. first permutation = 12345 -> last perm 54321\\n        string original=num;\\n        while(k--) next_permutation(num.begin(),num.end());\\n        \\n        //bring every element from initial position to desired position\\n        int count=0;\\n        for(int j=0;j<num.size();j++)\\n        {\\n            if(num[j]!=original[j])\\n            {\\n                int i=j;\\n                while(original[i]!=num[j]) i++;\\n                while(num[j]!=original[j])\\n                {\\n                    swap(original[i],original[i-1]);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632299,
                "title": "java-next-permutation-25-lines-comments",
                "content": "We need to find the next permutation, according to [Wikipedia](https://en.wikipedia.org/wiki/Permutation), this is how you find it: \\n1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n2. Find the largest index l greater than k such that a[k] < a[l].\\n3. Swap the value of a[k] with that of a[l].\\n4. Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nYou can also practice next permutation at https://leetcode.com/problems/next-permutation/. In fact, I recommend that you do that question first before even attempting this question.\\n\\nThe below is my solution: \\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] result = num.toCharArray();\\n        while(--k >= 0){ //next permutation, do it k times\\n            int swap = result.length - 2; \\n            while(swap >= 0 && result[swap] >= result[swap + 1]) --swap;\\n            int pair = result.length - 1;\\n            while(pair > swap && result[swap] >= result[pair]) --pair;\\n            swap(result, swap, pair);\\n            int lo = swap + 1;\\n            int hi = result.length - 1;\\n            while(lo < hi) swap(result, lo++, hi--);\\n        }\\n\\n\\n        int ans = 0;\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == result[i]) continue;\\n            int j = i;\\n            while(arr[i] != result[j]) ++j; //find the matching character \\n            ans += j - i; //number of swap needed to make it match\\n            while(--j >= i) swap(result, j, j + 1); //match it\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static void swap(char[] arr, int a, int b){\\n        char tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] result = num.toCharArray();\\n        while(--k >= 0){ //next permutation, do it k times\\n            int swap = result.length - 2; \\n            while(swap >= 0 && result[swap] >= result[swap + 1]) --swap;\\n            int pair = result.length - 1;\\n            while(pair > swap && result[swap] >= result[pair]) --pair;\\n            swap(result, swap, pair);\\n            int lo = swap + 1;\\n            int hi = result.length - 1;\\n            while(lo < hi) swap(result, lo++, hi--);\\n        }\\n\\n\\n        int ans = 0;\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == result[i]) continue;\\n            int j = i;\\n            while(arr[i] != result[j]) ++j; //find the matching character \\n            ans += j - i; //number of swap needed to make it match\\n            while(--j >= i) swap(result, j, j + 1); //match it\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static void swap(char[] arr, int a, int b){\\n        char tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613583,
                "title": "swift-solution-with-next-permutation-and-swapping",
                "content": "```\\nclass Solution {\\n    \\n    // MARK: - Reverse\\n    \\n    func reverse(_ num: inout [Character], _ i: Int) {\\n        var i = i\\n        var j = num.count - 1\\n        \\n        while i < j {\\n            num.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n    \\n    // MARK: - Next Permutation\\n    \\n    func nextPermutation(_ num: inout [Character]) {\\n        if num.count == 0 {\\n            return\\n        }\\n        \\n        var i = num.count - 1\\n        \\n        while i >= 1 {\\n            if num[i] > num[i - 1] {\\n                reverse(&num, i)\\n                for j in i..<num.count {\\n                    if num[j] > num[i - 1] {\\n                        num.swapAt(j, i - 1)\\n                        return\\n                    }\\n                }\\n            }\\n            i -= 1\\n        }\\n        \\n        for i in 1..<num.count {\\n            if num[num.count - i - 1] > num[num.count - i - 2] {\\n                reverse(&num, i)\\n                for j in (num.count - i - 1)..<num.count {\\n                    if num[j] > num[num.count - i - 2] {\\n                        num.swapAt(j, num.count - i - 2)\\n                        return\\n                    }\\n                }\\n            }\\n        }\\n        \\n        reverse(&num, 0)\\n    }\\n    \\n    // MARK: - Min Swaps\\n    \\n    func minSwaps(_ nums: inout [Character], _ target: [Character], _ size: Int) -> Int {\\n        var j = 0\\n        var swaps = 0\\n        \\n        for i in 0..<size {\\n            j = i\\n            while nums[j] != target[i] {\\n                j += 1\\n            }\\n            \\n            while i < j {\\n                nums.swapAt(j, j - 1)\\n                j -= 1\\n                swaps += 1\\n            }\\n        }\\n        \\n        return swaps\\n    }\\n    \\n    // MARK: - Get Min Swaps\\n    \\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        \\n        var target = Array(num)\\n        \\n        for i in 0..<k {\\n            nextPermutation(&target)\\n        }\\n        \\n        var nums = Array(num)\\n        \\n        return minSwaps(&nums, target, num.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // MARK: - Reverse\\n    \\n    func reverse(_ num: inout [Character], _ i: Int) {\\n        var i = i\\n        var j = num.count - 1\\n        \\n        while i < j {\\n            num.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n    \\n    // MARK: - Next Permutation\\n    \\n    func nextPermutation(_ num: inout [Character]) {\\n        if num.count == 0 {\\n            return\\n        }\\n        \\n        var i = num.count - 1\\n        \\n        while i >= 1 {\\n            if num[i] > num[i - 1] {\\n                reverse(&num, i)\\n                for j in i..<num.count {\\n                    if num[j] > num[i - 1] {\\n                        num.swapAt(j, i - 1)\\n                        return\\n                    }\\n                }\\n            }\\n            i -= 1\\n        }\\n        \\n        for i in 1..<num.count {\\n            if num[num.count - i - 1] > num[num.count - i - 2] {\\n                reverse(&num, i)\\n                for j in (num.count - i - 1)..<num.count {\\n                    if num[j] > num[num.count - i - 2] {\\n                        num.swapAt(j, num.count - i - 2)\\n                        return\\n                    }\\n                }\\n            }\\n        }\\n        \\n        reverse(&num, 0)\\n    }\\n    \\n    // MARK: - Min Swaps\\n    \\n    func minSwaps(_ nums: inout [Character], _ target: [Character], _ size: Int) -> Int {\\n        var j = 0\\n        var swaps = 0\\n        \\n        for i in 0..<size {\\n            j = i\\n            while nums[j] != target[i] {\\n                j += 1\\n            }\\n            \\n            while i < j {\\n                nums.swapAt(j, j - 1)\\n                j -= 1\\n                swaps += 1\\n            }\\n        }\\n        \\n        return swaps\\n    }\\n    \\n    // MARK: - Get Min Swaps\\n    \\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        \\n        var target = Array(num)\\n        \\n        for i in 0..<k {\\n            nextPermutation(&target)\\n        }\\n        \\n        var nums = Array(num)\\n        \\n        return minSwaps(&nums, target, num.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604524,
                "title": "golang-brute-force",
                "content": "```go\\nfunc getMinSwaps(num string, k int) int {\\n\\tafterSwap := []rune(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextBigger(afterSwap)\\n\\t}\\n\\tbeforeSwap := []rune(num)\\n\\tswaps := 0\\n\\tfor i := 0; i < len(afterSwap); i++ {\\n\\t\\tif afterSwap[i] == beforeSwap[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i+1; j < len(afterSwap); j++ {\\n\\t\\t\\tif afterSwap[i] == beforeSwap[j] {\\n\\t\\t\\t\\t// bubble j to i, need swap j-i times\\n\\t\\t\\t\\tswaps += j-i\\n\\t\\t\\t\\tcopy(beforeSwap[i+1:], beforeSwap[i:j])\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps\\n}\\n\\nfunc nextBigger(num []rune) {\\n\\tmaxValue := num[len(num)-1]\\n\\tcounter := make([]rune, 10)\\n\\tcounter[maxValue-\\'0\\']++\\n\\tfor i := len(num)-2; i >= 0; i-- {\\n\\t\\tcounter[num[i]-\\'0\\']++\\n\\t\\tif num[i] >= maxValue {\\n\\t\\t\\t// greater or equal, refresh maxValue\\n\\t\\t\\tmaxValue = num[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// less than max value, move next bigger value to num[i]\\n\\t\\tnext := num[i]+1\\n\\t\\tfor counter[next-\\'0\\'] == 0 {\\n\\t\\t\\tnext++\\n\\t\\t}\\n\\t\\tnum[i] = next\\n\\t\\tcounter[next-\\'0\\']--\\n\\t\\t// place other indexes\\n\\t\\tfor val, idx := \\'0\\', i+1; counter[val-\\'0\\'] != 0 || val < \\'9\\'; {\\n\\t\\t\\tif counter[val-\\'0\\'] != 0 {\\n\\t\\t\\t\\tnum[idx] = val\\n\\t\\t\\t\\tcounter[val-\\'0\\']--\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tval++\\n\\t\\t}\\n\\t\\tbreak\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getMinSwaps(num string, k int) int {\\n\\tafterSwap := []rune(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextBigger(afterSwap)\\n\\t}\\n\\tbeforeSwap := []rune(num)\\n\\tswaps := 0\\n\\tfor i := 0; i < len(afterSwap); i++ {\\n\\t\\tif afterSwap[i] == beforeSwap[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i+1; j < len(afterSwap); j++ {\\n\\t\\t\\tif afterSwap[i] == beforeSwap[j] {\\n\\t\\t\\t\\t// bubble j to i, need swap j-i times\\n\\t\\t\\t\\tswaps += j-i\\n\\t\\t\\t\\tcopy(beforeSwap[i+1:], beforeSwap[i:j])\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps\\n}\\n\\nfunc nextBigger(num []rune) {\\n\\tmaxValue := num[len(num)-1]\\n\\tcounter := make([]rune, 10)\\n\\tcounter[maxValue-\\'0\\']++\\n\\tfor i := len(num)-2; i >= 0; i-- {\\n\\t\\tcounter[num[i]-\\'0\\']++\\n\\t\\tif num[i] >= maxValue {\\n\\t\\t\\t// greater or equal, refresh maxValue\\n\\t\\t\\tmaxValue = num[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// less than max value, move next bigger value to num[i]\\n\\t\\tnext := num[i]+1\\n\\t\\tfor counter[next-\\'0\\'] == 0 {\\n\\t\\t\\tnext++\\n\\t\\t}\\n\\t\\tnum[i] = next\\n\\t\\tcounter[next-\\'0\\']--\\n\\t\\t// place other indexes\\n\\t\\tfor val, idx := \\'0\\', i+1; counter[val-\\'0\\'] != 0 || val < \\'9\\'; {\\n\\t\\t\\tif counter[val-\\'0\\'] != 0 {\\n\\t\\t\\t\\tnum[idx] = val\\n\\t\\t\\t\\tcounter[val-\\'0\\']--\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tval++\\n\\t\\t}\\n\\t\\tbreak\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1531996,
                "title": "optimal-typescript-solution",
                "content": "**Runtime: 264 ms, faster than 100.00% of TypeScript online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\nMemory Usage: 47.1 MB, less than 100.00% of TypeScript online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.**\\n\\n```\\nfunction getMinSwaps(num: string, k: number): number {\\n    let nums: number[] = num.split(\"\").map(a => parseInt(a));\\n    let permutation: number[] = [...nums];\\n\\n    for (let i = 0; i < k; i++) {\\n        permutation = findSmallestGreater(permutation);\\n    }\\n\\n    return findMoves(nums, permutation);\\n};\\n\\nfunction findSmallestGreater(permutation: number[]): number[] {\\n    let buffer: number[] = [permutation[permutation.length - 1]];\\n    let index: number = permutation.length - 2;\\n    let num: number;\\n\\n    // find the place where the sub array should be updated\\n    for (; index >= 0; index--) {\\n        num = permutation[index];\\n\\n        if (num < buffer[buffer.length - 1]) {\\n            break;\\n        }\\n\\n        buffer.push(num);\\n    }\\n\\n    // remove the updated part\\n    permutation = permutation.slice(0, index);\\n\\n    // arrange the updated part\\n    for (let i = 0; i < buffer.length; i++) {\\n        if (buffer[i] > num) {\\n            permutation.push(buffer[i]);\\n            buffer[i] = num;\\n            break;\\n        }\\n    }\\n\\n    // append to the original array\\n    permutation.push(...buffer);\\n\\n    return permutation;\\n};\\n\\nfunction findMoves(nums: number[], permutation: number[]): number {\\n    let times: number = 0;\\n\\n    // pop the number to the desired place\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < permutation.length; j++) {\\n            if (nums[i] == permutation[j]) {\\n                if (i == j) {\\n                    break;\\n                }\\n\\n                times += (j - i);\\n                permutation.splice(j, 1);\\n                permutation.splice(i, 0, nums[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return times;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction getMinSwaps(num: string, k: number): number {\\n    let nums: number[] = num.split(\"\").map(a => parseInt(a));\\n    let permutation: number[] = [...nums];\\n\\n    for (let i = 0; i < k; i++) {\\n        permutation = findSmallestGreater(permutation);\\n    }\\n\\n    return findMoves(nums, permutation);\\n};\\n\\nfunction findSmallestGreater(permutation: number[]): number[] {\\n    let buffer: number[] = [permutation[permutation.length - 1]];\\n    let index: number = permutation.length - 2;\\n    let num: number;\\n\\n    // find the place where the sub array should be updated\\n    for (; index >= 0; index--) {\\n        num = permutation[index];\\n\\n        if (num < buffer[buffer.length - 1]) {\\n            break;\\n        }\\n\\n        buffer.push(num);\\n    }\\n\\n    // remove the updated part\\n    permutation = permutation.slice(0, index);\\n\\n    // arrange the updated part\\n    for (let i = 0; i < buffer.length; i++) {\\n        if (buffer[i] > num) {\\n            permutation.push(buffer[i]);\\n            buffer[i] = num;\\n            break;\\n        }\\n    }\\n\\n    // append to the original array\\n    permutation.push(...buffer);\\n\\n    return permutation;\\n};\\n\\nfunction findMoves(nums: number[], permutation: number[]): number {\\n    let times: number = 0;\\n\\n    // pop the number to the desired place\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < permutation.length; j++) {\\n            if (nums[i] == permutation[j]) {\\n                if (i == j) {\\n                    break;\\n                }\\n\\n                times += (j - i);\\n                permutation.splice(j, 1);\\n                permutation.splice(i, 0, nums[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return times;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521158,
                "title": "c-using-next-permutation-and-brute-force-swaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string initial_num = num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        int swaps=0;\\n        int n = num.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(initial_num[i]!=num[i])\\n            {\\n                int change=num[i];\\n                int idx=i;\\n                while(idx<n && initial_num[idx]!=change)\\n                {\\n                    idx++;\\n                }\\n                while(idx!=i && idx<n)\\n                {\\n                    swap(initial_num[idx], initial_num[idx-1]);\\n                    idx--;\\n                    swaps++;\\n                }\\n            }\\n        }\\n        return swaps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string initial_num = num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1520930,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int getMinSwaps(String num, int k) \\n    {\\n        StringBuilder sb = new StringBuilder(num);\\n        while(k-- > 0)\\n        {\\n            int index = findNextGreaterNumber(sb);\\n            swapAndSort(sb, index);\\n        }\\n        \\n        return swapCount(num, sb);\\n    }\\n    \\n    int swapCount(String num, StringBuilder sb)\\n    {\\n        int res = 0, i = 0, j = 0, size = num.length();\\n        while(i < size)\\n        {\\n            j = i;\\n            while(num.charAt(i) != sb.charAt(j))\\n            {\\n                j++;\\n            }\\n            \\n            while(i < j)\\n            {\\n                swap(sb, j, j-1);\\n                j--;\\n                res++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void swap(StringBuilder sb, int i, int j)\\n    {\\n        char c = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, c);\\n    }\\n    \\n    int findNextGreaterNumber(StringBuilder sb)\\n    {\\n        int index = sb.length()-1;\\n        int minIndex = index;\\n        while(Character.getNumericValue(sb.charAt(index)) <= \\n              Character.getNumericValue(sb.charAt(index-1)))\\n        {\\n            index--;\\n        }\\n        \\n        return index-1;\\n    }\\n    \\n    void swapAndSort(StringBuilder sb, int index)\\n    {\\n        char toSwap = sb.charAt(index);\\n        char justGreater = sb.charAt(index+1);\\n        int greater = index+1;\\n        for(int i = index+2; i < sb.length(); i++)\\n        {\\n            if(toSwap < sb.charAt(i) && sb.charAt(i) < justGreater)\\n            {\\n                justGreater = sb.charAt(i);\\n                greater = i;\\n            }\\n        }\\n        \\n        char temp = sb.charAt(greater);\\n        sb.setCharAt(greater, sb.charAt(index));\\n        sb.setCharAt(index, temp);\\n        \\n        List<Character> res = new ArrayList<>();\\n        for(int i = index+1; i < sb.length(); i++)\\n        {\\n            res.add(sb.charAt(i));\\n        }\\n        \\n        Collections.sort(res);\\n        for(int i = index+1, j=0; i < sb.length(); i++,j++)\\n        {\\n            sb.setCharAt(i, res.get(j));\\n        }\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMinSwaps(String num, int k) \\n    {\\n        StringBuilder sb = new StringBuilder(num);\\n        while(k-- > 0)\\n        {\\n            int index = findNextGreaterNumber(sb);\\n            swapAndSort(sb, index);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1495904,
                "title": "c-using-next-permutation-reverse-fast",
                "content": "```\\nint getMinSwaps(string num, int k) {\\n        string temp = num;\\n        int n = num.length();\\n        while(k--) \\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; ++ i)\\n        {\\n            if(num[i]!=temp[i])\\n            {\\n                size_t t = temp.find(num[i],i+1);\\n                res += t - i;\\n                reverse(temp.begin()+i, temp.begin()+t+1);\\n                reverse(temp.begin()+i+1, temp.begin()+t+1);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nHappy coding :)",
                "solutionTags": [],
                "code": "```\\nint getMinSwaps(string num, int k) {\\n        string temp = num;\\n        int n = num.length();\\n        while(k--) \\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; ++ i)\\n        {\\n            if(num[i]!=temp[i])\\n            {\\n                size_t t = temp.find(num[i],i+1);\\n                res += t - i;\\n                reverse(temp.begin()+i, temp.begin()+t+1);\\n                reverse(temp.begin()+i+1, temp.begin()+t+1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481193,
                "title": "o-n-2-c-no-next-permutation-function",
                "content": "Well, I kind of forgot **next_permutation**  function existed, so had to make something that\\'s still polynomial (even tho not nearly as fast as next_permutation). \\n\\n**PART1**: finding the kth permutation\\nWe start from the the last digit of **num** and keep going left and adding numbers to **dp array** until we find such number **x** that is smaller than **at least 1** previously added numbers. then, we add the first number that is bigger than x (which is O(1) since the size of tracking array is always N =10) then swap it with x. \\n\\nAfter that we sort the numbers to the right of swapped number to ensure that the new number is bigger than the previous one, but as small as possible. This can be done via **count sort** since all the characters are numbers from 0-9, which leads to linear time sorting.\\n\\nWe repeat this process k times.\\nI think the complexity becomes O(N * K)\\n\\n**PART 2**: finding minimum swaps\\nWell, this is pretty straight forward and there are plenty of great explanations in the discussion so I won\\'t comment on this one. This runs in O(N^2) time I think.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string& num, int k) {\\n        string num_old = num;\\n        int N = (int)num.size();  \\n        for(int _ = 0; _ < k; ++_){\\n            bool dp[10] = {}; \\n            int  id[10] = {};  \\n            int count[10] = {};\\n            \\n            int idx = N -1; \\n            auto ptr = num.end() - 1; \\n            bool found = false; \\n            while(!found){   \\n                for(int i = (*ptr - \\'0\\') + 1; i < 10; ++i){\\n                    if(dp[i]){ \\n                        swap(num[id[i]], num[idx]);\\n                        for(int j = idx + 1; j < N; ++j) ++count[num[j] - \\'0\\'];       \\n                        int j = idx + 1;\\n                        int idx2 = 0; \\n                        while(idx2 < 10){\\n                            if(count[idx2]){\\n                                num[j++] = idx2 + 48;\\n                                --count[idx2];\\n                            } \\n                            else ++idx2;  \\n                        }    \\n                        found = true;\\n                        break;\\n                    }\\n                } \\n                dp[*ptr - \\'0\\'] = 1;\\n                id[*(ptr--) - \\'0\\'] = idx--;  \\n            }\\n        }   \\n        \\n        int cnt = 0, j;\\n        for(int i = 0; i < N; ++i){\\n            j = i; \\n            while(num_old[i] != num[j])  ++j;     \\n            for(; j > i; --j, ++cnt) swap(num[j], num[j-1]);     \\n            \\n        }   \\n       return cnt;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string& num, int k) {\\n        string num_old = num;\\n        int N = (int)num.size();  \\n        for(int _ = 0; _ < k; ++_){\\n            bool dp[10] = {}; \\n            int  id[10] = {};  \\n            int count[10] = {};\\n            \\n            int idx = N -1; \\n            auto ptr = num.end() - 1; \\n            bool found = false; \\n            while(!found){   \\n                for(int i = (*ptr - \\'0\\') + 1; i < 10; ++i){\\n                    if(dp[i]){ \\n                        swap(num[id[i]], num[idx]);\\n                        for(int j = idx + 1; j < N; ++j) ++count[num[j] - \\'0\\'];       \\n                        int j = idx + 1;\\n                        int idx2 = 0; \\n                        while(idx2 < 10){\\n                            if(count[idx2]){\\n                                num[j++] = idx2 + 48;\\n                                --count[idx2];\\n                            } \\n                            else ++idx2;  \\n                        }    \\n                        found = true;\\n                        break;\\n                    }\\n                } \\n                dp[*ptr - \\'0\\'] = 1;\\n                id[*(ptr--) - \\'0\\'] = idx--;  \\n            }\\n        }   \\n        \\n        int cnt = 0, j;\\n        for(int i = 0; i < N; ++i){\\n            j = i; \\n            while(num_old[i] != num[j])  ++j;     \\n            for(; j > i; --j, ++cnt) swap(num[j], num[j-1]);     \\n            \\n        }   \\n       return cnt;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437775,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        int counter = 0;\\n        var numArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n        var targetArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            NextPermutation(targetArray);\\n        }\\n\\n        for (int i = 0; i < numArray.Length; i++)\\n        {\\n            if (numArray[i] != targetArray[i])\\n            {\\n                var index = Array.IndexOf(numArray, targetArray[i], i + 1);\\n                for (int j = index; j > i; j--)\\n                {\\n                    counter++;\\n                    Swap(numArray, j, j - 1);\\n                }\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    public void NextPermutation(int[] array)\\n    {\\n        for (int i = array.Length - 2; i >= 0; i--)\\n        {\\n            if (array[i] < array[i + 1])\\n            {\\n                var current = array[i];\\n                var next = array.Skip(i + 1).Where(c => c > current).Min();\\n                for (int j = i + 1; j < array.Length; j++)\\n                {\\n                    if (array[j] == next)\\n                    {\\n                        Swap(array, i, j);\\n                        break;\\n                    }\\n                }\\n                Array.Sort(array, i + 1, array.Length - i - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n\\n    public void Swap(int[] array, int i, int j)\\n    {\\n        int tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        int counter = 0;\\n        var numArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n        var targetArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            NextPermutation(targetArray);\\n        }\\n\\n        for (int i = 0; i < numArray.Length; i++)\\n        {\\n            if (numArray[i] != targetArray[i])\\n            {\\n                var index = Array.IndexOf(numArray, targetArray[i], i + 1);\\n                for (int j = index; j > i; j--)\\n                {\\n                    counter++;\\n                    Swap(numArray, j, j - 1);\\n                }\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    public void NextPermutation(int[] array)\\n    {\\n        for (int i = array.Length - 2; i >= 0; i--)\\n        {\\n            if (array[i] < array[i + 1])\\n            {\\n                var current = array[i];\\n                var next = array.Skip(i + 1).Where(c => c > current).Min();\\n                for (int j = i + 1; j < array.Length; j++)\\n                {\\n                    if (array[j] == next)\\n                    {\\n                        Swap(array, i, j);\\n                        break;\\n                    }\\n                }\\n                Array.Sort(array, i + 1, array.Length - i - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n\\n    public void Swap(int[] array, int i, int j)\\n    {\\n        int tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431107,
                "title": "o-n-k-n-log-n-t-o-n-s-implicit-treap-next-permutation-python-3",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        import random\\n        \\n        class ImplicitTreap:\\n            class ImplicitTreapNode:\\n                def __init__(self, y, value, left=None, right=None):\\n                    self.y = y\\n                    self.value = value\\n                    self.left = left\\n                    self.right = right\\n                    self.size = 1\\n                \\n                def recalc(self):\\n                    self.size = (self.left.size if self.left is not None else 0) + (self.right.size if self.right is not None else 0) + 1\\n            \\n            def __init__(self, values=None):                \\n                self.root = None\\n                for value in values:\\n                    self.append(value)\\n            \\n            @staticmethod\\n            def _merge(left, right):\\n                if left is None:\\n                    return right\\n                if right is None:\\n                    return left\\n                \\n                if left.y > right.y:\\n                    left.right = ImplicitTreap._merge(left.right, right)\\n                    result = left\\n                else:\\n                    right.left = ImplicitTreap._merge(left, right.left)\\n                    result = right\\n                \\n                result.recalc()\\n                return result\\n            \\n            @staticmethod\\n            def _split(node, index):\\n                if node is None:\\n                    return None, None\\n                \\n                left_size = node.left.size if node.left is not None else 0\\n                if index >= left_size + 1:\\n                    left, right = ImplicitTreap._split(node.right, index - left_size - 1)\\n                    node.right = left\\n                    node.recalc()\\n                    return node, right\\n                else:\\n                    left, right = ImplicitTreap._split(node.left, index)\\n                    node.left = right\\n                    node.recalc()\\n                    return left, node\\n                \\n            def __getitem__(self, index):\\n                if self.root is None or index > self.root.size or index < -self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                if index < 0:\\n                    index = -1 - index\\n                \\n                node = self.root\\n                while True:\\n                    left_size = node.left.size if node.left is not None else 0\\n                    if index < left_size:\\n                        node = node.left\\n                    elif node.left is not None and index == 0:\\n                        return node.value\\n                    elif index == left_size:\\n                        return node.value\\n                    else:\\n                        node = node.right\\n                        index -= left_size + 1\\n        \\n            def insert(self, index, value):\\n                if self.root is None:\\n                    self.root = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                    return\\n                \\n                if index > self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                node = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                self.root = ImplicitTreap._merge(ImplicitTreap._merge(left, node), right)\\n            \\n            def append(self, value):\\n                self.insert(self.root.size if self.root is not None else 0, value)\\n            \\n            def pop(self, index=None):\\n                if index is None:\\n                    index = self.root.size - 1\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                _, right = ImplicitTreap._split(right, 1)\\n                self.root = ImplicitTreap._merge(left, right)\\n            \\n            def __len__(self):\\n                return self.root.size if self.root is not None else 0\\n            \\n            def __str__(self):\\n                result = []\\n                def dfs(node):\\n                    nonlocal result\\n                    if node is None:\\n                        return\\n                    \\n                    dfs(node.left)\\n                    result.append(node.value)\\n                    dfs(node.right)\\n                dfs(self.root)\\n                return str(result)\\n        \\n        \\n        def next_permutation(permutation):\\n            for i in range(len(permutation)-2, -1, -1):\\n                if permutation[i] < permutation[i+1]:\\n                    k = i\\n                    break\\n            else:\\n                return\\n            \\n            for i in range(len(permutation)-1, k, -1):\\n                if permutation[k] < permutation[i]:\\n                    r = i\\n                    break\\n            \\n            permutation = list(permutation)\\n            permutation[k], permutation[r] = permutation[r], permutation[k]\\n            return \\'\\'.join(permutation[0:k+1] + list(reversed(permutation[k+1:])))\\n        \\n        permutation = num\\n        for _ in range(k):\\n            permutation = next_permutation(permutation)\\n        \\n        result = 0\\n        permutation = ImplicitTreap(permutation)\\n        for i in range(len(permutation)):\\n            if num[i] != permutation[i]:\\n                for j in range(i+1, len(permutation)):\\n                    if num[i] == permutation[j]:\\n                        result += j - i \\n                        permutation.pop(j)\\n                        permutation.insert(i, num[i])\\n                        break\\n        return result\\n        \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        import random\\n        \\n        class ImplicitTreap:\\n            class ImplicitTreapNode:\\n                def __init__(self, y, value, left=None, right=None):\\n                    self.y = y\\n                    self.value = value\\n                    self.left = left\\n                    self.right = right\\n                    self.size = 1\\n                \\n                def recalc(self):\\n                    self.size = (self.left.size if self.left is not None else 0) + (self.right.size if self.right is not None else 0) + 1\\n            \\n            def __init__(self, values=None):                \\n                self.root = None\\n                for value in values:\\n                    self.append(value)\\n            \\n            @staticmethod\\n            def _merge(left, right):\\n                if left is None:\\n                    return right\\n                if right is None:\\n                    return left\\n                \\n                if left.y > right.y:\\n                    left.right = ImplicitTreap._merge(left.right, right)\\n                    result = left\\n                else:\\n                    right.left = ImplicitTreap._merge(left, right.left)\\n                    result = right\\n                \\n                result.recalc()\\n                return result\\n            \\n            @staticmethod\\n            def _split(node, index):\\n                if node is None:\\n                    return None, None\\n                \\n                left_size = node.left.size if node.left is not None else 0\\n                if index >= left_size + 1:\\n                    left, right = ImplicitTreap._split(node.right, index - left_size - 1)\\n                    node.right = left\\n                    node.recalc()\\n                    return node, right\\n                else:\\n                    left, right = ImplicitTreap._split(node.left, index)\\n                    node.left = right\\n                    node.recalc()\\n                    return left, node\\n                \\n            def __getitem__(self, index):\\n                if self.root is None or index > self.root.size or index < -self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                if index < 0:\\n                    index = -1 - index\\n                \\n                node = self.root\\n                while True:\\n                    left_size = node.left.size if node.left is not None else 0\\n                    if index < left_size:\\n                        node = node.left\\n                    elif node.left is not None and index == 0:\\n                        return node.value\\n                    elif index == left_size:\\n                        return node.value\\n                    else:\\n                        node = node.right\\n                        index -= left_size + 1\\n        \\n            def insert(self, index, value):\\n                if self.root is None:\\n                    self.root = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                    return\\n                \\n                if index > self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                node = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                self.root = ImplicitTreap._merge(ImplicitTreap._merge(left, node), right)\\n            \\n            def append(self, value):\\n                self.insert(self.root.size if self.root is not None else 0, value)\\n            \\n            def pop(self, index=None):\\n                if index is None:\\n                    index = self.root.size - 1\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                _, right = ImplicitTreap._split(right, 1)\\n                self.root = ImplicitTreap._merge(left, right)\\n            \\n            def __len__(self):\\n                return self.root.size if self.root is not None else 0\\n            \\n            def __str__(self):\\n                result = []\\n                def dfs(node):\\n                    nonlocal result\\n                    if node is None:\\n                        return\\n                    \\n                    dfs(node.left)\\n                    result.append(node.value)\\n                    dfs(node.right)\\n                dfs(self.root)\\n                return str(result)\\n        \\n        \\n        def next_permutation(permutation):\\n            for i in range(len(permutation)-2, -1, -1):\\n                if permutation[i] < permutation[i+1]:\\n                    k = i\\n                    break\\n            else:\\n                return\\n            \\n            for i in range(len(permutation)-1, k, -1):\\n                if permutation[k] < permutation[i]:\\n                    r = i\\n                    break\\n            \\n            permutation = list(permutation)\\n            permutation[k], permutation[r] = permutation[r], permutation[k]\\n            return \\'\\'.join(permutation[0:k+1] + list(reversed(permutation[k+1:])))\\n        \\n        permutation = num\\n        for _ in range(k):\\n            permutation = next_permutation(permutation)\\n        \\n        result = 0\\n        permutation = ImplicitTreap(permutation)\\n        for i in range(len(permutation)):\\n            if num[i] != permutation[i]:\\n                for j in range(i+1, len(permutation)):\\n                    if num[i] == permutation[j]:\\n                        result += j - i \\n                        permutation.pop(j)\\n                        permutation.insert(i, num[i])\\n                        break\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429816,
                "title": "letting-the-standard-c-library-do-all-the-work",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint getMinSwaps(std::string number, int k) {\\n\\t\\tauto permuted = number;\\n\\t\\tfor (auto i = 0; i != k; ++i) {\\n\\t\\t\\tstd::next_permutation(std::begin(permuted), std::end(permuted));\\n\\t\\t}\\n\\n\\t\\tauto count = 0;\\n\\t\\twhile (number != permuted) {\\n\\t\\t\\tauto [iter, jter] = std::mismatch(std::begin(number), std::end(number), std::cbegin(permuted));\\n\\t\\t\\tauto value = *jter;\\n\\t\\t\\tauto kter = std::find(std::next(iter), std::end(number), value);\\n\\t\\t\\tstd::rotate(iter, kter, std::next(kter));\\n\\n\\t\\t\\tcount += static_cast<int>(std::distance(iter, kter));\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint getMinSwaps(std::string number, int k) {\\n\\t\\tauto permuted = number;\\n\\t\\tfor (auto i = 0; i != k; ++i) {\\n\\t\\t\\tstd::next_permutation(std::begin(permuted), std::end(permuted));\\n\\t\\t}\\n\\n\\t\\tauto count = 0;\\n\\t\\twhile (number != permuted) {\\n\\t\\t\\tauto [iter, jter] = std::mismatch(std::begin(number), std::end(number), std::cbegin(permuted));\\n\\t\\t\\tauto value = *jter;\\n\\t\\t\\tauto kter = std::find(std::next(iter), std::end(number), value);\\n\\t\\t\\tstd::rotate(iter, kter, std::next(kter));\\n\\n\\t\\t\\tcount += static_cast<int>(std::distance(iter, kter));\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403356,
                "title": "effecient-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k)\\n    {\\n        string s=num;\\n        int z=0,count=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n           next_permutation(num.begin(),num.end());\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                z=i;\\n                break;\\n            }\\n        }\\n        int l=z;\\n        while(l<s.size())\\n        {\\n            int n=find(s.begin()+l,s.end(),num[l])-s.begin();\\n            reverse(s.begin()+l,s.begin()+n);\\n            reverse(s.begin()+l,s.begin()+n+1);\\n            count+=abs(n-l);\\n            l++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k)\\n    {\\n        string s=num;\\n        int z=0,count=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n           next_permutation(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1394377,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] original = generateDigitArray(num);\\n        int[] copied = Arrays.copyOf(original, original.length);\\n        \\n        while (k > 0) {\\n            nextPermutation(copied);\\n            k--;\\n        }\\n        \\n        return findMinSwaps(original, copied);\\n    }\\n    \\n    private int findMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n    \\n    private int[] generateDigitArray(String strnum) {\\n        List<Integer> result = new ArrayList();\\n        \\n        for (int i = 0; i < strnum.length(); i++) {\\n            result.add(strnum.charAt(i) - \\'0\\');\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n    \\n    private void nextPermutation(int[] nums) {\\n        int length = nums.length;\\n        \\n        int i = length - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) i--;\\n        \\n        int j = length - 1;\\n        if (i >= 0) {\\n            while (j >= 0 && nums[i] >= nums[j]) j--;\\n            swap(nums, i, j);\\n        }\\n        \\n        reverse(nums, i+1, length - 1);\\n    }\\n    \\n    private void swap(int[] nums, int start, int end) {\\n        if (start > end) return;\\n        \\n        int t = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = t;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start <= end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] original = generateDigitArray(num);\\n        int[] copied = Arrays.copyOf(original, original.length);\\n        \\n        while (k > 0) {\\n            nextPermutation(copied);\\n            k--;\\n        }\\n        \\n        return findMinSwaps(original, copied);\\n    }\\n    \\n    private int findMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n    \\n    private int[] generateDigitArray(String strnum) {\\n        List<Integer> result = new ArrayList();\\n        \\n        for (int i = 0; i < strnum.length(); i++) {\\n            result.add(strnum.charAt(i) - \\'0\\');\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n    \\n    private void nextPermutation(int[] nums) {\\n        int length = nums.length;\\n        \\n        int i = length - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) i--;\\n        \\n        int j = length - 1;\\n        if (i >= 0) {\\n            while (j >= 0 && nums[i] >= nums[j]) j--;\\n            swap(nums, i, j);\\n        }\\n        \\n        reverse(nums, i+1, length - 1);\\n    }\\n    \\n    private void swap(int[] nums, int start, int end) {\\n        if (start > end) return;\\n        \\n        int t = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = t;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start <= end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393848,
                "title": "c-explained-next-permutation-convert-string-a-to-b",
                "content": "This Problem is basically concatenation of 2 simple Problems\\n\\n1) Find kth permutation\\n      - Can be found using simple stl formula -  next_permutation(s.begin(),s.end());\\n\\n2)  Minimum swaps to convert string a to string b\\n    - As the constraints are small , you can use two for loops \\n      to convert easily.\\n\\t - The code is self explanatory\\n\\t - Dry run and you can easily understand the approach\\n\\n\\n```\\n\\nclass Solution {\\n    \\n    int swaps(string org,string num)\\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(org[i]!=num[i])\\n            {\\n                for(int j=i+1;j<num.size();j++)\\n                {\\n                    cnt++;\\n                   swap(org[i],org[j]);\\n\\n                    if(org[i]==num[i])\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n    \\n    \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        \\n        string org=num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n        cout<<\" org \"<<org<<endl;\\n        cout<<\" num \"<<num<<endl;\\n        return swaps(org,num);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int swaps(string org,string num)\\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(org[i]!=num[i])\\n            {\\n                for(int j=i+1;j<num.size();j++)\\n                {\\n                    cnt++;\\n                   swap(org[i],org[j]);\\n\\n                    if(org[i]==num[i])\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1340700,
                "title": "c-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(string s1, string s2){\\n        int i=0,j,step=0,n=s1.size();\\n        while(i<n){\\n            j=i;\\n            while(s1[i]!=s2[j]) j++;\\n            while(i<j){\\n                swap(s2[j],s2[j-1]);\\n                j--;\\n                step++;\\n            }\\n            i++;\\n        }\\n        return step;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int i;\\n        string s=num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        return f(s,num);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(string s1, string s2){\\n        int i=0,j,step=0,n=s1.size();\\n        while(i<n){\\n            j=i;\\n            while(s1[i]!=s2[j]) j++;\\n            while(i<j){\\n                swap(s2[j],s2[j-1]);\\n                j--;\\n                step++;\\n            }\\n            i++;\\n        }\\n        return step;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int i;\\n        string s=num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        return f(s,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318393,
                "title": "c-very-easy-with-explanations",
                "content": "first find kth `next permutation` (C++ has by default algorithm for it)\\nProbable internal implementation of `next_permutation` (just for fun)\\n```\\nvoid next_permutation(string& s) {\\n\\tauto it = is_sorted_until(rbegin(s), rend(s));\\n    if(it != rend(s)) swap(*it, *upper_bound(rbegin(s), it, *it));\\n    reverse(rbegin(s), it);\\n}\\n```\\nAfter that traverse both strings (original one and kth permutation one)\\nif it any position they differ. mark that position and find the number in other string,\\nMeans that .. suppose \\nstring is `s = \"5489355142\"`\\n```\\n\\t5 4 8 9 3 5 5 1 4 2  => original string\\n\\t5 4 8 9 3 5 5 4 2 1  => kth next permutation\\n\\t. . . . . . . *      => differing position (1 != 4)\\n\\twe find   1 (element from top string) in bottom string .\\n\\tin bottom string it is present at the end (last element of bottom string is 1)\\n\\t\\n\\twe mark this position as pos\\n\\tNow, we know that swap occurred between i and pos.\\n\\trun a loop from i to pos and swap s[pos] and s[pos - 1] and increase swap count\\n\\treturn count\\n```\\n##### Code\\n\\n```\\nint getMinSwaps(string s, int k) {\\n        string str = s;\\n        int count = 0;\\n        while(k--)\\n            next_permutation(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] != str[i]) {\\n                int pos = s.find(str[i], i);\\n                while(pos > i) {\\n                    swap(s[pos], s[pos - 1]);\\n                    count++;\\n                    pos--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid next_permutation(string& s) {\\n\\tauto it = is_sorted_until(rbegin(s), rend(s));\\n    if(it != rend(s)) swap(*it, *upper_bound(rbegin(s), it, *it));\\n    reverse(rbegin(s), it);\\n}\\n```\n```\\n\\t5 4 8 9 3 5 5 1 4 2  => original string\\n\\t5 4 8 9 3 5 5 4 2 1  => kth next permutation\\n\\t. . . . . . . *      => differing position (1 != 4)\\n\\twe find   1 (element from top string) in bottom string .\\n\\tin bottom string it is present at the end (last element of bottom string is 1)\\n\\t\\n\\twe mark this position as pos\\n\\tNow, we know that swap occurred between i and pos.\\n\\trun a loop from i to pos and swap s[pos] and s[pos - 1] and increase swap count\\n\\treturn count\\n```\n```\\nint getMinSwaps(string s, int k) {\\n        string str = s;\\n        int count = 0;\\n        while(k--)\\n            next_permutation(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] != str[i]) {\\n                int pos = s.find(str[i], i);\\n                while(pos > i) {\\n                    swap(s[pos], s[pos - 1]);\\n                    count++;\\n                    pos--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308870,
                "title": "faster-than-99-c-small-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(),s.end());\\n        }\\n        int i=0,j=0,count = 0;\\n        while(i<num.size()) {\\n            if(s[i] == num[j]) {\\n                i++;j++;\\n                continue;\\n            }\\n            while(s[i] != num[j]) j++;\\n            while(j>i) {\\n                swap(num[j],num[j-1]);\\n                count++;\\n                j--;\\n            }\\n            j = ++i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(),s.end());\\n        }\\n        int i=0,j=0,count = 0;\\n        while(i<num.size()) {\\n            if(s[i] == num[j]) {\\n                i++;j++;\\n                continue;\\n            }\\n            while(s[i] != num[j]) j++;\\n            while(j>i) {\\n                swap(num[j],num[j-1]);\\n                count++;\\n                j--;\\n            }\\n            j = ++i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293738,
                "title": "python3-leetcode-31-next-permutation",
                "content": "Basically the same solution as [LeetCode 31](https://leetcode.com/problems/next-permutation).\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        m = len(num)\\n        s = list(num)\\n        num = list(num)\\n        def next_permutation(n):\\n            i = m - 2\\n            while i >= 0 and n[i] >= n[i + 1]:\\n                i -= 1\\n            j = i + 1\\n            while j < m and n[i] < n[j]:\\n                j += 1\\n            j -= 1\\n            n[i], n[j] = n[j], n[i]\\n            i += 1\\n            j = m - 1\\n            while i < j:\\n                n[i], n[j] = n[j], n[i]\\n                i += 1\\n                j -= 1\\n            return n\\n        while k:\\n            num = next_permutation(num)\\n            k -= 1\\n        def calc(s, t):\\n            res = 0\\n            for i in range(m):\\n                if s[i] == t[i]:\\n                    continue\\n                j = i\\n                while j < m and s[j] != t[i]:\\n                    j += 1\\n                res += j - i\\n                s[i + 1:] = s[i:j] + s[j + 1:]\\n            return res\\n        return calc(s, num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        m = len(num)\\n        s = list(num)\\n        num = list(num)\\n        def next_permutation(n):\\n            i = m - 2\\n            while i >= 0 and n[i] >= n[i + 1]:\\n                i -= 1\\n            j = i + 1\\n            while j < m and n[i] < n[j]:\\n                j += 1\\n            j -= 1\\n            n[i], n[j] = n[j], n[i]\\n            i += 1\\n            j = m - 1\\n            while i < j:\\n                n[i], n[j] = n[j], n[i]\\n                i += 1\\n                j -= 1\\n            return n\\n        while k:\\n            num = next_permutation(num)\\n            k -= 1\\n        def calc(s, t):\\n            res = 0\\n            for i in range(m):\\n                if s[i] == t[i]:\\n                    continue\\n                j = i\\n                while j < m and s[j] != t[i]:\\n                    j += 1\\n                res += j - i\\n                s[i + 1:] = s[i:j] + s[j + 1:]\\n            return res\\n        return calc(s, num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284088,
                "title": "hint-if-you-need-it-this-problem-is-too-hard-for-medium",
                "content": "1. How to the smallest number that is larger than the input number(N)?\\n2. Do that for k times and get the target number X\\n3. To get X from N, how many swaps between adjacent digits are needed?\\n\\nI think both 1) and 3) alone justify a medium questions. This problem, asked as is, is obviously too hard for coding interview.",
                "solutionTags": [],
                "code": "1. How to the smallest number that is larger than the input number(N)?\\n2. Do that for k times and get the target number X\\n3. To get X from N, how many swaps between adjacent digits are needed?\\n\\nI think both 1) and 3) alone justify a medium questions. This problem, asked as is, is obviously too hard for coding interview.",
                "codeTag": "Unknown"
            },
            {
                "id": 1279012,
                "title": "c-solution-90-faster",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string num1=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=num1[i])\\n            {\\n                int j=i+1;\\n                for(;j<n;j++)\\n                {\\n                    if(num1[j]==num[i])\\n                    {\\n                        ans+=j-i;\\n                        break ;\\n                    }\\n                }\\n                while(j!=i)\\n                {\\n                    swap(num1[j],num1[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string num1=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=num1[i])\\n            {\\n                int j=i+1;\\n                for(;j<n;j++)\\n                {\\n                    if(num1[j]==num[i])\\n                    {\\n                        ans+=j-i;\\n                        break ;\\n                    }\\n                }\\n                while(j!=i)\\n                {\\n                    swap(num1[j],num1[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262439,
                "title": "c-easy-using-next-permutation-and-string-erase-and-insert",
                "content": "k the permutation of the array is being obtained by using next_permutation and then the string original string is compared with the modified string whenever the elements differ the difference between the positions is added to the ans and the original string is modified accordingly .The approach is given below \\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string temp = s;\\n        while(k--)\\n        {\\n           next_permutation(temp.begin() , temp.end()); \\n        }\\n        int ans =0 ; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != temp[i])\\n            {\\n                int j = i+1;\\n                while(j < s.size())\\n                {\\n                    if(s[j] == temp[i]) break;\\n                    j++;\\n                }\\n                s.insert(i, 1, temp[i]);\\n             \\n                s.erase(j+1,1);\\n    \\n                ans += j-i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string temp = s;\\n        while(k--)\\n        {\\n           next_permutation(temp.begin() , temp.end()); \\n        }\\n        int ans =0 ; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != temp[i])\\n            {\\n                int j = i+1;\\n                while(j < s.size())\\n                {\\n                    if(s[j] == temp[i]) break;\\n                    j++;\\n                }\\n                s.insert(i, 1, temp[i]);\\n             \\n                s.erase(j+1,1);\\n    \\n                ans += j-i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258858,
                "title": "js-next-permutation",
                "content": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar getMinSwaps = function(num, k) {\\n    const digits = num.split(\\'\\').map(ch => Number(ch))\\n    const len = digits.length\\n    \\n    function toNextPerm() {\\n        let i = -2 + len\\n        for (; i >= 0; i--)\\n            if (digits[i] < digits[1 + i])\\n                break\\n        \\n        let low = 1 + i, high = -1 + len\\n        const val = digits[i]\\n        while (low < high) {\\n            const mid = Math.ceil((low + high) / 2)\\n            if (digits[mid] > val)    low = mid\\n            else high = -1 + mid\\n        }\\n        \\n        const swapWith = low\\n        ;[digits[i], digits[swapWith]] = [digits[swapWith], digits[i]];\\n        \\n        for (let low = 1 + i, high = -1 + len;\\n        low < high; low++, high--) {\\n            [digits[low], digits[high]] = [digits[high], digits[low]]\\n        }\\n    }\\n    \\n    \\n    const snapshot = [...digits]\\n    for (let i = 0; i < k; i++)\\n        toNextPerm()\\n        \\n\\n    let result = 0\\n    for (let i = 0; i < len; i++) {\\n        const valA = snapshot[i]\\n        const valB = digits[i]\\n        if (valA === valB)  continue\\n        \\n        // let snapshot[i] <- valB\\n        const index = snapshot.indexOf(valB, 1 + i)\\n        const offset = index - i\\n        result += offset\\n        \\n        // swap\\n        for (let j = index; j > i; j--) {\\n            [snapshot[j], snapshot[j - 1]] = [snapshot[j - 1], snapshot[j]]\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar getMinSwaps = function(num, k) {\\n    const digits = num.split(\\'\\').map(ch => Number(ch))\\n    const len = digits.length\\n    \\n    function toNextPerm() {\\n        let i = -2 + len\\n        for (; i >= 0; i--)\\n            if (digits[i] < digits[1 + i])\\n                break\\n        \\n        let low = 1 + i, high = -1 + len\\n        const val = digits[i]\\n        while (low < high) {\\n            const mid = Math.ceil((low + high) / 2)\\n            if (digits[mid] > val)    low = mid\\n            else high = -1 + mid\\n        }\\n        \\n        const swapWith = low\\n        ;[digits[i], digits[swapWith]] = [digits[swapWith], digits[i]];\\n        \\n        for (let low = 1 + i, high = -1 + len;\\n        low < high; low++, high--) {\\n            [digits[low], digits[high]] = [digits[high], digits[low]]\\n        }\\n    }\\n    \\n    \\n    const snapshot = [...digits]\\n    for (let i = 0; i < k; i++)\\n        toNextPerm()\\n        \\n\\n    let result = 0\\n    for (let i = 0; i < len; i++) {\\n        const valA = snapshot[i]\\n        const valB = digits[i]\\n        if (valA === valB)  continue\\n        \\n        // let snapshot[i] <- valB\\n        const index = snapshot.indexOf(valB, 1 + i)\\n        const offset = index - i\\n        result += offset\\n        \\n        // swap\\n        for (let j = index; j > i; j--) {\\n            [snapshot[j], snapshot[j - 1]] = [snapshot[j - 1], snapshot[j]]\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256200,
                "title": "sharing-my-javascript-solution",
                "content": "```\\nvar getMinSwaps = function(num, k) {\\n  let nums = num.split(\"\");\\n  let perm = [...nums];\\n  for (let i = 0; i < k; i++) {\\n    perm = getNextPermutation(perm);\\n  }\\n  return countSwaps(nums, perm);\\n};\\n\\nfunction countSwaps(n1, n2) {\\n  let count = 0;\\n  for (let i = 0; i < n1.length; i++) {\\n    if (n1[i] !== n2[i]) {\\n      count += findAndSwap(n2, n1[i], i, i+1);\\n    } else {\\n      continue;\\n    }\\n  }\\n  return count;\\n}\\n\\nfunction findAndSwap(nums, val, swapIndex, start) {\\n  for (let i = start; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      return swapBetween(i, swapIndex, nums);\\n    }\\n  }\\n  throw new Error(`could not find elem to swap!`);\\n}\\n\\nfunction swapBetween(end, start, nums) {\\n  let count = 0;\\n  for (let i = end; i > start; i--) {\\n    [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\\n    count += 1;\\n  }\\n  \\n  return count;\\n}\\n\\nfunction getNextPermutation(nums) {\\n  let count = 0;\\n  for (let i = nums.length-2; i >= 0; i--) {\\n    if (nums[i] < nums[i+1]) {\\n      for (let j = nums.length-1; j > i; j--) {\\n        if (nums[j] > nums[i]) {\\n          [nums[i], nums[j]] = [nums[j], nums[i]];\\n          reverse(i+1, nums.length-1, nums);\\n          return nums;\\n        }\\n      }\\n    }\\n  }\\n  \\n  throw new Error(`not a valid number: ${nums}`);\\n}\\n\\nfunction reverse(start, end, nums) {\\n  while (start < end) {\\n    [nums[start], nums[end]] = [nums[end], nums[start]];\\n    start += 1;\\n    end -= 1;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n  let nums = num.split(\"\");\\n  let perm = [...nums];\\n  for (let i = 0; i < k; i++) {\\n    perm = getNextPermutation(perm);\\n  }\\n  return countSwaps(nums, perm);\\n};\\n\\nfunction countSwaps(n1, n2) {\\n  let count = 0;\\n  for (let i = 0; i < n1.length; i++) {\\n    if (n1[i] !== n2[i]) {\\n      count += findAndSwap(n2, n1[i], i, i+1);\\n    } else {\\n      continue;\\n    }\\n  }\\n  return count;\\n}\\n\\nfunction findAndSwap(nums, val, swapIndex, start) {\\n  for (let i = start; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      return swapBetween(i, swapIndex, nums);\\n    }\\n  }\\n  throw new Error(`could not find elem to swap!`);\\n}\\n\\nfunction swapBetween(end, start, nums) {\\n  let count = 0;\\n  for (let i = end; i > start; i--) {\\n    [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\\n    count += 1;\\n  }\\n  \\n  return count;\\n}\\n\\nfunction getNextPermutation(nums) {\\n  let count = 0;\\n  for (let i = nums.length-2; i >= 0; i--) {\\n    if (nums[i] < nums[i+1]) {\\n      for (let j = nums.length-1; j > i; j--) {\\n        if (nums[j] > nums[i]) {\\n          [nums[i], nums[j]] = [nums[j], nums[i]];\\n          reverse(i+1, nums.length-1, nums);\\n          return nums;\\n        }\\n      }\\n    }\\n  }\\n  \\n  throw new Error(`not a valid number: ${nums}`);\\n}\\n\\nfunction reverse(start, end, nums) {\\n  while (start < end) {\\n    [nums[start], nums[end]] = [nums[end], nums[start]];\\n    start += 1;\\n    end -= 1;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242317,
                "title": "c-explained-implementation",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\n   \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string temp = num; //store the string in temp to get process it \\n        int ans=0;\\n//next_permutation gives us the lexicographically greater permuatation, we repaeat it k times\\n        while(k--){\\n            next_permutation(temp.begin(), temp.end());\\n        }\\n        \\n// Now we loop & look for the first point of difference in temp & num string\\n        for(int i=0;i<num.size();i++){\\n//if i is the point of difference then we traverse further till we find the position in temp\\n//whose value equals num[i]\\n            if(temp[i] !=  num[i]){\\n                int j=i;\\n                while(num[i]!=temp[j]){\\n                    j++;\\n                }\\n// so once we have found the posiiton in temp the number of swap for this change will be j-i\\n                ans += j-i;\\n// we bring the nums[i] to same position in temp and remove the extra element at j+1\\n                temp.insert(temp.begin()+i, num[i]);\\n                temp.erase(temp.begin()+j+1);\\n            }\\n// we repeat this until all the char match in both num and temp\\n        }\\n        \\n        //finally return the ans\\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if explanation was useful & you liked the code:) **",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string temp = num; //store the string in temp to get process it \\n        int ans=0;\\n//next_permutation gives us the lexicographically greater permuatation, we repaeat it k times\\n        while(k--){\\n            next_permutation(temp.begin(), temp.end());\\n        }\\n        \\n// Now we loop & look for the first point of difference in temp & num string\\n        for(int i=0;i<num.size();i++){\\n//if i is the point of difference then we traverse further till we find the position in temp\\n//whose value equals num[i]\\n            if(temp[i] !=  num[i]){\\n                int j=i;\\n                while(num[i]!=temp[j]){\\n                    j++;\\n                }\\n// so once we have found the posiiton in temp the number of swap for this change will be j-i\\n                ans += j-i;\\n// we bring the nums[i] to same position in temp and remove the extra element at j+1\\n                temp.insert(temp.begin()+i, num[i]);\\n                temp.erase(temp.begin()+j+1);\\n            }\\n// we repeat this until all the char match in both num and temp\\n        }\\n        \\n        //finally return the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231901,
                "title": "c-know-yo-algorithm-s",
                "content": "First off, note that this is not quite as fast as the usual coding competition versions with numerical indices.\\n\\nHowever, if you\\'re interviewing at a company, people really love to see use of the std library.\\n\\nNote: you can probably do purely forward iteration in the last bit.\\n\\nThis is a greedy version because we (correctly) assume that the next item we find that matches the correct version in `num` is the item we want (greedy proof: the items in the \"mismatched\" region must construct an identical bag).\\n\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    static\\n    int getMinSwaps(string const &num, int const k) {\\n        auto permuted = num;\\n        for (int i{0}; i < k; ++i) {\\n            next_permutation(begin(permuted), end(permuted));\\n        }\\n        \\n\\t\\t// Find the first place where the two digits differ\\n        auto [num_b, perm_b] = mismatch(cbegin(num), cend(num), begin(permuted));\\n        \\n        // turn them into reverse iters so we can swap from the end\\n        auto perm_r = rbegin(permuted);\\n        auto perm_e = reverse_iterator(perm_b);\\n        \\n        int total_distance{};\\n        for (auto num_r = crbegin(num), num_e = reverse_iterator(num_b);\\n            num_r != num_e; advance(num_r, 1), advance(perm_r, 1)) {\\n            //cout << permuted << \\'\\\\n\\';\\n            // Find the first position where they mismatch\\n            auto [num_pos, perm_pos] = mismatch(num_r, num_e, perm_r);\\n            if (num_pos == num_e)\\n                break; // everything is fine!\\n            \\n            // search ahead in perm to find where it equals *num_pos\\n            auto perm_correct_pos = find(perm_pos, perm_e, *num_pos);\\n            assert(perm_correct_pos != perm_e); // it should ALWAYS find it\\n            \\n            total_distance += distance(perm_pos, perm_correct_pos);\\n\\t\\t\\t// change to a forward iterator so we only have to do a left rotate of distance 1\\n\\t\\t\\t// instead of a right rotate of distance N\\n            auto fwd = next(perm_correct_pos).base(); // flips it and subs 1\\n            auto rotate_result = rotate(fwd, fwd+1, perm_pos.base());\\n        }\\n        return total_distance;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    static\\n    int getMinSwaps(string const &num, int const k) {\\n        auto permuted = num;\\n        for (int i{0}",
                "codeTag": "Java"
            },
            {
                "id": 1205971,
                "title": "tried-next-permutation-bfs",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int f=INT_MAX;\\n    void nextpermutation(string& s)\\n    { int j=s.length()-1;\\n        while(j>0&&(s[j-1]-\\'0\\')>=(s[j]-\\'0\\'))\\n        {j--;}\\n        int i=s.length()-1;\\n     int ans=10;\\n     int ans1;\\n        while((j-1)<i)\\n        { if((s[i]-\\'0\\')>(s[j-1]-\\'0\\')&&(s[i]-\\'0\\')<ans)\\n        {ans=(s[i]-\\'0\\');\\n         ans1=i;}\\n            i--;\\n        }\\n        swap(s[j-1],s[ans1]);\\n     reverse(s.begin()+j,s.end());\\n        f=min(f,j-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n       string s=num;\\n        vector <int> v1[10],v2[10];\\n        for(int i=0;i<k;i++)\\n        { nextpermutation(num);\\n        }\\n\\n      queue <string> q;\\n        unordered_set <string> se;\\n        se.insert(s);\\n        q.push(s);\\n        int l=0;\\n        while(!q.empty())\\n        { l++;\\n\\n         int m=q.size();\\n            for(int i=0;i<m;i++)\\n            {string z=q.front();\\n         q.pop();  \\n\\n            for(int j=f;j<z.length()-1;j++)\\n            {\\n            swap(z[j],z[j+1]);\\n             \\n             if(z==num)\\n                 return l;\\n            if(se.count(z)==0)\\n               q.push(z);\\n             se.insert(z);\\n             swap(z[j],z[j+1]);}\\n            }\\n        }\\n        \\n        }\\n        return 0;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int f=INT_MAX;\\n    void nextpermutation(string& s)\\n    { int j=s.length()-1;\\n        while(j>0&&(s[j-1]-\\'0\\')>=(s[j]-\\'0\\'))\\n        {j--;}",
                "codeTag": "Java"
            },
            {
                "id": 1205492,
                "title": "java-next-permutation-adjacentswap-o-n-2",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] numsOriginal = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        int i = 0;\\n        for(char ch : num.toCharArray()){\\n            nums[i] = Character.getNumericValue(ch);\\n            numsOriginal[i] = nums[i];\\n            i++;\\n        }\\n        for(i =0 ; i < k; i++){\\n            nextPermutation(nums); \\n        }\\n        return findDistance(nums, numsOriginal);\\n    }\\n    \\n    private int findDistance(int[] original, int[] nums){\\n        int ct = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == original[i]) continue;\\n            int fI = original[i];\\n            int k = i+1;\\n            for( ;k <n; k++){\\n                if(nums[k] == fI){\\n                    break;\\n                }\\n            }\\n            for(int j = k; j>i; j--){\\n                int tmp = nums[j];\\n                nums[j] = nums[j-1];\\n                nums[j-1] = tmp;\\n                ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        if(nums.length == 1) return;\\n        int i = nums.length -2;\\n        for( ; i >=0; i--){\\n            if(nums[i] <nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i>=0){\\n            int k = i+1;\\n            int index = -1;\\n            for(; k< nums.length; k++){\\n                if(nums[k] > nums[i]){\\n                    index = k;\\n                }\\n            }\\n            int temp = nums[i];\\n            nums[i] = nums[index];\\n            nums[index] = temp;\\n        }\\n        Arrays.sort(nums,i+1, nums.length);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] numsOriginal = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        int i = 0;\\n        for(char ch : num.toCharArray()){\\n            nums[i] = Character.getNumericValue(ch);\\n            numsOriginal[i] = nums[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203470,
                "title": "does-not-pass-all-test-cases-will-improve-on-it",
                "content": "```\\n\"\"\"\\nCreated on Mon May 10 14:35:50 2021\\n\\n@author: Utpal\\n\"\"\"\\n\\ndef swap_element(lst, k, num_swaps):\\n    \\n     last = lst[-1]\\n     cnt = 0       \\n     \\n     for index, c in enumerate(lst[-2::-1]):\\n\\n               if int(last) > int(c) and cnt<k:   \\n                      lst[-1-(index+1)], lst[-(index+1)] = lst[-(index+1)], lst[-1-(index+1)]\\n                      num_swaps +=1\\n                      cnt+=1\\n                      last = lst[-1-(index+1)]\\n               else:\\n                      cnt+=1\\n                      continue\\n               \\n     return lst, num_swaps\\n    \\nclass Solution(object):\\n    def getMinSwaps(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not (num.isdigit()):\\n            raise ValueError(\"Non-digit found\")\\n        elif not(2 <= len(num) <= 1000):\\n            raise ValueError(\"length of num out of bounds\")\\n        elif not(1 <= k <= 1000):\\n            raise ValueError(\"k is out of bounds\")\\n        else:\\n            lst = []\\n            for c in num:\\n                lst.append(c)\\n            num_swaps = 0    \\n            for cnt in range(0,k):\\n                lst, num_swaps = swap_element(lst, k, num_swaps)\\n        return num_swaps    \\n\\nnum = \"5489355142\"\\nk = 4\\n\\n# num = \"11112\"\\n# k = 4\\n\\n# num = \"00123\"\\n# k = 1\\n\\nnum_swaps = Solution().getMinSwaps(num, k)\\nprint (num_swaps)          \\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nCreated on Mon May 10 14:35:50 2021\\n\\n@author: Utpal\\n\"\"\"\\n\\ndef swap_element(lst, k, num_swaps):\\n    \\n     last = lst[-1]\\n     cnt = 0       \\n     \\n     for index, c in enumerate(lst[-2::-1]):\\n\\n               if int(last) > int(c) and cnt<k:   \\n                      lst[-1-(index+1)], lst[-(index+1)] = lst[-(index+1)], lst[-1-(index+1)]\\n                      num_swaps +=1\\n                      cnt+=1\\n                      last = lst[-1-(index+1)]\\n               else:\\n                      cnt+=1\\n                      continue\\n               \\n     return lst, num_swaps\\n    \\nclass Solution(object):\\n    def getMinSwaps(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not (num.isdigit()):\\n            raise ValueError(\"Non-digit found\")\\n        elif not(2 <= len(num) <= 1000):\\n            raise ValueError(\"length of num out of bounds\")\\n        elif not(1 <= k <= 1000):\\n            raise ValueError(\"k is out of bounds\")\\n        else:\\n            lst = []\\n            for c in num:\\n                lst.append(c)\\n            num_swaps = 0    \\n            for cnt in range(0,k):\\n                lst, num_swaps = swap_element(lst, k, num_swaps)\\n        return num_swaps    \\n\\nnum = \"5489355142\"\\nk = 4\\n\\n# num = \"11112\"\\n# k = 4\\n\\n# num = \"00123\"\\n# k = 1\\n\\nnum_swaps = Solution().getMinSwaps(num, k)\\nprint (num_swaps)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201220,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int pos = 0;\\n        while(pos < n && s[pos] == num[pos])\\n            pos++;\\n        int ans = 0;\\n        for(int i = pos; i < n; i++) {\\n            if(s[i] != num[i]) {\\n                int in;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] == s[i]) {\\n                        ans += j - i;\\n                        in = j;\\n                        break;\\n                    }\\n                }\\n                char a = num[in];\\n                while(in > i) {\\n                    num[in] = num[in - 1];\\n                    in--;\\n                }\\n                num[i] = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int pos = 0;\\n        while(pos < n && s[pos] == num[pos])\\n            pos++;\\n        int ans = 0;\\n        for(int i = pos; i < n; i++) {\\n            if(s[i] != num[i]) {\\n                int in;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] == s[i]) {\\n                        ans += j - i;\\n                        in = j;\\n                        break;\\n                    }\\n                }\\n                char a = num[in];\\n                while(in > i) {\\n                    num[in] = num[in - 1];\\n                    in--;\\n                }\\n                num[i] = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200296,
                "title": "ruby-next-permutation",
                "content": "**Idea**\\n\\n- The problem can be divided into two smaller one: generate the next permutation of the string and calculate the swapping operation to get there.\\n- Generate next permutation:\\n  - Take \"3421\" as an example.\\n  - Going from right to left, find the first number that is not in the descending order that is \"3\".\\n  - Find the next larger number to \"3\" in the right side that is \"4\" then swap them. Now we have \"4321\". This can be done with binary search for 0(log(n)) runtime.\\n  - Sort \"321\" in ascending order to get \"123\". Actually, we can just reverse it to save time since the order is maintained.\\n  - Now we get \"4123\" as the next permutation of \"3421\".\\n- Calculate swapping operation:\\n - Take \"a = 4123\" and \"b = 3421\" as an example.\\n - For each number in a, find the index of that number in b\\n - Calculate the different between the two index and add to the final result.\\n\\n**Complexity**\\n\\n- O(n**2) for both generating permutation and calculating the swap operation\\n\\n**Code**\\n\\n```ruby\\nclass Solution\\n  def self.get_min_swap(a, k)\\n    a = a.split(\"\").reverse\\n    b = a.map(&:clone)\\n    k.times { b = gen_next_permuation(b) }\\n    calc_diff(b, a)\\n  end\\n\\n  def self.gen_next_permuation(a)\\n    n = a.length\\n    i = (0..n-2).find { |x| a[x] > a[x + 1] } + 1\\n    j = a[0, i].bsearch_index { |x| x > a[i] }\\n    a[i], a[j] = a[j], a[i]\\n    a[0, i].reverse + a[i, n]\\n  end\\n\\n  def self.calc_diff(a, b)\\n    ans = 0\\n    n = a.length\\n    n.times do |i|\\n      if a[i] != b[i]\\n        j = i\\n        j += 1 while j < n && b[j] != a[i]\\n        ans += j - i\\n        while j > i\\n          b[j], b[j - 1] = b[j - 1], b[i]\\n          j -= 1\\n        end\\n      end\\n    end\\n\\n    ans\\n  end\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Solution\\n  def self.get_min_swap(a, k)\\n    a = a.split(\"\").reverse\\n    b = a.map(&:clone)\\n    k.times { b = gen_next_permuation(b) }\\n    calc_diff(b, a)\\n  end\\n\\n  def self.gen_next_permuation(a)\\n    n = a.length\\n    i = (0..n-2).find { |x| a[x] > a[x + 1] } + 1\\n    j = a[0, i].bsearch_index { |x| x > a[i] }\\n    a[i], a[j] = a[j], a[i]\\n    a[0, i].reverse + a[i, n]\\n  end\\n\\n  def self.calc_diff(a, b)\\n    ans = 0\\n    n = a.length\\n    n.times do |i|\\n      if a[i] != b[i]\\n        j = i\\n        j += 1 while j < n && b[j] != a[i]\\n        ans += j - i\\n        while j > i\\n          b[j], b[j - 1] = b[j - 1], b[i]\\n          j -= 1\\n        end\\n      end\\n    end\\n\\n    ans\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192671,
                "title": "java-array-string-greedy-beats-92-next-permutation-adjacent-swapping",
                "content": "\\n    // O(n*k + n^2) O(n)\\n\\tpublic int getMinSwaps(String num, int k) {\\n\\n\\t\\tchar[] nums = num.toCharArray();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tnextPermutation(nums);\\n\\n\\t\\treturn minKAdjacentSwaps(nums, num);\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void nextPermutation(char[] nums) {\\n\\n\\t\\tint len = nums.length, ei = -1;\\n\\t\\tfor (int i = len - 1; i >= 1; i--) {\\n\\t\\t\\tint m = (nums[i - 1] - \\'0\\') - (nums[i] - \\'0\\');\\n\\t\\t\\tif (m < 0) {\\n\\t\\t\\t\\tei = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (ei == -1) {\\n\\t\\t\\treverse(nums, 0, len - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint idx = ei - 1, temp = nums[idx] - \\'0\\';\\n\\t\\tei = binarySearch(nums, ei, len - 1, temp);\\n\\n\\t\\tswap(nums, idx, ei);\\n\\t\\treverse(nums, idx + 1, len - 1);\\n\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(char[] nums, int hi, int lo, int target) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo >= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] - \\'0\\' > target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void reverse(char[] nums, int si, int ei) {\\n\\n\\t\\twhile (si < ei) {\\n\\t\\t\\tswap(nums, si, ei);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei--;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic void swap(char[] nums, int i, int j) {\\n\\n\\t\\tchar temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}\\n\\n\\t// O(n^2) O(1)\\n\\tpublic int minKAdjacentSwaps(char[] src, String target) {\\n\\n\\t\\tint len = src.length, i = 0, j = 0, count = 0;\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (src[i] != target.charAt(j)) {\\n\\t\\t\\t\\tfor (int k = i + 1; k < len; k++) {\\n\\t\\t\\t\\t\\tif (src[k] == target.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tfor (int l = k; l >= i + 1; l--) {\\n\\t\\t\\t\\t\\t\\t\\tswap(src, l, l - 1);\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(n*k + n^2) O(n)\\n\\tpublic int getMinSwaps(String num, int k) {\\n\\n\\t\\tchar[] nums = num.toCharArray();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tnextPermutation(nums);\\n\\n\\t\\treturn minKAdjacentSwaps(nums, num);\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void nextPermutation(char[] nums) {\\n\\n\\t\\tint len = nums.length, ei = -1;\\n\\t\\tfor (int i = len - 1; i >= 1; i--) {\\n\\t\\t\\tint m = (nums[i - 1] - \\'0\\') - (nums[i] - \\'0\\');\\n\\t\\t\\tif (m < 0) {\\n\\t\\t\\t\\tei = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (ei == -1) {\\n\\t\\t\\treverse(nums, 0, len - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint idx = ei - 1, temp = nums[idx] - \\'0\\';\\n\\t\\tei = binarySearch(nums, ei, len - 1, temp);\\n\\n\\t\\tswap(nums, idx, ei);\\n\\t\\treverse(nums, idx + 1, len - 1);\\n\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(char[] nums, int hi, int lo, int target) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo >= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] - \\'0\\' > target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void reverse(char[] nums, int si, int ei) {\\n\\n\\t\\twhile (si < ei) {\\n\\t\\t\\tswap(nums, si, ei);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei--;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic void swap(char[] nums, int i, int j) {\\n\\n\\t\\tchar temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}\\n\\n\\t// O(n^2) O(1)\\n\\tpublic int minKAdjacentSwaps(char[] src, String target) {\\n\\n\\t\\tint len = src.length, i = 0, j = 0, count = 0;\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (src[i] != target.charAt(j)) {\\n\\t\\t\\t\\tfor (int k = i + 1; k < len; k++) {\\n\\t\\t\\t\\t\\tif (src[k] == target.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tfor (int l = k; l >= i + 1; l--) {\\n\\t\\t\\t\\t\\t\\t\\tswap(src, l, l - 1);\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1192032,
                "title": "go-golang-next-permutation",
                "content": "```\\nfunc getMinSwaps(num string, k int) int {\\n    num1 := []byte(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextPermutation(num1)\\n\\t}\\n\\n\\tvar res, j int\\n\\tfor i := 0; i < len(num); i++ {\\n\\t\\tif num[i] != num1[i] {\\n\\t\\t\\tfor j = i + 1; num[i] != num1[j]; j++ {\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ; j != i; j-- {\\n\\t\\t\\t\\tnum1[j], num1[j-1] = num1[j-1], num1[j]\\n\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc nextPermutation(arr []byte) {\\n\\tn := len(arr)\\n\\ti := n - 2\\n\\tfor ; i >= 0 && arr[i] >= arr[i+1]; i-- {\\n\\t}\\n\\n\\tif i >= 0 {\\n\\t\\tj := n - 1\\n\\t\\tfor ; j >= 0 && arr[j] <= arr[i]; j-- {\\n\\t\\t}\\n\\n\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t}\\n\\n\\tfor k, m := i+1, n-1; k < m; k, m = k+1, m-1 {\\n\\t\\tarr[k], arr[m] = arr[m], arr[k]\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getMinSwaps(num string, k int) int {\\n    num1 := []byte(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextPermutation(num1)\\n\\t}\\n\\n\\tvar res, j int\\n\\tfor i := 0; i < len(num); i++ {\\n\\t\\tif num[i] != num1[i] {\\n\\t\\t\\tfor j = i + 1; num[i] != num1[j]; j++ {\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ; j != i; j-- {\\n\\t\\t\\t\\tnum1[j], num1[j-1] = num1[j-1], num1[j]\\n\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc nextPermutation(arr []byte) {\\n\\tn := len(arr)\\n\\ti := n - 2\\n\\tfor ; i >= 0 && arr[i] >= arr[i+1]; i-- {\\n\\t}\\n\\n\\tif i >= 0 {\\n\\t\\tj := n - 1\\n\\t\\tfor ; j >= 0 && arr[j] <= arr[i]; j-- {\\n\\t\\t}\\n\\n\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t}\\n\\n\\tfor k, m := i+1, n-1; k < m; k, m = k+1, m-1 {\\n\\t\\tarr[k], arr[m] = arr[m], arr[k]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191993,
                "title": "javascript-next-permutation-adjacent-swap-160ms",
                "content": "```\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    let finish = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        let cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (!finish[j] && a[j] == np[i]) {\\n                finish[j] = true;\\n                res += cnt;\\n                break;\\n            }\\n            if (!finish[j]) cnt++;\\n        }\\n    }\\n    return res;\\n};\\n\\n// Another version 148ms\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] == np[i]) continue;\\n        let j;\\n        for (j = i + 1; j < n && a[j] != np[i]; j++);\\n        for (let k = j; k > i; k--) {\\n            [a[k], a[k - 1]] = [a[k - 1], a[k]];\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n\\n//////////////////////////////////////////////////////////////////////////////////////\\nconst nextPermutation = (a) => {\\n    let n = a.length;\\n    let i, j;\\n    for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--);\\n    if (i == -1) return false;\\n    for (j = i + 1; j < n && a[i] < a[j]; j++);\\n    [a[i], a[j - 1]] = [a[j - 1], a[i]];\\n    for (let p = i + 1, q = n - 1; p < q; p++, q--)[a[p], a[q]] = [a[q], a[p]];\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    let finish = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        let cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (!finish[j] && a[j] == np[i]) {\\n                finish[j] = true;\\n                res += cnt;\\n                break;\\n            }\\n            if (!finish[j]) cnt++;\\n        }\\n    }\\n    return res;\\n};\\n\\n// Another version 148ms\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] == np[i]) continue;\\n        let j;\\n        for (j = i + 1; j < n && a[j] != np[i]; j++);\\n        for (let k = j; k > i; k--) {\\n            [a[k], a[k - 1]] = [a[k - 1], a[k]];\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n\\n//////////////////////////////////////////////////////////////////////////////////////\\nconst nextPermutation = (a) => {\\n    let n = a.length;\\n    let i, j;\\n    for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--);\\n    if (i == -1) return false;\\n    for (j = i + 1; j < n && a[i] < a[j]; j++);\\n    [a[i], a[j - 1]] = [a[j - 1], a[i]];\\n    for (let p = i + 1, q = n - 1; p < q; p++, q--)[a[p], a[q]] = [a[q], a[p]];\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191693,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        let numOriginal = num.map({ Int($0.asciiValue ?? 48) - 48 }), n = numOriginal.count\\n        var num = numOriginal, result = 0\\n        for i in 0..<k {\\n            nextPermutation(&num)\\n        }\\n        main: while true {\\n            for i in 0..<n where numOriginal[i] != num[i] {\\n                var j = i\\n                while num[j] != numOriginal[i] { j += 1 }\\n                num.remove(at: j)\\n                num.insert(numOriginal[i], at: i)\\n                result += j - i\\n                continue main\\n            }\\n            break\\n        }\\n        return result\\n    }\\n    func nextPermutation(_ nums: inout [Int]) { // https://leetcode.com/problems/next-permutation/\\n        let c = nums.count\\n        var i: Int = c - 1, j: Int = 0\\n        while i > 0 { // try to find ascending sequence\\n            if nums[i] > nums[i - 1] {\\n                break\\n            }\\n            i -= 1\\n        }\\n        if i > 0 { // ascending sequence exists, let\\'s find next greater number\\n            j = i\\n            while j < c {\\n                if nums[i - 1] >= nums[j] {\\n                    break\\n                }\\n                j += 1\\n            }\\n            nums.swapAt(i - 1, j - 1) // swap\\n        }\\n        j = i\\n        while j <= (i + (c - i) / 2 - 1) && nums[j] > nums[c - 1 - (j - i)] { // final sort (swap desc to asc)\\n            nums.swapAt(j, c - 1 - (j - i))\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        let numOriginal = num.map({ Int($0.asciiValue ?? 48) - 48 }), n = numOriginal.count\\n        var num = numOriginal, result = 0\\n        for i in 0..<k {\\n            nextPermutation(&num)\\n        }\\n        main: while true {\\n            for i in 0..<n where numOriginal[i] != num[i] {\\n                var j = i\\n                while num[j] != numOriginal[i] { j += 1 }\\n                num.remove(at: j)\\n                num.insert(numOriginal[i], at: i)\\n                result += j - i\\n                continue main\\n            }\\n            break\\n        }\\n        return result\\n    }\\n    func nextPermutation(_ nums: inout [Int]) { // https://leetcode.com/problems/next-permutation/\\n        let c = nums.count\\n        var i: Int = c - 1, j: Int = 0\\n        while i > 0 { // try to find ascending sequence\\n            if nums[i] > nums[i - 1] {\\n                break\\n            }\\n            i -= 1\\n        }\\n        if i > 0 { // ascending sequence exists, let\\'s find next greater number\\n            j = i\\n            while j < c {\\n                if nums[i - 1] >= nums[j] {\\n                    break\\n                }\\n                j += 1\\n            }\\n            nums.swapAt(i - 1, j - 1) // swap\\n        }\\n        j = i\\n        while j <= (i + (c - i) / 2 - 1) && nums[j] > nums[c - 1 - (j - i)] { // final sort (swap desc to asc)\\n            nums.swapAt(j, c - 1 - (j - i))\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576554,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            },
            {
                "id": 1919039,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            },
            {
                "id": 2007980,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            }
        ]
    }
]