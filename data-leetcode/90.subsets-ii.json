[
    {
        "title": "Subsets II",
        "question_content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 30168,
                "title": "c-solution-and-explanation",
                "content": "To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:\\nnum of subset\\n\\n -  (1        to 2^0) empty set is the first subset\\n -  (2^0+1 to 2^1) add the first element into subset from (1)\\n -  (2^1+1 to 2^2) add the second element into subset (1 to 2^1)\\n -  (2^2+1 to 2^3) add the third element into subset (1 to 2^2)\\n - ....\\n -  (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1))\\n\\nThen how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, ..., an) with each of them appearing (k1, k2, k3, ..., kn) times, the number of subset is (k1+1)*(k2+1)*...(kn+1). We can easily see how to write down all the subsets similar to the approach above.\\n\\n        class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}};\\n            sort(S.begin(),S.end());\\n            for(int i=0; i<S.size();){\\n                int count = 0; // num of elements are the same\\n                while(count + i<S.size() && S[count+i]==S[i])  count++;\\n                int previousN = totalset.size();\\n                for(int k=0; k<previousN; k++){\\n                    vector<int> instance = totalset[k];\\n                    for(int j=0; j<count; j++){\\n                        instance.push_back(S[i]);\\n                        totalset.push_back(instance);\\n                    }\\n                }\\n                i += count;\\n            }\\n            return totalset;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}",
                "codeTag": "Java"
            },
            {
                "id": 30164,
                "title": "accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand",
                "content": "**The characteristics of C++ reference is an outstanding tool for backtracking algorithm!**\\n\\nlet us use [1,2,3,4] as an example to explain my solution:\\n\\n    subsets([1,2,3,4]) = []\\n                         // push(1)\\n                         [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                         // pop(), push(2)\\n                         [2, subsets([3,4])]\\n                         // pop(), push(3)\\n                         [3, subsets([4])]\\n                         // pop(), push(4)\\n                         [4, subsets([])]\\n                         // pop()\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets ][1]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsets(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i) {\\n    \\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\tsubsets(res, nums, vec, i + 1);\\n    \\t\\t\\tvec.pop_back();\\n    \\t\\t}\\n    \\t}\\n    };\\n\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets II][2]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsetsWithDup(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsetsWithDup(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsetsWithDup(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i)\\n    \\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n    \\t\\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n    \\t\\t\\t\\tvec.pop_back();\\n    \\t\\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 169226,
                "title": "java-two-way-of-recursive-thinking",
                "content": "1) Each recursion level focuses on all the following elements. We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\\n2) Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388566,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30137,
                "title": "simple-iterative-solution",
                "content": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30166,
                "title": "simple-python-solution-without-extra-space",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "codeTag": "Java"
            },
            {
                "id": 1380237,
                "title": "c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bitmasking (with Hashing)**\\n- In a `nums` array of length `n`, there are total `2^n` possible subsets.\\n- The idea is that we use bitmasks of `n` bits to present the state of subsets, `mask` in `[0, 1, ... 2^n-1]`. If the `i`th bit in the `mask` is `1` means `nums[i]` exists in the subset presented by `mask`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- We need to hash the subset and add into a HashTable, let\\'s name `seen`, to check for duplicates.\\n\\n<iframe src=\"https://leetcode.com/playground/FqjVD8Dq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking version 1 (without Hashing)**\\n- We traverse the tree in PreOrder, starting with `index = 0`, for each `index`, we iterate elements from `nums[index]...nums[n-1]`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- If numbers are duplicates, we keep the first time, otherwise we skips. We can see it clearly through following picture.\\n\\n![image](https://assets.leetcode.com/users/images/f2fc14d2-fcf7-4d31-8844-0489a9b83281_1628047166.1461427.png)\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Backtracking version 2 (without Hasing)**\\n- For each elements of `nums`, there are 2 options: **pick** or **don\\'t pick** that number, so there is total **2^n** possible subsets.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t-  In don\\'t pick choice, we only call it if the last element in current subset different with  `nums[i]` otherwise duplicate occurs.\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 4: Iterative (with Hashing)**\\n- The idea is that we start with an empty subset.\\n- For each element `num` in `nums`, we iterate all all previous subsets, create new subsets by adding each previous subsets with `num`.\\n- For example: `nums = [1, 2, 3]`\\n\\t- First at all, `ans = [[]]`\\n\\t- Step 1, with `nums[0] = 1`, `ans = [[], [1]]`\\n\\t- Step 2, with `nums[1] = 2`, `ans = [[], [1], [2], [1, 2]]`\\n\\t- Step 3, with `nums[2] = 3`, `ans = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30305,
                "title": "simple-python-solution-dfs",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30156,
                "title": "subset-i-ii-and-perm-i-ii-difference-explained",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30150,
                "title": "very-simple-and-fast-java-solution",
                "content": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "codeTag": "Unknown"
            },
            {
                "id": 429537,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30158,
                "title": "standard-dfs-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }\\n        \\n        public void dfs(int[] nums,int index,List<Integer> path,List<List<Integer>> result){\\n            result.add(path);\\n            for(int i=index;i<nums.length;i++){\\n                if(i>index&&nums[i]==nums[i-1]) continue;\\n                List<Integer> nPath= new ArrayList<>(path);\\n                nPath.add(nums[i]);\\n                dfs(nums,i+1,nPath,result);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1380366,
                "title": "java-python-recursion-visualization",
                "content": "Constraints:\\n\\n**1 <= nums.length <= 10**\\n-10 <= nums[i] <= 10\\n\\nthe input size give us a clear hint that it is a backtracking solution, if there were no duplicates then it would easy problem to backtrack, the trick is to skip the duplicates **except the first time**.\\n**backTrack( index, currentList )** \\n\\nExample -> nums = [1,2,2,3]\\n\\n![image](https://assets.leetcode.com/users/images/faa81e48-fd2d-4cea-ba2c-6daa7d187343_1628014649.6702619.gif)\\n\\n\\nPython -\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\\n\\t\\t\\n\\n\\nJava version -\\n\\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/103350e1-7c5a-4cf1-836f-0af96d3c6359_1627981167.994198.png)\\n\\nPlease **upvote** if you find it **uselful**. Thanks.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1488442,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "Approach used- Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```\\nHope you found this useful :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30242,
                "title": "share-my-2ms-java-iteration-solution-very-simple-and-short",
                "content": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 750386,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30145,
                "title": "accepted-java-iterative-solution",
                "content": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1380191,
                "title": "c-simple-and-short-solution-without-recursion",
                "content": "**Explanation:**\\nFor each element in nums, we loop through all previous sets in res and create a new set by adding num to each one of them.\\n**Example:**\\nnum = [5, 6, 8]\\nWe start with one empty set. res = { {} }.\\nIteration 1: num = 5, res = { {}, {5} }.\\nIteration 2: num = 6, res = { {}, {5}, {6}, {5,6} }.\\nIteration 3: num = 8, res = { {}, {5}, {6}, {5,6}, {8}, {5,8}, {6,8}, {5,6,8} }.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095672,
                "title": "cpp-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30325,
                "title": "java-solution-using-bit-manipulation",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }else{\\n                            list.add(num[j]);\\n                        }\\n                    }\\n                }\\n                if(!illegal){\\n                   lists.add(list); \\n                }\\n                \\n            }\\n            return lists;\\n        }\\n    }\\n\\nThe idea is using every bit to represent one element in the set. The total number is 2 to num.length. Then we need to avoid duplicates. After we sort the array, the same number will be adjacent to each other. \\n\\nFor example the set is {1,1,1}. We can get subset {} and {1} first. That's great.\\nThen we need to pay attention. Suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate. \\nThat's why I write the predicate:\\nif(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n}\\n\\nHope someone can explain it better. I will go to gym now.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30270,
                "title": "share-my-5-lines-of-python-solution",
                "content": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 688517,
                "title": "python-very-very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362743,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209618,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380314,
                "title": "python-oneliner-with-product-explained",
                "content": "It is quite classical problem and in python we can use functionality of language to make it oneliner.\\nImagine, that we have case `[1, 1, 1, 2, 2, 3]`. Then what subsets we have? We cah take:\\n1. `[], [1], [1, 1], [1, 1, 1]` when we choose how many ones we take.\\n2. `[], [2], [2, 2]` when we choose how many twos we take.\\n3. `[], [3]` when we choose how many threes we take.\\n\\nOur answer is all options when we take one element from first line, one from second and one from third and concatenate them.\\nLet us look at `[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()]` in mor details: what we have is `A = [[[], [1], [1, 1], [1, 1, 1]], [[], [2], [2, 2]], [[], [3]]]`. Now, what we need to do is to use functionality of product: we want to take elements from `A[0]`, `A[1]` and `A[2]` and for this we use trick `[chain(*i) for i in product(*A)]`, where `*` used to let product know that we want to give each element `A[0], A[1], A[2]` as parameter of product: try to do `product([[1,2,3],[4,5]])` and `product(*[[1,2,3],[4,5]])` and see the difference. The same trick is used for chain.\\n\\n#### Complexity\\nNot very tight bound for time complexity is `O(2^n*n)`, where `n` is total number of elements, space complexity as well. In fact complexity (time and space) is `O((a1+1)*...*(ak+1)*n)`, where `a1, ..., ak` are frequencies of each element.\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30292,
                "title": "share-my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }\\n    private:\\n        void subsetsWithDupWorker(const vector<int>& nums, vector<vector<int>>& subsets, vector<int>& subset, int begin) {\\n            subsets.push_back(subset);\\n            for (int i = begin; i < nums.size(); i++) {\\n                if (i != begin && nums[i] == nums[i-1]) continue;\\n                subset.push_back(nums[i]);\\n                subsetsWithDupWorker(nums, subsets, subset, i+1);\\n                subset.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1303284,
                "title": "general-approach-to-backtracking-problems-in-c",
                "content": "Below I present a general approach to many standard backtracking problems. A similar version exists for JAVA [here](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) but I thought it would be a good idea to do the same for C++ as well, even though  the essence of the solutions remains the same. Most of these problems follow a single template as given below. \\n\\n```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\\n\\n\\n**1**.[78. Subsets](https://leetcode.com/problems/subsets/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**2**.[90. Subsets II](https://leetcode.com/problems/subsets-ii/) (Subsets with duplicates)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**3.** [77. Combinations](https://leetcode.com/problems/combinations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\\n\\n**4.** [39. Combination Sum\\n](https://leetcode.com/problems/combination-sum/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\\n\\n**5.** [40. Combination Sum II\\n](https://leetcode.com/problems/combination-sum-ii/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\\n\\n**6.**  [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\\n\\n**7.** [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**8.** [46. Permutations](https://leetcode.com/problems/permutations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250020,
                "title": "c-recursive-and-iterative",
                "content": "To skip duplicates, sort `nums`.\\n\\n**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30304,
                "title": "48ms-solution-with-subset-construction-method",
                "content": "One possible solution is to generate all possible subset using bit-mask, and use a set to test the existence of a subset. However, this method may generate duplicate subsets during the process, and has unsatisfiable time complexity. E.g. for input <1 1 1 1 1 1 1 1 1>, the above method will generate too many duplicate subsets.\\n\\nI use a subset construction method, whose mechanism is illustrated with an example:\\n\\ninput: <1 2 2 3 3 3> (assumed to be sorted)\\n\\ninitialization: empty set <>. ret = {<>}\\n\\nfor element 1, add it to ret, and we get: <1>. ret = {<> <1>}\\n\\nfor element 2, add it to ret, and we get: <2> <1 2>; however, notice that we have two elements of 2, hence we further need to add <2 2> to {<> <1>}, and get <2 2> <1 2 2>. ret = {<> <1> <2> <1 2> <2 2> <1 2 2>}\\n\\nfor element 3, we newly construct the following:              \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>             \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>             \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>                 \\nfinally, ret = {<> <1> <2> <1 2> <2 2> <1 2 2>   \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>   \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>   \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>\\n}\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }\\n                }\\n                i = j;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2697523,
                "title": "c-clean-code-subset-ii-brute-force-and-optimized",
                "content": "**1. Brute Force : Generate all subsets (Subset-II)** \\n\\n**Time Complexity :** **`O(2^n*( klog(x) )).2^n`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. More Optimized - (Subset-II)**  \\n\\n**Time Complexity :** **`O(k * 2^n)`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921938,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549662,
                "title": "java-tc-o-n-2-n-sc-o-uniquenums-space-optimized-iterative-backtracking-solutions",
                "content": "**Space Optimized Iterative Solution. This solution takes only O(Unique Nums) for countMap**\\n\\n```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N + Unique Nums) space for recursion depth, temp list and countMap**\\n\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [78. Subsets](https://leetcode.com/problems/subsets/discuss/1549657/Java-or-TC:-O(N*2N)-or-SC:-O(1)-or-Constant-Space-Iterative-and-Backtracking-solutions)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380213,
                "title": "subset-ii-2-approaches-backtracking-iterative-c-java-python",
                "content": "**THIS PROBLEM IS VERY SIMILAR TO [THIS PROBLEM](https://leetcode.com/problems/subsets/)**\\n**NOW COMING TO THE PROBLEM AT HAND**\\n**OBSERVATION TO BE MADE:**\\n* If there are no duplicates the answer is directly `2^N`\\n\\t* This is because you have two choices for each element, either putting it into the subset or not.\\n\\n# **APPORACH I: Iterative**\\n**Algorithm:**\\nSuppose we have {1,2,3,3,3}\\nNow after each iteration our 2-d vector becomes like this-\\n```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\\nIf the number is a duplicate one, we just need to add this number to the last created subsets in the previous step.\\n\\n`In C++`\\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\\n`In Python`\\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\\n**TIME COMPLEXITY: O(N)**\\n\\n# **APPROACH II: Backtracking**\\nThe characteristics of C++ reference is an outstanding tool for backtracking algorithm!\\n**Algorithm:**\\nLet us use [1,2,3,4] as an example to explain my solution:\\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```\\n**TIME COMPLEXITY: O(2^N)**\\n",
                "solutionTags": [],
                "code": "```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085695,
                "title": "same-code-with-tweaking-solved-2-problems-easy-to-understand",
                "content": "# CHECK THE RECURSION TREE BELOW FOR BETTER UNDERSTANDING .\\n\\n**SIMILAR QUESTION LINK WITH SOLUTION **\\nhttps://leetcode.com/problems/non-decreasing-subsequences/description/\\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3085690/same-code-with-tweaking-solved-2-problems-easy-to-understand/\\n\\n# Intuition\\nSame code is used in solving Non decreasing Subsequence question .\\n\\n# Approach\\nWe are sorting given array. And find all subsequence it can can make ,along with the check that subset should not be repeated .\\ni.e.\\n if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```\\n\\n## ![image.png](https://assets.leetcode.com/users/images/b241b88c-e53b-42d2-9fb5-4e111c7e7d27_1674383113.75447.png)\\n\\n\\n#UPVOTE IF YOU LIKED THE EFFORT\\nTHANK YOU\\nCODE BY :) AMAN MAURYA\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953370,
                "title": "fully-explained-c-solution-with-example-time-space-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n>  \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & Backtracking.***\\n- Here we\\u2019ll first sort the array and for every index, we\\u2019ll try to push elements in such a way that it doesn\\u2019t contain any duplicates.\\n- In every function call, we\\u2019ll push our temp to ans vector. For the first call, it will push an empty subset.\\n- Now we will iterate from index to n-1 & try to pick & not pick an element.\\n- To avoid duplicates if we have already picked an element for the current index of temp with the same value as the index of the given array then we\\u2019ll continue.\\n- After every call we\\u2019ll pop our current element.\\n- Let\\'s explain this with an example:\\n    \\n    ```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\\n    \\n- **Time complexity:** O(2^n * n).\\n- **Space complexity:** O(2^n * k).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984188,
                "title": "java-simple-recursion",
                "content": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647010,
                "title": "javascript-backtrack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30334,
                "title": "share-simple-recursive-java-solution",
                "content": "my method is simple, try to output all combination of the list and skip the same integer.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }\\n    private static void Rec(int[] a,List<List<Integer>> result, LinkedList<Integer> temp, int current){\\n        result.add(new LinkedList(temp));\\n        for(int i=current;i<a.length;i++){\\n            if(i==current || a[i]!=a[i-1]){\\n                temp.add(a[i]);\\n                Rec(a,result,temp,i+1);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n        return;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2626736,
                "title": "complete-walkthrough-with-pictures-working-explained-behind-the-approach",
                "content": "**Don\\'t have time to read at all. Read only conclusion part, guaranteed you\\'ll be able to write the code by yourself**\\n\\n```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\\n\\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\\n\\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044127,
                "title": "c-solution-easy-to-understand-beats-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```\\n\\n**Happy coding**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690114,
                "title": "python-backtracking-solution",
                "content": "Using sorting and comparison to prevent duplicates. \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```\\nRuntime: 32 ms, faster than 92.15% of Python3 online submissions for Subsets II.\\nMemory Usage: 13.9 MB, less than 84.06% of Python3 online submissions for Subsets II.\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630505,
                "title": "no-for-loop-more-intuitive",
                "content": "I noticed the for-loop is used for all the backtracing questions. It is fine. However, it\\'s more intuitive if each recursion focuses on itself - choose or not choose.\\n\\nThe non for-loop is a general solution if you don\\'t need to leap and inspect all other elements in the dataset.\\n\\nUse this question as example. Here\\'s the code:\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```\\n\\nUpdated on 08/16/2021: another example we can apply choose or not choose\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1407822/No-for-loop.-More-intuitive.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267930,
                "title": "python-4-line-beats-99-42",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229447,
                "title": "python-backtracking-general-approach-beats-100",
                "content": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```\\n\\t\\nSimilar approach can be applied to the below and other problems:\\n\\n* https://leetcode.com/problems/subsets/\\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/combinations/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [],
                "code": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30286,
                "title": "recursion-and-non-recursion-java-solution-for-your-reference",
                "content": "Two solution, recursion and non-recursion:\\n\\nRecursion solution:\\n\\n    public class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }\\n                return;\\n            }\\n            l.add(nums[p]);\\n            search(l, p+1);\\n            l.remove(l.size()-1);\\n            search(l, p+1);\\n        }\\n        \\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            this.n = nums.length; this.nums = nums;\\n            Arrays.sort(nums);\\n            search(new ArrayList<Integer>(), 0);\\n            return res;\\n        }\\n    }\\n\\nNon-recursion solution:\\n\\n    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> temp = new ArrayList<>();\\n            res.add(temp);\\n            Arrays.sort(nums);\\n            int l = 0, k;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i == 0 || nums[i] != nums[i-1])\\n                    l = res.size();\\n                k = res.size();\\n                for (int j = k-l; j < k; j++) {\\n                    temp = new ArrayList<>(res.get(j));\\n                    temp.add(nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30315,
                "title": "c-ac-regular-backtracking-solution-for-both-subsets-i-and-ii",
                "content": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2772818,
                "title": "subsets-ii-java-solution-2-lines-added-in-subsets-i-problem",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882468,
                "title": "simple-java-solution-based-on-backtracking-with-comments-1ms",
                "content": "**Approach:**\\nThis is a classic backtracking problem is solved using the recommened template of\\n- make a choice\\n- backtrack\\n- undo your choice\\n\\n**Caveats:**\\nThe choice to sort the array introduces `O(n log n)` complexity but the worst-case complexity for generating the subsets is already `O(2^n)`.\\nThis allows us to use sorting without any impact on overall time complexity of the solution.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171626,
                "title": "python-solution",
                "content": "Use a dictionary to keep track of the number of appearances of each number. One can then easily construct the power set of `nums` based on this dictionary.\\n\\nE.g., `nums = [1,1,2,2,2,4,4,5]`. In this case `dic = {1:2, 2:3, 4:2, 5:1}`. We intialize `res = [[]]`, and build the solution iteratively as we loop over the dictionary. We first reach `key, val = 1, 2`. The power set of `[1,1]` is `res = [[], [1], [1,1]]`. Then we reach `key, val = 2, 3`. The power set of `[1,1,2,2,2]` is obtained by appending either `0`, `1`, `2`, or `3` 2\\'s to all elements in `res`. After which we get `res = [[], [1], [1,1], [2], [1,2], [1,1,2],[2,2], [1,2,2], [1,1,2,2],[2,2,2], [1,2,2,2], [1,1,2,2,2]]`. After we loop over `dic`, `res` will be the power set of `nums`.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\\n\\nSame idea, with a backtracking algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30196,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513086,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728917,
                "title": "java-easy-to-understand-same-logic-of-subsets-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662559,
                "title": "java-solution-and-explanation-with-time-and-space-complexity",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }\\n    \\n    public void findUniqueSubSets(int ind, int[] nums, ArrayList<Integer> ds, ArrayList<List<Integer>> ansList)\\n    {\\n        //initially we add an empty list to our ansList \\n        //to generate an empty list like this -> [] \\n        ansList.add(new ArrayList<Integer>(ds));\\n        \\n        //start chking from 0th to n-1th index. using for loop\\n        for(int i = ind; i< nums.length; i++)\\n        {\\n            //chk for duplicates if any just avoid them\\n            if( i != ind && nums[i] == nums[i-1]) continue;\\n            //i != ind . ind is the first index always for which we are chking \\n            //so if i is not ind then we are not visiting that element \\n            //for the first time and might be and that might be a duplicate \\n            //which we again chk using nums[i] == nums[i-1]\\n            \\n            //if we came across this if condition that only means that we are at an element \\n            //which is not a duplicate \\n            //so we have to add it to our arryalist ds\\n            ds.add(nums[i]);\\n            \\n            //again call recursion for the next index\\n            findUniqueSubSets(i+1, nums, ds, ansList);\\n            \\n            //while returning make sure to remove the element we added because \\n            //we wouldn\\'t want that to be present for the next recursion call\\n            ds.remove(ds.size() -1);\\n                \\n        }\\n    }\\n    \\n    }\\n    \\nTime Complexity: O(k * 2^n) -> O(2^n) for generating every subset + O(k) to insert every subset in another data structure. assuming average length of each subset is near about K.\\n\\nSpace Complexity: O(2^n * k) to store every subset and the Auxiliary space is O(n) if n is the depth of the recursion tree.\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1380340,
                "title": "c-standard-backtracking-template",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217790,
                "title": "simple-c-solution-with-explanation-easiest-way-to-remove-duplicates-not-using-sets",
                "content": "To get all the subsets, for each element in the array, we have 2 choices \\nEither include it in subset or not.\\nJust need to improve on that approach to **remove duplicates**, which can be done easily by just making sure that if the last element in our present subset is equal to our present element, then you have to surely include present element in the subset , i.e, dont skip the present element.\\nThe subset which will form if we don\\'t include the present element will lead to duplicacy.\\nBasically :\\n```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\\n###  C++ code \\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```\\nps:- try to make the recursion tree for an example test case ( [1,2,2] ) to understand it better.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726404,
                "title": "java-backtracking-easy-to-understand-explanation",
                "content": "\\n```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```\\nIf you can follow the Numbers and the arrows you will get the idea \\nif you didn\\'t understand any point let me know and will try to explain it again\\n\\n![image](https://assets.leetcode.com/users/images/d81b304b-f002-4049-a57b-d0513f8f714b_1594493500.5942798.png)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124257,
                "title": "javascript-68-ms-98-88",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30146,
                "title": "c-subsets-and-subsets-ii-almost-same-recursive-method",
                "content": "Subset\\n```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\\nSubset 2\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30202,
                "title": "c-6ms-dp-clean-code-explanation",
                "content": "C++, 6ms: DP, Simple & Clean Code\\n**Time:** O(n*2^n)\\n**Space:** O(2^n)\\n\\n**Solution:**\\n```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\\n\\n**Explanation:**\\n\\nI will first show you how the algorithm works with an input array containing no duplication.\\n\\nFor example, Input: `[1, 2, 3]`\\n\\nWe first add the empty set to the result.\\nThen, for each number in the input, we will concatenate the current number with all the previous results to generate a new set. \\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\nThen, ` { [ ], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] } ` is our answer.\\n\\nNow, let's take a look at an example with duplication.\\nFor example, Input: `[1, 2, 2]`\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\\n\\nYou can observe that the first 2 sets generated in the 4th round are duplication of 3rd round's sets.\\nTo fix this problem, we will need to remember how many items were added to our solution which was 2.\\nThen, we can avoid using [ ], [1] which were used in the 3rd round to generate those 2 sets.\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\\n\\nNow, you should be able to understand this part of the code.\\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```\\nDon't forget to sort the input array first, otherwise `nums[i] != nums[i-1]` comparison just does not make sense.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742710,
                "title": "python3-simple-recursive-solution",
                "content": "# Intuition\\nThe intuition behind the code is to use a recursive approach to generate subsets. At each step, we have two choices: either include the current element in the subset or exclude it. By making these choices for each element in the array, we can generate all possible subsets.\\n\\n# Approach\\n**Sort the array nums** \\nSorting the array ensures that duplicate elements will appear next to each other, making it easier to handle them later in the code.\\n\\n**Create the recursive function subsets** \\nThis function takes two parameters: index (the current index being considered) and elements (the current subset being constructed).\\n\\n**Handle base case** \\nIf the current index reaches the length of the array (index == len(nums)), it means we have processed all elements. At this point, we check if the elements subset is already present in the res list. If not, we append it to res. This check is necessary to avoid duplicate subsets.\\n\\n**Make recursive calls**\\n**Not Pick**\\nCall subsets recursively with the next index without picking the current element (subsets(index + 1, elements)). This represents the choice of excluding the current element from the subset.\\n**Pick**\\nCall subsets recursively with the next index, including the current element (subsets(index + 1, elements + [nums[index]])). This represents the choice of picking the current element and adding it to the subset.\\n\\n**Duplicate Check**\\nThe code avoids duplicates by checking if a subset already exists in the res list before appending it. We sort the input array in the start to ensure that duplicate elements will be adjacent, simplifying the duplicate check.\\n\\nNow, we call the subsets function initially with index = 0 and an empty elements list.\\n\\nFinally, we return the final res list containing all the generated subsets.\\n\\n# Complexity\\n- Time complexity: **O(2^n)** \\n\\n- Space complexity: **O(2^n)** \\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596532,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070879,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506092,
                "title": "java-concise-4-solutions-0-ms-100-beats",
                "content": "**1. Regular recursion**\\n```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n**2. Optimized recursion**\\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\\n3. **Using Bit mask for set generation. Using sort (with hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\\n4. **Using Bit mask for set generation. Using sort (without hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380488,
                "title": "c-easy-clean-solution-using-vector-set-and-multiset",
                "content": "**Solution:**\\n\\n1. Consider every subsequence as a collection of `bits`.\\n2. 0, 1, 10, 11, 100, 101, 110, 111, and so on.\\n3. We can observe that every `set bit(1)` indicates that we must include that particular element present in the array `nums` and every `unset bit(0)` indicates we must ignore that element.\\n4. Check for every number which particular bit is set or unset using `i & (1 << j)`. This formula helps us to know whether to include a particular element or not.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859563,
                "title": "python-sort-bfs-approach-without-additional-space",
                "content": "Hello,\\n\\nThis solution is similar to the subset I problem solution. The explaination is below.\\n\\n\\n```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```\\n\\n1- Intuition:\\n- Subset problem (without duplicates):\\n\\t- Let\\'s have the following input: [1,2,3] and let\\'s `combinations` be our output\\n\\t- We\\'ll start with `combinations = [[]]`\\n\\t- For each value `n` in `nums`, merge it with every existing `combination` and append it to the output list\\n\\t- For `n: 1`:  append( `[] + [1]`)  into `combinations = [[], [1]]`\\n\\t- For `n: 2`:  append( `[] + [2]`, `[1] + [2]`)  into `combinations = [[], [1], [2], [1,2]]`\\n\\t- For `n: 3`:  append( `[] + [3]`, `[1] + [3]`, `[2] + [3]`, `[1,2] + [3]` )  into `combinations = [[], [1], [2], [1,2], [1,2,3]]`\\n\\n- Subset II problem (with duplicates):\\n\\t- It\\'s the same solution as the solution above. We just need to:\\n\\t\\t- (1). Identify duplicates => Sort `nums`\\n\\t\\t- (2). We need to avoid looping on all combinations when dealing with a duplicate. \\n\\t\\t- We need to start from a specific position of the list `combinations`\\n\\t- Let\\'s have the following input: [1,2,2,3,3] and suppose that it\\'s already sorted\\n\\t- For the `1st. n: 2`:  `combinations = [[], [1], [2], [1,2]]`\\n\\t- For the `2nd. n: 2`:  \\n\\t\\t- We need to avoid the existing combinations `[] + [2]`, `[1] + [2]` \\n\\t\\t- We need to consider only `[2] + [2]` and `[1,2] + [2]`\\n\\t\\t- In other words, we need to start from the combinations appended by previous `n: 2` \\n\\t\\t- `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2]]`\\n\\t- For the `1st. n: 3`:  `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2], [3], [1,3], [2,3], [1,2,3], [2,2,3],[1,2,2,3]]`\\n\\t- For the `2nd. n:3`\\n\\t\\t- We need to start from the combinations appended by previous `n: 3`: position: 6\\n\\t\\t- We\\'ll then append: `[3] + [3], [1,3] + [3] , ...,  [1,2,2,3] + [3]`\\n\\n2- Complexity Analysis:\\n- Let\\'s `n` be the number of values in `nums`\\n- Time Complexity: `O(n * 2^n)`\\n\\t\\t- The output `combinations` doubles for every value in `nums`: `O(2^n)` combinations (including duplicates)\\n\\t\\t- Every combination is created from merging a previous combination with a value: T(merge): `O(n)`\\n- Space Complexity: `O(n * 2^n)` (same as above)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377184,
                "title": "easy-peasy-python-comments-best-iterative-solution",
                "content": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 30322,
                "title": "my-solution-using-bit-masks",
                "content": "Here is my solution using bit masks.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }\\n            }\\n            if(!solution.contains(subset))\\n                solution.add(subset);\\n        }\\n        \\n        return solution;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3683856,
                "title": "c-well-commented-backtracking-faster-than-100-c-submissions",
                "content": "# Complexity\\n- Time complexity: $$O(2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631632,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361683,
                "title": "easy-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346713,
                "title": "easy-to-understand-efficient-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we need to make subsets so for each element \"Pick\" and \"Not Pick\" decision needs to be taken. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Subset I. \\n\\n- Just when we are about to not pick an element we need to not pick all the similar elements and increase the index \\'i\\'.\\n\\nAnd this job is done by the following code block -->\\n```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(2^n)*\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n*O(n^2)*\\n\\nMy Subset I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/subsets/solutions/3342538/100-beats-used-backtracking-efficient-c-code/\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217062,
                "title": "easy-c-solution-with-loop-and-backtracking-o-n-unique",
                "content": "# INTUITION \\nAs we have solved the question of finding subsets, here we will use similar approach to find the subsets for this question. make an array of all subsets and then **remove duplicates using inbuilt functions**\\n# APPROACH\\n1.  We are using here recursive technique. so firstly declare two vector ... one for answer and other as auxillary one.\\n2.  make a recursive function **solve** which will give all subsets recursively \\n3. **parameters for solve function** - answer vector, output vector, input vector and index for traversing.\\n4. HERE, we will play exclude and include game, in excluding step, just increase the index by 1.\\n5. for include, first we extract the elements from input vector and insert in the output vector ......and then make a recursive call.\\n6. when the **base case(index>= nums.size())** is reached, insert the output vector in answer vector and return.\\n\\n# COMPLEXITY\\n**TIME COMPLEXITY**-  overall is O(N)\\n**SPACE COMPLEXITY**- O(N)\\n```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654821,
                "title": "c-backtracking-set-3ms",
                "content": "**Runtime:** 3 ms, faster than 73.08% of C++ online submissions for Subsets II.\\n**Memory Usage:** 7.8 MB, less than 54.76% of C++ online submissions for Subsets II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487304,
                "title": "aditya-verma-s-approach-simple-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        \\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        \\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<int>op;\\n        \\n        solve(nums, op);\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433693,
                "title": "java-backtracking-easy",
                "content": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333174,
                "title": "c-simple-and-short-solution-no-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242864,
                "title": "recursion-using-aditya-verma-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087030,
                "title": "python-easy-to-understand-list-solution-by-changing-start-end-indexes",
                "content": "Consider the example [1, 5, 3, 3]\\n\\n1. Sort nums to place duplicates next to each other [1, 3, 3, 5]\\n2. Start with an empty set: [[]]\\n3. Add the first number (1) to all the existing subsets to create new subsets: [[], [1]];\\n4. Add the second number (3) to all the existing subsets: [[], [1], [3], [1,3]].\\n5. The next number (3) is a duplicate. If we add it to all existing subsets we will get:\\n    [[], [1], [3], [1,3], [3], [1,3], [3,3], [1,3,3]]\\n6. To handle this instead of adding (3) to all the existing subsets, we only add it to the new subsets which were created in the previous (4th) step ([3],[1,3]):\\n    [[], [1], [3], [1,3], [3,3], [1,3,3]]\\n\\t\\n7. Finally, add the forth number (5) to all the existing subsets: [[], [1], [3], [1,3], [3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]]\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```\\n\\nTime Complexity: O(N * 2^N) [Number of subsets double at each step for every element N (if not duplicate)]\\nSpace Complexity: O(N * 2^N) [O(2^N) subsets taking O(N) space]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852051,
                "title": "almost-same-code-as-subset-i-problem-simple-recursive-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Alternate method--**\\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773502,
                "title": "java-solution-recursion-beats-100",
                "content": "Here, I have used a recursive approach where we pick the first occurrence of every unique element in every recursive call.\\n\\nApproach:\\nBrute force: Follow a general subsequence pattern using recursion and add every subsequence to the final ArrayList. Then convert the ArrayList to a HashSet and again convert it back to an ArrayList. This process takes extra time while converting the ArrayList to a HashSet and then back to an ArrayList.\\n\\nWe can avoid these extra conversions while doing the subsequence recursion.\\n\\nOptimized approach: Initially, sort the array because we need all duplicate elements consecutively. Start the recursion and add the list to the \"ans\" (final ArrayList). Run a for loop because we need to go through every possibility of a subsequence from the current element to the end of the array.\\n\\nIf (i != ind && arr[i] == arr[i-1]), continue;\\n\\nThis condition is used to check if the current element is a duplicate or the first occurrence. If it is a duplicate, we continue the loop without adding it to the list. Otherwise, we add it to the list and make further recursive calls for other elements. Make sure to remove the last element of the list while backtracking to reconstruct the previous list.\\n\\nTime complexity: O(2^n * n)\\n- 2^n is the worst case of the number of subsequences formed. This occurs when all elements are unique.\\n- n is for adding the list to \"ans.\\n\\nSpace complexity : O(2^n * k)\\n\\n- 2^n is number of sub ArrayLists(list) in the final ArrayLists(ans)\\n- k is average size of sub ArrayList(list) \\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697570,
                "title": "same-approches-as-subset-i-with-brute-force-and-backtracking",
                "content": "# 1. Subset 1 Approach-->TC:[2^N*N]\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\\n# 1. Backtracking--->TC:Log(2^N)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\\n# 2. Backtracking Concept:TC:[N*log(N)+log(2^N)]\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\\n# 2. Same Approach as Subset I-->TC:[N^2X2^N*LogN] Heavy brute force but it works \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696610,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677317,
                "title": "c-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137672,
                "title": "c-easy-solution-recursion-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851465,
                "title": "java-simple-java-solution-without-any-for-while-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424966,
                "title": "easy-c-solution-using-backtracking-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328340,
                "title": "c-solution-recursion-backtracking",
                "content": "**Code is availible in comment**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2237485,
                "title": "c-easy-solution-using-backtracking",
                "content": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n            v.push_back(arr[i]); // take the number\\n        subset(arr,N,i+1);\\n        v.pop_back();\\n        while(i+1<N and arr[i]==arr[i+1]) i+=1; // to not include the same element as we have already taken \\n        subset(arr,N,i+1);//not take the number\\n        \\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n         int N = arr.size();\\n        sort(arr.begin(),arr.end()); // to get same value continously\\n        subset(arr,N,0);\\n        return ans;\\n    }\\n    };\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1883021,
                "title": "c-bitwise-shift-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }\\n            }\\n            sort(vc.begin(), vc.end());\\n            if (st.count(vc) == 0) {\\n                res.push_back(vc);\\n                st.insert(vc);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1743898,
                "title": "accepted-7ms-c-solution-basic-concept",
                "content": "The basic concept is that if a number occurs x times, then we have x+1 alternatives, i.e., include it 0 times, 1 times, 2 times, ..... or x times. For eg. x=1 ,then we have two options either leave it (0 times)  or include it (1 times).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557834,
                "title": "not-the-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485015,
                "title": "c-backtracking-bit-manipulation-two-solution",
                "content": "**BACKTRACKING**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**BIT MANIPULATION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381390,
                "title": "c-solution-recursion-aditya-verma-s-subset-video",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380224,
                "title": "python3-4-line-solution-faster-than-92-03-of-python3-online-submissions",
                "content": "Using Python, the solution can be written in 4 lines.\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```\\nRuntime: 32 ms, faster than 92.03% of Python3 online submissions for Subsets II.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359678,
                "title": "without-sorting-very-simple-backtracking-solution",
                "content": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```\\nIdea:\\n1. In every btrack() call, we explore 2 choices for inp[0] which are: adding it to \"out\" and not adding it \"out\".\\n2. But if inp[0] already has atleast one occurence in \"out\", then *We must make only one choice i.e., adding it to out*  (This is an observation)\\n\\nPlease comment if you have any doubt and upvote if you found this solution as helpful.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140408,
                "title": "clear-and-simple-explanation-with-intuition",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Subsets](https://leetcode.com/problems/subsets/) problem and I already explained that in detail [here](https://leetcode.com/problems/subsets/discuss/1140388/Clear-and-simple-explanation-with-example-:-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n**Concept:** Since we have to avoid the duplicates , hence we are going to use **set** data structure here. \\n\\nBut that alone wont be enough, cause the *set* can\\'t distinguish between elements if they are in different order.\\nFor instance: `[1,2,3]  !=[3,2,1]` as per the needs of our question, but the *set* can\\'t distinguish between that, so we need a way to maintain the relatibve order of elements to be same for every same combination ....\\n\\n**Thats right, the correct answer is sorting.** Sorting will maintain the oder of elements and then we can use the set to eliminate the duplicates.\\n\\nAnd thats it!!! Keeping this in mind here is the code: \\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939135,
                "title": "c-0ms-clean-concise-code-beats-100-time-12-lines",
                "content": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774097,
                "title": "python-solution-recursive-explanation",
                "content": "How Subsets II is different from Subset I codewise?\\n\\nExplanation:\\nThere are two important cases that helps us understand the solution.\\n\\nCase 1: Checking the use of sort() function.\\n```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\nIf the nums array is not sorted the output results into:\\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\\n\\nRecursive operation explanation step-by-step:\\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\\n\\n\\n\\n\\n\\nCase 2: Recursive function explanation for the condition (if i > 0 and nums[i] == nums[i-1]) \\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\\n\\n\\n\\nBelow is the solution: \\nTotal Runtime is 32 ms.\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```\\n\\n===============================================\\nPlease let me know if you have issues in understanding any part of the solution.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501730,
                "title": "javascript-solution-easy-two-pointers",
                "content": "### The idea\\n1. Sort input `nums`\\n2. Use `prevIndex` to mark the start position of subsets to take considered of\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308274,
                "title": "java-1ms-simple-solution",
                "content": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110975,
                "title": "golang-simple-sort-backtrack-solution",
                "content": "Simply sort and if the same number appears skip it while iterating and backtracking.\\n\\n```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30159,
                "title": "subsets-vs-subsets-ii-add-only-3-more-lines-to-subsets-solution",
                "content": "The solution of subset II could be easily derived from the answer of subset I. \\n\\nHere is my answer of subset I: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n\\nIn this problem, we need to change two things: \\n1. Sort the input nums, so that we won't get lists such as [1,4] and [4, 1] at the same time. \\n2. Check duplicates when adding new list to res. \\nHere is Subset II solution based on subset I solution: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900796,
                "title": "retarded-way-to-solve-this-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Generate all subsets, sort each subset to handle duplicates, use custom hash as key in a map to store and filter unique subsets.\\n\\n\\n# Complexity\\n- Time complexity:2^n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759029,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![download.png](https://assets.leetcode.com/users/images/bd5ee898-f275-4f33-b89f-c1c960bbe6ec_1689245864.4761305.png)\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE \\u2B06\\uFE0F\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608983,
                "title": "best-recursive-approach-no-sets-94-time-beats-80-space-beats",
                "content": "# Intuition\\n**My main goal was to not using sets and i found a solution. Best solution that i saw here.**\\n# Approach\\n1. It starts by initializing the result array with an empty subset [] as the first element. This will be the starting point for building other subsets.\\n2. The nums array is sorted in non-decreasing order using the sorted() method. Sorting the array is important to handle duplicates effectively.\\n3. A loop is iterated over the indices of nums from 0 to nums.count - 1. For each index num, the following steps are performed:\\nIf num is 0 or the current number nums[num] is different from the previous number nums[num - 1], indicating a new element or a distinct occurrence of a duplicate element, the following actions are taken:\\n- A new subset subset is created with the current number nums[num].\\n- The new subset subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find all subsets considering the current subset and the remaining elements starting from num.\\n4. The findingAllSubsets function takes the nums array, the result array, the current subset, and the current index as input parameters.\\n5. Inside the findingAllSubsets function:\\n- If the current index is equal to or greater than nums.count - 1, indicating that there are no more elements remaining, the function returns.\\n- The variable nextIndex is set to the current index plus 1.\\n- A while loop is used to increment nextIndex while it is within bounds and the next number at nums[nextIndex + 1] is equal to the current number at nums[nextIndex]. This handles consecutive duplicates and ensures that all occurrences of duplicates are considered only once.\\n- The findingAllSubsets function is called recursively to find subsets starting from the updated nextIndex.\\n- A new subset is created by appending the next number in nums (at index + 1) to the current subset.\\n- The new subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find subsets starting from the current index plus 1.\\n6. Finally, the result array, containing all the subsets, is returned.\\n\\n# Complexity\\n- Time complexity O(2^N):\\nThe time complexity of this code is O(2^N), where N is the number of elements in the input array \"nums\". This is because the code generates all possible subsets, and the number of subsets grows exponentially with the input size. For each element in the input array, the code generates two subsets: one that includes the element and one that doesn\\'t. Hence, the overall time complexity is exponential.\\n\\n\\n- Space complexity O(2^N):\\nThe space complexity of this code is O(2^N), which is the same as the time complexity. This is because the code generates all possible subsets and stores them in the \"result\" array. The number of subsets is exponential, and therefore the space required to store them also grows exponentially. Additionally, there are other variables and recursive function calls that contribute to the space complexity, but their impact is relatively small compared to the subsets.\\n\\n\\n# Uncommented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\n\\n# Commented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\nIf you liked this solution, then do not forget to rate it please \\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605755,
                "title": "java-easy-solution-with-comments",
                "content": "# Intuition\\n Idea: Here in this Question, the question is given that, the nums may contain duplicates so we have to skip duplicates. For skipping the duplicates, we have to sort the nums array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n + n * 2^n)$$ \\n\\n- Space complexity:\\n$$OO(2^n + n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290882,
                "title": "java-recursion-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162453,
                "title": "python-clean-backtracking-with-sets",
                "content": "# Intuition\\nAny time I am trying to find permutations using items from a set, I first try to determine whether I can use backtracking. It turns out this works fine in this case, since we know the input array size is 10 or less.\\n\\n# Approach\\nIn order to avoid duplicates, we should first sort the array of nums. Then we can be sure that our subsets will always occur in non-decreasing order. Here we perform backtracking, but since we are looking for all possible subsets, we don\\'t need to do any checks before adding our interim results to the output. At each step, we take our current subset and go through the remaining elements in the array and perform backtracking with the subset plus that element. We store the results in a set in order to avoid duplication.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^N * N)$$\\n\\n- Space complexity:\\n$$O(2^N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062151,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847966,
                "title": "100-submission-with-0ms-time-c-solution-of-simple-recursion-and-backtracing",
                "content": "Time complexity: O(2^n)\\nspace complexity: O(N)\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }\\n\\t\\t\\t}   \\n\\t\\t}\\n   \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); // sorting is must as our loop is checking only adjacent elements in the vector\\n        vector<int> x;\\n        solve(x,0,nums);\\n        return ans;\\n        }\\n    };\\n\\n\\n\\n\\nDO UPVOTE IF HELPED AND FEEDBACK PURELY WELLCOMED :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2768249,
                "title": "0ms-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713874,
                "title": "subsets-ll",
                "content": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664469,
                "title": "9ms-c-space-98-beats-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238100,
                "title": "subsets-ii-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210692,
                "title": "python-set-soooooo-easyyyyyyy",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2178266,
                "title": "my-simple-recursive-solution-using-set-for-handling-duplicates",
                "content": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2135519,
                "title": "c-solution-simple-recursive-backtracking",
                "content": "```\\n\\n```class Solution {\\npublic:\\n   void help(int i,vector<int> &nums,vector<int> &subset,vector<vector<int>> &ans){\\n       int n = nums.size();\\n       //Base condition\\n       if(i == n){\\n           ans.push_back(subset);\\n           return;\\n       }else{\\n           //Including ith element\\n           subset.push_back(nums[i]);\\n           help(i+1,nums,subset,ans);\\n           subset.pop_back();  //Backtraking\\n           \\n           //Skip ith element\\n           while(i+1 <n && nums[i] == nums[i+1]) i++;\\n           help(i+1,nums,subset,ans);\\n       }\\n   }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        help(0,nums,subset,ans);\\n        return ans;\\n    }\\n};````````\\n\\nIf it\\'s useful please vote :-:",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1840236,
                "title": "easy-c-82-faster",
                "content": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821453,
                "title": "python-iterative-solution",
                "content": "This is similar to an iterative DP. We initialize an empty list then populate that list progressively. We have a new variable `prev` that keeps track of the previous length of our result. If current number is equal to the last number, we make sure to add only to those lists that already had that number (i.e.) we don\\'t replace it, just append. This makes sure there are 0 repetitions.\\n\\n\\nSuppose we have `[1,2,2]` and `res` right now is `[[], [1], [2], [1,2]]`\\nWe have `prev = 2`. Now we have one more `2` remaining. If we start from the beginning of res and append `2` to all of them, [2] and [1,2] will be repeated. Hence we start from prev (i.e.) 2nd index from which all lists already have a `2`. \\n\\nRemember we do not **replace** an already occurred element but **append**.\\n\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794784,
                "title": "c-100-faster-recursive-solution",
                "content": "\\tclass Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.push_back(nums[idx]);\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t\\ttemp.pop_back();\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());   //to avoid duplicates\\n\\t\\t\\t vector<vector<int>> ans;\\n\\t\\t\\t vector<int> temp;\\n\\t\\t\\t helper(nums,0,temp);\\n\\t\\t\\t for(auto &it: st)\\n\\t\\t\\t\\t\\tans.push_back(it);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1722060,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 3 ms, faster than 42.29% of Java online submissions for Subsets II.\\n\\nSimilar to ```78. Subsets``` [Only have to make two changes as array contains duplicates:- 1)Sort the array. 2)Use HashSet to add the subset lists.]\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```78. Subsets```\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675120,
                "title": "unique-java-solution-using-hashset-to-avoid-duplicates",
                "content": "The Basic Idea is to use HashSet to remove the duplicates and procede as you solve the Subset problem, that is either choose a particular element or not choose. \\nAlso don\\'t forget to sort the array beforehand so that there is no duplicate ordering of the numbers inside the final answer!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```\\nPlease upvote if found helpful!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490893,
                "title": "c-solution-aditya-verma-recursive-method-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "codeTag": "Java"
            },
            {
                "id": 1458912,
                "title": "javascript-backtracking",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448506,
                "title": "c-easy-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437563,
                "title": "js-backtracking",
                "content": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431473,
                "title": "one-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414383,
                "title": "java-dfs-using-sorted-nums-to-skip-duplicate-subtrees-with-diagram-faster-than-99-5",
                "content": "This is a typical DFS solution, except we say that if we\\'re at a number with a repeating value, the left subtree will not choose an edge corresponding with the repeated value.\\n\\nSo general structure:\\nAt each step, recurse left excluding the duplicate number.\\nThen (unless this subtree is ignoring this value) recurse right with no limits.\\n\\nHere\\'s an example of how the execution for nums = [1, 2, 2] would go.\\n\\n![image](https://assets.leetcode.com/users/images/40155b43-c4c7-4ef2-b1ed-80431f7102d4_1629418968.448155.png)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398718,
                "title": "python-solution-with-memoization-similar-to-subset-problem",
                "content": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "solutionTags": [],
                "code": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1381403,
                "title": "python-solution-97-75-faster-just-used-tuple-instead-of-array",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/ff697d3b-343d-4657-a867-36e3999c60bd_1628015519.1739736.png)\\n\\nanyone with 100% solution?",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381101,
                "title": "python-easy-bitmasks",
                "content": "SIMILAR PROBLEM: \\nhttps://leetcode.com/problems/subsets\\nSOLUTION:\\nhttps://leetcode.com/problems/subsets/discuss/1381094/PYTHON-oror-BITMASK\\n\\n\\nApproach:\\nWe map each subset to a bitmask of length n, where 1 on the ith position in bitmask means\\nthe presence of nums[i] in the subset, and 0 means its absence.\\n\\nNow we want our subsets without duplicates, so we need to filter out the repeated subsets!\\nWho better can do this work except SET !!\\nAfter finding all subsets, we push them in set and get only unique subset entries, and we return that set as our output.\\n\\nTC: O(Nx2^N)\\nSC: O(N) to store \\'ans\\'\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380607,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }\\n            \\n            resultSize = result.size();\\n            \\n            while (startIndex < resultSize) {\\n                List<Integer> list = new ArrayList<>(result.get(startIndex));\\n                \\n                list.add(nums[i]);\\n                \\n                result.add(list);\\n                \\n                startIndex++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1380270,
                "title": "subset-ii-simple-backtracking-java-solution",
                "content": "**Approach:**\\nThe Magic happens at 3 places.\\n\\n1.) Sorting the input array\\n2.) checking for duplicates\\n3.) if(i > index) condition\\n\\nSo after sorting, all the duplicates are next to each other.\\n\\nFor Example: 1,3,5,2,5,3,2,3 becomes 1,2,2,3,3,3,5,5\\n\\nAfter sorting, as per the backtracking flow we can avoid making calls to duplicate numbers because the same pattern will follow again. \\nIn case of above example,\\n1,2,3,3,3,5,5\\nThe above subset will come for both 2\\'s at index 1 and 2.\\n\\nAnd finally the condition \"if(i > index &&  nums[i] == nums[i-1])\",\\nif the condition was if(i > 0), the code will still return some duplicate subset.\\nIn order to avoid duplicate subsets, you need to set the codition from the current index position of recursion. i.e if(i > index)\\n\\nHope this was helpful.\\n\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}\\n\\n\\t\\tprivate void dfs(List<List<Integer>> subsetList, int nums[], int index, List<Integer> tempList){\\n\\n\\t\\t\\tsubsetList.add(new ArrayList<>(tempList));\\n\\n\\t\\t\\tif(index>= nums.length)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tfor(int i = index; i < nums.length; i++){\\n\\n\\t\\t\\t\\tif(i > index &&  nums[i] == nums[i-1])\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\ttempList.add(nums[i]);\\n\\t\\t\\t\\tdfs(subsetList, nums, i+1, tempList);\\n\\t\\t\\t\\ttempList.remove(tempList.size() - 1);\\n\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1357701,
                "title": "easy-backtracking-using-python-3",
                "content": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316241,
                "title": "c-backtracking-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```\\n\\nWe can use `unordered_set<vector<int>>` and sort it or `set<vector<int>>` for storing the possible subsets and after the recursion store all the possible subset in 2-D array and return it but that method increase the space as well as time . That approach is basically brute because we are only storing distinct subset without doing anything . Therefore we can use the above approach , and stop for call when we have duplicate elements.\\n\\nHope you liked the solution. If you have , pls upvote it.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300129,
                "title": "0-ms-faster-than-100-percent-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255330,
                "title": "c-back-tracking-bit-masking-2-methods",
                "content": "**1. Back Tracking : Runtime: 4 ms, Memory Usage: 7.4 MB**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\\n\\n**2. Bit Masking: Runtime: 20 ms, Memory Usage: 12.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```\\n\\n**Important :** Back Tracking returns all the unique subsets in Lexicographical order.\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244947,
                "title": "python-and-cpp-sort-bit-masking-simple-solution",
                "content": "Python Solution : \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\\n\\n\\nC++ Solution :\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n\\nLike Than Upvote This",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221403,
                "title": "simple-java-solution",
                "content": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1161736,
                "title": "python3-easy-solution",
                "content": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1042854,
                "title": "python-solution-with-explanation",
                "content": "We will keep on adding stuff to result variable which will be a list of lists. The idea is that we first sort the array to just know if the current number is not same as previous number. If it is not same then it means we need to append this number to all the lists already there in result. If it is same, then in order to avoid duplicate we can only append current number to the lists which were generated(and added to result) using previous number. So we need to track previous which will contain a lists of lists generated from previous number. \\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963168,
                "title": "python-3",
                "content": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "solutionTags": [],
                "code": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 926489,
                "title": "very-simple-backtrack-python-solution",
                "content": "I think (not sure) space and time complexity would be O(N*2^N), any thoughts?\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851791,
                "title": "c-an-easy-solutions-for-subsets-i-and-subsets-ii",
                "content": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836880,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654330,
                "title": "javascript-concise-recursive-solution",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619897,
                "title": "simple-python-solution-using-set-and-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576618,
                "title": "general-iterative-approach-with-queue-in-swift",
                "content": "**General Approach**\\nI prefer solving backtracking problems iteratively with a simple queue. The general approach I take:\\n1. Add element to queue\\n2. Loop over input\\n3. Loop over current queue size\\n4. Remove first element from queue\\n5. Use the removed element\\n\\n**Permutations**\\nhttps://leetcode.com/problems/permutations/\\n\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\\n\\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Permutations II**\\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\\n\\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Subset**\\nhttps://leetcode.com/problems/subsets/\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\\n\\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\\n\\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Letter Combinations of a Phone Number**\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\\n\\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Queue"
                ],
                "code": "```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557116,
                "title": "scala-beautifully-elegant-fold",
                "content": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528323,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572090,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1568913,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2070774,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2059050,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2052359,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2013448,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2010742,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2009435,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1966724,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1960953,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1946014,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1938381,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1935888,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1928000,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1922658,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890598,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1848069,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1833839,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812431,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1789409,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            }
        ]
    }
]