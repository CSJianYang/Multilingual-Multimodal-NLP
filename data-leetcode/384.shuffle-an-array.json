[
    {
        "title": "Shuffle an Array",
        "question_content": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\nImplement the Solution class:\n\n\tSolution(int[] nums) Initializes the object with the integer array nums.\n\tint[] reset() Resets the array to its original configuration and returns it.\n\tint[] shuffle() Returns a random shuffling of the array.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\nOutput\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n                       // Any permutation of [1,2,3] must be equally likely to be returned.\n                       // Example: return [3, 1, 2]\nsolution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 50\n\t-106 <= nums[i] <= 106\n\tAll the elements of nums are unique.\n\tAt most 104 calls in total will be made to reset and shuffle.",
        "solutions": [
            {
                "id": 85958,
                "title": "first-accepted-solution-java",
                "content": "```\\nimport java.util.Random;\\n\\npublic class Solution {\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        if(nums == null) return null;\\n        int[] a = nums.clone();\\n        for(int j = 1; j < a.length; j++) {\\n            int i = random.nextInt(j + 1);\\n            swap(a, i, j);\\n        }\\n        return a;\\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        int t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Random;\\n\\npublic class Solution {\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        if(nums == null) return null;\\n        int[] a = nums.clone();\\n        for(int j = 1; j < a.length; j++) {\\n            int i = random.nextInt(j + 1);\\n            swap(a, i, j);\\n        }\\n        return a;\\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        int t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86053,
                "title": "python-hack",
                "content": "Just for fun.\\n```\\nclass Solution(object):\\n    def __init__(self, nums):\\n        self.reset = lambda: nums\\n        self.shuffle = lambda: random.sample(nums, len(nums))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self, nums):\\n        self.reset = lambda: nums\\n        self.shuffle = lambda: random.sample(nums, len(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358803,
                "title": "word-ladder-ii-no-tle-with-approach-using-bfs",
                "content": "*Due to new testcases, the old solutions are giving TLE*\\n\\n# **APPROACH:**\\nGiven two words (beginWord and endWord), and a dictionary\\u2019s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\\n1. Only one letter can be changed at a time\\n1. Each transformed word must exist in the word list. Note that beginWordis not a transformed word.\\n\\n**MUST DO:** This question is an advanced version of 127. Word Ladder. So try that too.  [Question Link](https://leetcode.com/problems/word-ladder/)\\n\\n**EXAMPLE:** \\nHere is an example of Word Ladder\\n![image](https://assets.leetcode.com/users/images/e94132b3-fa0e-49dd-a261-2f62bd6a2ee6_1627110797.38981.jpeg)\\n\\n\\n\\n**KEEP IN MIND:**\\n* Return an empty list if there is no such transformation sequence.\\n* All words have the same length.\\n* All words contain only lowercase alphabetic characters.\\n* You may assume no duplicates in the word list.\\n* You may assume beginWord and endWord are non-empty and are not the same.\\n\\n\\u274C ***Solution - I (TLE)***\\n\\n<details>\\n<summary> Solution </summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> mp ; \\n        // Record the number of conversions required to reach this string\\n        vector<vector<string>> ans ;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) \\n        {\\n            mp.insert({w,INT_MAX});\\n        }\\n        mp[beginWord]=0;  \\n\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty())\\n        {\\n            auto n = q.front() ;\\n            q.pop() ;\\n\\t\\t\\t//find word and sequence\\n            string w = n.first ;\\n            auto v=n.second ;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord)\\n            {\\n                ans.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i = 0 ; i < w.size() ; i++)\\n            {\\n                string t = w ;\\n                for(char c=\\'a\\' ; c <= \\'z\\' ; c++)\\n                {\\n                    t[i] = c ;\\n                    if(t==w)\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp.find(t)==mp.end())\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp[t]<(int)v.size())\\n                    {\\n                        continue ;\\n                    } \\n                    mp[t] = (int)v.size() ;\\n                    v.push_back(t) ;\\n                    q.push({t,v}) ;\\n                    v.pop_back() ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n</details>\\n\\n<hr>\\n\\n\\u2714\\uFE0F ***Solution - II***\\n```\\nclass Solution {\\npublic:\\n    bool neighbour(string a, string b){\\n        int cnt = 0 ;\\n        for(int i = 0 ; i < a.length() ; i++)\\n        {\\n            if(a[i] != b[i])\\n            {\\n                cnt++ ;\\n            }\\n        }\\n        return cnt == 1 ;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        wordList.insert(wordList.begin(), beginWord);\\n        for(int i = 1 ; i < wordList.size() ; i++)\\n        {\\n            if(wordList[i] == wordList[0]) // string compare\\n            {\\n                wordList[i] = wordList.back() ;\\n                wordList.pop_back() ;\\n                break ;\\n            }\\n        }\\n        map<string, int> wti ; // word to index\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            wti.insert({wordList[i], i}) ;\\n        }\\n        if(!wti.count(endWord)) \\n        {\\n            return {} ;\\n        }\\n        vector<vector<int>> edges(wti.size()) ;\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            for(int j = 0 ; j < wordList.size() ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    if(neighbour(wordList[i], wordList[j]))\\n                    {\\n                        edges[i].push_back(j) ;\\n                    }\\n                }\\n            }\\n        }\\n        // BFS  \\n        int start_node = 0 , target_node = wti[endWord] , r = 0 , min_step = INT_MAX ;\\n        vector<int> vis(wordList.size(), INT_MAX) ;   \\n        vis[start_node] = 0 ;\\n        queue<int> q ;   \\n        q.push(start_node) ;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size() ;\\n            for (int i = 0 ; i < sz ; i++)\\n            {\\n                int fr = q.front() ;  \\n                q.pop() ;\\n                if(fr == target_node)\\n                {\\n                    min_step = min(min_step , r) ;\\n                }\\n                for(int j = 0 ; j < edges[fr].size() ; j++)\\n                {\\n                    int update_node = edges[fr][j] ;\\n                    if(r + 1 < vis[update_node])\\n                    {\\n                        vis[update_node] = r + 1 ;\\n                        q.push(update_node);\\n                    }\\n                }\\n            }\\n            r++ ;\\n        }\\n        if(min_step == INT_MAX)\\n        {\\n            return {} ;\\n        }\\n        queue<vector<string>> q2 ; \\n        q2.push({wordList[target_node]}) ;\\n        r = min_step ;\\n        while(r)\\n        {\\n             int sz  = q2.size() ;\\n             for(int i = 0 ; i < sz ; i++)\\n             {\\n                vector<string> seq = q2.front() ;\\n                q2.pop();\\n                string back = seq.back() ;\\n                int curr = wti[back] ;\\n                for (int j = 0 ; j < edges[curr].size() ; j++)\\n                {\\n                    int new_node = edges[curr][j] ;\\n                    if (vis[new_node] == r - 1)\\n                    {\\n                        seq.push_back(wordList[new_node]) ;\\n                        q2.push(seq) ;\\n                        seq.pop_back() ;\\n                    }\\n                }\\n            }\\n            r-- ;\\n        }\\n        vector<vector<string>> ans;\\n        while(!q2.empty())\\n        {\\n            vector<string> temp = q2.front() ;\\n            q2.pop() ;\\n            reverse(begin(temp) , end(temp)) ;\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> mp ; \\n        // Record the number of conversions required to reach this string\\n        vector<vector<string>> ans ;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) \\n        {\\n            mp.insert({w,INT_MAX});\\n        }\\n        mp[beginWord]=0;  \\n\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty())\\n        {\\n            auto n = q.front() ;\\n            q.pop() ;\\n\\t\\t\\t//find word and sequence\\n            string w = n.first ;\\n            auto v=n.second ;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord)\\n            {\\n                ans.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i = 0 ; i < w.size() ; i++)\\n            {\\n                string t = w ;\\n                for(char c=\\'a\\' ; c <= \\'z\\' ; c++)\\n                {\\n                    t[i] = c ;\\n                    if(t==w)\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp.find(t)==mp.end())\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp[t]<(int)v.size())\\n                    {\\n                        continue ;\\n                    } \\n                    mp[t] = (int)v.size() ;\\n                    v.push_back(t) ;\\n                    q.push({t,v}) ;\\n                    v.pop_back() ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool neighbour(string a, string b){\\n        int cnt = 0 ;\\n        for(int i = 0 ; i < a.length() ; i++)\\n        {\\n            if(a[i] != b[i])\\n            {\\n                cnt++ ;\\n            }\\n        }\\n        return cnt == 1 ;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        wordList.insert(wordList.begin(), beginWord);\\n        for(int i = 1 ; i < wordList.size() ; i++)\\n        {\\n            if(wordList[i] == wordList[0]) // string compare\\n            {\\n                wordList[i] = wordList.back() ;\\n                wordList.pop_back() ;\\n                break ;\\n            }\\n        }\\n        map<string, int> wti ; // word to index\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            wti.insert({wordList[i], i}) ;\\n        }\\n        if(!wti.count(endWord)) \\n        {\\n            return {} ;\\n        }\\n        vector<vector<int>> edges(wti.size()) ;\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            for(int j = 0 ; j < wordList.size() ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    if(neighbour(wordList[i], wordList[j]))\\n                    {\\n                        edges[i].push_back(j) ;\\n                    }\\n                }\\n            }\\n        }\\n        // BFS  \\n        int start_node = 0 , target_node = wti[endWord] , r = 0 , min_step = INT_MAX ;\\n        vector<int> vis(wordList.size(), INT_MAX) ;   \\n        vis[start_node] = 0 ;\\n        queue<int> q ;   \\n        q.push(start_node) ;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size() ;\\n            for (int i = 0 ; i < sz ; i++)\\n            {\\n                int fr = q.front() ;  \\n                q.pop() ;\\n                if(fr == target_node)\\n                {\\n                    min_step = min(min_step , r) ;\\n                }\\n                for(int j = 0 ; j < edges[fr].size() ; j++)\\n                {\\n                    int update_node = edges[fr][j] ;\\n                    if(r + 1 < vis[update_node])\\n                    {\\n                        vis[update_node] = r + 1 ;\\n                        q.push(update_node);\\n                    }\\n                }\\n            }\\n            r++ ;\\n        }\\n        if(min_step == INT_MAX)\\n        {\\n            return {} ;\\n        }\\n        queue<vector<string>> q2 ; \\n        q2.push({wordList[target_node]}) ;\\n        r = min_step ;\\n        while(r)\\n        {\\n             int sz  = q2.size() ;\\n             for(int i = 0 ; i < sz ; i++)\\n             {\\n                vector<string> seq = q2.front() ;\\n                q2.pop();\\n                string back = seq.back() ;\\n                int curr = wti[back] ;\\n                for (int j = 0 ; j < edges[curr].size() ; j++)\\n                {\\n                    int new_node = edges[curr][j] ;\\n                    if (vis[new_node] == r - 1)\\n                    {\\n                        seq.push_back(wordList[new_node]) ;\\n                        q2.push(seq) ;\\n                        seq.pop_back() ;\\n                    }\\n                }\\n            }\\n            r-- ;\\n        }\\n        vector<vector<string>> ans;\\n        while(!q2.empty())\\n        {\\n            vector<string> temp = q2.front() ;\\n            q2.pop() ;\\n            reverse(begin(temp) , end(temp)) ;\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85979,
                "title": "straight-forward-c-solution",
                "content": "Straight-forward solution\\n```\\nclass Solution {\\n    vector<int> nums;\\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> result(nums);\\n        for (int i = 0;i < result.size();i++) {\\n            int pos = rand()%(result.size()-i);\\n            swap(result[i+pos], result[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * vector<int> param_1 = obj.reset();\\n * vector<int> param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> nums;\\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> result(nums);\\n        for (int i = 0;i < result.size();i++) {\\n            int pos = rand()%(result.size()-i);\\n            swap(result[i+pos], result[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * vector<int> param_1 = obj.reset();\\n * vector<int> param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283088,
                "title": "c-solution-with-intuition-and-explanation",
                "content": "## Motive\\nOur motive in this question is to find a random permutation of an array on demand. Now this random permutation should be trully random with a uniform probability distribution.\\nIn other words, for any call to shuffle(), all permutations of the array should have equal probability of being returned.\\n\\nLet\\'s try doing it by hand. We take the elements of the array in a bag and shuffle them, then for each position in the shuffled array, we draw one element from the bag, and put that element in that position, and so on, until the bag is empty.\\nWe can simulate this exact process in our code by maintaining a copy of the original array and generating a random index of the array to put at each index.\\n\\nBut the problem arises in the exclusion of the selected elements from the bag. We could do a normal array delete (or shift) and that would cost us O(n) in the worst case, making our time complexity O(n<sup>2</sup>), but we can do better.\\n<br />\\n\\n## Approach\\nThe bottleneck that\\'s causing us all this trouble is, ironically the bag itself. So why not, merge it with something else we are storing, such that it can be updated easily?\\nWe maintain two parts of the array, the already-shuffled part, and the unshuffled part. The unshuffled part is at the beginning of the array, and the shuffled part is built from the last element onwards. At every iteration, we draw an element from the unshuffled part and swap it with the current element, effectively removing the drawn element and adding the replaced element to the bag. Then we reduce the size of the bag to account for the reduction in size of the unshuffled part. \\nContinuing in this way, we generate the whole shuffled array and then return it.\\n<br/>\\n\\n## Proof of Randomness\\nNow, how do we prove that this is indeed a random draw from all the possible permutations of the array, and not from a subset?\\n\\nLet\\'s see it this way,\\nThe probability for a particular element to be selected as the ith element is 1/i (as we randomly draw a number from i elements). Thus, for a particular element, the probability of it being at the nth position in the array is 1/n. (where n is the size of the array). i.e ```P(n) = 1/n```\\n\\nWhat about the probability of it being at the (n-1)th position? \\nFor it to be in the (n-1)th position, it needs to be rejected at the nth position and then accepted at the (n-1)th position.\\nThus P(n-1) = ((n-1)/n) * (1/n-1) , or ```P(n-1) = 1/n```\\n\\nIn this way, we can prove that ```P(i) = 1/n``` for all 1 <= i <= n (1-indexed position), which in turn, means that every permutation of the array is equally likely.\\n<br/>\\n\\n\\n## Code \\n```\\nclass Solution {\\n\\tvector<int> original;\\n\\tint n;\\npublic:\\n\\n\\tSolution(vector<int>& nums) {\\n\\t\\toriginal = nums;\\n\\t\\tn = original.size();\\n\\t}\\n\\t\\n\\tvector<int> reset() {\\n\\t\\treturn original;\\n\\t}\\n\\t\\n\\tvector<int> shuffle() {\\n\\t\\t\\t//make a copy of the original\\n\\t\\t\\tvector<int> shuffled = original;\\n\\t\\t\\t\\n\\t\\t\\tint leftSize = n;\\n\\t\\t\\tfor(int i = n-1; i>=0; i--) {\\n\\t\\t\\t\\t//draw from the bag\\n\\t\\t\\t\\tint j = rand()%leftSize;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//put this element at current position\\n\\t\\t\\t\\t//and put the original element in the bag\\n\\t\\t\\t\\tswap(shuffled[i], shuffled[j]);\\n\\t\\t\\t\\tleftSize--;\\n\\t\\t\\t}\\n\\t\\t\\treturn shuffled;\\n\\t}\\n\\t\\n};\\n```\\n<br/>\\n\\n## Fancy Words\\nBoth the methods described above are called Fisher Yates Algorithm for random shuffling, with the second one being optimised for O(n) performance.\\n\\n**Time: O(n)** as we traverse the array only once\\n**Space: O(1)** if we don\\'t consider the return array as extra space. Otherwise O(n).\\n\\n<br/>\\n\\n**Upvote** if you liked this post and learned something from it, and feel free to ask any doubts or suggest any corrections/improvements in the comments.",
                "solutionTags": [
                    "C"
                ],
                "code": "```P(n) = 1/n```\n```P(n-1) = 1/n```\n```P(i) = 1/n```\n```\\nclass Solution {\\n\\tvector<int> original;\\n\\tint n;\\npublic:\\n\\n\\tSolution(vector<int>& nums) {\\n\\t\\toriginal = nums;\\n\\t\\tn = original.size();\\n\\t}\\n\\t\\n\\tvector<int> reset() {\\n\\t\\treturn original;\\n\\t}\\n\\t\\n\\tvector<int> shuffle() {\\n\\t\\t\\t//make a copy of the original\\n\\t\\t\\tvector<int> shuffled = original;\\n\\t\\t\\t\\n\\t\\t\\tint leftSize = n;\\n\\t\\t\\tfor(int i = n-1; i>=0; i--) {\\n\\t\\t\\t\\t//draw from the bag\\n\\t\\t\\t\\tint j = rand()%leftSize;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//put this element at current position\\n\\t\\t\\t\\t//and put the original element in the bag\\n\\t\\t\\t\\tswap(shuffled[i], shuffled[j]);\\n\\t\\t\\t\\tleftSize--;\\n\\t\\t\\t}\\n\\t\\t\\treturn shuffled;\\n\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85957,
                "title": "easy-python-solution-based-on-generating-random-index-and-swapping",
                "content": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n\\n    def reset(self):\\n        return self.nums\\n\\n    def shuffle(self):\\n        ans = self.nums[:]                     # copy list\\n        for i in range(len(ans)-1, 0, -1):     # start from end\\n            j = random.randrange(0, i+1)    # generate random index \\n            ans[i], ans[j] = ans[j], ans[i]    # swap\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n\\n    def reset(self):\\n        return self.nums\\n\\n    def shuffle(self):\\n        ans = self.nums[:]                     # copy list\\n        for i in range(len(ans)-1, 0, -1):     # start from end\\n            j = random.randrange(0, i+1)    # generate random index \\n            ans[i], ans[j] = ans[j], ans[i]    # swap\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350213,
                "title": "python-fisher-yates-algorithm-explained",
                "content": "In this problem we need to shuffle given array and there are different ways to do it. The most optimal algorithm is called Fisher-Yates Algorithm, where we swap original array elements. The idea is to do several steps:\\n1. Take `i = 0` and then generate random index from `[0, n-1]` and swap these two elements.\\n2. Take `i = 1` and then generate random index from `[1, n-1]` and swap these two elements.\\n...\\n\\nActually this code is for Fisher-Yates with indexes from lowest to highest, classical one is in opposite direction, but this one a bit easirer to code. It is not obvious why this algorithm will generate all shuffles with the same probability, but it can be solved by induction, see wikipedia for more details.\\n\\n#### Complexity\\nTime complexity is `O(n)` both for reset and shuffle. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def __init__(self, nums):\\n        self.nums = nums[:]\\n        self.copy = nums[:]\\n\\n    def reset(self):\\n        self.nums = self.copy[:]\\n        return self.nums\\n        \\n    def shuffle(self):\\n        n = len(self.nums)\\n        for i in range(n):\\n            j = randint(i, n - 1)\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def __init__(self, nums):\\n        self.nums = nums[:]\\n        self.copy = nums[:]\\n\\n    def reset(self):\\n        self.nums = self.copy[:]\\n        return self.nums\\n        \\n    def shuffle(self):\\n        n = len(self.nums)\\n        for i in range(n):\\n            j = randint(i, n - 1)\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86006,
                "title": "simple-java-solution",
                "content": "```\\npublic class Solution {\\n\\n    private int[] nums;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] rand = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            int r = (int) (Math.random() * (i+1));\\n            rand[i] = rand[r];\\n            rand[r] = nums[i];\\n        }\\n        return rand;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    private int[] nums;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] rand = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            int r = (int) (Math.random() * (i+1));\\n            rand[i] = rand[r];\\n            rand[r] = nums[i];\\n        }\\n        return rand;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160162,
                "title": "elegant-100-solution-in-python-using-random-in-3-lines-of-code",
                "content": "```\\nimport random\\n\\nclass Solution:\\n    \\n    def __init__(self, nums):\\n        self.nums = nums\\n\\n    def reset(self):\\n        return self.nums\\n\\n    def shuffle(self):\\n        return sorted(self.nums, key=lambda x: random.random())          \\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass Solution:\\n    \\n    def __init__(self, nums):\\n        self.nums = nums\\n\\n    def reset(self):\\n        return self.nums\\n\\n    def shuffle(self):\\n        return sorted(self.nums, key=lambda x: random.random())          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361796,
                "title": "non-ve-integers-without-consecutive-1s-java-explaination",
                "content": "**Intuition**\\nThe tricky fact here is to see how the problem can be reduced to fibonacci sequence\\nLets see a few cases for numbers with `k` bits.\\n\\n*Assumption*: The solution for `k=0` is `1`. Since the number with 0 bits is not possible as any number will have `1` bit we have taken the assumption that if there was a number with `0` bit, it wont have consecutive `1`.\\n\\n`k=1`\\nThe number with `1` bit has `2` solutions. i.e `0` and `1`\\n\\n`k=2`\\nThe possible numbers are:\\n```\\n00\\n01\\n----\\n10   = A\\n~~~\\n11   = B\\n```\\nIn the above we can se that this can be represented as the sum of the solutions for `k=0` and `k=1`. The reason behind this is if we divide the above in the mid, `0` and `1` are appended to the solution of previous bit (i.e. `k=1`). Now the above half has `0` appended so it wont affect the solution of `k=1`. For below half we can again divide into two parts say `A` & `B`. The half `B` will always have dublicate `1` so we will not have our solution as part of it. The part A will be the result of `k=0`\\n\\nThis wil be more clear for `k=3`\\n\\n`k=3`\\n\\n```\\n000\\n001\\n010\\n011\\n------\\n100    = A\\n101\\n~~~~~ \\n110    = B\\n111\\n```\\n\\nSo for `k=3`, `F(k) = F(2)+F(1)`\\n\\nNow that we have the above sorted lets move into the approach.\\n\\n* We first need to determine the total bits (`k`) for the number `n`.\\n* Then we calculate the fibonacci sequence for all `k`\\n* Then the part is how do we calculate the solution till `n`\\n* For this we calculate the solutions for `bit=k-1`. Why we do so is because we have the full result available till the `k-1` bit.\\nEg: Lets say the number was `10101`. This has `k=5` bits. The first `1` is at the 5th bit from right. so we can divide the solution to `0000` to `1111` which is `F(k=4)`. Then we find the next bit which has `1`. This would be 3rd bit from right. So we can add this to solution and so on.\\n* If any any time we have 2 consecutive `1` there is no point in checking more. So we return the answer `res`.\\n* By the end if we have not returned the answer then we can return `res+1` to include the number itself.\\n\\n```\\nclass Solution {\\n    public int findIntegers(int n) {\\n        String binary = Integer.toBinaryString(n);\\n        int k = binary.length();\\n\\n        int[] fib = new int[k+1];\\n        fib[0] = 1;\\n        fib[1] = 2;\\n        for(int i=2;i<=k;i++){\\n            fib[i] = fib[i-1]+fib[i-2];\\n        }\\n        \\n        boolean isLastBitOne = false;\\n        int res=0;\\n        int bit = k-1;\\n        while(bit>=0){\\n            if((n & (1<<bit))==0){\\n                isLastBitOne=false;\\n            } else {\\n                res+=fib[bit];\\n                if(isLastBitOne){\\n                    return res;\\n                }\\n                isLastBitOne=true;\\n            }\\n            bit--;\\n        }\\n        \\n        return res+1; // Since we started from one lesser bit, we add one to include \\'n\\' itself\\n    }\\n}\\n```\\nPlease upvote if you like this so that it can reach others.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n00\\n01\\n----\\n10   = A\\n~~~\\n11   = B\\n```\n```\\n000\\n001\\n010\\n011\\n------\\n100    = A\\n101\\n~~~~~ \\n110    = B\\n111\\n```\n```\\nclass Solution {\\n    public int findIntegers(int n) {\\n        String binary = Integer.toBinaryString(n);\\n        int k = binary.length();\\n\\n        int[] fib = new int[k+1];\\n        fib[0] = 1;\\n        fib[1] = 2;\\n        for(int i=2;i<=k;i++){\\n            fib[i] = fib[i-1]+fib[i-2];\\n        }\\n        \\n        boolean isLastBitOne = false;\\n        int res=0;\\n        int bit = k-1;\\n        while(bit>=0){\\n            if((n & (1<<bit))==0){\\n                isLastBitOne=false;\\n            } else {\\n                res+=fib[bit];\\n                if(isLastBitOne){\\n                    return res;\\n                }\\n                isLastBitOne=true;\\n            }\\n            bit--;\\n        }\\n        \\n        return res+1; // Since we started from one lesser bit, we add one to include \\'n\\' itself\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373887,
                "title": "trapping-rainwater-detailed-explanation-java",
                "content": "**Intuition**\\n* Water can only be trapped if there are blocks on the left and right to make sure it does not flow.\\n* Thus minimum number of blocks has to be 3\\n* Now the idea is to maintain a `leftMax` and a `rightMax` to store the max height of blocks on the left and right side.\\n* What do we acheive with this `leftMax` & `rightMax`? At any point (lets say `i`) we can know that the water which can be trapped will either be bounded by the `leftMax` or `rightMax`, whichever is mimimum.\\nEg: Say we have heights as `0-indexed` array `[3,1,6]` and `i=1`. So `leftMax=3` and `rightMax=6`. What could be the water trapped at `i`? Since if we fill water of more than `3 units` heights it will flow from the left side.\\n* Once we know if `leftMax` is my bound(lesser) or `rightMax`, we will fill the water to that height. But we need to subtract the height of the `ith` block if we need to fill water. In above eg. water at `i=1` block would be `2` since the height of this block is `1`.\\n* So we start from both sides and if `rightMax` is greater, then we know our bound is on the left side and vice versa.\\n* We also need to update our `leftMax`  or `rightMax` if the height of the block is greater than `leftMax` or `rightMax` based on indices `l` and `r` respectively.\\n* If `l` becomes greater than `r` we have seen all the blocks so return the water trapped.\\n\\n```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(1)`\\n\\nWe can also do the same with `O(n)` space. The idea is same but instead of two pointers we keep `leftMax` and `rightMax` for any index in an array.\\n*Note*: Since only lower bound is needed in this case is the reason why we can eliminate this array by the use of two pointers.\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n\\nPlease upvote if this helps you understanding so it can reach others as well. Thanks :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86001,
                "title": "c-solution-with-fisher-yates-algorithm",
                "content": "Use Fisher Yates algorithm to randomize. Keep an extra idx array to store the original index of each element, so that we can correctly reset each element to its original position. Also note that \"srand(time(NULL))\" must be placed in the constructor, not the shuffle() function. \\n```\\nclass Solution {\\n    vector<int> arr, idx;\\npublic:\\n    Solution(vector<int> nums) {\\n        srand(time(NULL));\\n        arr.resize(nums.size());\\n        idx.resize(nums.size());\\n        for (int i=0;i<nums.size();i++){\\n            arr[i] = nums[i];\\n            idx[i] = nums[i];\\n        }\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        for (int i=0;i<arr.size();i++)\\n            arr[i] = idx[i];\\n        return arr;    \\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n         int i,j;\\n         for (i = arr.size() - 1; i > 0; i--) {\\n            j = rand() % (i + 1);\\n            swap(arr[i], arr[j]);\\n         }\\n         return arr;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> arr, idx;\\npublic:\\n    Solution(vector<int> nums) {\\n        srand(time(NULL));\\n        arr.resize(nums.size());\\n        idx.resize(nums.size());\\n        for (int i=0;i<nums.size();i++){\\n            arr[i] = nums[i];\\n            idx[i] = nums[i];\\n        }\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        for (int i=0;i<arr.size();i++)\\n            arr[i] = idx[i];\\n        return arr;    \\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n         int i,j;\\n         for (i = arr.size() - 1; i > 0; i--) {\\n            j = rand() % (i + 1);\\n            swap(arr[i], arr[j]);\\n         }\\n         return arr;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356577,
                "title": "binary-tree-pruning-2-approaches-easy-understanding-clean-code",
                "content": "# **APPROACH I:**\\n**Divide and conquer:**\\n`Code in C++`\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* pruneTree(TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return NULL ;\\n        }\\n        TreeNode* left = pruneTree(root->left) ;\\n        root->left = left ;\\n        TreeNode* right = pruneTree(root->right) ;\\n        root->right = right ;\\n        if(root->val == 0 && root->left == NULL && root->right == NULL)\\n        {\\n            return NULL ;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# **APPROACH II:**\\n**Recursion:**\\n* Prune children of the tree recursively (`either` left-right-parent `or` right-left-parent)\\n* `containsOne(node)`: Whether the tree at this node contains 1, and it also prunes **all subtrees not containing 1**. *Example:*\\n```node.left does not contain a 1, then we should prune it via node.left = null.``` \\n* Also, the current node\\u2019s value needs to be checked.\\n**Time Complexity: O(N)\\nSpace Complexity: O(h)**\\n\\n`Code In Java`\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pruneTree(TreeNode root) {\\n\\t\\tif (root == null) \\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tif (!containsOne(root))\\n\\t\\t{\\n\\t\\t\\treturn null ;\\n\\t\\t}\\n\\t\\troot.left = pruneTree(root.left);\\n\\t\\troot.right = pruneTree(root.right);\\n\\t\\treturn root;    \\n    }\\n\\n    private boolean containsOne(TreeNode root) \\n    {\\n        if (root == null) \\n        {\\n            return false;\\n        }\\n        if (root.val == 1) \\n        {\\n            return true ;\\n        }\\n        return containsOne(root.left) || containsOne(root.right); \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* pruneTree(TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return NULL ;\\n        }\\n        TreeNode* left = pruneTree(root->left) ;\\n        root->left = left ;\\n        TreeNode* right = pruneTree(root->right) ;\\n        root->right = right ;\\n        if(root->val == 0 && root->left == NULL && root->right == NULL)\\n        {\\n            return NULL ;\\n        }\\n        return root;\\n    }\\n};\\n```\n```node.left does not contain a 1, then we should prune it via node.left = null.```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pruneTree(TreeNode root) {\\n\\t\\tif (root == null) \\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tif (!containsOne(root))\\n\\t\\t{\\n\\t\\t\\treturn null ;\\n\\t\\t}\\n\\t\\troot.left = pruneTree(root.left);\\n\\t\\troot.right = pruneTree(root.right);\\n\\t\\treturn root;    \\n    }\\n\\n    private boolean containsOne(TreeNode root) \\n    {\\n        if (root == null) \\n        {\\n            return false;\\n        }\\n        if (root.val == 1) \\n        {\\n            return true ;\\n        }\\n        return containsOne(root.left) || containsOne(root.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350079,
                "title": "c-simple-and-short-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums) {\\n        original = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffled = original;\\n        \\n        for (int i = original.size() - 1; i >= 0; i--) {\\n            int r = rand() % (i+1);\\n            swap(shuffled[i], shuffled[r]);\\n        }\\n        \\n        return shuffled;\\n    }\\n    \\nprivate:\\n    vector<int> original;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums) {\\n        original = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffled = original;\\n        \\n        for (int i = original.size() - 1; i >= 0; i--) {\\n            int r = rand() % (i+1);\\n            swap(shuffled[i], shuffled[r]);\\n        }\\n        \\n        return shuffled;\\n    }\\n    \\nprivate:\\n    vector<int> original;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352325,
                "title": "push-dominoes-2-approaches-easy-understanding",
                "content": "# Approach #1: Adjacent Symbols\\nBetween *every group* of vertical dominoes ( `\\'.\\'` ), we have up to two non-vertical dominoes bordering this group. Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: *there are 9 of them* (as the border could be empty). \\nAnd, if we border the dominoes by `\\'L\\'` and `\\'R\\'`, there are only 4 cases. \\nWe\\'ll write new letters between these symbols depending on each case.\\n\\n**Algorithm**\\n* If we have say `\"A....B\"`, where A = B, then we should write `\"AAAAAA\"`.\\n* If we have `\"R....L\"`, then we will write `\"RRRLLL\"`, or `\"RRR.LLL\"` if we have an odd number of dots. If the initial symbols are at positions `i` and `j`, we can check our distance `k-i` and `j-k` to decide at position k whether to write `\\'L\\'`, `\\'R\\'`, or `\\'.\\'`.\\n* If we have `\"L....R\"` we don\\'t do anything. We can `skip` this case.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\\n\\n# Approach #2: Calculate Force\\nWe can calculate the net force applied on every domino. The forces we care about are how close a domino is to a leftward `R\\'`, and to a rightward `\\'L\\'`: the closer we are, the stronger the force.\\n\\n**Algorithm**\\n1. Scanning from left to right, our force decays by 1 every iteration, and resets to `N` if we meet an `\\'R\\'`, so that `force[i]` is *higher* (than `force[j]`) if and only if `dominoes[i]` is closer (looking leftward) to `\\'R\\'` (than `dominoes[j]`).\\n2. Similarly, scanning from right to left, we can find the force going rightward (closeness to `\\'L\\'`).\\n3. For some domino `answer[i]`, if the forces are equal, then the answer is `\\'.\\'`. Otherwise, the answer is implied by whichever force is stronger.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\\n\\n**Solution In C++**\\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```\\nDo let me know any other approaches that come to your mind!",
                "solutionTags": [],
                "code": "```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365598,
                "title": "3sum-closest-easy-w-approach-c-java",
                "content": "# **APPROACH:**\\n* Given an `array nums with n integers` and `one target`. We have to find `three integers` in nums such that the **sum is closest to the target**. We will return the sum of the three integers. \\n* We can take one assumption that each input would have exactly one solution. \\n\\n**TESTCASE:**\\nIf the given array is like `[-1,2,1,-4]` and the target is `1`, then the triplet will be `[-1,2,1]` this has the closest sum, that is `2`.\\n\\n# **ALGORITHM:**\\n\\n* Sort the array nums, ans := 0, diff := Infinity, n := size of nums\\n* for i in range 0 to n \\u2013 1\\n\\t* left := i + 1, right := n \\u2013 1\\n\\t* while left < right\\n\\t\\t* temp := nums[left] + nums[right] + nums[i]\\n\\t\\t* If `|target \\u2013 temp| < diff`, then ans := temp and diff := |target \\u2013 temp|\\n\\t\\t* If `temp = target`, then return temp, \\n\\t\\t* Otherwise when `temp > target`, then decrease right by 1, else increase left by 1\\n* return ans\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n`In Java`\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367779,
                "title": "beautiful-array-easy-clean-w-2-approach",
                "content": "# **APPROACH 1:**\\n* **Iterative/sorting-**\\n![Meaning Of Using Bits](https://assets.leetcode.com/users/images/8a56cda7-5496-49b8-89be-2eae3e4ad95b_1627456380.537388.png)\\n\\n\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\\n**Time Complexity: O(NlogN)\\nSpace Complexity: O(1)**\\n\\n\\n\\n# **APPROACH 2:**\\n**ALGORITHM:**\\n* Create a vector called ans, insert 1 into ans\\n* While size of ans < N\\n\\t* create a vector temp\\n\\t* for i in range 0 to size of ans \\u2013 1 \\n\\t\\t* if ans[i] * 2 \\u2013 1 <= N, then insert ans[i] * 2 \\u2013 1 into temp array \\n\\t* for i in range 0 to size of ans \\u2013 1\\n\\t\\t* if ans[i] * 2 <= N, then insert ans[i] * 2 into temp array\\n\\t* set ans := temp\\n* return ans\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363462,
                "title": "convert-sorted-array-to-binary-search-tree-easy-recursion",
                "content": "# **APPROACH:**\\nConstructing from sorted array in O(n) time is simpler as we can get the middle element in O(1) time. Following is a simple algorithm where we first find the middle node of list and make it root of the tree to be constructed. .\\n\\n**ALGORITHM:**\\n1) Get the Middle of the array and make it root.\\n2) Recursively do same for left half and right half.\\n\\t\\t  a) Get the middle of left half and make it left child of the root created in step 1.\\n\\t\\t  b) Get the middle of right half and make it right child of the root created in step 1.\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    using it = vector<int>::const_iterator;\\n    TreeNode* convert(it beg, it end) {\\n        if (beg >= end) return nullptr;\\n        \\n        const auto mid = beg + (end - beg)/2;\\n        return new TreeNode(*mid, convert(beg, mid), convert(mid+1, end));\\n    }\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        return convert(nums.cbegin(), nums.cend());\\n    }\\n};\\n```\\n`In Java`\\n```\\npublic TreeNode sortedArrayToBST(int[] nums, int si, int ei) {\\n    if(si > ei)\\n        return null;\\n    int mid = (si + ei + 1) / 2;\\n    TreeNode root = new TreeNode(nums[mid]);\\n    root.left = sortedArrayToBST(nums, si, mid - 1);\\n    root.right = sortedArrayToBST(nums, mid + 1, ei);\\n    return root;\\n}\\n\\npublic TreeNode sortedArrayToBST(int[] nums) {\\n    return sortedArrayToBST(nums, 0, nums.length - 1);\\n}\\n```\\n**TIME COMPLEXITY: O(N)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    using it = vector<int>::const_iterator;\\n    TreeNode* convert(it beg, it end) {\\n        if (beg >= end) return nullptr;\\n        \\n        const auto mid = beg + (end - beg)/2;\\n        return new TreeNode(*mid, convert(beg, mid), convert(mid+1, end));\\n    }\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        return convert(nums.cbegin(), nums.cend());\\n    }\\n};\\n```\n```\\npublic TreeNode sortedArrayToBST(int[] nums, int si, int ei) {\\n    if(si > ei)\\n        return null;\\n    int mid = (si + ei + 1) / 2;\\n    TreeNode root = new TreeNode(nums[mid]);\\n    root.left = sortedArrayToBST(nums, si, mid - 1);\\n    root.right = sortedArrayToBST(nums, mid + 1, ei);\\n    return root;\\n}\\n\\npublic TreeNode sortedArrayToBST(int[] nums) {\\n    return sortedArrayToBST(nums, 0, nums.length - 1);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85975,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar Solution = function(nums) {\\n    // hold nums in Solution\\n    this.nums = nums;\\n};\\n\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\nSolution.prototype.shuffle = function() {\\n    // create a copy of this.nums, shuffle it, and return it\\n    const shuffled = this.nums.slice();\\n    const n = shuffled.length;\\n    const swap = (arr, i, j) => {\\n        let tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n\\n    // swap elements with random elements\\n    for (let i = 0; i < n; i++) \\n        swap(shuffled, i, Math.floor(Math.random() * n));\\n    \\n    return shuffled;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Solution = function(nums) {\\n    // hold nums in Solution\\n    this.nums = nums;\\n};\\n\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\nSolution.prototype.shuffle = function() {\\n    // create a copy of this.nums, shuffle it, and return it\\n    const shuffled = this.nums.slice();\\n    const n = shuffled.length;\\n    const swap = (arr, i, j) => {\\n        let tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n\\n    // swap elements with random elements\\n    for (let i = 0; i < n; i++) \\n        swap(shuffled, i, Math.floor(Math.random() * n));\\n    \\n    return shuffled;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355198,
                "title": "partition-array-into-disjoint-intervals-detailed-explaination-java",
                "content": "**Intuition**\\n* We need to divide the array into 2 parts such that max element on the left side is smaller or equal to every element on the right\\n* We can maintain a `maxLeft` to keep track of this.\\n* Now if we come across any number `num[i]` which is smaller than the `maxLeft`, this  number cannot be part of the right side.\\n* Thus we need to update the `maxLeft` and the index of our partition `p`\\n* Regarding updating our index, its straight forward to update to `i` since the ith element has to be part of left side.\\n* Now what would be the updated `maxLeft`. This has to simply be the value of the maximum element encountered so far since this element was present before ith index so has to be the `maxLeft` now.\\n* Thus we will keep track of a `max` and update `maxLeft` to this value whenever we encounter a smaller number than `maxLeft`\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```\\nPlease upvote this solution if it helps you in understanding so it can reach others as well.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867754,
                "title": "simple-c-std-shuffle-and-fisher-yates-with-tips-faster-than-99-50",
                "content": "- Avoid using `rand()` because it only generates pseudo-random integral value between 0 and `RAND_MAX` which value is implementation dependent.\\n- You should also avoid using `random_shuffle()` which is using `rand()` (problematic for inputs larger than `RAND_MAX`).\\n\\nLuckly, there are some alternatives, namely, C++ `<random>` header and `std::shuffle`. The following example is using `<random>` to generate pseudo-random numbers along with the [Fisher-Yates Shuffle algorithm](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)  to produce random permutations of the array:\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(const vector<int>& nums) : nums(nums), arr(nums), seed(random_device{}()) {}\\n\\n    vector<int> reset() {\\n\\t\\tarr = nums;\\n\\t\\treturn arr;\\n\\t}\\n\\n    vector<int> shuffle() {\\n        for (int i = size(arr) - 1; i > 0; --i) {\\n            auto idx = uniform_int_distribution<int>(0, i)(seed);\\n            swap(arr[i], arr[idx]);\\n        }\\n        return arr;\\n    }\\nprivate:\\n    vector<int> arr, nums;\\n    default_random_engine seed;\\n};\\n```\\nThe code in `vector<int> shuffle()` could be replaced with `std::shuffle` like so:\\n```\\nvector<int> shuffle() {\\n\\tstd::shuffle(begin(arr), end(arr), seed);\\n\\treturn arr;\\n}\\n```\\nIn-fact, the underlying implementation of `std::shuffle` is [possibly using the same algorithm](https://en.cppreference.com/w/cpp/algorithm/random_shuffle) anyway:\\n```\\ntemplate<class RandomIt, class URBG>\\nvoid shuffle(RandomIt first, RandomIt last, URBG&& g)\\n{\\n    typedef typename std::iterator_traits<RandomIt>::difference_type diff_t;\\n    typedef std::uniform_int_distribution<diff_t> distr_t;\\n    typedef typename distr_t::param_type param_t;\\n \\n    distr_t D;\\n    diff_t n = last - first;\\n    for (diff_t i = n-1; i > 0; --i) {\\n        using std::swap;\\n        swap(first[i], first[D(g, param_t(0, i))]);\\n    }\\n}\\n```\\nIn an interview setting, you will be asked the implement the algorithm youself (instead of relying on `std::shuffle`) but it\\'s worth mentioning anyway.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(const vector<int>& nums) : nums(nums), arr(nums), seed(random_device{}()) {}\\n\\n    vector<int> reset() {\\n\\t\\tarr = nums;\\n\\t\\treturn arr;\\n\\t}\\n\\n    vector<int> shuffle() {\\n        for (int i = size(arr) - 1; i > 0; --i) {\\n            auto idx = uniform_int_distribution<int>(0, i)(seed);\\n            swap(arr[i], arr[idx]);\\n        }\\n        return arr;\\n    }\\nprivate:\\n    vector<int> arr, nums;\\n    default_random_engine seed;\\n};\\n```\n```\\nvector<int> shuffle() {\\n\\tstd::shuffle(begin(arr), end(arr), seed);\\n\\treturn arr;\\n}\\n```\n```\\ntemplate<class RandomIt, class URBG>\\nvoid shuffle(RandomIt first, RandomIt last, URBG&& g)\\n{\\n    typedef typename std::iterator_traits<RandomIt>::difference_type diff_t;\\n    typedef std::uniform_int_distribution<diff_t> distr_t;\\n    typedef typename distr_t::param_type param_t;\\n \\n    distr_t D;\\n    diff_t n = last - first;\\n    for (diff_t i = n-1; i > 0; --i) {\\n        using std::swap;\\n        swap(first[i], first[D(g, param_t(0, i))]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86017,
                "title": "using-fisher-u2013yates-shuffle-java-solution",
                "content": "refer wikipedia for **Fisher\\u2013Yates shuffle**, here share my solution:\\n```\\npublic class Solution {\\n    private int[] nums;\\n    private int[] copy;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.copy = nums.clone();\\n    }\\n\\n    public int[] reset() {\\n        return copy;\\n    }\\n\\n    public int[] shuffle() {\\n        Random random = new Random();\\n        for (int i = nums.length - 1; i > 0; i--) {\\n            int j = random.nextInt(i + 1);\\n            int t = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = t;\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int[] nums;\\n    private int[] copy;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.copy = nums.clone();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1373785,
                "title": "trapping-rain-water-basic-implementation-w-explanation",
                "content": "<hr>\\n\\n\\u274C **(Brute-Force) Now TLE**\\n# **METHOD 1:**\\n**Approach:**\\nThe idea is to traverse every array element and find the highest bars on the left and right sides. Take the smaller of two heights. The difference between the smaller height and height of the current element is the amount of water that can be stored in this array element.\\n\\n**Algorithm:**\\n* Traverse the array from start to end.\\n* For every element, traverse the array from start to that index and find the maximum height (a) and traverse the array from the current index to end, and find the maximum height (b).\\n* The amount of water that will be stored in this column is min(a,b) \\u2013 array[i], add this value to the total amount of water stored\\n* Print the total amount of water stored.\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n^2)\\nSPACE COMPLEXITY: O(1)**\\n\\n<hr>\\n\\n\\u2714\\uFE0F **Precomputing Maximum on left and right**\\n# **METHOD 2:**\\n\\n**Approach**\\n* `a[i]` bar can only store water if there is a higher bar on its left as well as right.\\n* In this, we store maximum heights of bars in a new vector `lheight` and `rheight`\\n* Maximum water that could be stored in the `a[i]`th bar is the minimum height of the highest bar on its left and right i.e. `min(lheight[i] , rheight[i])`\\n* If `a[i] > min(lheight[i] , rheight[i])` then the water stored is ` min(lheight[i] , rheight[i]) - a[i]`\\n\\n**SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024615,
                "title": "javascript-es6",
                "content": "```javascript\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.random = [...nums];\\n    }\\n    \\n    reset() {\\n        return this.nums;\\n    }\\n    \\n    shuffle() {\\n        for(let i = 0; i < this.random.length; i++) {\\n            const randIdx = Math.floor(Math.random() * this.random.length);\\n            this.swap(i, randIdx);\\n        }\\n        return this.random;\\n    }\\n    \\n    swap(i, j) {\\n        [this.random[i], this.random[j]] = [this.random[j], this.random[i]]\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.random = [...nums];\\n    }\\n    \\n    reset() {\\n        return this.nums;\\n    }\\n    \\n    shuffle() {\\n        for(let i = 0; i < this.random.length; i++) {\\n            const randIdx = Math.floor(Math.random() * this.random.length);\\n            this.swap(i, randIdx);\\n        }\\n        return this.random;\\n    }\\n    \\n    swap(i, j) {\\n        [this.random[i], this.random[j]] = [this.random[j], this.random[i]]\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673643,
                "title": "python-best-optimal-approach",
                "content": "\\tclass Solution:\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.arr = nums[:]  # Deep Copy, Can also use Shallow Copy concept!\\n\\t\\t\\t# self.arr = nums  # Shallow Copy would be something like this!\\n\\n\\t\\tdef reset(self) -> List[int]:\\n\\t\\t\\treturn self.arr\\n\\n\\t\\tdef shuffle(self) -> List[int]:\\n\\t\\t\\tans = self.arr[:]\\n\\t\\t\\tfor i in range(len(ans)):\\n\\t\\t\\t\\tswp_num = random.randrange(i, len(ans))  # Fisher-Yates Algorithm\\n\\t\\t\\t\\tans[i], ans[swp_num] = ans[swp_num], ans[i]\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.arr = nums[:]  # Deep Copy, Can also use Shallow Copy concept!\\n\\t\\t\\t# self.arr = nums  # Shallow Copy would be something like this!\\n\\n\\t\\tdef reset(self) -> List[int]:\\n\\t\\t\\treturn self.arr\\n\\n\\t\\tdef shuffle(self) -> List[int]:\\n\\t\\t\\tans = self.arr[:]\\n\\t\\t\\tfor i in range(len(ans)):\\n\\t\\t\\t\\tswp_num = random.randrange(i, len(ans))  # Fisher-Yates Algorithm\\n\\t\\t\\t\\tans[i], ans[swp_num] = ans[swp_num], ans[i]\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1502330,
                "title": "python-fisher-yates-algorithm-clean-concise",
                "content": "```python\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.backup = nums[:]\\n        self.nums = nums[:]\\n\\n    def reset(self) -> List[int]:\\n        self.nums = self.backup.copy()\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        for i in range(n):\\n            j = randint(i, n-1)\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```\\nComplexity:\\n- Time: \\n\\t- init, reset, shuffle: `O(N)`\\n- Space: \\n\\t- init: `O(N)`\\n\\t- reset: `O(N)`\\n\\t- shuffle: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.backup = nums[:]\\n        self.nums = nums[:]\\n\\n    def reset(self) -> List[int]:\\n        self.nums = self.backup.copy()\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        for i in range(n):\\n            j = randint(i, n-1)\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354475,
                "title": "partition-array-into-disjoint-intervals-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }\\n            maxi =max(nums[i],maxi); \\n        }\\n        return ptr+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 86026,
                "title": "well-explained-o-n-java-solution-by-using-random-class-and-swapping-current-with-a-random-previous-index",
                "content": "```\\nimport java.util.Random; // import Random class from utils package.\\npublic class Solution {\\n    private int[] nums = null;\\n    private Random random = null;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random(System.currentTimeMillis());\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return Arrays.copyOf(nums,nums.length); // just return a copy.\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] ans = Arrays.copyOf(nums,nums.length); // create a copy\\n        for(int i = 1 ; i < nums.length ; i++){\\n            int swapIndex = random.nextInt(i+1); // generate a random number within visited elements including current index.\\n            swap(ans,i,swapIndex); // swap the index\\n        }\\n        return ans;\\n    }\\n    private void swap(int[] ans, int from , int to){\\n        int temp = ans[from];\\n        ans[from] = ans[to];\\n        ans[to] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Random; // import Random class from utils package.\\npublic class Solution {\\n    private int[] nums = null;\\n    private Random random = null;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random(System.currentTimeMillis());\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return Arrays.copyOf(nums,nums.length); // just return a copy.\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] ans = Arrays.copyOf(nums,nums.length); // create a copy\\n        for(int i = 1 ; i < nums.length ; i++){\\n            int swapIndex = random.nextInt(i+1); // generate a random number within visited elements including current index.\\n            swap(ans,i,swapIndex); // swap the index\\n        }\\n        return ans;\\n    }\\n    private void swap(int[] ans, int from , int to){\\n        int temp = ans[from];\\n        ans[from] = ans[to];\\n        ans[to] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367878,
                "title": "beautiful-array-recursion-with-short-explanation-c",
                "content": "Approach:\\n\\t\\n\\tRecursion: At first, we can put all even numbers on the left, and all odd numbers on the right.\\n\\t\\n    1. In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n    because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n    2.Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n    to the actual number from 1 to N.\\n    3.For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n    and we need to multiply 2 for each number.\\n    we need to make them as (1, 5, 3).\\n\\t\\n\\t\\n\\t\\nCode:\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1};\\n        }\\n        int even=n/2;\\n        int odd=(n+1)/2;\\n        vector<int>right=beautifulArray(odd);\\n        vector<int>left=beautifulArray(even);\\n\\n        for(int i=0; i<left.size(); i++)\\n        {\\n            left[i]=left[i]*2;\\n        }\\n        for(int i=0; i<right.size(); i++)\\n        {\\n            right[i]=right[i]*2-1;\\n        }\\n\\n        left.insert(left.end(),right.begin(),right.end());\\n\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 1354395,
                "title": "partition-array-into-disjoint-intervals-c-with-approach",
                "content": "# **APPROACH:**\\nSuppose we have an array A, we have to partition it into two subarrays left and right such that \\u2212\\n1. Every element in left subarray is `less than or equal` to every element in right subarray.\\n2. Left and right subarrays are `non-empty`.\\n3. Left subarray has the `smallest possible size`.\\n\\nWe have to find the `length of left` after such a partitioning. It is guaranteed that such a partitioning exists.\\n# TEST CASE\\n* If the input is like `[5,0,3,8,6]` \\n* The output will be 3\\n\\t* left array will be [5,0,3] \\n\\t* Right subarray will be [8,6].\\n# **ALGORITHM**\\nTo solve this, we will follow these steps \\u2212\\n* n := size of A, create an array mx of size n\\n* minVal := last element of A\\n* mx[0] := A[0]\\n* for i in range 1 to n \\u2013 1\\n\\t* mx[i] := max of A[i] and A[i \\u2013 1]\\n* ans := size of A \\u2013 1\\n* for i in range n \\u2013 1 down to 1\\n\\t* minVal := minimum of minVal and A[i]\\n\\t* if minVal >= mx[i \\u2013 1], then ans := i\\n* return ans\\n\\n# **SOLUTION:**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n)\\nSPACE COMPLEXITY: O(1)**\\nI\\'ll try different approaches too and update this.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85962,
                "title": "javascript-solution-with-comments",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums || [];\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    // var a = this.nums; // this is wrong, looks like JS will pass by reference when inside an object\\n    var a = [];\\n    this.nums.forEach((val, key) => a[key] = val); // need to copy key value one by one\\n    \\n    for (var i = 0; i < a.length; i++) {\\n        var rand = Math.floor(Math.random() * (a.length - i)) + i; // be careful to get the floor of random\\n        var tmp = a[i];\\n        a[i] = a[rand];\\n        a[rand] = tmp;\\n    }\\n    return a;\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = Object.create(Solution).createNew(nums)\\n * var param_1 = obj.reset()\\n * var param_2 = obj.shuffle()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums || [];\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    // var a = this.nums; // this is wrong, looks like JS will pass by reference when inside an object\\n    var a = [];\\n    this.nums.forEach((val, key) => a[key] = val); // need to copy key value one by one\\n    \\n    for (var i = 0; i < a.length; i++) {\\n        var rand = Math.floor(Math.random() * (a.length - i)) + i; // be careful to get the floor of random\\n        var tmp = a[i];\\n        a[i] = a[rand];\\n        a[rand] = tmp;\\n    }\\n    return a;\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = Object.create(Solution).createNew(nums)\\n * var param_1 = obj.reset()\\n * var param_2 = obj.shuffle()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85992,
                "title": "my-straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int> nums) :re_input(nums),input(nums){\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return re_input;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        random_shuffle(input.begin(),input.end());\\n        return input;\\n    }\\n    vector<int>input;\\n    vector<int>re_input;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int> nums) :re_input(nums),input(nums){\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return re_input;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        random_shuffle(input.begin(),input.end());\\n        return input;\\n    }\\n    vector<int>input;\\n    vector<int>re_input;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254615,
                "title": "384-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- In the __init__ method, we initialize two instance variables: self.nums and self.original. self.nums is the input array, and self.original is a copy of it. We create the copy so that we can reset the array later.\\n\\n- In the reset method, we reset the self.nums array to its original state by copying the self.original array into it.\\n\\n- In the shuffle method, we shuffle the array by iterating over each element of the array and swapping it with a randomly selected element from the remaining elements of the array.\\n\\n- We start by setting n to the length of the array.\\n\\n- We then iterate over each index i from 0 to n-1.\\n\\n- For each index i, we choose a random index j from i to n-1 using random.randrange(i, n).\\n\\n- We then swap the element at index i with the element at index j using self.nums[i], self.nums[j] = self.nums[j], self.nums[i].\\n\\n- Finally, we return the shuffled array self.nums.\\n\\nThis solution has a time complexity of O(n), which is optimal since we need to visit each element of the array at least once to shuffle it.\\n\\n# Complexity\\n- Time complexity:\\n69.60%\\n\\n- Space complexity:\\n58.20%\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.original = list(nums)\\n\\n    def reset(self) -> List[int]:\\n        self.nums = list(self.original)\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        for i in range(n):\\n            # Choose a random index j from i to n-1\\n            j = random.randrange(i, n)\\n            # Swap nums[i] and nums[j]\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.original = list(nums)\\n\\n    def reset(self) -> List[int]:\\n        self.nums = list(self.original)\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        for i in range(n):\\n            # Choose a random index j from i to n-1\\n            j = random.randrange(i, n)\\n            # Swap nums[i] and nums[j]\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193639,
                "title": "fisher-yates-algorithm-c",
                "content": "**Upvote++ if it helps you**\\n```\\n// Fisher Yates Algorithm\\nclass Solution {\\nprivate:\\n    vector<int> orgArr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        orgArr = nums;\\n        n = orgArr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return orgArr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffArr = orgArr;\\n        int last = n;\\n        for( int i = n-1; i>=0; i--){\\n            int ptr = rand()%last;\\n            swap(shuffArr[i], shuffArr[ptr]);\\n            last--;\\n        }\\n        return shuffArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Fisher Yates Algorithm\\nclass Solution {\\nprivate:\\n    vector<int> orgArr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        orgArr = nums;\\n        n = orgArr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return orgArr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffArr = orgArr;\\n        int last = n;\\n        for( int i = n-1; i>=0; i--){\\n            int ptr = rand()%last;\\n            swap(shuffArr[i], shuffArr[ptr]);\\n            last--;\\n        }\\n        return shuffArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367966,
                "title": "beautiful-array-cpp-simple-iterative-solution-explained",
                "content": "As per the the question if nums[k] multiply with 2 == nums[i]+nums[j] where i<k<j then the array is not beautiful . so we will use some basic maths now to solve this question .\\nnow as we know that (2 multiply with even number ) == even and also (odd*2) == even. so we can clearly say that in order to achieve desired result we have to make right hand side of following equation odd because left hand side be always even.\\nso in order to do that we will seperate both odd elements and even elements and place odd elements in left side of array and even in right side . hence making array beautiful.\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361454,
                "title": "non-negative-integers-without-consecutive-ones-solution-easy-bit-dp-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n    int findIntegers(int n) {\\n\\n        n++;\\n        int odd[34]={};\\n        int num=n;\\n        for(int i=0;i<32;i++)\\n        {\\n            odd[i]=num%2;\\n            num/=2;\\n        }\\n        int ans=0;\\n        int dp[34]={};\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<32;i++)\\n        {\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(odd[i])\\n            {\\n                ans+=dp[i];\\n            }\\n            if(odd[i] && odd[i+1])\\n            {\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n    int findIntegers(int n) {\\n\\n        n++;\\n        int odd[34]={}",
                "codeTag": "Java"
            },
            {
                "id": 1356652,
                "title": "python3-simple-dfs-solution",
                "content": "```\\nclass Solution:\\n    def pruneTree(self, root: TreeNode) -> TreeNode:\\n        if root.left:\\n            root.left = self.pruneTree(root.left)\\n        if root.right:\\n            root.right = self.pruneTree(root.right)\\n        if not (root.val or root.left or root.right):\\n            return None\\n        return root",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pruneTree(self, root: TreeNode) -> TreeNode:\\n        if root.left:\\n            root.left = self.pruneTree(root.left)\\n        if root.right:\\n            root.right = self.pruneTree(root.right)\\n        if not (root.val or root.left or root.right):\\n            return None\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 1350024,
                "title": "c-68ms-100-simple-and-easy",
                "content": "Runtime: 68 ms, faster than 100.00% of C++ online submissions for Shuffle an Array.\\nMemory Usage: 90.2 MB, less than 89.94% of C++ online submissions for Shuffle an Array.\\n```\\nclass Solution {\\npublic:\\n  vector<int> original, shuffled;\\n  int n;\\n  \\n  Solution(vector<int>& nums) {\\n    original = nums;\\n    shuffled = nums;\\n    n = nums.size();\\n  }\\n    \\n  vector<int> reset() {\\n    return original;      \\n  }\\n    \\n  vector<int> shuffle() {  \\n    swap(shuffled[rand()%n], shuffled[rand()%n]);\\n    return shuffled;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> original, shuffled;\\n  int n;\\n  \\n  Solution(vector<int>& nums) {\\n    original = nums;\\n    shuffled = nums;\\n    n = nums.size();\\n  }\\n    \\n  vector<int> reset() {\\n    return original;      \\n  }\\n    \\n  vector<int> shuffle() {  \\n    swap(shuffled[rand()%n], shuffled[rand()%n]);\\n    return shuffled;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180878,
                "title": "python-fisher-yates-intuition-explained",
                "content": "So I managed to come up with the fisher-yates solution myself and my thought process was as followed. For the shuffle to be truely random, each element needs to have the same chance/probability of being placed in a given position in the output array. I first thought about sampling from the original array without replacement and if we selected the item to place randomly that would give all elements the same chance of being chosen. I then realised that we could do this sampling in-place by swapping the chosen element into it\\'s final position each iteration.\\n\\n* We have n elements to select\\n* We select an element randomly and this will be the element we are seating in it\\'s final position.\\n* We move the element to the 1st index in the array by swapping it with the element that occupies the 1st index\\n* We\\'ve seated 1 element into its final position and now we repeat the process by selecting from the last n-1 elements and so on.\\n\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        \\n\\n    def reset(self) -> List[int]:\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        return self.nums\\n        \\n\\n    def shuffle(self) -> List[int]:\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        copy = self.nums.copy()\\n        for i in range(len(copy) - 1):\\n            j = random.randint(i, len(copy)-1)\\n            copy[i], copy[j] = copy[j],copy[i]\\n        return copy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        \\n\\n    def reset(self) -> List[int]:\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        return self.nums\\n        \\n\\n    def shuffle(self) -> List[int]:\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        copy = self.nums.copy()\\n        for i in range(len(copy) - 1):\\n            j = random.randint(i, len(copy)-1)\\n            copy[i], copy[j] = copy[j],copy[i]\\n        return copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714854,
                "title": "javascript-simple-approach-using-sort-function-with-custom-comparator",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n    this.original = nums.slice();\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n */\\nSolution.prototype.reset = function() {\\n    return this.original;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n */\\nSolution.prototype.shuffle = function() {\\n    this.nums.sort( (a,b) => {if(Math.random() > 0.5) return 1; else return -1;});\\n    return this.nums;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n    this.original = nums.slice();\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n */\\nSolution.prototype.reset = function() {\\n    return this.original;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n */\\nSolution.prototype.shuffle = function() {\\n    this.nums.sort( (a,b) => {if(Math.random() > 0.5) return 1; else return -1;});\\n    return this.nums;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3210831,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector <int> n1, n2;\\n    Solution(vector<int>& nums) {\\n        n1=n2=nums;\\n        \\n    }\\n    \\n    vector<int> reset() {\\n        return n2;\\n        \\n    }\\n    \\n    vector<int> shuffle() {\\n        \\n        next_permutation(n1.begin(),n1.end());\\n        return n1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector <int> n1, n2;\\n    Solution(vector<int>& nums) {\\n        n1=n2=nums;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2763798,
                "title": "easy-to-understand-using-random-library",
                "content": "```\\nimport random\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.arr=nums\\n        self.real=nums[:]\\n    def reset(self) -> List[int]:\\n        return self.real\\n    def shuffle(self) -> List[int]:\\n        narr=self.arr\\n        n=len(narr)\\n        for i in range(n):\\n            a=random.randint(0,n-1)\\n            b=random.randint(0,n-1)\\n            narr[a],narr[b]=narr[b],narr[a]\\n        return narr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.arr=nums\\n        self.real=nums[:]\\n    def reset(self) -> List[int]:\\n        return self.real\\n    def shuffle(self) -> List[int]:\\n        narr=self.arr\\n        n=len(narr)\\n        for i in range(n):\\n            a=random.randint(0,n-1)\\n            b=random.randint(0,n-1)\\n            narr[a],narr[b]=narr[b],narr[a]\\n        return narr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371377,
                "title": "01-matrix-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] updateMatrix(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n\\t\\t// iterate thru top left to bottom right\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(mat[i][j] == 0){\\n                    ans[i][j] = 0; \\n                }\\n                else{\\n                    ans[i][j] = m * n;\\n                    //up\\n                    if(i != 0){\\n                        ans[i][j] = Math.min(ans[i - 1][j] + 1, ans[i][j]);\\n                    }\\n                    //left\\n                    if(j != 0){\\n                        ans[i][j] = Math.min(ans[i][j - 1] + 1, ans[i][j]); \\n                    }\\n                } \\n            }  \\n        }\\n\\t\\t// iterate thru bottom right to top left\\n        for(int i = m - 1; i>=0; i--){\\n            for(int j = n - 1; j>= 0; j--){\\n                if(ans[i][j] != 0){\\n                    //down\\n                    if(i != m - 1){\\n                        ans[i][j] = Math.min(ans[i + 1][j] + 1, ans[i][j]);  \\n                    }\\n                    //right\\n                    if(j != n - 1){\\n                        ans[i][j] = Math.min(ans[i][j + 1] + 1, ans[i][j]);\\n                    } \\n                }     \\n            } \\n        }    \\n        return ans;\\n    }\\n}\\n```\\n\\nThank you to the commenter who suggested I add (a[i][j] != 0) to the 2nd condition!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] updateMatrix(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n\\t\\t// iterate thru top left to bottom right\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(mat[i][j] == 0){\\n                    ans[i][j] = 0; \\n                }\\n                else{\\n                    ans[i][j] = m * n;\\n                    //up\\n                    if(i != 0){\\n                        ans[i][j] = Math.min(ans[i - 1][j] + 1, ans[i][j]);\\n                    }\\n                    //left\\n                    if(j != 0){\\n                        ans[i][j] = Math.min(ans[i][j - 1] + 1, ans[i][j]); \\n                    }\\n                } \\n            }  \\n        }\\n\\t\\t// iterate thru bottom right to top left\\n        for(int i = m - 1; i>=0; i--){\\n            for(int j = n - 1; j>= 0; j--){\\n                if(ans[i][j] != 0){\\n                    //down\\n                    if(i != m - 1){\\n                        ans[i][j] = Math.min(ans[i + 1][j] + 1, ans[i][j]);  \\n                    }\\n                    //right\\n                    if(j != n - 1){\\n                        ans[i][j] = Math.min(ans[i][j + 1] + 1, ans[i][j]);\\n                    } \\n                }     \\n            } \\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350742,
                "title": "c-clean-easy-solution-using-next-permutation",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> ori, temp, track;\\n    Solution(vector<int>& nums) {\\n        ori = temp = track = nums;\\n    }\\n    vector<int> reset() {\\n        return ori;\\n    }\\n    vector<int> shuffle() {\\n        do{\\n            if(temp != track && temp != ori)\\n                break;   \\n        }while(next_permutation(temp.begin(), temp.end()));\\n        track = temp;\\n        return temp;\\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ori, temp, track;\\n    Solution(vector<int>& nums) {\\n        ori = temp = track = nums;\\n    }\\n    vector<int> reset() {\\n        return ori;\\n    }\\n    vector<int> shuffle() {\\n        do{\\n            if(temp != track && temp != ori)\\n                break;   \\n        }while(next_permutation(temp.begin(), temp.end()));\\n        track = temp;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350663,
                "title": "shuffle-an-array-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v,v1;int n;\\n    Solution(vector<int>& nums) {\\n        v=nums;  \\n        v1=nums;\\n     n =v.size();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n     v=v1;\\n        return v;\\n    }\\n    \\n      void swap(int *a,int *b){\\n          int temp =*a;\\n          *a=*b;\\n          *b= temp;\\n      }  \\n\\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n         \\n        for(int i = n-1;i>0;i--)\\n        {\\n        int j =rand() %(i+1);   // each time a new index is produced\\n        swap(&v[i],&v[j]);\\n    }\\n        return v;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v,v1;int n;\\n    Solution(vector<int>& nums) {\\n        v=nums;  \\n        v1=nums;\\n     n =v.size();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n     v=v1;\\n        return v;\\n    }\\n    \\n      void swap(int *a,int *b){\\n          int temp =*a;\\n          *a=*b;\\n          *b= temp;\\n      }  \\n\\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n         \\n        for(int i = n-1;i>0;i--)\\n        {\\n        int j =rand() %(i+1);   // each time a new index is produced\\n        swap(&v[i],&v[j]);\\n    }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350118,
                "title": "shuffle-an-array-java-solution",
                "content": "```\\nclass Solution {\\n\\n    private List<Integer> original;\\n    private List<Integer> shuffled;\\n    int[] nums;\\n    public Solution(int[] nums) {\\n        this.original = new ArrayList<>();\\n        this.nums = new int[nums.length];\\n        for(int i : nums){\\n            original.add(i);\\n        }\\n        this.shuffled = new ArrayList<>(original);\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        add(original);\\n        return this.nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        Collections.shuffle(shuffled);\\n        add(shuffled);\\n        return this.nums;\\n    }\\n    \\n    \\n    private void add(List<Integer> list){\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = list.get(i);\\n        }\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```\\n\\n\\n***Please upvote if you like the solution***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private List<Integer> original;\\n    private List<Integer> shuffled;\\n    int[] nums;\\n    public Solution(int[] nums) {\\n        this.original = new ArrayList<>();\\n        this.nums = new int[nums.length];\\n        for(int i : nums){\\n            original.add(i);\\n        }\\n        this.shuffled = new ArrayList<>(original);\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        add(original);\\n        return this.nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        Collections.shuffle(shuffled);\\n        add(shuffled);\\n        return this.nums;\\n    }\\n    \\n    \\n    private void add(List<Integer> list){\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = list.get(i);\\n        }\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520920,
                "title": "python-3-using-random-shuffle",
                "content": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums =  nums\\n              \\n    def reset(self) -> List[int]:\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        s = random.sample(self.nums, len(self.nums))\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums =  nums\\n              \\n    def reset(self) -> List[int]:\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        s = random.sample(self.nums, len(self.nums))\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 86000,
                "title": "python-solution-in-a-few-lines",
                "content": "```\\nimport random\\n\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type size: int\\n        \"\"\"\\n        self._array = nums\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        return self._array\\n        \\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        shuffled_array = self._array[:] \\n        random.shuffle(shuffled_array)\\n        return shuffled_array\\n          \\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type size: int\\n        \"\"\"\\n        self._array = nums\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        return self._array\\n        \\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        shuffled_array = self._array[:] \\n        random.shuffle(shuffled_array)\\n        return shuffled_array\\n          \\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639001,
                "title": "javascript-shuffle",
                "content": "```\\nvar Solution = function(nums) {\\n    this.nums = [...nums];\\n    this.arr = nums;\\n};\\nSolution.prototype.reset = function() {\\n    this.arr = [...this.nums];\\n    return this.arr;\\n};\\nSolution.prototype.shuffle = function() {\\n    let shuffle = (arr) => {\\n        for (let i = 0; i < arr.length; i++) {\\n            let rand = Math.floor(Math.random() * arr.length);\\n            let temp = arr[i];\\n            arr[i] = arr[rand];\\n            arr[rand] = temp;\\n        }\\n    }\\n    shuffle(this.arr);\\n    return this.arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Solution = function(nums) {\\n    this.nums = [...nums];\\n    this.arr = nums;\\n};\\nSolution.prototype.reset = function() {\\n    this.arr = [...this.nums];\\n    return this.arr;\\n};\\nSolution.prototype.shuffle = function() {\\n    let shuffle = (arr) => {\\n        for (let i = 0; i < arr.length; i++) {\\n            let rand = Math.floor(Math.random() * arr.length);\\n            let temp = arr[i];\\n            arr[i] = arr[rand];\\n            arr[rand] = temp;\\n        }\\n    }\\n    shuffle(this.arr);\\n    return this.arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461637,
                "title": "javascript-solution-86",
                "content": "This is basically the same solution posted by @abashev here (https://leetcode.com/problems/shuffle-an-array/discuss/2034271/JavaScript-solution-Ultrafast) ... but I\\'ll put a little explainer because I asked this as an interview question for years. Here\\'s the code : \\n```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n    reset() {\\n        return this.nums;\\n    }\\n    shuffle() {\\n        const arr = [...this.nums];\\n        for (let i = 0; i < arr.length; i++) {\\n            const r = i + Math.floor(Math.random() * arr.length - i);\\n            const tmp = arr[i];\\n            arr[i] = arr[r];\\n            arr[r] = tmp\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nThe solution is pretty easy once you read it but there is one fine point - the basic idea is you iterate through the array, for each index of the array you pick another random numberr in the array, and swap the current element with the element at that position. The fine point I mentioned is this part right here : \\n`const r = i + Math.floor(Math.random() * arr.length - i);`\\nI could have done `Math.floor(Math.random * arr.length)` - but instead I choose a random number *between the current index and the end of the array!* This is optimal because it ensures that each index is swapped only once. With the other method you create a higher chance for the elements lower in the array that they will be swapped more frequently, and hence have \"more randomness\" ... there has to be a better way to say that but you get it. This makes the solution satisfy the requirement that \"*All permutations of the array should be equally likely as a result of the shuffling.*\"\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n    reset() {\\n        return this.nums;\\n    }\\n    shuffle() {\\n        const arr = [...this.nums];\\n        for (let i = 0; i < arr.length; i++) {\\n            const r = i + Math.floor(Math.random() * arr.length - i);\\n            const tmp = arr[i];\\n            arr[i] = arr[r];\\n            arr[r] = tmp\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590233,
                "title": "python-solution-without-using-random-beats-99",
                "content": "This example uses the time module and modulus operation to in-place shuffle our list.\\n\\nWe initialize with a copy of our original list and a shuffled list.\\nWhenever shuffled() is called we will just reshuffle our shuffled list.\\n\\nInstead of using the random module we make a \\'choice\\' by taking our (time counter % available) choices left.\\nWhen we make a \\'choice\\'  that number is swapped with the one at the end of the available list. This avoids having to rebuild a list.\\n\\n\\nInitialization :\\n\\ttime: (O)N\\n\\tspace: (O)N\\n\\t\\nreset:\\n\\ttime: (O)1\\n\\tspace: (O)1\\n\\nshuffle:\\n\\ttime: (O)N\\n\\tspace: (O)1\\n\\n```\\nimport time\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.shuffled = nums[:]\\n        \\n    def reset(self) -> List[int]:\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        t = time.perf_counter_ns\\n        shuffled = self.shuffled\\n        for available in range(len(shuffled), 0, -1):\\n            choice = t() % available\\n            shuffled[choice], shuffled[available-1] = shuffled[available-1], shuffled[choice]\\n        \\n        return shuffled\\n```\\n\\n\\nThere are various ways to keep time with their tradeoffs. I am not using the fastest implementation in this example.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport time\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.shuffled = nums[:]\\n        \\n    def reset(self) -> List[int]:\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        t = time.perf_counter_ns\\n        shuffled = self.shuffled\\n        for available in range(len(shuffled), 0, -1):\\n            choice = t() % available\\n            shuffled[choice], shuffled[available-1] = shuffled[available-1], shuffled[choice]\\n        \\n        return shuffled\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544499,
                "title": "javascript-es6-solution-2-fisher-yates-o-n",
                "content": "The inline comments explain the code.\\n```\\n// constructor \\nvar Solution = function(nums) {\\n    this.nums = nums;\\n};\\n\\n// the spread operator makes a copy of the array\\nSolution.prototype.reset = function() {\\n    return [...this.nums];\\n};\\n\\n// numbers to the right of i are already randomized\\nSolution.prototype.shuffle = function() {\\n\\t// copy the array\\n   let ans = [...this.nums];\\n    for(let i = ans.length - 1; i > 0; i--) {\\n\\t\\t// j ranges from [0, i] inclusive\\n        let j = Math.floor(Math.random() * (i+1));\\n\\t\\t// the JS swap syntax\\n        [ans[i], ans[j]] = [ans[j], ans[i]];\\n    }\\n    return ans;    \\n};\\n\\n```\\nThe following code uses the exact logic, but loops through the array from left to right\\n\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return [...this.nums];\\n};\\n\\nSolution.prototype.shuffle = function() {\\n    const nums = [...this.nums]\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        const randomIdx = Math.floor(Math.random() * (nums.length - i)) + i;\\n        [nums[i], nums[randomIdx]] = [nums[randomIdx], nums[i]];\\n    }\\n    return nums;    \\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// constructor \\nvar Solution = function(nums) {\\n    this.nums = nums;\\n};\\n\\n// the spread operator makes a copy of the array\\nSolution.prototype.reset = function() {\\n    return [...this.nums];\\n};\\n\\n// numbers to the right of i are already randomized\\nSolution.prototype.shuffle = function() {\\n\\t// copy the array\\n   let ans = [...this.nums];\\n    for(let i = ans.length - 1; i > 0; i--) {\\n\\t\\t// j ranges from [0, i] inclusive\\n        let j = Math.floor(Math.random() * (i+1));\\n\\t\\t// the JS swap syntax\\n        [ans[i], ans[j]] = [ans[j], ans[i]];\\n    }\\n    return ans;    \\n};\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return [...this.nums];\\n};\\n\\nSolution.prototype.shuffle = function() {\\n    const nums = [...this.nums]\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        const randomIdx = Math.floor(Math.random() * (nums.length - i)) + i;\\n        [nums[i], nums[randomIdx]] = [nums[randomIdx], nums[i]];\\n    }\\n    return nums;    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407590,
                "title": "easy-c-code-very-simple-appraoch",
                "content": "```\\nclass Solution {\\n    vector<int> original;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> shuffle = original;\\n        int n = original.size();\\n        for(int i=0;i<n;i++){\\n            int z = rand() % n;\\n            swap(shuffle[i], shuffle[z]);\\n        }\\n        \\n        return shuffle;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> original;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> shuffle = original;\\n        int n = original.size();\\n        for(int i=0;i<n;i++){\\n            int z = rand() % n;\\n            swap(shuffle[i], shuffle[z]);\\n        }\\n        \\n        return shuffle;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366055,
                "title": "3sum-closest-easy-to-understand-c",
                "content": "Store all possible sum and then find the answer\\'s index using upperbound.\\nTime Complexity O(n^2)\\nwhere n = size of the nums vector.\\n\\nclass Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }\\n    }\\n    sort(store.begin(),store.end());\\n    int ind = upper_bound(store.begin(),store.end(),target)-store.begin();\\n\\t\\n    if(ind==store.size())  return store[ind-1];\\n    if(ind==0) return store[0];\\n    int dif1 = abs(store[ind]-target);\\n    int dif2 = abs(target-store[ind-1]);\\n    if(min(dif1,dif2)==dif1) return store[ind];\\n    return store[ind-1];\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1363529,
                "title": "convert-sorted-array-to-binary-search-tree-java",
                "content": "```\\nclass Solution {\\n    public TreeNode make(int a[],int l,int h){\\n        if(l>h){return null;}\\n        if(l==h){return new TreeNode(a[l]);}\\n        int m = l+(h-l)/2;\\n        return new TreeNode(a[m],make(a,l,m-1),make(a,m+1,h));\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        return make(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode make(int a[],int l,int h){\\n        if(l>h){return null;}\\n        if(l==h){return new TreeNode(a[l]);}\\n        int m = l+(h-l)/2;\\n        return new TreeNode(a[m],make(a,l,m-1),make(a,m+1,h));\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        return make(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358914,
                "title": "python-word-ladder-ii-for-beginners",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352428,
                "title": "python-push-dominoes-really-simple-solution-o-n",
                "content": "Fully annotated code below but the idea behind it is:\\n - if we have no \\'collisions\\' then the dots in the middle will all be the same e.g. \\'L.....L\\' - all the dots will be \\'L\\', and vice versa for \\'R......R\\' all being \\'R\\'\\n - if we have a collision, then we attribute the dots in the middle evenly between \\'R\\' and \\'L\\' i.e. \\'R....L\\' becomes \\'RRRLLL\\'\\n - if we have a collision with an odd number of \\'.\\' then the middle element remains a \\'.\\'\\n - if we never have a collision e.g. \\'L....R\\' then we keep all the dots\\n\\nThe above allows us to walk through the array just once and add on what we need as we go.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350725,
                "title": "c-python-a-good-practice-of-random-generator",
                "content": "Approach 1:\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums): _nums(nums){}\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return _nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> res(_nums);\\n        for(int i = 0, n = _nums.size(); i < n; i++){\\n            int new_choice = rand() % (n - i); // right hand: generating an integer within the range of [0, n-i-1]\\n            swap(res[n-1-i], res[new_choice]);\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<int> _nums;\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def __init__(self, nums):\\n        self.array = nums\\n        self.original = list(nums)        \\n\\n    def reset(self):        \\n        self.array = list(self.original)        \\n        return self.array\\n\\n    def shuffle(self):\\n        n = len(self.array)\\n        for idx in range(n):            \\n            remove_idx = random.randrange(n-idx)            \\n            self.array[remove_idx], self.array[n-idx-1] = self.array[n-idx-1], self.array[remove_idx]\\n\\n        return self.array\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums): _nums(nums){}\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return _nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int> res(_nums);\\n        for(int i = 0, n = _nums.size(); i < n; i++){\\n            int new_choice = rand() % (n - i); // right hand: generating an integer within the range of [0, n-i-1]\\n            swap(res[n-1-i], res[new_choice]);\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<int> _nums;\\n};\\n```\n```\\nclass Solution:\\n    def __init__(self, nums):\\n        self.array = nums\\n        self.original = list(nums)        \\n\\n    def reset(self):        \\n        self.array = list(self.original)        \\n        return self.array\\n\\n    def shuffle(self):\\n        n = len(self.array)\\n        for idx in range(n):            \\n            remove_idx = random.randrange(n-idx)            \\n            self.array[remove_idx], self.array[n-idx-1] = self.array[n-idx-1], self.array[remove_idx]\\n\\n        return self.array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350537,
                "title": "rust-fisher-yates-shuffle",
                "content": "```rust\\nuse rand::distributions::Uniform;\\nuse rand::prelude::*;\\n\\nstruct Solution {\\n    origin: Vec<i32>,\\n    shuffled: Vec<i32>,\\n    rng: ThreadRng,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Solution {\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            origin: nums.clone(),\\n            shuffled: nums,\\n            rng: thread_rng(),\\n        }\\n    }\\n\\n    /** Resets the array to its original configuration and return it. */\\n    fn reset(&mut self) -> Vec<i32> {\\n        self.shuffled = self.origin.clone();\\n        self.origin.clone()\\n    }\\n\\n    /** Returns a random shuffling of the array. */\\n    fn shuffle(&mut self) -> Vec<i32> {\\n        let n = self.shuffled.len();\\n        // NOTE: Fisher\\u2013Yates shuffle\\n        for i in 0..(n - 1) {\\n            let uniform = Uniform::from(i..n);\\n            let j = self.rng.sample(uniform);\\n            self.shuffled.swap(i, j);\\n        }\\n        self.shuffled.clone()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse rand::distributions::Uniform;\\nuse rand::prelude::*;\\n\\nstruct Solution {\\n    origin: Vec<i32>,\\n    shuffled: Vec<i32>,\\n    rng: ThreadRng,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Solution {\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            origin: nums.clone(),\\n            shuffled: nums,\\n            rng: thread_rng(),\\n        }\\n    }\\n\\n    /** Resets the array to its original configuration and return it. */\\n    fn reset(&mut self) -> Vec<i32> {\\n        self.shuffled = self.origin.clone();\\n        self.origin.clone()\\n    }\\n\\n    /** Returns a random shuffling of the array. */\\n    fn shuffle(&mut self) -> Vec<i32> {\\n        let n = self.shuffled.len();\\n        // NOTE: Fisher\\u2013Yates shuffle\\n        for i in 0..(n - 1) {\\n            let uniform = Uniform::from(i..n);\\n            let j = self.rng.sample(uniform);\\n            self.shuffled.swap(i, j);\\n        }\\n        self.shuffled.clone()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342558,
                "title": "think-big-nsum-instead-of-4sum-solution-c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        Array.Sort(nums);\\t\\n\\treturn kSum(nums, 0, 4, target);\\n}\\n\\npublic IList<IList<int>> kSum(int[] nums, int start, int k, int target)\\n{\\n\\tint len = nums.Length;\\n\\tIList<IList<int>> res = new List<IList<int>>();\\n\\tif (k == 2)\\n\\t{\\n\\t\\tint left = start, right = len - 1;\\n\\t\\twhile (left < right)\\n\\t\\t{\\n\\t\\t\\tint sum = nums[left] + nums[right];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.Add((new List<int> { nums[left], nums[right]}));\\n\\t\\t\\t\\twhile (left < right && nums[left] == nums[left + 1]) left++;\\n\\t\\t\\t\\twhile (left < right && nums[right] == nums[right - 1]) right--;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\telse if (sum < target) left++;\\n\\t\\t\\telse right--;\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tfor (int i = start; i < len-k+1; i++)\\n\\t\\t{\\n\\t\\t\\twhile (i > start && i<len-1 && nums[i] == nums[i - 1]) { i++;};\\n\\t\\t\\tvar temp = kSum(nums, i+1, k-1, target-nums[i]);\\n\\t\\t\\tforeach (var element in temp)\\n\\t\\t\\t{\\n\\t\\t\\t\\telement.Add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t    foreach (var val in temp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.Add(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        Array.Sort(nums);\\t\\n\\treturn kSum(nums, 0, 4, target);\\n}\\n\\npublic IList<IList<int>> kSum(int[] nums, int start, int k, int target)\\n{\\n\\tint len = nums.Length;\\n\\tIList<IList<int>> res = new List<IList<int>>();\\n\\tif (k == 2)\\n\\t{\\n\\t\\tint left = start, right = len - 1;\\n\\t\\twhile (left < right)\\n\\t\\t{\\n\\t\\t\\tint sum = nums[left] + nums[right];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.Add((new List<int> { nums[left], nums[right]}));\\n\\t\\t\\t\\twhile (left < right && nums[left] == nums[left + 1]) left++;\\n\\t\\t\\t\\twhile (left < right && nums[right] == nums[right - 1]) right--;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\telse if (sum < target) left++;\\n\\t\\t\\telse right--;\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tfor (int i = start; i < len-k+1; i++)\\n\\t\\t{\\n\\t\\t\\twhile (i > start && i<len-1 && nums[i] == nums[i - 1]) { i++;};\\n\\t\\t\\tvar temp = kSum(nums, i+1, k-1, target-nums[i]);\\n\\t\\t\\tforeach (var element in temp)\\n\\t\\t\\t{\\n\\t\\t\\t\\telement.Add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t    foreach (var val in temp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.Add(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042725,
                "title": "do-not-store-or-return-the-original-array",
                "content": "Note that it\\'s not a good practice to store the input argument (which is an array) in the constructor, nor return the internal class member array to the outside world. This is NOT SAFE.\\n\\nAlways make a copy.\\n\\nBelow is my solution based on the Fisher-Yates algorithm.\\n```\\nclass Solution {\\n    private int[] arr = null;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        arr = Arrays.copyOf(nums, nums.length);\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return Arrays.copyOf(arr, arr.length);\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] res = Arrays.copyOf(arr, arr.length);\\n        int total = res.length;\\n        while (total > 0) {\\n            int x = rand.nextInt(total--);\\n            int tmp = res[total];\\n            res[total] = res[x];\\n            res[x] = tmp;\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] arr = null;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        arr = Arrays.copyOf(nums, nums.length);\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return Arrays.copyOf(arr, arr.length);\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int[] res = Arrays.copyOf(arr, arr.length);\\n        int total = res.length;\\n        while (total > 0) {\\n            int x = rand.nextInt(total--);\\n            int tmp = res[total];\\n            res[total] = res[x];\\n            res[x] = tmp;\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 783073,
                "title": "python-easy-solution",
                "content": "**Python | Easy Solution**\\n\\n```\\nclass Solution:\\n    def __init__(self, A):\\n        self.A = A\\n    def reset(self):\\n        \\'\\'\\'\\n        Resets the array to its original configuration and return it.\\n        \\'\\'\\'\\n        return list(self.A)\\n    def shuffle(self):\\n        \\'\\'\\'\\n        Returns a random shuffling of the array.\\n        \\'\\'\\'\\n        A = list(self.A)\\n        B = []\\n        while A:\\n            i           = random.randint( 0 , len(A) - 1 )\\n            A[i], A[-1] = A[-1], A[i]\\n            B.append( A.pop() )\\n        return B\\n```\\n\\n**PS. Loop Version (a bit faster)**\\n```\\nclass Solution:\\n    def __init__(self, A):\\n        self.A = A\\n    def reset(self):\\n        \\'\\'\\'\\n        Resets the array to its original configuration and return it.\\n        \\'\\'\\'\\n        return list(self.A)\\n    def shuffle(self):\\n        \\'\\'\\'\\n        Returns a random shuffling of the array.\\n        \\'\\'\\'\\n        A = list(self.A)\\n        L = len(A)-1\\n        B = []\\n        for k in range(L+1):\\n            i           = random.randint( 0 , L-k )\\n            A[i], A[-1] = A[-1], A[i]\\n            B.append( A.pop() )\\n        return B\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, A):\\n        self.A = A\\n    def reset(self):\\n        \\'\\'\\'\\n        Resets the array to its original configuration and return it.\\n        \\'\\'\\'\\n        return list(self.A)\\n    def shuffle(self):\\n        \\'\\'\\'\\n        Returns a random shuffling of the array.\\n        \\'\\'\\'\\n        A = list(self.A)\\n        B = []\\n        while A:\\n            i           = random.randint( 0 , len(A) - 1 )\\n            A[i], A[-1] = A[-1], A[i]\\n            B.append( A.pop() )\\n        return B\\n```\n```\\nclass Solution:\\n    def __init__(self, A):\\n        self.A = A\\n    def reset(self):\\n        \\'\\'\\'\\n        Resets the array to its original configuration and return it.\\n        \\'\\'\\'\\n        return list(self.A)\\n    def shuffle(self):\\n        \\'\\'\\'\\n        Returns a random shuffling of the array.\\n        \\'\\'\\'\\n        A = list(self.A)\\n        L = len(A)-1\\n        B = []\\n        for k in range(L+1):\\n            i           = random.randint( 0 , L-k )\\n            A[i], A[-1] = A[-1], A[i]\\n            B.append( A.pop() )\\n        return B\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529556,
                "title": "go-99-solution-by-rand-intn-n",
                "content": "```go\\ntype Solution struct {\\n\\toriginal []int\\n}\\n\\nfunc Constructor(nums []int) Solution {\\n\\trand.Seed(time.Now().UnixNano())\\n\\treturn Solution{\\n\\t\\toriginal: nums,\\n\\t}\\n}\\n\\n/** Resets the array to its original configuration and return it. */\\nfunc (s *Solution) Reset() []int {\\n\\treturn s.original\\n}\\n\\n/** Returns a random shuffling of the array. */\\nfunc (s *Solution) Shuffle() []int {\\n\\tshuffle := make([]int, len(s.original))\\n\\tcopy(shuffle, s.original)\\n\\tfor i := 0; i < len(shuffle)-1; i++ {\\n\\t\\tindex := rand.Intn(len(shuffle)-i)\\n\\t\\tshuffle[len(shuffle)-1-i], shuffle[index] = shuffle[index], shuffle[len(shuffle)-1-i]\\n\\t}\\n\\treturn shuffle\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Solution struct {\\n\\toriginal []int\\n}\\n\\nfunc Constructor(nums []int) Solution {\\n\\trand.Seed(time.Now().UnixNano())\\n\\treturn Solution{\\n\\t\\toriginal: nums,\\n\\t}\\n}\\n\\n/** Resets the array to its original configuration and return it. */\\nfunc (s *Solution) Reset() []int {\\n\\treturn s.original\\n}\\n\\n/** Returns a random shuffling of the array. */\\nfunc (s *Solution) Shuffle() []int {\\n\\tshuffle := make([]int, len(s.original))\\n\\tcopy(shuffle, s.original)\\n\\tfor i := 0; i < len(shuffle)-1; i++ {\\n\\t\\tindex := rand.Intn(len(shuffle)-i)\\n\\t\\tshuffle[len(shuffle)-1-i], shuffle[index] = shuffle[index], shuffle[len(shuffle)-1-i]\\n\\t}\\n\\treturn shuffle\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169087,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.original = nums\\n        self.now = list(nums)\\n        self.n = len(nums)\\n        \\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.now = list(self.original)\\n        return self.now\\n        \\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(self.n):\\n            idx = random.randint(i,self.n-1)\\n            self.now[i], self.now[idx] = self.now[idx], self.now[i]\\n        return self.now\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.original = nums\\n        self.now = list(nums)\\n        self.n = len(nums)\\n        \\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.now = list(self.original)\\n        return self.now\\n        \\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(self.n):\\n            idx = random.randint(i,self.n-1)\\n            self.now[i], self.now[idx] = self.now[idx], self.now[i]\\n        return self.now\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85972,
                "title": "golang-solution-135ms-using-fisher-u2013yates-shuffle",
                "content": "```\\ntype Solution []int\\n\\nfunc Constructor(nums []int) Solution {\\n    return Solution(nums)\\n}\\n\\nfunc (s *Solution) Reset() []int {\\n    return *s\\n}\\n\\nfunc (s *Solution) Shuffle() []int {\\n    nums := make([]int, len(*s))\\n    copy(nums, *s)\\n    for i := 0; i < len(nums)-1; i++ {\\n        j := i + rand.Intn(len(nums)-i)\\n        nums[i], nums[j] = nums[j], nums[i]\\n    }\\n    return nums\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Solution []int\\n\\nfunc Constructor(nums []int) Solution {\\n    return Solution(nums)\\n}\\n\\nfunc (s *Solution) Reset() []int {\\n    return *s\\n}\\n\\nfunc (s *Solution) Shuffle() []int {\\n    nums := make([]int, len(*s))\\n    copy(nums, *s)\\n    for i := 0; i < len(nums)-1; i++ {\\n        j := i + rand.Intn(len(nums)-i)\\n        nums[i], nums[j] = nums[j], nums[i]\\n    }\\n    return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86007,
                "title": "java-fisher-yates-shuffle-in-place-swap",
                "content": "```\\nprivate int[] nums;\\nprivate Random r;\\n\\npublic Solution(int[] nums) {\\n\\tthis.nums = nums;\\n\\tr = new Random();\\n}\\n\\npublic int[] reset() {\\n\\treturn this.nums;\\n}\\n\\npublic int[] shuffle() {\\n\\tint[] shuffledNums = Arrays.copyOf(nums,nums.length);\\n\\tfor(int i=1; i<shuffledNums.length; i++) {\\n\\t\\tswap(shuffledNums,i,r.nextInt(i+1));\\n\\t}\\n\\treturn shuffledNums;\\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n\\tif(nums[i]==nums[j]) return;\\n\\tnums[i] = nums[i]^nums[j];\\n\\tnums[j] = nums[i]^nums[j];\\n\\tnums[i] = nums[i]^nums[j];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int[] nums;\\nprivate Random r;\\n\\npublic Solution(int[] nums) {\\n\\tthis.nums = nums;\\n\\tr = new Random();\\n}\\n\\npublic int[] reset() {\\n\\treturn this.nums;\\n}\\n\\npublic int[] shuffle() {\\n\\tint[] shuffledNums = Arrays.copyOf(nums,nums.length);\\n\\tfor(int i=1; i<shuffledNums.length; i++) {\\n\\t\\tswap(shuffledNums,i,r.nextInt(i+1));\\n\\t}\\n\\treturn shuffledNums;\\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n\\tif(nums[i]==nums[j]) return;\\n\\tnums[i] = nums[i]^nums[j];\\n\\tnums[j] = nums[i]^nums[j];\\n\\tnums[i] = nums[i]^nums[j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86050,
                "title": "straight-forward-python-solution",
                "content": "```\\nfrom random import shuffle\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        \\n        :type nums: List[int]\\n        :type size: int\\n        \"\"\"\\n        self.nums = nums\\n        self.l = len(nums)\\n        self.ord = range(self.l)\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.ord = range(self.l)\\n        return self.nums\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        shuffle(self.ord)\\n        return [self.nums[i] for i in self.ord]\\n```\\n\\n1. I'm not sure if I am allowed to use the built in random library, nor the point of this question. \\n2. I am neither sure if this can be done in a O(1) space, as `reset` function requires remembering the original state of the array. \\n3. The reason I'm keeping `self.ord` is that initializing a large `range` is very time consuming, so initializing it over and over again will fail the test, exceeding the time limit.  \\n4. Remembering `order` takes less memory than keeping a copy of the original array, as the original array may contain objects larger that `int`. \\n\\n I'm open to suggestions. Thank you for reading.",
                "solutionTags": [],
                "code": "```\\nfrom random import shuffle\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        \\n        :type nums: List[int]\\n        :type size: int\\n        \"\"\"\\n        self.nums = nums\\n        self.l = len(nums)\\n        self.ord = range(self.l)\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.ord = range(self.l)\\n        return self.nums\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        shuffle(self.ord)\\n        return [self.nums[i] for i in self.ord]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335190,
                "title": "python-code-reset-without-storing-the-original-array",
                "content": "\\n```\\nRead a lot a solution, but everywhere the original array\\nis stored seperately and returned when reset is called.\\n\\nI tried to reset the array we suffled,\\nhowever many times we shuffle it, below is the \\naccepted solution, it is slow, beats only 10% but it \\nis the full solution in my view.\\n```\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.index = [i for i in range(0,len(nums))]\\n\\n    def reset(self) -> List[int]:\\n        n = len(self.nums)\\n        nums2 = [0 for _ in range(0,n) ]\\n        for i in range(0,n):\\n            nums2[self.index[i]] = self.nums[i]\\n        self.index = [i for i in range(0,n)]\\n        self.nums = nums2\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        nums2 = [ 0 for _ in range(0,n) ]\\n        index2 = [0 for _ in range(0,n) ]\\n        filled = []\\n        i = 0\\n        while(i < n):\\n            r = randint( 0,n-1)\\n            if( r not in filled):\\n                filled.append(r);\\n                nums2[r]  =  self.nums[i]\\n                index2[r] = self.index[i] \\n                i+=1\\n        self.nums = nums2 ;\\n        self.index = index2 \\n        return self.nums\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nRead a lot a solution, but everywhere the original array\\nis stored seperately and returned when reset is called.\\n\\nI tried to reset the array we suffled,\\nhowever many times we shuffle it, below is the \\naccepted solution, it is slow, beats only 10% but it \\nis the full solution in my view.\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.index = [i for i in range(0,len(nums))]\\n\\n    def reset(self) -> List[int]:\\n        n = len(self.nums)\\n        nums2 = [0 for _ in range(0,n) ]\\n        for i in range(0,n):\\n            nums2[self.index[i]] = self.nums[i]\\n        self.index = [i for i in range(0,n)]\\n        self.nums = nums2\\n        return self.nums\\n\\n    def shuffle(self) -> List[int]:\\n        n = len(self.nums)\\n        nums2 = [ 0 for _ in range(0,n) ]\\n        index2 = [0 for _ in range(0,n) ]\\n        filled = []\\n        i = 0\\n        while(i < n):\\n            r = randint( 0,n-1)\\n            if( r not in filled):\\n                filled.append(r);\\n                nums2[r]  =  self.nums[i]\\n                index2[r] = self.index[i] \\n                i+=1\\n        self.nums = nums2 ;\\n        self.index = index2 \\n        return self.nums\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201832,
                "title": "to-the-point-code-self-explanatory-code",
                "content": "\\n**PLEASE UPVOTE IF YOU LIKE THE APPRAOCH !!**\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>v1,v2;\\n    Solution(vector<int>& nums) {\\n        v1=v2=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return v1;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int t1=rand()%v1.size();\\n        int t2=rand()%v1.size();\\n        int temp=v2[t1];\\n        v2[t1]=v2[t2];\\n        v2[t2]=temp;\\n        return v2;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>v1,v2;\\n    Solution(vector<int>& nums) {\\n        v1=v2=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return v1;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int t1=rand()%v1.size();\\n        int t2=rand()%v1.size();\\n        int temp=v2[t1];\\n        v2[t1]=v2[t2];\\n        v2[t2]=temp;\\n        return v2;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044136,
                "title": "o-1-time-complexity-java-solution",
                "content": "# Intuition\\nSince shuffle of any order is accepted, I will swap only two elements for every shuffle.\\n\\n# Approach\\nTake a random value from 0 to nums.length.\\nLet random = x; where 0<=x<=ums.length;\\nswap nums[random] with nums[random-1];\\n\\nif random is 0, then swap it with last element of the input array\\n\\n# Complexity\\n- Time complexity:\\nO(1) - as we will always swap only 2 elements for every shuffle.\\n\\n- Space complexity:\\nO(N) - for storing the clone array.\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] array;\\n    private int[] original;\\n    private int[] reset;\\n\\n    Random rand = new Random();\\n    public Solution(int[] nums) {\\n        original = nums.clone();\\n        reset = nums.clone();\\n        array = original;\\n    }\\n\\n    public int[] reset() {\\n        return reset;\\n    }\\n\\n    public int[] shuffle() {\\n        int random = rand.nextInt(array.length);\\n        int next = random-1;\\n        if(random == 0){\\n            next = array.length -1;\\n        }\\n        int temp = array[random];\\n        array[random] = array[next];\\n        array[next] = temp;\\n        return array;\\n    }\\n}\\n\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] array;\\n    private int[] original;\\n    private int[] reset;\\n\\n    Random rand = new Random();\\n    public Solution(int[] nums) {\\n        original = nums.clone();\\n        reset = nums.clone();\\n        array = original;\\n    }\\n\\n    public int[] reset() {\\n        return reset;\\n    }\\n\\n    public int[] shuffle() {\\n        int random = rand.nextInt(array.length);\\n        int next = random-1;\\n        if(random == 0){\\n            next = array.length -1;\\n        }\\n        int temp = array[random];\\n        array[random] = array[next];\\n        array[next] = temp;\\n        return array;\\n    }\\n}\\n\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951018,
                "title": "short-concise-c-rand-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v1, v2;\\n    Solution(vector<int>& nums) {\\n        v1=v2=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return v1;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int t1 = rand()%v1.size();\\n        int t2 = rand()%v1.size();\\n        swap(v2[t1],v2[t2]);\\n        return v2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v1, v2;\\n    Solution(vector<int>& nums) {\\n        v1=v2=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return v1;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int t1 = rand()%v1.size();\\n        int t2 = rand()%v1.size();\\n        swap(v2[t1],v2[t2]);\\n        return v2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895335,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    private int[] nums;\\n    private int[] shuffled;\\n    private Random rnd = new Random();\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        shuffled = new int[nums.Length];\\n        Array.Copy(nums, shuffled, nums.Length);\\n    }\\n    \\n    public int[] Reset() {\\n        Array.Copy(nums, shuffled, nums.Length);\\n        return nums;\\n    }\\n    \\n    public int[] Shuffle() {\\n        for(int i=0;i< shuffled.Length; i++){\\n            int random = rnd.Next(i, shuffled.Length);\\n            int temp = shuffled[i];\\n            shuffled[i] = shuffled[random];\\n            shuffled[random] = temp;\\n        }\\n        return shuffled;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.Reset();\\n * int[] param_2 = obj.Shuffle();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] nums;\\n    private int[] shuffled;\\n    private Random rnd = new Random();\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        shuffled = new int[nums.Length];\\n        Array.Copy(nums, shuffled, nums.Length);\\n    }\\n    \\n    public int[] Reset() {\\n        Array.Copy(nums, shuffled, nums.Length);\\n        return nums;\\n    }\\n    \\n    public int[] Shuffle() {\\n        for(int i=0;i< shuffled.Length; i++){\\n            int random = rnd.Next(i, shuffled.Length);\\n            int temp = shuffled[i];\\n            shuffled[i] = shuffled[random];\\n            shuffled[random] = temp;\\n        }\\n        return shuffled;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.Reset();\\n * int[] param_2 = obj.Shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672236,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\nvector<int> original;\\n\\tint n;\\npublic:\\n\\n\\tSolution(vector<int>& nums) {\\n\\t\\toriginal = nums;\\n\\t\\tn = original.size();\\n\\t}\\n\\t\\n\\tvector<int> reset() {\\n\\t\\treturn original;\\n\\t}\\n\\t\\n\\tvector<int> shuffle() {\\n\\t\\t\\tvector<int> shuffled = original;\\n\\t\\t\\t\\n\\t\\t\\tint leftSize = n;\\n\\t\\t\\tfor(int i = n-1; i>=0; i--) {\\n\\t\\t\\t\\tint j = rand()%leftSize;\\n\\t\\t\\t\\tswap(shuffled[i], shuffled[j]);\\n\\t\\t\\t\\tleftSize--;\\n\\t\\t\\t}\\n\\t\\t\\treturn shuffled;\\n\\t}\\n\\t\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nvector<int> original;\\n\\tint n;\\npublic:\\n\\n\\tSolution(vector<int>& nums) {\\n\\t\\toriginal = nums;\\n\\t\\tn = original.size();\\n\\t}\\n\\t\\n\\tvector<int> reset() {\\n\\t\\treturn original;\\n\\t}\\n\\t\\n\\tvector<int> shuffle() {\\n\\t\\t\\tvector<int> shuffled = original;\\n\\t\\t\\t\\n\\t\\t\\tint leftSize = n;\\n\\t\\t\\tfor(int i = n-1; i>=0; i--) {\\n\\t\\t\\t\\tint j = rand()%leftSize;\\n\\t\\t\\t\\tswap(shuffled[i], shuffled[j]);\\n\\t\\t\\t\\tleftSize--;\\n\\t\\t\\t}\\n\\t\\t\\treturn shuffled;\\n\\t}\\n\\t\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630890,
                "title": "java-easy-clean-crisp-readable-code",
                "content": "Please upvote if you like.... :)\\n```\\nclass Solution {\\n    private int originalArray [] = null;\\n    private int shuffledArray [] = null;\\n    private Random random = null;\\n    \\n    public Solution(int[] nums) {\\n        this.originalArray = nums.clone();\\n        this.shuffledArray = nums;\\n        this.random = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return this.originalArray;    \\n    }\\n    \\n    public int getRandomIndex(int start , int end) {\\n        int randomNumber = this.random.nextInt(end - start + 1);\\n        return start + randomNumber;\\n    }\\n    \\n    public int[] shuffle() {\\n        int totalNumbers = this.shuffledArray.length;\\n        for(int index = 0; index < totalNumbers; index++) {\\n            int randomIndex = getRandomIndex(index , totalNumbers - 1);\\n            int temp = this.shuffledArray[randomIndex];\\n            this.shuffledArray[randomIndex] = this.shuffledArray[index];\\n            this.shuffledArray[index] = temp;\\n\\n        }\\n        return this.shuffledArray;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int originalArray [] = null;\\n    private int shuffledArray [] = null;\\n    private Random random = null;\\n    \\n    public Solution(int[] nums) {\\n        this.originalArray = nums.clone();\\n        this.shuffledArray = nums;\\n        this.random = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return this.originalArray;    \\n    }\\n    \\n    public int getRandomIndex(int start , int end) {\\n        int randomNumber = this.random.nextInt(end - start + 1);\\n        return start + randomNumber;\\n    }\\n    \\n    public int[] shuffle() {\\n        int totalNumbers = this.shuffledArray.length;\\n        for(int index = 0; index < totalNumbers; index++) {\\n            int randomIndex = getRandomIndex(index , totalNumbers - 1);\\n            int temp = this.shuffledArray[randomIndex];\\n            this.shuffledArray[randomIndex] = this.shuffledArray[index];\\n            this.shuffledArray[index] = temp;\\n\\n        }\\n        return this.shuffledArray;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603548,
                "title": "c-easy-solution-rand-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>org;\\n    int n;\\n    Solution(vector<int>& nums) {\\n        org = nums;\\n        n = nums.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return org;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr = org;\\n        int sz = n;\\n        for(int i=n-1;i>-1;i--)\\n        {\\n            int ind = rand()%sz--;\\n            swap(arr[ind],arr[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>org;\\n    int n;\\n    Solution(vector<int>& nums) {\\n        org = nums;\\n        n = nums.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return org;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr = org;\\n        int sz = n;\\n        for(int i=n-1;i>-1;i--)\\n        {\\n            int ind = rand()%sz--;\\n            swap(arr[ind],arr[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424280,
                "title": "python-clean-and-easy-o-n",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.shuffles = nums[:]\\n        \\n\\n    def reset(self) -> List[int]:\\n        self.shuffles = self.nums[:]\\n        return self.shuffles\\n\\n    def shuffle(self) -> List[int]:\\n        random.shuffle(self.shuffles)\\n        return self.shuffles\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.shuffles = nums[:]\\n        \\n\\n    def reset(self) -> List[int]:\\n        self.shuffles = self.nums[:]\\n        return self.shuffles\\n\\n    def shuffle(self) -> List[int]:\\n        random.shuffle(self.shuffles)\\n        return self.shuffles\\n",
                "codeTag": "Java"
            },
            {
                "id": 2384538,
                "title": "c-solution-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> res;\\n    Solution(vector<int>& nums) {\\n        ans=nums;\\n        res=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return res;\\n    }\\n    \\n    vector<int> shuffle() {\\n        next_permutation(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you like the solution :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> res;\\n    Solution(vector<int>& nums) {\\n        ans=nums;\\n        res=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return res;\\n    }\\n    \\n    vector<int> shuffle() {\\n        next_permutation(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986284,
                "title": "c-o-n-solution-easy",
                "content": "```\\npublic class Solution {\\n\\n    private Random r;\\n    private int[] original;\\n    public Solution(int[] nums) {\\n        this.r = new Random();\\n        this.original = nums.ToArray();\\n    }\\n    \\n    public int[] Reset() {\\n        return original;\\n    }\\n    \\n    public int[] Shuffle() {\\n        var nums = original.ToArray();\\n        \\n        //Swap current element and random element, with the index next or equal to current \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            var j = r.Next(i, nums.Length); //from current index to length - 1 \\n            (nums[i], nums[j]) = (nums[j], nums[i]);\\n        }\\n          \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    private Random r;\\n    private int[] original;\\n    public Solution(int[] nums) {\\n        this.r = new Random();\\n        this.original = nums.ToArray();\\n    }\\n    \\n    public int[] Reset() {\\n        return original;\\n    }\\n    \\n    public int[] Shuffle() {\\n        var nums = original.ToArray();\\n        \\n        //Swap current element and random element, with the index next or equal to current \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            var j = r.Next(i, nums.Length); //from current index to length - 1 \\n            (nums[i], nums[j]) = (nums[j], nums[i]);\\n        }\\n          \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690866,
                "title": "c-easy-to-understand-simple-solution-2-approaches",
                "content": "**Approach 1 using set**\\n```\\nclass Solution {\\nprivate:\\n vector<int> original;\\n vector<int> curr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original=nums;\\n        curr=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        curr=original;\\n        return curr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffled;\\n        set<int> check;\\n        int n=curr.size();\\n        while(check.size()!=n)\\n        {\\n            int i=rand()%n;\\n            if(check.find(i)==check.end())\\n            {\\n            shuffled.push_back(curr[i]);\\n            check.insert(i);\\n            }\\n        }\\n        curr=shuffled;\\n        return curr;\\n    }\\n};\\n```\\n**Approach 2 using swap**\\n```\\nclass Solution {\\nprivate:\\n vector<int> original;\\n vector<int> curr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original=nums;\\n        curr=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        curr=original;\\n        return curr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int n=curr.size();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int j=rand()%n;\\n            swap(curr[i],curr[j]);\\n            n--;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n vector<int> original;\\n vector<int> curr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original=nums;\\n        curr=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        curr=original;\\n        return curr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> shuffled;\\n        set<int> check;\\n        int n=curr.size();\\n        while(check.size()!=n)\\n        {\\n            int i=rand()%n;\\n            if(check.find(i)==check.end())\\n            {\\n            shuffled.push_back(curr[i]);\\n            check.insert(i);\\n            }\\n        }\\n        curr=shuffled;\\n        return curr;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n vector<int> original;\\n vector<int> curr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        original=nums;\\n        curr=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        curr=original;\\n        return curr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int n=curr.size();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int j=rand()%n;\\n            swap(curr[i],curr[j]);\\n            n--;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609825,
                "title": "99-faster-c-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    Solution(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr = nums;\\n        random_shuffle ( arr.begin(), arr.end() );\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    Solution(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr = nums;\\n        random_shuffle ( arr.begin(), arr.end() );\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603711,
                "title": "very-simple-c-solution-100",
                "content": "```\\ntypedef struct {\\n    int * original;\\n    int * nums;\\n    int size;\\n} Solution;\\n\\n\\nSolution* solutionCreate(int* nums, int numsSize) {\\n    Solution * result = (Solution *)malloc(sizeof(Solution));\\n    result->original = (int *)malloc(numsSize*sizeof(int));\\n    result->nums = (int *)malloc(numsSize*sizeof(int));\\n    result->size = numsSize;\\n    memcpy(result->original, nums, numsSize*sizeof(int));\\n    memcpy(result->nums, nums, numsSize*sizeof(int));\\n    return result;\\n}\\n\\nint* solutionReset(Solution* obj, int* retSize) {\\n    *retSize = obj->size;\\n    memcpy(obj->nums, obj->original, obj->size*sizeof(int));\\n    return obj->original;\\n}\\n\\nint* solutionShuffle(Solution* obj, int* retSize) {\\n    *retSize = obj->size;\\n    for(int i = 0; i < obj->size; i++)\\n    {\\n        int temp = obj->nums[i];\\n        int pos = rand() % obj->size;\\n        obj->nums[i] = obj->nums[pos];\\n        obj->nums[pos] = temp;\\n    }\\n    return obj->nums;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->nums);\\n    free(obj->original);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int * original;\\n    int * nums;\\n    int size;\\n} Solution;\\n\\n\\nSolution* solutionCreate(int* nums, int numsSize) {\\n    Solution * result = (Solution *)malloc(sizeof(Solution));\\n    result->original = (int *)malloc(numsSize*sizeof(int));\\n    result->nums = (int *)malloc(numsSize*sizeof(int));\\n    result->size = numsSize;\\n    memcpy(result->original, nums, numsSize*sizeof(int));\\n    memcpy(result->nums, nums, numsSize*sizeof(int));\\n    return result;\\n}\\n\\nint* solutionReset(Solution* obj, int* retSize) {\\n    *retSize = obj->size;\\n    memcpy(obj->nums, obj->original, obj->size*sizeof(int));\\n    return obj->original;\\n}\\n\\nint* solutionShuffle(Solution* obj, int* retSize) {\\n    *retSize = obj->size;\\n    for(int i = 0; i < obj->size; i++)\\n    {\\n        int temp = obj->nums[i];\\n        int pos = rand() % obj->size;\\n        obj->nums[i] = obj->nums[pos];\\n        obj->nums[pos] = temp;\\n    }\\n    return obj->nums;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->nums);\\n    free(obj->original);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1538524,
                "title": "c-o-1-time",
                "content": "Don\\'t know why it is accepted..\\n```\\nclass Solution {\\npublic:\\n    vector<int> base;\\n    vector<int> inited;\\n    Solution(vector<int>& nums) {\\n        base = nums;\\n        inited =nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return base;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int r = rand() % (inited.size()-1);\\n        int temp = inited[r];\\n        inited[r] = inited[r+1];\\n        inited[r+1] = temp;\\n        return inited;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> base;\\n    vector<int> inited;\\n    Solution(vector<int>& nums) {\\n        base = nums;\\n        inited =nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return base;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int r = rand() % (inited.size()-1);\\n        int temp = inited[r];\\n        inited[r] = inited[r+1];\\n        inited[r+1] = temp;\\n        return inited;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401778,
                "title": "my-adventure-with-this-problem",
                "content": "attempt 1, brute force, peeked the solution page\\n```\\n    # Runtime: 284 ms, faster than 73.60%\\n    # Memory Usage: 19.6 MB, less than 10.42%\\n    #\\n    # Time: O(n**2), Space: O(n)\\n    #\\n    # Each element in @aux has the same probability to be chosen:\\n    #     * assume Pk is the probability that an element e in @aux is chosen in\\n    #       iteration k\\n    #     * Pk = P(e not chosen in the previous k - 1 iterations) *\\n    #            P(e chosen at the kth iteration)\\n    #          = (n-1)/(n) * (n-2)/(n-1) * ... * (n-k+1)/(n-k+2) * 1/(n-k+1)\\n    #          = 1/n\\n    #     * so each element has the same probability to be chosen even is is\\n    #       chosen in different iteration\\n    #\\n    # The proof is important because the Fisher-Yates Algorithm use the same\\n    # concept of this brute force one but with improved space and time\\n    # complexity. And since this brute force one is uniformly distributed, the\\n    # Fisher-Yates Algorithm will also be.\\n    def shuffle(self) -> List[int]:\\n        aux = list(self.original)\\n        array = [None] * len(aux)\\n        for i in range(len(array)):\\n            # randomly pick 1 element from @aux and put it into @array\\n            # note that as we keep popoing @aux, len(aux) becomes less and less,\\n            # and the random range we use is narrower and narrower\\n            #\\n            # note: pop() is O(n), so the total time would be O(n**2)\\n            array[i] = aux.pop(random.randrange(len(aux)))\\n        return array\\n```\\nattempt 3, Fisher-Yates Algorithm, shuffle from high to low\\n```\\n    # Time: O(n), Space: O(1)\\n    #\\n    # note:\\n    #     * this is actually equivalent to the previous brute force solution in\\n    #       the sense that @array[0:i+1] is actually the @aux in the brute force\\n    #       solution\\n    def shuffle(self):\\n        array = list(self.original)\\n        for i in range(len(array) - 1, 0, -1): # @i from n-1 down to 1\\n            # randomly pick 1 element from 0 up to (including) @i, @i is\\n            # included because it is yet to be shuffled (think of the @aux array\\n            # in the brute force solution)\\n            r = random.randrange(0, i + 1)\\n            array[i], array[r] = array[r], array[i]\\n        return array\\n```\\nattempt 4, Fisher-Yates Algorithm, shuffle from low to high\\n```\\n    def shuffle(self):\\n        array = list(self.original)\\n        for i in range(len(array)): # run @i from 0 up\\n            # randomly select 1 element from @i up to end\\n            r = random.randrange(i, len(array))\\n            array[i], array[r] = array[r], array[i]\\n        return array\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    # Runtime: 284 ms, faster than 73.60%\\n    # Memory Usage: 19.6 MB, less than 10.42%\\n    #\\n    # Time: O(n**2), Space: O(n)\\n    #\\n    # Each element in @aux has the same probability to be chosen:\\n    #     * assume Pk is the probability that an element e in @aux is chosen in\\n    #       iteration k\\n    #     * Pk = P(e not chosen in the previous k - 1 iterations) *\\n    #            P(e chosen at the kth iteration)\\n    #          = (n-1)/(n) * (n-2)/(n-1) * ... * (n-k+1)/(n-k+2) * 1/(n-k+1)\\n    #          = 1/n\\n    #     * so each element has the same probability to be chosen even is is\\n    #       chosen in different iteration\\n    #\\n    # The proof is important because the Fisher-Yates Algorithm use the same\\n    # concept of this brute force one but with improved space and time\\n    # complexity. And since this brute force one is uniformly distributed, the\\n    # Fisher-Yates Algorithm will also be.\\n    def shuffle(self) -> List[int]:\\n        aux = list(self.original)\\n        array = [None] * len(aux)\\n        for i in range(len(array)):\\n            # randomly pick 1 element from @aux and put it into @array\\n            # note that as we keep popoing @aux, len(aux) becomes less and less,\\n            # and the random range we use is narrower and narrower\\n            #\\n            # note: pop() is O(n), so the total time would be O(n**2)\\n            array[i] = aux.pop(random.randrange(len(aux)))\\n        return array\\n```\n```\\n    # Time: O(n), Space: O(1)\\n    #\\n    # note:\\n    #     * this is actually equivalent to the previous brute force solution in\\n    #       the sense that @array[0:i+1] is actually the @aux in the brute force\\n    #       solution\\n    def shuffle(self):\\n        array = list(self.original)\\n        for i in range(len(array) - 1, 0, -1): # @i from n-1 down to 1\\n            # randomly pick 1 element from 0 up to (including) @i, @i is\\n            # included because it is yet to be shuffled (think of the @aux array\\n            # in the brute force solution)\\n            r = random.randrange(0, i + 1)\\n            array[i], array[r] = array[r], array[i]\\n        return array\\n```\n```\\n    def shuffle(self):\\n        array = list(self.original)\\n        for i in range(len(array)): # run @i from 0 up\\n            # randomly select 1 element from @i up to end\\n            r = random.randrange(i, len(array))\\n            array[i], array[r] = array[r], array[i]\\n        return array\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1374970,
                "title": "trapping-rain-water-python-solution",
                "content": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if len(height) <= 1:\\n            return 0\\n        \\n        l = 0\\n        r = len(height) - 1\\n        \\n        if height[l] <= height[r]:\\n            lvl = height[l]\\n \\n        else:\\n            lvl = height[r]\\n           \\n        \\n        water = 0\\n        while(l < r):\\n            if height[l] <= height[r]:\\n                if height[l] <= lvl:\\n                    water += lvl-height[l]\\n                if height[l] > lvl: # but height[l] <= height[r]\\n                    lvl = height[l]\\n                l += 1\\n            else:\\n                if height[r] <= lvl:\\n                    water += lvl-height[r]\\n                if height[r] > lvl: # but height[r] <= height[l]\\n                    lvl = height[r]\\n                r -= 1\\n            \\n        return water\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if len(height) <= 1:\\n            return 0\\n        \\n        l = 0\\n        r = len(height) - 1\\n        \\n        if height[l] <= height[r]:\\n            lvl = height[l]\\n \\n        else:\\n            lvl = height[r]\\n           \\n        \\n        water = 0\\n        while(l < r):\\n            if height[l] <= height[r]:\\n                if height[l] <= lvl:\\n                    water += lvl-height[l]\\n                if height[l] > lvl: # but height[l] <= height[r]\\n                    lvl = height[l]\\n                l += 1\\n            else:\\n                if height[r] <= lvl:\\n                    water += lvl-height[r]\\n                if height[r] > lvl: # but height[r] <= height[l]\\n                    lvl = height[r]\\n                r -= 1\\n            \\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370040,
                "title": "542-01-matrix-python",
                "content": "A 2 must be surrounded by >1, because any 0 would make it a 1. \\nA 3 must be surrounded by >2, because any 1 would make it a 2. \\nRepeatedly update 1s into 2s, 2s into 3s, etc. until no more updates can be done. \\nKeep a set of active cells to avoid looping over old cells. \\n\\n```\\nclass Solution:\\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\t\\t# set up active list of cells \\n        ijs = {(i,j) for i in range(m) for j in range(n) if mat[i][j] > 0}\\n        k = 1\\n        while len(ijs) > 0:\\n            removes = set()\\n            for i,j in ijs:\\n\\t\\t\\t# check 4 neighbors, if all large enough, increase self value  \\n                if mat[max(0,i-1)][j] >= k:\\n                    if mat[min(m-1,i+1)][j] >= k:\\n                        if mat[i][max(0,j-1)] >= k:\\n                            if mat[i][min(n-1,j+1)] >= k:\\n                                mat[i][j] = k + 1\\n                                continue\\n                \\n\\t\\t\\t\\t# if one of the neighbors was smaller, this cell deactivates \\n                removes.add((i,j))\\n\\t\\t\\t# remove any cells slated for removal\\n            ijs.difference_update(removes)   \\n            k += 1\\n        return mat\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\t\\t# set up active list of cells \\n        ijs = {(i,j) for i in range(m) for j in range(n) if mat[i][j] > 0}\\n        k = 1\\n        while len(ijs) > 0:\\n            removes = set()\\n            for i,j in ijs:\\n\\t\\t\\t# check 4 neighbors, if all large enough, increase self value  \\n                if mat[max(0,i-1)][j] >= k:\\n                    if mat[min(m-1,i+1)][j] >= k:\\n                        if mat[i][max(0,j-1)] >= k:\\n                            if mat[i][min(n-1,j+1)] >= k:\\n                                mat[i][j] = k + 1\\n                                continue\\n                \\n\\t\\t\\t\\t# if one of the neighbors was smaller, this cell deactivates \\n                removes.add((i,j))\\n\\t\\t\\t# remove any cells slated for removal\\n            ijs.difference_update(removes)   \\n            k += 1\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370003,
                "title": "01-matrix-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    bool isSafe(int n,int m,int i,int j)\\n    {\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n\\t    int m=mat[0].size();\\n\\t    vector<vector<int>>res(n,vector<int>(m,INT_MAX));\\n\\t    queue<pair<int,int>>pq;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        for(int j=0;j<m;j++)\\n\\t        {\\n\\t               if(mat[i][j]==0)\\n\\t               {\\n\\t                   pq.push({i,j});\\n\\t                   res[i][j]=0;\\n\\t               }\\n\\t        }\\n\\t    }\\n\\t    while(!pq.empty())\\n\\t    {\\n\\t        int i=pq.front().first;\\n\\t        int j=pq.front().second;\\n\\t        pq.pop();\\n\\t        if(isSafe(n,m,i,j+1)==true)\\n\\t        {\\n\\t            if(res[i][j+1]>res[i][j]+1)\\n\\t            {\\n\\t                res[i][j+1]=res[i][j]+1;\\n\\t                pq.push({i,j+1});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i+1,j)==true)\\n\\t        {\\n\\t            if(res[i+1][j]>res[i][j]+1)\\n\\t            {\\n\\t                res[i+1][j]=res[i][j]+1;\\n\\t                pq.push({i+1,j});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i-1,j)==true)\\n\\t        {\\n\\t            if(res[i-1][j]>res[i][j]+1)\\n\\t            {\\n\\t                res[i-1][j]=res[i][j]+1;\\n\\t                pq.push({i-1,j});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i,j-1)==true)\\n\\t        {\\n\\t            if(res[i][j-1]>res[i][j]+1)\\n\\t            {\\n\\t                res[i][j-1]=res[i][j]+1;\\n\\t                pq.push({i,j-1});\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isSafe(int n,int m,int i,int j)\\n    {\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n\\t    int m=mat[0].size();\\n\\t    vector<vector<int>>res(n,vector<int>(m,INT_MAX));\\n\\t    queue<pair<int,int>>pq;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        for(int j=0;j<m;j++)\\n\\t        {\\n\\t               if(mat[i][j]==0)\\n\\t               {\\n\\t                   pq.push({i,j});\\n\\t                   res[i][j]=0;\\n\\t               }\\n\\t        }\\n\\t    }\\n\\t    while(!pq.empty())\\n\\t    {\\n\\t        int i=pq.front().first;\\n\\t        int j=pq.front().second;\\n\\t        pq.pop();\\n\\t        if(isSafe(n,m,i,j+1)==true)\\n\\t        {\\n\\t            if(res[i][j+1]>res[i][j]+1)\\n\\t            {\\n\\t                res[i][j+1]=res[i][j]+1;\\n\\t                pq.push({i,j+1});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i+1,j)==true)\\n\\t        {\\n\\t            if(res[i+1][j]>res[i][j]+1)\\n\\t            {\\n\\t                res[i+1][j]=res[i][j]+1;\\n\\t                pq.push({i+1,j});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i-1,j)==true)\\n\\t        {\\n\\t            if(res[i-1][j]>res[i][j]+1)\\n\\t            {\\n\\t                res[i-1][j]=res[i][j]+1;\\n\\t                pq.push({i-1,j});\\n\\t            }\\n\\t        }\\n\\t        if(isSafe(n,m,i,j-1)==true)\\n\\t        {\\n\\t            if(res[i][j-1]>res[i][j]+1)\\n\\t            {\\n\\t                res[i][j-1]=res[i][j]+1;\\n\\t                pq.push({i,j-1});\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365748,
                "title": "convert-sorted-array-to-binary-search-tree-c-solution",
                "content": "the main idea was to devide the array each time on three segments;\\n\\nlike:\\n\\n```\\n                            a b c d e f g\\nstep 1:\\n                               c \\n\\t\\t\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t\\t     abc        def  \\n\\t\\t\\t\\t\\t   \\n\\t\\tstep 2 :\\n\\t\\t\\n\\t\\t                        c \\n\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t b     e\\n\\t\\t\\t\\t\\t       / \\\\      /\\\\ \\n\\t\\t\\t\\t\\t\\t  a c      d  f\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  and so on .\\n\\t\\t\\n```\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int>v;\\nvoid makeTree(TreeNode * root , int l , int r )\\n{\\n   int mid = (l+r)/2;\\n\\n    root->val = v[mid];\\n \\n   if(l==r)\\n    return;\\n\\n   if( l==mid){\\n\\n       root ->right = new TreeNode();\\n       makeTree(root -> right ,mid+1 ,r );\\n     }\\n    else{\\n      root->left = new TreeNode();\\n      root ->right = new TreeNode();\\n     makeTree(root -> right ,mid+1 ,r );\\n     makeTree( root -> left , l , mid-1);\\n    }\\n return;\\n}\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n         v.assign(nums.size(),0);\\n        for(int i=0 ; i< nums.size() ;i++)\\n        {\\n            v[i]=nums[i];\\n        }\\n        TreeNode * root = new TreeNode();\\n        \\n         makeTree(root ,0, nums.size()-1);   \\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n                            a b c d e f g\\nstep 1:\\n                               c \\n\\t\\t\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t\\t     abc        def  \\n\\t\\t\\t\\t\\t   \\n\\t\\tstep 2 :\\n\\t\\t\\n\\t\\t                        c \\n\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t b     e\\n\\t\\t\\t\\t\\t       / \\\\      /\\\\ \\n\\t\\t\\t\\t\\t\\t  a c      d  f\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  and so on .\\n\\t\\t\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int>v;\\nvoid makeTree(TreeNode * root , int l , int r )\\n{\\n   int mid = (l+r)/2;\\n\\n    root->val = v[mid];\\n \\n   if(l==r)\\n    return;\\n\\n   if( l==mid){\\n\\n       root ->right = new TreeNode();\\n       makeTree(root -> right ,mid+1 ,r );\\n     }\\n    else{\\n      root->left = new TreeNode();\\n      root ->right = new TreeNode();\\n     makeTree(root -> right ,mid+1 ,r );\\n     makeTree( root -> left , l , mid-1);\\n    }\\n return;\\n}\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n         v.assign(nums.size(),0);\\n        for(int i=0 ; i< nums.size() ;i++)\\n        {\\n            v[i]=nums[i];\\n        }\\n        TreeNode * root = new TreeNode();\\n        \\n         makeTree(root ,0, nums.size()-1);   \\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351246,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n\\n    Random r = new Random();\\n    int[] arr;\\n    int[] original;\\n    public Solution(int[] nums) {\\n        arr = nums.clone();\\n        original = nums.clone();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        arr = original.clone();\\n        return arr;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            int random = r.nextInt(i+1); // (i+1) bcs it is till upperboound-1 hence the bound needs to be from 0-i \\n            int temp = arr[i];\\n            arr[i] = arr[random];\\n            arr[random] = temp;\\n        }\\n        return arr;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    Random r = new Random();\\n    int[] arr;\\n    int[] original;\\n    public Solution(int[] nums) {\\n        arr = nums.clone();\\n        original = nums.clone();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        arr = original.clone();\\n        return arr;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            int random = r.nextInt(i+1); // (i+1) bcs it is till upperboound-1 hence the bound needs to be from 0-i \\n            int temp = arr[i];\\n            arr[i] = arr[random];\\n            arr[random] = temp;\\n        }\\n        return arr;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350916,
                "title": "c-using-rand-method-easy-to-understand",
                "content": "**Threee things are to be implemented here:-**\\n\\n# Initializes the object with the integer array nums.\\n1. This is a simple task. Here we have to create an array, and initialize it will all the elements of the given array.\\n2. Since, it should follow the principle of `OOP` we\\'ve to make the array `private`.\\n3. Make sure, no operation is done on this array.\\n\\n# Resets the array\\n1. Just return the data member which was declared in `Step I` .\\n2. It is the orignal array itself.\\n\\n#  Generate shuffling array.\\n1. First, make a method to shuffle the elements of the array. To do achieve this, first we need to do some operation on random indexes.\\n2.  Suppose an operation `XYZ` has to be performed on two elements. For that we should know the indices of both the element. Hence, we can do it by the conventional method, the for loop. But it is necessary to ensure randomness. \\n3.  Hence, the operation `XYZ` will be done randomly, we will use `rand()` operation to randomly generate index.\\n\\nHere is the implementation:- \\n\\n```\\nclass Solution {\\nprivate:\\n    vector<int> temp;    \\npublic:\\n    Solution(vector<int>& nums) {\\n        temp = nums;        \\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return temp;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector <int> temp_2;\\n        temp_2 = temp;\\n        \\n        for(int i = 0;i < temp_2.size();i++){\\n            \\n            //  rand() generates random number. It can generate any number between 1 to temp.size() - 1;\\n            int index = rand() % (i+1);\\n            \\n            // Swap to randomly shuffle the numbers.\\n            swap(temp_2[i],temp_2[index]);\\n        }\\n        return temp_2;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n \\n ```\\n \\n I hope you got it. It was not a good question, but will definitely help you to brush up your `OOP` knowledge.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> temp;    \\npublic:\\n    Solution(vector<int>& nums) {\\n        temp = nums;        \\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return temp;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector <int> temp_2;\\n        temp_2 = temp;\\n        \\n        for(int i = 0;i < temp_2.size();i++){\\n            \\n            //  rand() generates random number. It can generate any number between 1 to temp.size() - 1;\\n            int index = rand() % (i+1);\\n            \\n            // Swap to randomly shuffle the numbers.\\n            swap(temp_2[i],temp_2[index]);\\n        }\\n        return temp_2;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1350047,
                "title": "python-very-easy-and-simple",
                "content": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums):\\n        self.original = nums.copy()\\n        self.random = nums.copy()\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        self.random = self.original.copy()\\n        return self.random\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        random.shuffle(self.random)\\n        return self.random\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums):\\n        self.original = nums.copy()\\n        self.random = nums.copy()\\n\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        \"\"\"\\n        self.random = self.original.copy()\\n        return self.random\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        \"\"\"\\n        random.shuffle(self.random)\\n        return self.random\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165080,
                "title": "simple-and-interesting-problem",
                "content": "Sure, we can say many kinds of shuffle way, but does it really equal opportunities? Let\\'s check out\\n\\nI\\'ll use this code to verify how my shuffle equal opportunities is:\\n\\n## Test code\\n\\n```typescript\\nconst s = new Solution([-6, 10, 184])\\nconst map = {\\n    \"-6,10,184\": 0,\\n    \"-6,184,10\": 0,\\n    \"184,-6,10\": 0,\\n    \"184,10,-6\": 0,\\n    \"10,184,-6\": 0,\\n    \"10,-6,184\": 0,\\n} as any\\n\\nfor (let i = 0; i < 1e4; i++) {\\n    map[s.shuffle().toString()]++\\n    s.reset()\\n}\\nconsole.log(map);\\n```\\n\\n## 1. sort + random\\n\\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        return this.nums.slice().sort(() => 0.5 - Math.random())\\n    }\\n}\\n```\\n\\nAnd after we run test code, we got this:\\n\\n```typescript\\n{\\n  \"-6,10,184\": 3727,\\n  \"-6,184,10\": 643,\\n  \"184,-6,10\": 596,\\n  \"184,10,-6\": 3118,\\n  \"10,184,-6\": 655,\\n  \"10,-6,184\": 1261\\n}\\n```\\n\\nhum, looks not ok, right?\\n\\n## 2. replace first item\\n\\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        const nums = this.nums.slice()\\n        for (let i = 0, j = nums.length; i < j; i++) {\\n            if (Math.random() > 0.5) {\\n                [nums[0], nums[i]] = [nums[i], nums[0]]\\n            }\\n        }\\n        return nums\\n    }\\n}\\n```\\n\\nAnd result is:\\n\\n```javascript\\n{\\n  \"-6,10,184\": 2512,\\n  \"-6,184,10\": 0,\\n  \"184,-6,10\": 2421,\\n  \"184,10,-6\": 2508,\\n  \"10,184,-6\": 0,\\n  \"10,-6,184\": 2559\\n}\\n```\\n\\nemmm\\n\\n## 3.  fisher-yates\\n\\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        const nums = this.nums.slice()\\n        for (let i = 0, j = nums.length; i < j; i++) {\\n            const idx = Math.floor(Math.random() * j) as number\\n            [nums[idx], nums[i]] = [nums[i], nums[idx]]\\n        }\\n        return nums\\n    }\\n}\\n```\\n\\nwola\\n\\n```javascript\\n{\\n  \"-6,10,184\": 1501,\\n  \"-6,184,10\": 1850,\\n  \"184,-6,10\": 1476,\\n  \"184,10,-6\": 1563,\\n  \"10,184,-6\": 1831,\\n  \"10,-6,184\": 1779\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nconst s = new Solution([-6, 10, 184])\\nconst map = {\\n    \"-6,10,184\": 0,\\n    \"-6,184,10\": 0,\\n    \"184,-6,10\": 0,\\n    \"184,10,-6\": 0,\\n    \"10,184,-6\": 0,\\n    \"10,-6,184\": 0,\\n} as any\\n\\nfor (let i = 0; i < 1e4; i++) {\\n    map[s.shuffle().toString()]++\\n    s.reset()\\n}\\nconsole.log(map);\\n```\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        return this.nums.slice().sort(() => 0.5 - Math.random())\\n    }\\n}\\n```\n```typescript\\n{\\n  \"-6,10,184\": 3727,\\n  \"-6,184,10\": 643,\\n  \"184,-6,10\": 596,\\n  \"184,10,-6\": 3118,\\n  \"10,184,-6\": 655,\\n  \"10,-6,184\": 1261\\n}\\n```\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        const nums = this.nums.slice()\\n        for (let i = 0, j = nums.length; i < j; i++) {\\n            if (Math.random() > 0.5) {\\n                [nums[0], nums[i]] = [nums[i], nums[0]]\\n            }\\n        }\\n        return nums\\n    }\\n}\\n```\n```javascript\\n{\\n  \"-6,10,184\": 2512,\\n  \"-6,184,10\": 0,\\n  \"184,-6,10\": 2421,\\n  \"184,10,-6\": 2508,\\n  \"10,184,-6\": 0,\\n  \"10,-6,184\": 2559\\n}\\n```\n```typescript\\nclass Solution {\\n    nums: number[] = []\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    reset(): number[] {\\n        return this.nums\\n    }\\n\\n    shuffle(): number[] {\\n        const nums = this.nums.slice()\\n        for (let i = 0, j = nums.length; i < j; i++) {\\n            const idx = Math.floor(Math.random() * j) as number\\n            [nums[idx], nums[i]] = [nums[i], nums[idx]]\\n        }\\n        return nums\\n    }\\n}\\n```\n```javascript\\n{\\n  \"-6,10,184\": 1501,\\n  \"-6,184,10\": 1850,\\n  \"184,-6,10\": 1476,\\n  \"184,10,-6\": 1563,\\n  \"10,184,-6\": 1831,\\n  \"10,-6,184\": 1779\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784411,
                "title": "c-fisher-yates-shuffle-algorithm",
                "content": "```csharp\\npublic class Solution \\n{\\n    private int[] original;    \\n    Random r;\\n\\n    public Solution(int[] nums) \\n    {\\n        original = nums;        \\n        r = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] Reset()\\n    {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] Shuffle() \\n    {\\n        var shuffled = new int[original.Length];\\n        Array.Copy(original, shuffled, shuffled.Length);\\n                \\n        for(int i = shuffled.Length - 1; i >= 0; i--)\\n        {\\n            int next = r.Next(i + 1);\\n            int t = shuffled[next];\\n            shuffled[next] = shuffled[i];\\n            shuffled[i] = t;\\n        }\\n                \\n        return shuffled;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    private int[] original;    \\n    Random r;\\n\\n    public Solution(int[] nums) \\n    {\\n        original = nums;        \\n        r = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] Reset()\\n    {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] Shuffle() \\n    {\\n        var shuffled = new int[original.Length];\\n        Array.Copy(original, shuffled, shuffled.Length);\\n                \\n        for(int i = shuffled.Length - 1; i >= 0; i--)\\n        {\\n            int next = r.Next(i + 1);\\n            int t = shuffled[next];\\n            shuffled[next] = shuffled[i];\\n            shuffled[i] = t;\\n        }\\n                \\n        return shuffled;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616519,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> original;\\n    vector<int> arr;\\n    \\n    Solution(vector<int>& nums) {\\n        original = nums;\\n        arr = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        if (arr.size()<2) return arr;\\n        for (int i=0; i<arr.size()-1; i++){\\n            int ind = i + rand()%(arr.size()-i);\\n            int temp = arr[ind];\\n            arr[ind] = arr[i];\\n            arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> original;\\n    vector<int> arr;\\n    \\n    Solution(vector<int>& nums) {\\n        original = nums;\\n        arr = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return original;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        if (arr.size()<2) return arr;\\n        for (int i=0; i<arr.size()-1; i++){\\n            int ind = i + rand()%(arr.size()-i);\\n            int temp = arr[ind];\\n            arr[ind] = arr[i];\\n            arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493002,
                "title": "go-golang-o-n-beats-100",
                "content": "```\\nfunc Constructor(nums []int) Solution {\\n    return Solution{arr: nums}\\n}\\n\\n\\n/** Resets the array to its original configuration and return it. */\\nfunc (this *Solution) Reset() []int {\\n    return this.arr\\n}\\n\\n\\n/** Returns a random shuffling of the array. */\\nfunc (this *Solution) Shuffle() []int {\\n    tmp := make([]int, len(this.arr))\\n    copy(tmp, this.arr)\\n    for i := 0; i < len(this.arr); i++ {\\n        r := rand.Intn(len(this.arr))\\n        tmp[i], tmp[r] = tmp[r], tmp[i]\\n    }\\n    return tmp\\n}",
                "solutionTags": [],
                "code": "```\\nfunc Constructor(nums []int) Solution {\\n    return Solution{arr: nums}\\n}\\n\\n\\n/** Resets the array to its original configuration and return it. */\\nfunc (this *Solution) Reset() []int {\\n    return this.arr\\n}\\n\\n\\n/** Returns a random shuffling of the array. */\\nfunc (this *Solution) Shuffle() []int {\\n    tmp := make([]int, len(this.arr))\\n    copy(tmp, this.arr)\\n    for i := 0; i < len(this.arr); i++ {\\n        r := rand.Intn(len(this.arr))\\n        tmp[i], tmp[r] = tmp[r], tmp[i]\\n    }\\n    return tmp\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 389444,
                "title": "three-ruby-solutions-with-o-n-space-complexity",
                "content": "```\\nclass Solution\\n    def initialize(nums)\\n        @nums = nums\\n    end\\n\\n\\tdef reset()\\n        @nums\\n    end\\n\\n    def shuffle()\\n      len = @nums.length\\n      shuffled_array = []\\n      while(shuffled_array.length != len)\\n        random_num = @nums.sample\\n        shuffled_array << random_num unless shuffled_array.include?(random_num)\\n      end\\n      shuffled_array\\n    end\\nend\\n\\n```\\n**SWAPPING**\\n```\\nclass Solution\\n\\n    attr_accessor :nums, :len\\n    def initialize(nums)\\n        @nums = nums\\n        @len = nums.length\\n    end\\n\\n    def reset()\\n        nums\\n    end\\n\\n    def shuffle()\\n      shuffled_array = nums.clone\\n      (0...len).each { |i|\\n        random_idx = rand(i...len)\\n        shuffled_array[i], shuffled_array[random_idx] = shuffled_array[random_idx], shuffled_array[i]\\n      }\\n      shuffled_array\\n    end\\nend\\n```\\n**Without constructing shuffled array for each shuffle(To reduce time complexity)**\\n```\\nclass Solution\\n\\n    attr_accessor :nums, :len, :shuffled_array\\n\\n    def initialize(nums)\\n        @nums = nums\\n        @len = nums.length\\n        @shuffled_array = @nums.clone\\n    end\\n\\n    def reset()\\n        nums\\n    end\\n\\n    def shuffle()\\n      (0...len).each { |i|\\n        random_idx = rand(i...len)\\n        shuffled_array[i], shuffled_array[random_idx] = shuffled_array[random_idx], shuffled_array[i]\\n      }\\n      shuffled_array\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass Solution\\n    def initialize(nums)\\n        @nums = nums\\n    end\\n\\n\\tdef reset()\\n        @nums\\n    end\\n\\n    def shuffle()\\n      len = @nums.length\\n      shuffled_array = []\\n      while(shuffled_array.length != len)\\n        random_num = @nums.sample\\n        shuffled_array << random_num unless shuffled_array.include?(random_num)\\n      end\\n      shuffled_array\\n    end\\nend\\n\\n```\n```\\nclass Solution\\n\\n    attr_accessor :nums, :len\\n    def initialize(nums)\\n        @nums = nums\\n        @len = nums.length\\n    end\\n\\n    def reset()\\n        nums\\n    end\\n\\n    def shuffle()\\n      shuffled_array = nums.clone\\n      (0...len).each { |i|\\n        random_idx = rand(i...len)\\n        shuffled_array[i], shuffled_array[random_idx] = shuffled_array[random_idx], shuffled_array[i]\\n      }\\n      shuffled_array\\n    end\\nend\\n```\n```\\nclass Solution\\n\\n    attr_accessor :nums, :len, :shuffled_array\\n\\n    def initialize(nums)\\n        @nums = nums\\n        @len = nums.length\\n        @shuffled_array = @nums.clone\\n    end\\n\\n    def reset()\\n        nums\\n    end\\n\\n    def shuffle()\\n      (0...len).each { |i|\\n        random_idx = rand(i...len)\\n        shuffled_array[i], shuffled_array[random_idx] = shuffled_array[random_idx], shuffled_array[i]\\n      }\\n      shuffled_array\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374478,
                "title": "javascript-solution-beats-98",
                "content": "Runtime: 216 ms, faster than 98.53% of JavaScript online submissions for Shuffle an Array.\\nMemory Usage: 57.1 MB, less than 100.00% of JavaScript online submissions for Shuffle an Array.\\n\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.cache = new Array(...nums)\\n    this.nums = nums\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.cache\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    const len = this.nums.length\\n    for (let i = 0; i < len; i++) {\\n        const rand = Math.round(Math.random() * (len - 1) + 0);\\n        [this.nums[i], this.nums[rand]] = [this.nums[rand], this.nums[i]]\\n    }\\n    return this.nums\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(nums)\\n * var param_1 = obj.reset()\\n * var param_2 = obj.shuffle()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.cache = new Array(...nums)\\n    this.nums = nums\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.cache\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    const len = this.nums.length\\n    for (let i = 0; i < len; i++) {\\n        const rand = Math.round(Math.random() * (len - 1) + 0);\\n        [this.nums[i], this.nums[rand]] = [this.nums[rand], this.nums[i]]\\n    }\\n    return this.nums\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(nums)\\n * var param_1 = obj.reset()\\n * var param_2 = obj.shuffle()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354913,
                "title": "java-simple-solution",
                "content": "the logic is simple, generate a random number (r) of the array size (n) and swap the number at the index r with the element at index n - 1 and we decrement n. So we continue doing this till we reach the 1st index. I used ArrayCopy since it uses Java Native Interface and is faster than clone(). Reference : https://www.javaspecialists.eu/archive/Issue124.html\\n\\neg : num = [1, 2, 3, 4, 5],  n = 5\\n\\n1)  random generates 1, so we swap num[1] with num[n - 1] which is num[4] and then decrement n\\n     num = [1, 5, 3, 4, 2] , n = 4\\n\\t \\n2) random generates 2 , so we swap num[2] with num[3]\\n\\t num = [1, 5, 4, 3, 2], n = 3\\n\\t\\n3) random generates 0, so swap num[0] with num[2]\\n\\tnum = [4, 5, 1, 3, 2], n = 2\\n\\t\\n4) random generates 0, swap num[0] with num[1]\\n\\tnum = [5, 4, 1, 3, 2], n = 1\\n\\t\\nWe then stop and return the shuffled array.\\n\\t\\n\\n```\\nclass Solution {\\n    Random r;\\n    int original[];\\n    int nums[];\\n    public Solution(int[] nums) {\\n        r = new Random();    \\n        this.nums = nums;\\n        this.original = new int[nums.length]; \\n        System.arraycopy(nums, 0, original, 0, nums.length); \\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        System.arraycopy(original, 0, nums, 0, nums.length);\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int n = nums.length;\\n        while(n > 1){\\n            int index = r.nextInt(n);\\n            swap(nums, index, n - 1);\\n            n--;\\n        }\\n        return nums; \\n    }\\n    \\n    public void swap(int[] a, int i, int j){\\n        int t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Random r;\\n    int original[];\\n    int nums[];\\n    public Solution(int[] nums) {\\n        r = new Random();    \\n        this.nums = nums;\\n        this.original = new int[nums.length]; \\n        System.arraycopy(nums, 0, original, 0, nums.length); \\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        System.arraycopy(original, 0, nums, 0, nums.length);\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int n = nums.length;\\n        while(n > 1){\\n            int index = r.nextInt(n);\\n            swap(nums, index, n - 1);\\n            n--;\\n        }\\n        return nums; \\n    }\\n    \\n    public void swap(int[] a, int i, int j){\\n        int t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329091,
                "title": "c-solution-not-accepted",
                "content": "Can someone please point out what\\'s wrong with this solution?\\n\\n```class Solution {\\npublic:\\n    vector<int> p, pos;\\n    \\n    Solution(vector<int>& nums) {\\n        p = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        if(pos.empty()) return p;\\n        int n = pos.size();\\n        for(int i = 0;  i < n; i++){\\n            swap(p[i], p[pos[i]]);\\n        }\\n        return p;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        int n = p.size();\\n        pos.clear();\\n        for(int i = 0; i < n; i++){\\n            float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\\n            int idx = floor(n*r);\\n            pos.push_back(idx);\\n            swap(p[i], p[idx]);\\n        }\\n        return p;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    vector<int> p, pos;\\n    \\n    Solution(vector<int>& nums) {\\n        p = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        if(pos.empty()) return p;\\n        int n = pos.size();\\n        for(int i = 0;  i < n; i++){\\n            swap(p[i], p[pos[i]]);\\n        }\\n        return p;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        int n = p.size();\\n        pos.clear();\\n        for(int i = 0; i < n; i++){\\n            float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\\n            int idx = floor(n*r);\\n            pos.push_back(idx);\\n            swap(p[i], p[idx]);\\n        }\\n        return p;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */```",
                "codeTag": "Java"
            },
            {
                "id": 328574,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums[:]\\n        self.now = nums[:]\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.now = self.nums[:] # list(self.nums) also create new array\\n        return self.now\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in xrange(len(self.now) - 1):\\n            idx = random.randint(i,len(self.now) - 1)\\n            self.now[i],self.now[idx] = self.now[idx],self.now[i]\\n        \\n        return self.now\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums[:]\\n        self.now = nums[:]\\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        self.now = self.nums[:] # list(self.nums) also create new array\\n        return self.now\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in xrange(len(self.now) - 1):\\n            idx = random.randint(i,len(self.now) - 1)\\n            self.now[i],self.now[idx] = self.now[idx],self.now[i]\\n        \\n        return self.now\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282166,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n\\n    int[] nums;\\n        \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n\\t\\tint size = nums.length;\\n\\t\\tint[] res = new int[size];\\n\\t\\tArrayList<Integer> hat = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\that.add(nums[i]);\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (!hat.isEmpty()) {\\n\\t\\t\\tRandom r = new Random();\\n\\t\\t\\tres[i++] = hat.remove(r.nextInt(hat.size()));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int[] nums;\\n        \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n\\t\\tint size = nums.length;\\n\\t\\tint[] res = new int[size];\\n\\t\\tArrayList<Integer> hat = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\that.add(nums[i]);\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (!hat.isEmpty()) {\\n\\t\\t\\tRandom r = new Random();\\n\\t\\t\\tres[i++] = hat.remove(r.nextInt(hat.size()));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267712,
                "title": "python-code-with-comments-90-faster",
                "content": "```\\nimport random \\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        #create instance of nums to be used in the below methods \\n        self.nums_shuffle=nums\\n        self.original=list(nums)\\n       \\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        #return the original list \\n        return self.original\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        #shuffling using fiesher yates algorithm \\n        for i in range(len(self.nums_shuffle)):\\n            \\n            #generate random numbers \\n            j=random.randint(i,len(self.nums_shuffle)-1)\\n            \\n            #swap the elements \\n            self.nums_shuffle[i],self.nums_shuffle[j] = self.nums_shuffle[j],self.nums_shuffle[i]\\n            \\n        return self.nums_shuffle\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random \\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        #create instance of nums to be used in the below methods \\n        self.nums_shuffle=nums\\n        self.original=list(nums)\\n       \\n    def reset(self):\\n        \"\"\"\\n        Resets the array to its original configuration and return it.\\n        :rtype: List[int]\\n        \"\"\"\\n        #return the original list \\n        return self.original\\n\\n    def shuffle(self):\\n        \"\"\"\\n        Returns a random shuffling of the array.\\n        :rtype: List[int]\\n        \"\"\"\\n        #shuffling using fiesher yates algorithm \\n        for i in range(len(self.nums_shuffle)):\\n            \\n            #generate random numbers \\n            j=random.randint(i,len(self.nums_shuffle)-1)\\n            \\n            #swap the elements \\n            self.nums_shuffle[i],self.nums_shuffle[j] = self.nums_shuffle[j],self.nums_shuffle[i]\\n            \\n        return self.nums_shuffle\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247470,
                "title": "optimized-accepted-java-solution",
                "content": "The general idea is to use an `originalNums` to keep track of the original nums array and a copy to do shuffling. The shuffling part is borrowed from `Collections.shuffle()` API from JDK. Check out the code below:\\n\\n```java\\nclass Solution {\\n    \\n    private int[] originalNums; // To keep track of the original nums array\\n    private int[] nums; // To do shuffling\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n        if (nums == null) {\\n            return;\\n        }\\n        this.originalNums = nums;\\n        this.nums = nums.clone();\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return this.originalNums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        for (int i = this.nums.length; i > 1; i--) {\\n            swap(i-1, random.nextInt(i));\\n        }\\n        return this.nums;\\n    }\\n    \\n    private void swap(int i, int j) {\\n        if (i == j) {\\n            return;\\n        }\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    private int[] originalNums; // To keep track of the original nums array\\n    private int[] nums; // To do shuffling\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n        if (nums == null) {\\n            return;\\n        }\\n        this.originalNums = nums;\\n        this.nums = nums.clone();\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return this.originalNums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        for (int i = this.nums.length; i > 1; i--) {\\n            swap(i-1, random.nextInt(i));\\n        }\\n        return this.nums;\\n    }\\n    \\n    private void swap(int i, int j) {\\n        if (i == j) {\\n            return;\\n        }\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229859,
                "title": "c-6-lines",
                "content": "```\\nvector<int> arr;\\nSolution(vector<int> nums) { swap(arr, nums); }\\nvector<int> reset() { return arr; }\\nvector<int> shuffle() {\\n  vector<int> sh = arr;\\n  for (auto i = 0; i < sh.size(); ++i) swap(sh[i], sh[rand() % sh.size()]);\\n  return sh;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> arr;\\nSolution(vector<int> nums) { swap(arr, nums); }\\nvector<int> reset() { return arr; }\\nvector<int> shuffle() {\\n  vector<int> sh = arr;\\n  for (auto i = 0; i < sh.size(); ++i) swap(sh[i], sh[rand() % sh.size()]);\\n  return sh;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197912,
                "title": "java-150ms-faster-than-94",
                "content": "```\\nclass Solution {\\n    int[] a;\\n    Random random;\\n\\n    public Solution(int[] nums) {\\n        a = nums;\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return a;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int len = a.length;\\n        int[] shuffledNums = Arrays.copyOf(a, len);\\n        for (int i = 0; i < len; i++) {\\n            int randomPosition = i + random.nextInt(len - i);\\n            int temp = shuffledNums[i];\\n            shuffledNums[i] = shuffledNums[randomPosition];\\n            shuffledNums[randomPosition] = temp;\\n        }\\n        return shuffledNums;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] a;\\n    Random random;\\n\\n    public Solution(int[] nums) {\\n        a = nums;\\n        random = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] reset() {\\n        return a;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] shuffle() {\\n        int len = a.length;\\n        int[] shuffledNums = Arrays.copyOf(a, len);\\n        for (int i = 0; i < len; i++) {\\n            int randomPosition = i + random.nextInt(len - i);\\n            int temp = shuffledNums[i];\\n            shuffledNums[i] = shuffledNums[randomPosition];\\n            shuffledNums[randomPosition] = temp;\\n        }\\n        return shuffledNums;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187910,
                "title": "accepted-c-solution",
                "content": "```\ntypedef struct {\n    int size;\n    int *original;\n    int *array;\n} Solution;\n\nSolution* solutionCreate(int* nums, int size) {\n    Solution *solution = (Solution *) malloc(sizeof(Solution));\n    solution->original = (int *) malloc((sizeof(int) * size));\n    solution->size = size;\n    memcpy(solution->original, nums, sizeof(int) * size);\n    solution->array = nums;\n    return solution;\n}\n\n/** Resets the array to its original configuration and return it. */\nint* solutionReset(Solution* obj, int *returnSize) {\n    *returnSize = obj->size;\n    obj->array = (int *) malloc((sizeof(int) * obj->size));\n    memcpy(obj->array, obj->original, sizeof(int) * obj->size);\n    return obj->array;\n}\n\n/** Returns a random shuffling of the array. */\nint* solutionShuffle(Solution* obj, int *returnSize) {\n    int t, n_rand;\n    for (int i = 0; i < obj->size; i++) {\n        t = obj->array[i];\n        n_rand = rand() % (obj->size - i) + i;\n        obj->array[i] = obj->array[n_rand];\n        obj->array[n_rand] = t;\n    }\n    *returnSize = obj->size;\n    return obj->array;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj->original);\n    free(obj->array);\n    free(obj);\n}\n```",
                "solutionTags": [],
                "code": "```\ntypedef struct {\n    int size;\n    int *original;\n    int *array;\n} Solution;\n\nSolution* solutionCreate(int* nums, int size) {\n    Solution *solution = (Solution *) malloc(sizeof(Solution));\n    solution->original = (int *) malloc((sizeof(int) * size));\n    solution->size = size;\n    memcpy(solution->original, nums, sizeof(int) * size);\n    solution->array = nums;\n    return solution;\n}\n\n/** Resets the array to its original configuration and return it. */\nint* solutionReset(Solution* obj, int *returnSize) {\n    *returnSize = obj->size;\n    obj->array = (int *) malloc((sizeof(int) * obj->size));\n    memcpy(obj->array, obj->original, sizeof(int) * obj->size);\n    return obj->array;\n}\n\n/** Returns a random shuffling of the array. */\nint* solutionShuffle(Solution* obj, int *returnSize) {\n    int t, n_rand;\n    for (int i = 0; i < obj->size; i++) {\n        t = obj->array[i];\n        n_rand = rand() % (obj->size - i) + i;\n        obj->array[i] = obj->array[n_rand];\n        obj->array[n_rand] = t;\n    }\n    *returnSize = obj->size;\n    return obj->array;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj->original);\n    free(obj->array);\n    free(obj);\n}\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149793,
                "title": "python-94-fisher-yates",
                "content": "```python\\nfrom random import randint\\n\\n\\nclass Solution(object):\\n    def __init__(self, a):\\n        self._orig = [x for x in a]\\n        self._a = a\\n\\n    def reset(self):\\n        self._a = [x for x in self._orig]\\n        return self._a\\n\\n    def shuffle(self):\\n        n, a = len(self._a), self._a\\n        for i in range(n):\\n            j = randint(i, n-1)\\n            a[i], a[j] = a[j], a[i]\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom random import randint\\n\\n\\nclass Solution(object):\\n    def __init__(self, a):\\n        self._orig = [x for x in a]\\n        self._a = a\\n\\n    def reset(self):\\n        self._a = [x for x in self._orig]\\n        return self._a\\n\\n    def shuffle(self):\\n        n, a = len(self._a), self._a\\n        for i in range(n):\\n            j = randint(i, n-1)\\n            a[i], a[j] = a[j], a[i]\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141333,
                "title": "beats-100-c-solution",
                "content": "````\\npublic class Solution {\\n    private Random rand;\\n    private int[] nums;\\n    //private int[] copiedNums;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rand = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] Reset() {\\n        return this.nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] Shuffle() \\n    {\\n        var copiedNums = new int[this.nums.Length];\\n        Array.Copy(this.nums, copiedNums, this.nums.Length);\\n\\n        if(this.nums != null)\\n        {\\n            int last = copiedNums.Length - 1;\\n            for (int i = 1; i < copiedNums.Length; i++)\\n            {\\n                //  the range of return values includes minValue but not maxValue\\n                Swap(copiedNums, rand.Next(0, last+1), last);\\n                last--;\\n            }\\n            return copiedNums;\\n        }\\n\\n        return this.nums;\\n    }\\n    \\n    private void Swap(int [] arr, int loc1, int loc2 )\\n        {\\n            int temp = arr[loc1];\\n            arr[loc1] = arr[loc2];\\n            arr[loc2] = temp;\\n        }\\n}\\n\\n````",
                "solutionTags": [],
                "code": "````\\npublic class Solution {\\n    private Random rand;\\n    private int[] nums;\\n    //private int[] copiedNums;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rand = new Random();\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    public int[] Reset() {\\n        return this.nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    public int[] Shuffle() \\n    {\\n        var copiedNums = new int[this.nums.Length];\\n        Array.Copy(this.nums, copiedNums, this.nums.Length);\\n\\n        if(this.nums != null)\\n        {\\n            int last = copiedNums.Length - 1;\\n            for (int i = 1; i < copiedNums.Length; i++)\\n            {\\n                //  the range of return values includes minValue but not maxValue\\n                Swap(copiedNums, rand.Next(0, last+1), last);\\n                last--;\\n            }\\n            return copiedNums;\\n        }\\n\\n        return this.nums;\\n    }\\n    \\n    private void Swap(int [] arr, int loc1, int loc2 )\\n        {\\n            int temp = arr[loc1];\\n            arr[loc1] = arr[loc2];\\n            arr[loc2] = temp;\\n        }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137196,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar Solution = function(nums) {\\n    this.nums = [...nums];\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    let random = [];\\n    let numsCopy = [...this.nums];\\n    while(numsCopy.length > 0){\\n        let index = Math.floor(Math.random() * numsCopy.length);\\n        random.push(numsCopy[index]);\\n        numsCopy.splice(index, 1);\\n    }\\n    return random;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Solution = function(nums) {\\n    this.nums = [...nums];\\n};\\n\\n/**\\n * Resets the array to its original configuration and return it.\\n * @return {number[]}\\n */\\nSolution.prototype.reset = function() {\\n    return this.nums;\\n};\\n\\n/**\\n * Returns a random shuffling of the array.\\n * @return {number[]}\\n */\\nSolution.prototype.shuffle = function() {\\n    let random = [];\\n    let numsCopy = [...this.nums];\\n    while(numsCopy.length > 0){\\n        let index = Math.floor(Math.random() * numsCopy.length);\\n        random.push(numsCopy[index]);\\n        numsCopy.splice(index, 1);\\n    }\\n    return random;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116191,
                "title": "declarative-solutions-in-swift-and-javascript",
                "content": "For some reason, there is no option on this problem to sumbit a `Swift` solution. Here is how I have implemented it in the past in production code. It favors concision and readability over performance, but the complexity of O(n *log* n)  has always been sufficient for my needs. (Note: it isn't in the `class Solution {}` format LeetCode always seems to use with `Swift`.)\n\n```swift\nextension Array {\n    var shuffled: [Element] {\n        return self.map    { (arc4random(), $0) }\n                   .sorted { $0.0 < $1.0 }\n                   .map    { $0.1 }\n    }\n}\n```\n\nHere is the equivalent I wrote in `JavaScript` a couple years ago.\n```JavaScript\nvar array_utils_module = {\n    shuffled: function () {\n        return this.map( n => [ Math.random(), n ] )\n\t\t   .sort()\n\t\t   .map( n => n[1] );\n    }\n}\n\nmodule.exports = array_utils_module;\n```\n",
                "solutionTags": [],
                "code": "```swift\nextension Array {\n    var shuffled: [Element] {\n        return self.map    { (arc4random(), $0) }\n                   .sorted { $0.0 < $1.0 }\n                   .map    { $0.1 }\n    }\n}\n```\n```JavaScript\nvar array_utils_module = {\n    shuffled: function () {\n        return this.map( n => [ Math.random(), n ] )\n\t\t   .sort()\n\t\t   .map( n => n[1] );\n    }\n}\n\nmodule.exports = array_utils_module;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116151,
                "title": "a-simple-c-solution-beats-100-00-accepted",
                "content": "Runtime: 88 ms\n```\ntypedef struct {\n    int *original;\n    int size;\n} Solution;\n\nSolution* solutionCreate(int* nums, int size) {\n    Solution* obj=(Solution*)malloc(sizeof(Solution));\n    obj->original=nums;\n    obj->size=size;\n    return obj;\n}\n\n/** Resets the array to its original configuration and return it. */\nint* solutionReset(Solution* obj, int *returnSize) {\n    *returnSize=obj->size;\n    return obj->original;\n}\n\n/** Returns a random shuffling of the array. */\nint* solutionShuffle(Solution* obj, int *returnSize) {\n    *returnSize=obj->size;\n    int *ret=(int*)calloc((*returnSize),sizeof(int));\n    int *array=(int*)calloc((*returnSize),sizeof(int));\n    int temp=0;\n    int count=-1;\n    for(int i=0;i<*returnSize;i++){\n        temp=random()%((*returnSize)-i);\n        for(int j=0;j<*returnSize;j++){\n            if(array[j]==0){\n                count++;\n                if(count==temp){\n                    array[j]=1;\n                    count=-1;\n                    ret[i]=obj->original[j];\n                    break;\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj->original);\n    free(obj);\n}\n\n/**\n * Your Solution struct will be instantiated and called as such:\n * struct Solution* obj = solutionCreate(nums, size);\n * int* param_1 = solutionReset(obj);\n * int* param_2 = solutionShuffle(obj);\n * solutionFree(obj);\n */\n````",
                "solutionTags": [],
                "code": "```\ntypedef struct {\n    int *original;\n    int size;\n} Solution;\n\nSolution* solutionCreate(int* nums, int size) {\n    Solution* obj=(Solution*)malloc(sizeof(Solution));\n    obj->original=nums;\n    obj->size=size;\n    return obj;\n}\n\n/** Resets the array to its original configuration and return it. */\nint* solutionReset(Solution* obj, int *returnSize) {\n    *returnSize=obj->size;\n    return obj->original;\n}\n\n/** Returns a random shuffling of the array. */\nint* solutionShuffle(Solution* obj, int *returnSize) {\n    *returnSize=obj->size;\n    int *ret=(int*)calloc((*returnSize),sizeof(int));\n    int *array=(int*)calloc((*returnSize),sizeof(int));\n    int temp=0;\n    int count=-1;\n    for(int i=0;i<*returnSize;i++){\n        temp=random()%((*returnSize)-i);\n        for(int j=0;j<*returnSize;j++){\n            if(array[j]==0){\n                count++;\n                if(count==temp){\n                    array[j]=1;\n                    count=-1;\n                    ret[i]=obj->original[j];\n                    break;\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj->original);\n    free(obj);\n}\n\n/**\n * Your Solution struct will be instantiated and called as such:\n * struct Solution* obj = solutionCreate(nums, size);\n * int* param_1 = solutionReset(obj);\n * int* param_2 = solutionShuffle(obj);\n * solutionFree(obj);\n */\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85963,
                "title": "shuffle-clean-c-8-lines-put-srand-in-constructor",
                "content": "```\\nclass Solution {\\n    vector<int>nums;\\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums=nums;\\n        srand((unsigned)time(0));\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int>res(nums.begin(),nums.end());\\n        for(int i=0;i<res.size();i++)\\n            swap(res[i],res[rand()%res.size()]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>nums;\\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums=nums;\\n        srand((unsigned)time(0));\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return nums;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        vector<int>res(nums.begin(),nums.end());\\n        for(int i=0;i<res.size();i++)\\n            swap(res[i],res[rand()%res.size()]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448142,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n// initializes first\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }\\n    // return direct nums\\n    public int[] reset() {\\n       return nums; \\n    }\\n    public int[] shuffle() {\\n        int[] shuffle = nums.clone();\\n       // suffle the nums (index)nums.length-1 to 0th index\\n        for(int i = nums.length-1; i > 0; i--){\\n            int index = random.nextInt(i + 1);\\n            // swap nums\\n            int temp =shuffle[i];\\n          shuffle[i] = shuffle[index];\\n            shuffle[index] = temp;\\n        }\\n        return shuffle;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n// initializes first\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }\\n    // return direct nums\\n    public int[] reset() {\\n       return nums; \\n    }\\n    public int[] shuffle() {\\n        int[] shuffle = nums.clone();\\n       // suffle the nums (index)nums.length-1 to 0th index\\n        for(int i = nums.length-1; i > 0; i--){\\n            int index = random.nextInt(i + 1);\\n            // swap nums\\n            int temp =shuffle[i];\\n          shuffle[i] = shuffle[index];\\n            shuffle[index] = temp;\\n        }\\n        return shuffle;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371580,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple swapping of indexes and holding the temporary array values.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWell quite a simple question we can simply store the orignal array in temp and return it for the rest func()\\nFor the shuffle function we can get the index of random and swap it with the array index starting from back;\\nIn each iteration we decrement the array size.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>orignal;\\nint n;\\n    Solution(vector<int>& nums) {\\n     orignal=nums;\\n        n=nums.size();\\n    }\\n    \\n    vector<int> reset() {\\n       return orignal;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int>shuffled=orignal;\\n        int back=n;\\n        for(int i=n-1;i>0;i--){\\n            int j=rand()%back;\\n            swap(shuffled[i],shuffled[j]);\\n            back--;\\n        }\\nreturn shuffled;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>orignal;\\nint n;\\n    Solution(vector<int>& nums) {\\n     orignal=nums;\\n        n=nums.size();\\n    }\\n    \\n    vector<int> reset() {\\n       return orignal;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int>shuffled=orignal;\\n        int back=n;\\n        for(int i=n-1;i>0;i--){\\n            int j=rand()%back;\\n            swap(shuffled[i],shuffled[j]);\\n            back--;\\n        }\\nreturn shuffled;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332152,
                "title": "beats-72-88-of-python3-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In the `__init__` method we will create two instances one is `self.nums` which is input Array given to us and second is  `self.original` which is copy of original input array.\\n\\n- In the reset method we will just return the `self.original` which is input array given to us. \\n\\n- In the shuffle method we will iterate thorough the array and we will take random index j which will range from `i` to `len(nums)` and we will swap elements in i th and j th index and we will return the array. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        #given arr\\n        self.nums = nums\\n        #copy of given array to return at time of reset\\n        self.original = list(nums)\\n\\n    def reset(self) -> List[int]:\\n        #return original array that we stored earlier\\n        return self.original\\n\\n    def shuffle(self) -> List[int]:\\n        for i in range(len(self.nums)):\\n            # Choose a random index j from i to n-1\\n            j = random.randrange(i, len(self.nums))\\n            # Swap nums[i] and nums[j]\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        #given arr\\n        self.nums = nums\\n        #copy of given array to return at time of reset\\n        self.original = list(nums)\\n\\n    def reset(self) -> List[int]:\\n        #return original array that we stored earlier\\n        return self.original\\n\\n    def shuffle(self) -> List[int]:\\n        for i in range(len(self.nums)):\\n            # Choose a random index j from i to n-1\\n            j = random.randrange(i, len(self.nums))\\n            # Swap nums[i] and nums[j]\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278878,
                "title": "most-easiest-solution-in-ruby-only-3-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n\\n=begin\\n    :type nums: Integer[]\\n=end\\n    def initialize(nums)\\n        @n = nums\\n    end\\n\\n\\n=begin\\n    :rtype: Integer[]\\n=end\\n    def reset()\\n        @n\\n    end\\n\\n\\n=begin\\n    :rtype: Integer[]\\n=end\\n    def shuffle()\\n        @n.shuffle\\n    end\\n\\n\\nend\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution.new(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass Solution\\n\\n=begin\\n    :type nums: Integer[]\\n=end\\n    def initialize(nums)\\n        @n = nums\\n    end\\n\\n\\n=begin\\n    :rtype: Integer[]\\n=end\\n    def reset()\\n        @n\\n    end\\n\\n\\n=begin\\n    :rtype: Integer[]\\n=end\\n    def shuffle()\\n        @n.shuffle\\n    end\\n\\n\\nend\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution.new(nums)\\n# param_1 = obj.reset()\\n# param_2 = obj.shuffle()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238884,
                "title": "c-short-fast-solution",
                "content": "Do you wonder why I use **arr.ToArray()**?  Well, as it\\'s necessary to create a copy of an array this is the easiest way to do that.\\nJust try to run tests without it and you will find out that **Shuffle()** method will shuffle initial array too.\\n\\n***Note:*** Use **.CopyTo()** instead of **.ToArray()**\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    int[] arr;\\n    int[] newArr;\\n    Random rnd = new Random();\\n    public Solution(int[] nums) => (arr, newArr) = (nums, new int[nums.Length]);\\n    public int[] Reset() => arr;\\n\\n    public int[] Shuffle()\\n    {\\n        arr.CopyTo(newArr, 0);\\n        for (int i = newArr.Length - 1; i > 0; i--)\\n        {\\n            int k = rnd.Next(i + 1);\\n            (newArr[k], newArr[i]) = (newArr[i], newArr[k]);\\n        }\\n        return newArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\npublic class Solution\\n{\\n    int[] arr;\\n    int[] newArr;\\n    Random rnd = new Random();\\n    public Solution(int[] nums) => (arr, newArr) = (nums, new int[nums.Length]);\\n    public int[] Reset() => arr;\\n\\n    public int[] Shuffle()\\n    {\\n        arr.CopyTo(newArr, 0);\\n        for (int i = newArr.Length - 1; i > 0; i--)\\n        {\\n            int k = rnd.Next(i + 1);\\n            (newArr[k], newArr[i]) = (newArr[i], newArr[k]);\\n        }\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837693,
                "title": "simple-scala-solution",
                "content": "```\\n  import scala.util.chaining._\\n\\n  class Solution(_nums: Array[Int]) {\\n\\n    val rand = new util.Random\\n    val shuffled: Array[Int] = _nums.clone()\\n\\n    def reset(): Array[Int] = {\\n      _nums\\n    }\\n\\n    def shuffle(): Array[Int] = {\\n      var maxIndex = _nums.length\\n      _nums.indices.map {\\n        _ =>\\n          val pick = rand.between(0, maxIndex)\\n          shuffled(pick).tap {\\n            pickedVal =>\\n              shuffled(pick) = shuffled(maxIndex - 1)\\n              shuffled(maxIndex - 1) = pickedVal\\n              maxIndex -= 1\\n          }\\n      }.toArray\\n\\n    }\\n\\n  }\\n  ```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  import scala.util.chaining._\\n\\n  class Solution(_nums: Array[Int]) {\\n\\n    val rand = new util.Random\\n    val shuffled: Array[Int] = _nums.clone()\\n\\n    def reset(): Array[Int] = {\\n      _nums\\n    }\\n\\n    def shuffle(): Array[Int] = {\\n      var maxIndex = _nums.length\\n      _nums.indices.map {\\n        _ =>\\n          val pick = rand.between(0, maxIndex)\\n          shuffled(pick).tap {\\n            pickedVal =>\\n              shuffled(pick) = shuffled(maxIndex - 1)\\n              shuffled(maxIndex - 1) = pickedVal\\n              maxIndex -= 1\\n          }\\n      }.toArray\\n\\n    }\\n\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2580406,
                "title": "video-explicaci-n-en-espa-ol",
                "content": "https://www.youtube.com/watch?v=bQrOOOeXXeY&ab_channel=Leetcodeenespa%C3%B1ol",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "https://www.youtube.com/watch?v=bQrOOOeXXeY&ab_channel=Leetcodeenespa%C3%B1ol",
                "codeTag": "Unknown"
            },
            {
                "id": 2561711,
                "title": "93-fatser-fisher-yates-shuffle-o-n-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/4222267b-de51-4df4-9361-91433fe2d215_1662889984.3572574.png)\\n\\n\\n```\\npublic class Solution \\n{\\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) \\n    {\\n        this.nums = nums;\\n    } \\n    \\n    public int[] Reset() {\\n        return nums;\\n    }\\n    \\n    public int[] Shuffle() \\n    {\\n        int len = nums.Length;\\n        int[] numsCopy = new int[len];\\n        Array.Copy(nums, numsCopy, len); // create a new array to play with as we have to return original array in reset method\\n        \\n        for(int i= len-1; i>=0; i--) // In Fisher\\u2013Yates shuffle\\'s algorithm we start shuffing from last index, hence reverse loop\\n        {\\n            int randomNum = rand.Next(i+1); // generate random number from 0 to i, as we don\\'t shuffle number which are already done shuffling from right side. for e.g. [1 2 3], random number limit will be 0 - 2. But we are passing rand.Nex(3) right? Random.Next it sets boudary to -1, hence 3 - 1 = 2.\\n\\t\\t\\t\\n\\t\\t\\t//This is plain swap \\n            int temp = numsCopy[i];\\n            numsCopy[i] = numsCopy[randomNum];\\n            numsCopy[randomNum] = temp;\\n        }\\n        return numsCopy;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) \\n    {\\n        this.nums = nums;\\n    } \\n    \\n    public int[] Reset() {\\n        return nums;\\n    }\\n    \\n    public int[] Shuffle() \\n    {\\n        int len = nums.Length;\\n        int[] numsCopy = new int[len];\\n        Array.Copy(nums, numsCopy, len); // create a new array to play with as we have to return original array in reset method\\n        \\n        for(int i= len-1; i>=0; i--) // In Fisher\\u2013Yates shuffle\\'s algorithm we start shuffing from last index, hence reverse loop\\n        {\\n            int randomNum = rand.Next(i+1); // generate random number from 0 to i, as we don\\'t shuffle number which are already done shuffling from right side. for e.g. [1 2 3], random number limit will be 0 - 2. But we are passing rand.Nex(3) right? Random.Next it sets boudary to -1, hence 3 - 1 = 2.\\n\\t\\t\\t\\n\\t\\t\\t//This is plain swap \\n            int temp = numsCopy[i];\\n            numsCopy[i] = numsCopy[randomNum];\\n            numsCopy[randomNum] = temp;\\n        }\\n        return numsCopy;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554641,
                "title": "easy-accepted-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    Random rand;\\n    int len;\\n    int[] shuffled;\\n    int[] original;\\n\\n    public Solution(int[] nums) {\\n        \\n        rand = new Random();\\n        len = nums.length;\\n        shuffled = new int[len];\\n        original = nums;\\n    }\\n    \\n    public int[] reset() {\\n        \\n        return original;\\n    }\\n    \\n    public int[] shuffle() {\\n        \\n        Arrays.fill(shuffled, Integer.MIN_VALUE);        \\n        for(int i=0; i<len;){\\n            int newPos = rand.nextInt(len);\\n            if(shuffled[newPos]==Integer.MIN_VALUE){\\n                shuffled[newPos] = original[i];\\n                i++;\\n            }\\n        }\\n        return shuffled;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Random rand;\\n    int len;\\n    int[] shuffled;\\n    int[] original;\\n\\n    public Solution(int[] nums) {\\n        \\n        rand = new Random();\\n        len = nums.length;\\n        shuffled = new int[len];\\n        original = nums;\\n    }\\n    \\n    public int[] reset() {\\n        \\n        return original;\\n    }\\n    \\n    public int[] shuffle() {\\n        \\n        Arrays.fill(shuffled, Integer.MIN_VALUE);        \\n        for(int i=0; i<len;){\\n            int newPos = rand.nextInt(len);\\n            if(shuffled[newPos]==Integer.MIN_VALUE){\\n                shuffled[newPos] = original[i];\\n                i++;\\n            }\\n        }\\n        return shuffled;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442062,
                "title": "easy-solution-in-c",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> initial;\\n    Solution(vector<int>& nums) {\\n        initial=nums;\\n    }\\n    \\n    vector<int> reset() {\\n        return initial;\\n    }\\n    \\n    vector<int> shuffle() {\\n        int size=initial.size();\\n        vector<int> newVec(initial.begin(),initial.end());\\n        for(int i=0;i<size;i++){\\n            int ind=rand()%size;\\n            swap(newVec[i],newVec[ind]);\\n        }\\n        return newVec;\\n    }\\n};\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> initial;\\n    Solution(vector<int>& nums) {\\n        initial=nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2441657,
                "title": "java-easy-solution",
                "content": "class Solution {\\n\\n\\t//reset is origin return;\\n\\t//shuffle is origin shuffle return;\\n\\t\\n    private int[] arr;\\n    \\n    public Solution(int[] nums) {\\n        arr = nums.clone();        \\n    }\\n    \\n    public int[] reset() {\\n        return arr;\\n    }\\n    \\n    public int[] shuffle() {\\n        int[] newArr = arr.clone();\\n        \\n        for(int i = 0; i < newArr.length; i++) {\\n            int idx = (int) (Math.random() * (i + 1));  \\n            swap(newArr, idx, i);\\n        }\\n        return newArr;        \\n    }\\n    \\n    public void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\t//reset is origin return;\\n\\t//shuffle is origin shuffle return;\\n\\t\\n    private int[] arr;\\n    \\n    public Solution(int[] nums) {\\n        arr = nums.clone();        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2406898,
                "title": "rust-standard-solution-with-comments",
                "content": "My impression is that the whole idea here is to learn to implement Fisher-Yates or some other appropriate shuffling algorithm, so calling the `shuffle` method from `rand` kind of defeats that purpose. And looking at other solutions, why on earth would you want to keep both the original `Vec` and a shuffled copy in the `Solution` struct? Too bad downvoting a solution costs a reputation point, because having such solutions upvoted teaches bad programming habits. As I found no \"standard\" solution, here is mine:\\n\\n```\\nuse rand::{self, Rng};\\n\\nstruct Solution {\\n    nums: Vec<i32>,\\n}\\n\\nimpl Solution {\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self { nums }\\n    }\\n\\n    fn reset(&self) -> Vec<i32> {\\n        self.nums.clone()\\n    }\\n\\n    fn shuffle(&self) -> Vec<i32> {\\n        let mut rng = rand::thread_rng();\\n        let mut shuffled = self.nums.clone();\\n        let n = shuffled.len();\\n        for i in 0..n {\\n            shuffled.swap(i, rng.gen_range(i, n));\\n        }\\n        shuffled\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse rand::{self, Rng};\\n\\nstruct Solution {\\n    nums: Vec<i32>,\\n}\\n\\nimpl Solution {\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self { nums }\\n    }\\n\\n    fn reset(&self) -> Vec<i32> {\\n        self.nums.clone()\\n    }\\n\\n    fn shuffle(&self) -> Vec<i32> {\\n        let mut rng = rand::thread_rng();\\n        let mut shuffled = self.nums.clone();\\n        let n = shuffled.len();\\n        for i in 0..n {\\n            shuffled.swap(i, rng.gen_range(i, n));\\n        }\\n        shuffled\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234258,
                "title": "java-easy-and-clean-code",
                "content": "\\'\\'\\'\\nclass Solution {\\n    \\n    int[] arr;\\n\\n    public Solution(int[] nums) {\\n        arr=nums;\\n    }\\n    \\n    public int[] reset() {\\n        \\n        return arr;\\n    }\\n    \\n    public int[] shuffle() {\\n        \\n        int[] nums=new int[arr.length];\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        for(int i=0;i<arr.length;i++)\\n            l.add(arr[i]);\\n        \\n        Random rand=new Random();\\n        \\n        for (int i=0;i<nums.length;i++) {\\n            int remove=rand.nextInt(l.size());\\n            nums[i]=l.get(remove);\\n            l.remove(remove);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int[] arr;\\n\\n    public Solution(int[] nums) {\\n        arr=nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2034271,
                "title": "javascript-solution-ultrafast",
                "content": "```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.orig = [...nums];\\n    }\\n\\n    reset() {\\n        return this.orig;\\n    }\\n\\n    shuffle() {\\n        const n = this.nums.length;\\n\\n        for (let i = 0; i < n; i++) {\\n            const j = Math.floor(Math.random() * (n - i)) + i;\\n            const tmp = this.nums[i];\\n            this.nums[i] = this.nums[j];\\n            this.nums[j] = tmp;\\n        }\\n        \\n        return this.nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.orig = [...nums];\\n    }\\n\\n    reset() {\\n        return this.orig;\\n    }\\n\\n    shuffle() {\\n        const n = this.nums.length;\\n\\n        for (let i = 0; i < n; i++) {\\n            const j = Math.floor(Math.random() * (n - i)) + i;\\n            const tmp = this.nums[i];\\n            this.nums[i] = this.nums[j];\\n            this.nums[j] = tmp;\\n        }\\n        \\n        return this.nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981521,
                "title": "using-next-permutation-c",
                "content": "Using next permutation every time the shuffle is called\\n-> the permutations are stored in a variable as pervPermutation so as to avoid same shuffling when we reset the array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    vector<int> original, prevPermutation;\\n    Solution(vector<int>& nums) {\\n        this->nums= nums;\\n        this->prevPermutation = nums;\\n        this->original = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        this->nums = original;\\n        return this->nums;\\n    }\\n    \\n    vector<int> shuffle() {\\n        next_permutation(prevPermutation.begin(), prevPermutation.end());\\n        return prevPermutation;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    vector<int> original, prevPermutation;\\n    Solution(vector<int>& nums) {\\n        this->nums= nums;\\n        this->prevPermutation = nums;\\n        this->original = nums;\\n    }\\n    \\n    vector<int> reset() {\\n        this->nums = original;\\n        return this->nums;\\n    }\\n    \\n    vector<int> shuffle() {\\n        next_permutation(prevPermutation.begin(), prevPermutation.end());\\n        return prevPermutation;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * vector<int> param_1 = obj->reset();\\n * vector<int> param_2 = obj->shuffle();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1946674,
                "title": "simple-typescript-javascript-solution",
                "content": "My simple solution, beats 73% of typescript submissions\\n```\\nclass Solution {\\n    private original: number[] = [];\\n    constructor(nums: number[]) {\\n        this.original = nums;\\n    }\\n\\n    reset(): number[] {\\n        return this.original;\\n    }\\n\\n    shuffle(): number[] {\\n        return [...this.original.map(value => ({ value, sort: Math.random() }))\\n            .sort((a, b) => a.sort - b.sort)\\n            .map(({ value }) => value)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\n    private original: number[] = [];\\n    constructor(nums: number[]) {\\n        this.original = nums;\\n    }\\n\\n    reset(): number[] {\\n        return this.original;\\n    }\\n\\n    shuffle(): number[] {\\n        return [...this.original.map(value => ({ value, sort: Math.random() }))\\n            .sort((a, b) => a.sort - b.sort)\\n            .map(({ value }) => value)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824269,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    int a[];\\n    int c[];\\n    public Solution(int[] n) {\\n        int k=n.length,p=0;\\n        a=new int[k];\\n        c=new int[k];\\n        for(int i:n)\\n        {\\n            a[p]=i;\\n            c[p++]=i;\\n        }\\n    }\\n    \\n    public int[] reset() {\\n        return a;\\n    }\\n    \\n    public int[] shuffle() {\\n        int k=c.length;\\n        while(k>0)\\n        {\\n            int p=(int)(Math.random()*k);\\n            int d=c[k-1];\\n            c[k-1]=c[p];\\n            c[p]=d;\\n            k-=1;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    int a[];\\n    int c[];\\n    public Solution(int[] n) {\\n        int k=n.length,p=0;\\n        a=new int[k];\\n        c=new int[k];\\n        for(int i:n)\\n        {\\n            a[p]=i;\\n            c[p++]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1772656,
                "title": "java-solution-using-some-trick-to-make-shuffle-also-o-1",
                "content": "It is asked in question that after shuffling all array elements should have equal probablity of picking up.\\nso for that what we can do is to just swap the last element of array with any random index starting from i=0 till second last. and return the array. in such way retured array elements remain there in same freq. and will picked randomly\\nWill be storing 2 arrays one for orignal which will be returned from reset method. and scond copy array on which we keep on modifying using random method.\\n\\n```\\nclass Solution {\\n    private int[] orig;\\n    private int[] copy;\\n    private Random random =new Random();\\n    public Solution(int[] nums) {\\n        orig=nums.clone();\\n        copy=nums;\\n    }\\n    \\n    public int[] reset() {\\n        return orig;\\n    }\\n    \\n    public int[] shuffle() {\\n        int index = random.nextInt(copy.length-1);\\n        int t=copy[index];\\n        copy[index]=copy[copy.length-1];\\n        copy[copy.length-1]=t;\\n        return copy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] orig;\\n    private int[] copy;\\n    private Random random =new Random();\\n    public Solution(int[] nums) {\\n        orig=nums.clone();\\n        copy=nums;\\n    }\\n    \\n    public int[] reset() {\\n        return orig;\\n    }\\n    \\n    public int[] shuffle() {\\n        int index = random.nextInt(copy.length-1);\\n        int t=copy[index];\\n        copy[index]=copy[copy.length-1];\\n        copy[copy.length-1]=t;\\n        return copy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750683,
                "title": "java-99-87-faster-easy-and-clean-code",
                "content": "Runtime: 62 ms, faster than 99.87% of Java online submissions for Shuffle an Array.\\n\\n```\\nclass Solution {\\n    private int[] nums;\\n    private int[] shuffleArr;\\n    private Random rand;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.shuffleArr = nums.clone();\\n        this.rand = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        //return the nums array \\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        for (int i = 0; i < shuffleArr.length; i++) {\\n            //Find a random Index and swap it with element at index i.\\n            int randIdx = i + rand.nextInt(shuffleArr.length - i);\\n            swap(i, randIdx);\\n        }\\n        \\n        return shuffleArr;\\n    }\\n    \\n    //swap function\\n    private void swap(int i, int j) {\\n        int temp = shuffleArr[i];\\n        shuffleArr[i] = shuffleArr[j];\\n        shuffleArr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] nums;\\n    private int[] shuffleArr;\\n    private Random rand;\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.shuffleArr = nums.clone();\\n        this.rand = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        //return the nums array \\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        for (int i = 0; i < shuffleArr.length; i++) {\\n            //Find a random Index and swap it with element at index i.\\n            int randIdx = i + rand.nextInt(shuffleArr.length - i);\\n            swap(i, randIdx);\\n        }\\n        \\n        return shuffleArr;\\n    }\\n    \\n    //swap function\\n    private void swap(int i, int j) {\\n        int temp = shuffleArr[i];\\n        shuffleArr[i] = shuffleArr[j];\\n        shuffleArr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721395,
                "title": "two-c-solutions-with-and-without-swapping-self-explanatory",
                "content": "**Method 1: Swapping with randomly generated index.**\\n```\\nclass Solution {\\npublic:\\n    int size = 0;\\n    vector<int> real;\\n    vector<int> shuffled;\\n    Solution(vector<int>& nums)\\n    {\\n        size = nums.size();\\n        real = nums;\\n        shuffled = nums;\\n    }\\n    \\n    vector<int> reset()\\n    {\\n        return real;\\n    }\\n    \\n    vector<int> shuffle()\\n    {\\n        if(size==1) return real;  // An edge case to be handled.\\n        int i = 0;\\n        while(i < size)\\n            swap(shuffled[i++], shuffled[rand()%size]);  // Swapping with randomly generated index\\n        return shuffled;\\n    }\\n};\\n```\\n\\n\\n**Shifting the last index to the first in the new shuffled array.** (Will cost you more time and space)\\n\\n```\\nclass Solution {\\npublic:\\n    int size = 0;\\n    vector<int> real;\\n    vector<int> shuffled;\\n    Solution(vector<int>& nums)\\n    {\\n        size = nums.size();\\n        real = nums;\\n        shuffled = nums;\\n    }\\n    \\n    vector<int> reset()\\n    {\\n        return real;\\n    }\\n    \\n    vector<int> shuffle()\\n    {\\n        if(size==1) return real;   // An edge case to be handled.\\n        vector<int> res;\\n        res.push_back(shuffled[size-1]);      // Pushing the last element to the first place in new array\\n        for(int i=0; i<size-1; i++)        // Pushing remaining elements from beginning until (size-1)\\n            res.push_back(shuffled[i]);\\n        shuffled = res;\\n        return shuffled;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int size = 0;\\n    vector<int> real;\\n    vector<int> shuffled;\\n    Solution(vector<int>& nums)\\n    {\\n        size = nums.size();\\n        real = nums;\\n        shuffled = nums;\\n    }\\n    \\n    vector<int> reset()\\n    {\\n        return real;\\n    }\\n    \\n    vector<int> shuffle()\\n    {\\n        if(size==1) return real;  // An edge case to be handled.\\n        int i = 0;\\n        while(i < size)\\n            swap(shuffled[i++], shuffled[rand()%size]);  // Swapping with randomly generated index\\n        return shuffled;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int size = 0;\\n    vector<int> real;\\n    vector<int> shuffled;\\n    Solution(vector<int>& nums)\\n    {\\n        size = nums.size();\\n        real = nums;\\n        shuffled = nums;\\n    }\\n    \\n    vector<int> reset()\\n    {\\n        return real;\\n    }\\n    \\n    vector<int> shuffle()\\n    {\\n        if(size==1) return real;   // An edge case to be handled.\\n        vector<int> res;\\n        res.push_back(shuffled[size-1]);      // Pushing the last element to the first place in new array\\n        for(int i=0; i<size-1; i++)        // Pushing remaining elements from beginning until (size-1)\\n            res.push_back(shuffled[i]);\\n        shuffled = res;\\n        return shuffled;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697422,
                "title": "java-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        \\n        int[] shuffled = Arrays.copyOf(this.nums, this.nums.length);\\n        \\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            int rand = this.rand.nextInt(this.nums.length);\\n            swap(shuffled, i, rand);\\n        }\\n        \\n        return shuffled;\\n        \\n    }\\n    \\n    public void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        \\n        int[] shuffled = Arrays.copyOf(this.nums, this.nums.length);\\n        \\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            int rand = this.rand.nextInt(this.nums.length);\\n            swap(shuffled, i, rand);\\n        }\\n        \\n        return shuffled;\\n        \\n    }\\n    \\n    public void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630008,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<int> v;\\n    \\n    Solution(vector<int>& nums) {\\n        \\n        swap(v,nums);\\n        \\n    }\\n    \\n    vector<int> reset() {\\n        \\n        return v;\\n        \\n    }\\n    \\n    vector<int> shuffle() {\\n        \\n        int i;\\n        \\n        vector<int> vec = v;\\n        \\n        for(i=0; i < vec.size( ); i++)\\n        {\\n            int a = rand() % vec.size( );\\n            \\n            swap(vec[i], vec[a]);\\n            \\n        }\\n        \\n        return vec;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> v;\\n    \\n    Solution(vector<int>& nums) {\\n        \\n        swap(v,nums);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1600268,
                "title": "java-explained-o-n-fisher-yates-shuffle-algorithm",
                "content": "// We need to generate Random Permutation of the array (without changing the original array since we need to do reset())\\n// The idea is to start from the last element, swap it with a randomly selected element from the whole array (including last). Now consider the array from 0 to n-2 (size reduced by 1), and repeat the process till we hit the first element. \\n\\n// TC : O(N) \\n// SC : O(N)\\n\\n```\\nclass Solution {\\n\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        rand = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        int[] aux = nums.clone();\\n        \\n        for(int i = aux.length - 1; i > 0; i--) { // dont need to check for 0\\n            int randIdx = rand.nextInt(i + 1);\\n            swap(aux, i, randIdx);\\n        }\\n        \\n        return aux;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int[] param_1 = obj.reset();\\n * int[] param_2 = obj.shuffle();\\n */",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        rand = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    public int[] shuffle() {\\n        int[] aux = nums.clone();\\n        \\n        for(int i = aux.length - 1; i > 0; i--) { // dont need to check for 0\\n            int randIdx = rand.nextInt(i + 1);\\n            swap(aux, i, randIdx);\\n        }\\n        \\n        return aux;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576168,
                "title": "c-fisher-yates-algorithm-beats-96-8",
                "content": "```cpp\\nclass Solution\\n{\\npublic:\\n  Solution(vector<int> &nums)\\n  {\\n    original = nums;\\n    m_nums = nums;\\n    n = nums.size();\\n  }\\n\\n  vector<int> reset()\\n  {\\n    m_nums = original;\\n    return m_nums;\\n  }\\n\\n  // Fisher-Yates algorithm\\n  vector<int> shuffle()\\n  {\\n    for (int i = 0; i < n; ++i)\\n    {\\n      int j = rand() % (n - i) + i; // range i to n-1\\n      std::swap(m_nums[i], m_nums[j]);\\n    }\\n    return m_nums;\\n  }\\n\\nprivate:\\n  vector<int> original, m_nums;\\n  int n;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n  Solution(vector<int> &nums)\\n  {\\n    original = nums;\\n    m_nums = nums;\\n    n = nums.size();\\n  }\\n\\n  vector<int> reset()\\n  {\\n    m_nums = original;\\n    return m_nums;\\n  }\\n\\n  // Fisher-Yates algorithm\\n  vector<int> shuffle()\\n  {\\n    for (int i = 0; i < n; ++i)\\n    {\\n      int j = rand() % (n - i) + i; // range i to n-1\\n      std::swap(m_nums[i], m_nums[j]);\\n    }\\n    return m_nums;\\n  }\\n\\nprivate:\\n  vector<int> original, m_nums;\\n  int n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573109,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n\\n    private int[] num;\\n    private Random r;\\n    public Solution(int[] nums) {\\n        num = nums;\\n        r = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return num;\\n    }\\n    \\n    public int[] shuffle() {\\n        int[] sfl = Arrays.copyOf(num,num.length);\\n        for(int i=1; i<num.length; i++)\\n            swap(sfl, i, r.nextInt(i+1));\\n        return sfl;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        if(i == j)  return;\\n        nums[i] ^= nums[j];\\n        nums[j] ^= nums[i];\\n        nums[i] ^= nums[j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int[] num;\\n    private Random r;\\n    public Solution(int[] nums) {\\n        num = nums;\\n        r = new Random();\\n    }\\n    \\n    public int[] reset() {\\n        return num;\\n    }\\n    \\n    public int[] shuffle() {\\n        int[] sfl = Arrays.copyOf(num,num.length);\\n        for(int i=1; i<num.length; i++)\\n            swap(sfl, i, r.nextInt(i+1));\\n        return sfl;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        if(i == j)  return;\\n        nums[i] ^= nums[j];\\n        nums[j] ^= nums[i];\\n        nums[i] ^= nums[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536316,
                "title": "c-2-solutions-1-using-random-shuffle-2-implementing-shuffle-method",
                "content": "# Using random_shuffle \\n```\\nclass Solution {\\n    vector<int> arr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        n = arr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr2 = arr;\\n        random_shuffle(arr2.begin() , arr2.end());\\n        return arr2;        \\n    }\\n};\\n```\\n\\n# Implementing Shuffle method\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        n = arr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr2 = arr;\\n        for(int i =0;i<n;i++){\\n            int randIndex = (rand()% ( n-i)) + i;\\n            swap( arr2[randIndex] , arr2[i]);\\n        }\\n        return arr2;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> arr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        n = arr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr2 = arr;\\n        random_shuffle(arr2.begin() , arr2.end());\\n        return arr2;        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> arr;\\n    int n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        n = arr.size();\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        vector<int> arr2 = arr;\\n        for(int i =0;i<n;i++){\\n            int randIndex = (rand()% ( n-i)) + i;\\n            swap( arr2[randIndex] , arr2[i]);\\n        }\\n        return arr2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519646,
                "title": "java-fisher-yates-algo-linear-space-time-solution",
                "content": "```\\nclass Solution {\\n    \\n    int arr[];\\n    public Solution(int[] nums) {\\n        arr=nums;\\n    }\\n    \\n    public int[] reset() {\\n        return arr;\\n    }\\n\\n    public int[] shuffle() {\\n        int copy[]=arr.clone();\\n        \\n        for(int i=copy.length-1;i>0;i--){\\n            int j=new Random().nextInt(i+1);\\n            int temp=copy[i];\\n            copy[i]=copy[j];\\n            copy[j]=temp;\\n        }\\n        return copy;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int arr[];\\n    public Solution(int[] nums) {\\n        arr=nums;\\n    }\\n    \\n    public int[] reset() {\\n        return arr;\\n    }\\n\\n    public int[] shuffle() {\\n        int copy[]=arr.clone();\\n        \\n        for(int i=copy.length-1;i>0;i--){\\n            int j=new Random().nextInt(i+1);\\n            int temp=copy[i];\\n            copy[i]=copy[j];\\n            copy[j]=temp;\\n        }\\n        return copy;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398681,
                "title": "c-shuffle-an-array-fisher-yates-shuffle-or-knuth-shuffle",
                "content": "**Fisher-Yates Shuffle or Knuth Shuffle**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\nprivate:\\n    vector<int> orignal;\\n    vector<int> random;\\npublic:\\n    Solution(vector<int>& nums) {\\n        orignal = nums;\\n        random = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return orignal;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        if(random.empty()){\\n            return random;\\n        }\\n        \\n        int n = random.size();\\n        \\n        for(int i = n; i > 0; i--){\\n            swap(random[i - 1], random[rand()%i]);\\n        }\\n        \\n        return random;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> orignal;\\n    vector<int> random;\\npublic:\\n    Solution(vector<int>& nums) {\\n        orignal = nums;\\n        random = nums;\\n    }\\n    \\n    /** Resets the array to its original configuration and return it. */\\n    vector<int> reset() {\\n        return orignal;\\n    }\\n    \\n    /** Returns a random shuffling of the array. */\\n    vector<int> shuffle() {\\n        if(random.empty()){\\n            return random;\\n        }\\n        \\n        int n = random.size();\\n        \\n        for(int i = n; i > 0; i--){\\n            swap(random[i - 1], random[rand()%i]);\\n        }\\n        \\n        return random;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375637,
                "title": "trapping-rain-water-python",
                "content": "The brute force approach which is the simple one to understand is to get the highest elevation from the left & right side. \\nFrom there we take the smaller of both and subtract the current amount we are on and add it to the total.\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n\\t\\twater = 0\\n\\t\\t\\n\\t\\t#since we need to be in between buildings we don\\'t \\n\\t\\t#need the first or last one\\n        for i in range(1,len(height)-1):\\n\\t\\t\\n\\t\\t\\t#get all heights from the left side\\n            l = max(height[:i+1])\\n\\t\\t\\t\\n\\t\\t\\t#get all heights from the right side\\n            r = max(height[i:])\\n\\t\\t\\t\\n\\t\\t\\t#min and subtract current one\\n            water += min(l,r) - height[i]\\n        return water\\n                \\n```\\nComplexity for the brute force is O(n^2) and space of O(1).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n\\t\\twater = 0\\n\\t\\t\\n\\t\\t#since we need to be in between buildings we don\\'t \\n\\t\\t#need the first or last one\\n        for i in range(1,len(height)-1):\\n\\t\\t\\n\\t\\t\\t#get all heights from the left side\\n            l = max(height[:i+1])\\n\\t\\t\\t\\n\\t\\t\\t#get all heights from the right side\\n            r = max(height[i:])\\n\\t\\t\\t\\n\\t\\t\\t#min and subtract current one\\n            water += min(l,r) - height[i]\\n        return water\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374256,
                "title": "trapping-rain-water-c-tricky-one-but-simple",
                "content": "// Take 2 arrays\\n//  left array will store all max heights from left to right\\n//  right array will store all max heights from right to left\\n// Take min of two array and subtrat from height[i]\\n\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(!n)\\n            return 0;\\n        \\n        int left[n];\\n        int right[n];\\n        \\n        left[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            left[i] = max(left[i-1], height[i]);\\n        }\\n        right[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i] = max(right[i+1], height[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            ans += min(left[i], right[i])-height[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(!n)\\n            return 0;\\n        \\n        int left[n];\\n        int right[n];\\n        \\n        left[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            left[i] = max(left[i-1], height[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1374184,
                "title": "trapping-rain-water-c-o-n-runtime-o-n-space",
                "content": "Basic idea here is take 2 arrays of size n.\\n`left_max` will store all max heights from left to right.\\n`right_max` will store all max heights from right to left.\\nTraverse the whole array from left to right without including last and first elements as outside of boundaries.\\ntake the min from left and right heights (as water will only get filled till min height) and subtract the current array element to get the stored water in current space.\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n = a.size();\\n        if (!n) return 0;\\n        int left_max[n];\\n        int right_max[n];\\n        left_max[0] = a[0];\\n        right_max[n-1] = a[n-1];\\n        for (int i = 1; i < n; i++)\\n            left_max[i] = max(left_max[i-1],a[i]);\\n        for (int i = n-2; i >= 0; i--)\\n            right_max[i] = max(right_max[i+1],a[i]);\\n        int sum = 0;\\n        for(int i = 1; i < n - 1; i++) {\\n            if (min(left_max[i-1],right_max[i+1]) - a[i] > 0)\\n                sum += min(left_max[i-1],right_max[i+1]) - a[i];\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n = a.size();\\n        if (!n) return 0;\\n        int left_max[n];\\n        int right_max[n];\\n        left_max[0] = a[0];\\n        right_max[n-1] = a[n-1];\\n        for (int i = 1; i < n; i++)\\n            left_max[i] = max(left_max[i-1],a[i]);\\n        for (int i = n-2; i >= 0; i--)\\n            right_max[i] = max(right_max[i+1],a[i]);\\n        int sum = 0;\\n        for(int i = 1; i < n - 1; i++) {\\n            if (min(left_max[i-1],right_max[i+1]) - a[i] > 0)\\n                sum += min(left_max[i-1],right_max[i+1]) - a[i];\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370773,
                "title": "cpp-detailed-bfs",
                "content": "//shortest paths-unweighted graph---->bfs(very standard)\\n//but usually 1 source node---minimum distance from that particular node\\n//but here multiple source nodes\\n//so push all of them first\\n//WHY???\\n//WHEN WE POP AND EXPLORE WE ARE DOING SO IN INCREASING ORDER OF THEIR LEVELS\\n//SO WHEN WE DISCOVER A NODE FIRST WE ARE EXPLORING IT FROM MINI POSSIBLE LEVEL NODE THAT IT IS CONNECTED TO\\n//first the source..then level 1 nodes..then level 2 and so on\\n//here the case is there are many level 0 nodes\\n//so push all of them first!!!\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        if(i==m||j==n||j<0||i<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> dir={{1,0},{0,1},{0,-1},{-1,0}};\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) \\n    {\\n        queue<pair<int,int>> q;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>> dis(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                { \\n                    q.push({i,j});\\n                    dis[i][j]=0;\\n                }\\n            }\\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            for(auto& x:dir)\\n            {\\n                int a=curr.first+x[0];\\n                int b=curr.second+x[1];\\n                if(isvalid(a,b,m,n)&&dis[a][b]==-1)\\n                {\\n                    q.push({a,b});\\n                    dis[a][b]=dis[curr.first][curr.second]+1;\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        if(i==m||j==n||j<0||i<0)\\n            return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1370648,
                "title": "01-matrix-bfs-solution",
                "content": "```\\nclass Solution {\\n    static bool isBoundary(const vector<vector<int>>& mat, int r, int c)\\n    {\\n        return \\n            (r > 0 && mat[r-1][c] == 0) ||\\n            (c > 0 && mat[r][c-1] == 0) ||\\n            (r < mat.size() - 1 && mat[r+1][c] == 0) ||\\n            (c < mat[0].size() - 1 && mat[r][c+1] == 0);\\n    }\\npublic:\\n    // we are going to use BFS, but initially we have to prime queue with all boundary 1s without duplicates\\n    // and replacing non-boundary 1s with INF=m*n to indicate non-visited as bigger than\\n    // length of any possible way\\n    // then we start BFS from this queue for every non-0 neighbor marking it min(itself+1, neighbor) -\\n    // by this way we will flood-fill all islands of 1s from boundary inside with shortest way to boundary\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        const int INF = mat.size() * mat[0].size();\\n        \\n        queue<pair<int, int>> q; // queue of <row, column> coordinates\\n        \\n        // priming queue with boundaries and marking all 1s as INF - not visited\\n        for(int r = 0; r < mat.size(); ++r) {\\n            for(int c = 0; c < mat[0].size(); ++c) {\\n                if(mat[r][c] == 0)\\n                    continue;\\n                if(isBoundary(mat, r, c))\\n                    q.push({r, c});\\n                else\\n                    mat[r][c] = INF;\\n            }\\n        }\\n        \\n        // BFS\\n        while(!q.empty()) {\\n            auto [r, c] = q.front();\\n            q.pop();\\n            \\n            int self = mat[r][c];\\n            \\n            array<pair<int, int>, 4> neighbors { {{r-1, c}, {r+1, c}, {r, c-1}, {r, c+1}} };\\n            auto isValid = [&mat](int r, int c) {\\n                return r >= 0 && r < mat.size() && c >= 0 && c < mat[0].size();\\n            };\\n            \\n            for(auto [rn, cn] : neighbors) {\\n                if(!isValid(rn, cn) || mat[rn][cn] == 0)\\n                    continue;\\n                if(mat[rn][cn] == INF)\\n                    q.push({rn, cn});\\n                mat[rn][cn] = min(mat[rn][cn], self + 1);\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool isBoundary(const vector<vector<int>>& mat, int r, int c)\\n    {\\n        return \\n            (r > 0 && mat[r-1][c] == 0) ||\\n            (c > 0 && mat[r][c-1] == 0) ||\\n            (r < mat.size() - 1 && mat[r+1][c] == 0) ||\\n            (c < mat[0].size() - 1 && mat[r][c+1] == 0);\\n    }\\npublic:\\n    // we are going to use BFS, but initially we have to prime queue with all boundary 1s without duplicates\\n    // and replacing non-boundary 1s with INF=m*n to indicate non-visited as bigger than\\n    // length of any possible way\\n    // then we start BFS from this queue for every non-0 neighbor marking it min(itself+1, neighbor) -\\n    // by this way we will flood-fill all islands of 1s from boundary inside with shortest way to boundary\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        const int INF = mat.size() * mat[0].size();\\n        \\n        queue<pair<int, int>> q; // queue of <row, column> coordinates\\n        \\n        // priming queue with boundaries and marking all 1s as INF - not visited\\n        for(int r = 0; r < mat.size(); ++r) {\\n            for(int c = 0; c < mat[0].size(); ++c) {\\n                if(mat[r][c] == 0)\\n                    continue;\\n                if(isBoundary(mat, r, c))\\n                    q.push({r, c});\\n                else\\n                    mat[r][c] = INF;\\n            }\\n        }\\n        \\n        // BFS\\n        while(!q.empty()) {\\n            auto [r, c] = q.front();\\n            q.pop();\\n            \\n            int self = mat[r][c];\\n            \\n            array<pair<int, int>, 4> neighbors { {{r-1, c}, {r+1, c}, {r, c-1}, {r, c+1}} };\\n            auto isValid = [&mat](int r, int c) {\\n                return r >= 0 && r < mat.size() && c >= 0 && c < mat[0].size();\\n            };\\n            \\n            for(auto [rn, cn] : neighbors) {\\n                if(!isValid(rn, cn) || mat[rn][cn] == 0)\\n                    continue;\\n                if(mat[rn][cn] == INF)\\n                    q.push({rn, cn});\\n                mat[rn][cn] = min(mat[rn][cn], self + 1);\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370352,
                "title": "01-matrix-without-bfs",
                "content": "\\nFirst Intializing a 2d matrix (say m) with a max value (say INT_MAX).\\nThen traversing the given matrix in forward direction and checking for the min between the present idex value  m(i,j) the upper index m(i-1,j) and the left index m(i,j-1) and if the min value is from upper and left index then update then current value with the min value +1 (only if mat[i][j]==1).\\nThen again traversing backwards from the last element in the matrix  and checking for the min between the present idex value m(i,j) the lower index m(i+1,j) and the right index m(i,j+1) and if the min value is from lower and right index then update then current value with the min value +1 (only if mat[i][j]==1)..\\nAfter doing the above 2 passes we will get the resultant matrix .\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        vector<vector<int>>m(mat.size(),vector<int>(mat[0].size(),INT_MAX));\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                int f=0;\\n                if(mat[i][j]!=0)\\n                {\\n                if(i-1>=0)\\n                {\\n                    if(m[i-1][j]<m[i][j])\\n                    {\\n                        f=1;\\n                        m[i][j] =min(m[i-1][j],m[i][j]);\\n                    }\\n                  \\n                }\\n                if(j-1>=0)\\n                {\\n                   if(m[i][j-1]<m[i][j])\\n                    {\\n                        f=1;\\n                        m[i][j] =min(m[i][j-1],m[i][j]);\\n                    }\\n                }\\n                    if(f==1)\\n                    m[i][j]+=1;\\n                }\\n                else\\n                    m[i][j]=0;\\n            }\\n        }\\n         for(int i=mat.size()-1;i>=0;i--)\\n        {\\n            for(int j=mat[i].size()-1;j>=0;j--)\\n            {\\n                int f=0;\\n                if(mat[i][j]!=0)\\n                {\\n                if(i+1<mat.size())\\n                {\\n                   if(m[i+1][j]<m[i][j])\\n                    {\\n                        f=1;\\n                        m[i][j] =min(m[i+1][j],m[i][j]);\\n                    }\\n                }\\n                if(j+1<mat[0].size())\\n                {\\n                   if(m[i][j+1]<m[i][j])\\n                    {\\n                        f=1;\\n                        m[i][j] =min(m[i][j+1],m[i][j]);\\n                    }\\n                }\\n                    if(f==1)\\n                    m[i][j]+=1;\\n                }\\n                else\\n                    m[i][j]=0;\\n            }\\n        }\\n        \\n        return m;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        vector<vector<int>>m(mat.size(),vector<int>(mat[0].size(),INT_MAX));\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                int f=0;\\n                if(mat[i][j]!=0)\\n                {\\n                if(i-1>=0)\\n                {\\n                    if(m[i-1][j]<m[i][j])\\n                    {\\n                        f=1;\\n                        m[i][j] =min(m[i-1][j],m[i][j]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1370303,
                "title": "01-matrix-solution-bfs-approach-easy-explained",
                "content": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\\n\\nThe distance between two adjacent cells is 1.\\n\\n\\nSolutions:\\nBFS Approach:\\nCreate a new 2d array for storing the answer of matrix;\\nCreate a queue of type pair<int,int> for storing the indexes.\\nInitialise the array with Infinite and then traverse in the origin array if we get a value zero we store the zero value index in the output[][] array and also push the index of original matrix in the queue.\\n\\nTraverse the queue till the queue is empty().\\nIn every call pop() the element from queue and check in the four direction that  from position of (i,j) which contain the 0 value in the original matrix. Check the four direction element in the output matrix elemnt greater than current index (i,j) element, if  yes than replace the output of new direction index to output[i+1][j]=output[i][j]+1;\\nThis will check for all four directions and replace the output array with the new value.\\nIn the if condition We are also checking the index is safe or not.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n,m;\\n        n=mat.size();\\n        m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==0){\\n                    q.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp.first;\\n            int y=temp.second;\\n            if(x+1<n and ans[x+1][y]>ans[x][y]+1){\\n                ans[x+1][y]=ans[x][y]+1;\\n                q.push({x+1,y});\\n            }\\n            \\n            if(y+1<m and ans[x][y+1]>ans[x][y]+1){\\n                ans[x][y+1]=ans[x][y]+1;\\n                q.push({x,y+1});\\n            }\\n            if(x-1>=0 and ans[x-1][y]>ans[x][y]+1){\\n                ans[x-1][y]=ans[x][y]+1;\\n                q.push({x-1,y});\\n            }\\n            \\n            \\n            if(y-1>=0 and ans[x][y-1]>ans[x][y]+1){\\n                ans[x][y-1]=ans[x][y]+1;\\n                q.push({x,y-1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n,m;\\n        n=mat.size();\\n        m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==0){\\n                    q.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp.first;\\n            int y=temp.second;\\n            if(x+1<n and ans[x+1][y]>ans[x][y]+1){\\n                ans[x+1][y]=ans[x][y]+1;\\n                q.push({x+1,y});\\n            }\\n            \\n            if(y+1<m and ans[x][y+1]>ans[x][y]+1){\\n                ans[x][y+1]=ans[x][y]+1;\\n                q.push({x,y+1});\\n            }\\n            if(x-1>=0 and ans[x-1][y]>ans[x][y]+1){\\n                ans[x-1][y]=ans[x][y]+1;\\n                q.push({x-1,y});\\n            }\\n            \\n            \\n            if(y-1>=0 and ans[x][y-1]>ans[x][y]+1){\\n                ans[x][y-1]=ans[x][y]+1;\\n                q.push({x,y-1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369761,
                "title": "01-matrix-bfs-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,INT_MAX));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j] == 0)\\n                {\\n                    ans[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        while(!q.empty())\\n        {\\n            int a =q.front().first;\\n            int b=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int up= a + dx[i];\\n                int down = b+dy[i];\\n                if(up<0 || up>=n || down<0 || down>=m) continue;\\n                else if(ans[up][down] > ans[a][b] + 1)\\n                {\\n                    ans[up][down] = ans[a][b] + 1;\\n                    q.push({up,down});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,INT_MAX));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j] == 0)\\n                {\\n                    ans[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        while(!q.empty())\\n        {\\n            int a =q.front().first;\\n            int b=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int up= a + dx[i];\\n                int down = b+dy[i];\\n                if(up<0 || up>=n || down<0 || down>=m) continue;\\n                else if(ans[up][down] > ans[a][b] + 1)\\n                {\\n                    ans[up][down] = ans[a][b] + 1;\\n                    q.push({up,down});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366269,
                "title": "c-3-sum-closest-two-methods-2-pointers-and-brute-force-easy",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Two pointers approach- time complexity O(n^2)**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nint n=nums.size(),low,high,ans=0,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n          low=i+1;\\n          high=n-1;\\n           while(low<high)\\n           {\\n               if(abs(nums[i]+nums[high]+nums[low]-target)<mini)\\n               {\\n                   mini=abs(nums[i]+nums[high]+nums[low]-target);\\n                   ans=nums[i]+nums[high]+nums[low];\\n               }\\n               if(nums[i]+nums[high]+nums[low]<target)\\n               {\\n                   low++;\\n               }    \\n              else\\n              high--;\\n                \\n           }   \\n        } \\n      return ans;  \\n    }\\n};\\n```\\n**Brute force- Time complexity O(n^3)**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       int mini=INT_MAX,n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                 if(mini==INT_MAX)\\n                  mini=nums[i]+nums[j]+nums[k];\\n            else if(abs(mini-target)>abs(nums[i]+nums[j]+nums[k]-target))\\n                   mini=nums[i]+nums[j]+nums[k];\\n                }\\n            }   \\n        }   \\n    return mini;\\n    }\\n};\\n```\\n**Another brute force(taking extra variable for simplicity)**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       int mini=INT_MAX,res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                for(int k=j+1;k<nums.size();k++)\\n                {\\n                    if(abs(nums[i]+nums[j]+nums[k]-target)<mini)\\n                    {\\n                     mini=  abs(nums[i]+nums[j]+nums[k]-target);\\n                       res= nums[i]+nums[j]+nums[k];        \\n                    }\\n                }   \\n            }   \\n        } \\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nint n=nums.size(),low,high,ans=0,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n          low=i+1;\\n          high=n-1;\\n           while(low<high)\\n           {\\n               if(abs(nums[i]+nums[high]+nums[low]-target)<mini)\\n               {\\n                   mini=abs(nums[i]+nums[high]+nums[low]-target);\\n                   ans=nums[i]+nums[high]+nums[low];\\n               }\\n               if(nums[i]+nums[high]+nums[low]<target)\\n               {\\n                   low++;\\n               }    \\n              else\\n              high--;\\n                \\n           }   \\n        } \\n      return ans;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       int mini=INT_MAX,n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                 if(mini==INT_MAX)\\n                  mini=nums[i]+nums[j]+nums[k];\\n            else if(abs(mini-target)>abs(nums[i]+nums[j]+nums[k]-target))\\n                   mini=nums[i]+nums[j]+nums[k];\\n                }\\n            }   \\n        }   \\n    return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       int mini=INT_MAX,res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                for(int k=j+1;k<nums.size();k++)\\n                {\\n                    if(abs(nums[i]+nums[j]+nums[k]-target)<mini)\\n                    {\\n                     mini=  abs(nums[i]+nums[j]+nums[k]-target);\\n                       res= nums[i]+nums[j]+nums[k];        \\n                    }\\n                }   \\n            }   \\n        } \\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365110,
                "title": "python3-convert-sorted-array-to-binary-search-tree-solution-easy-recursion",
                "content": "Hi All,\\n\\nthis solution is using recursion. The nums array was alreay sorted, so no need to think of Balanced binary search tree (like AVL tree) implementation.\\n\\nYou consider mid of nums array as root of tree and then recursively call left (low to mid -1) and right (mid+1 to high) for constructing the left and right subtree respectively.\\n\\n```\\nclass Solution:\\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\\n        \\n        n = len(nums)\\n        if n==1:\\n            return TreeNode(nums[0])\\n        low = 0\\n        high = n - 1\\n        def insertIntoBST(low: int, high: int) -> TreeNode:\\n            # print(low,high)\\n            if low == high:\\n                return TreeNode(nums[low])\\n            \\n            mid = low + (high-low)//2\\n            root = TreeNode(nums[mid])\\n            if mid == low:\\n                root.right = insertIntoBST(mid+1,high)\\n                return root\\n            root.left = insertIntoBST(low,mid-1)\\n            root.right = insertIntoBST(mid+1,high)\\n            return root\\n        \\n        return insertIntoBST(low, high)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\\n        \\n        n = len(nums)\\n        if n==1:\\n            return TreeNode(nums[0])\\n        low = 0\\n        high = n - 1\\n        def insertIntoBST(low: int, high: int) -> TreeNode:\\n            # print(low,high)\\n            if low == high:\\n                return TreeNode(nums[low])\\n            \\n            mid = low + (high-low)//2\\n            root = TreeNode(nums[mid])\\n            if mid == low:\\n                root.right = insertIntoBST(mid+1,high)\\n                return root\\n            root.left = insertIntoBST(low,mid-1)\\n            root.right = insertIntoBST(mid+1,high)\\n            return root\\n        \\n        return insertIntoBST(low, high)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363864,
                "title": "c-sorted-array-to-bst-easy-to-understand-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int> arr,int s,int e)\\n    {\\n        if(s>e)\\n         return NULL;   \\n        int mid=(s+e)/2;\\n        int rootData=arr[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=helper(arr,s,mid-1);\\n        root->right=helper(arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        int n=nums.size();\\n       return helper(nums,0,n-1);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int> arr,int s,int e)\\n    {\\n        if(s>e)\\n         return NULL;   \\n        int mid=(s+e)/2;\\n        int rootData=arr[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=helper(arr,s,mid-1);\\n        root->right=helper(arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        int n=nums.size();\\n       return helper(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569105,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1566506,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1575879,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1573800,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1573435,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1841888,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1695646,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1571659,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1572441,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 2045069,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1569105,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1566506,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1575879,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1573800,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1573435,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1841888,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1695646,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1571659,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 1572441,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 2045069,
                "content": [
                    {
                        "username": "chenw2000",
                        "content": "Based on the statement in the question: \\n\\n\"// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\"\\n\\nHow does the OJ validate it?"
                    },
                    {
                        "username": "Angus_zhang",
                        "content": "Like 382 and 384, once I use the function of srand(), the random sequence is fixed, which means every time invoking the function to produce random number, the results are all the same. However, if only use rand(), then AC. \\nI think the fact should be if only using rand(), the results should be the same. Once using srand(), the results should be different. But the fact is just on the contrary. \\nCan anyone explain it? Thank you."
                    },
                    {
                        "username": "swetapatel21",
                        "content": "The solution is never changing the original array so why do we need to clone it in the reset function?\\n\\nCan someone explain this to me?"
                    },
                    {
                        "username": "c_jain",
                        "content": "I am very curious to know how Online Judges creates testcases for these kind of problems? I used __C++ \"shuffle\"__  function to generate randomness and got WA verdict but when I used \"__Fisher-Yates algorithm__\" I got AC verdict. So how the judge differentiates between results as it is random, means no one knows it in advance?"
                    },
                    {
                        "username": "charonme",
                        "content": "good question, I used the \"naive method\" and it got accepted, I then did some tests and comparisons locally with the modern Fisher\\u2013Yates as described on wiki and indeed the F-Y is much more evenly distributed than my naive method"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "check here:\\n**https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle**"
                    },
                    {
                        "username": "haolee0702",
                        "content": "Just curious, how they test if the probability is even? "
                    },
                    {
                        "username": "Rahul07109",
                        "content": "Why this question can\\'t be solved using next_permutation() function ?"
                    },
                    {
                        "username": "_Dora_",
                        "content": "We can solve it refer below\\n```\\nclass Solution {\\npublic:\\n    vector<int> v,original;\\n    Solution(vector<int>& nums) \\n    {\\n        v=nums;\\n        original=nums;\\n    }\\n    \\n    vector<int> reset() \\n    {\\n        return original;\\n    }\\n    \\n    vector<int> shuffle() \\n    {\\n        next_permutation(begin(v),end(v));\\n        return v;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "haruhiku",
                        "content": "The trick \"rand() % n\" may not fit the uniform distribution requirement as lower numbers are more likely to be picked by this operation, according to this post:\\nhttps://discuss.leetcode.com/topic/53979/straight-forward-c-solution\\n\\nThen which function can truly generate the random numbers within a range in C++? I am not sure if std::uniform_int_distribution can do the job (http://www.cplusplus.com/reference/random/uniform_int_distribution/)...Suggestions are welcomed :)"
                    },
                    {
                        "username": "JPV",
                        "content": "Why is this rated \"Medium\"?  It\\'s easier than many \"Easy\" questions."
                    },
                    {
                        "username": "aabarron",
                        "content": "Coming up with and implementing Fisher-Yates without ever seeing it isn't trivial, I guess? (If it was trivial would it be named?). If you use built-in functions to shuffle then it's certainly easy, but I think that's against the spirit of the problem. (And if you're asked this in a job interview they won't let you use built-in functions to generate a random permutation... if they did, why even ask this question to begin with?)"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "The below code is showing wrong answer.\n`vector<int> shuffle() `\n    `{`\n        `chan=ori;`\n       ` int m=rand()%((int)chan.size());`\n        `int n=rand()%((int)chan.size());`\n        \n        int t=chan[m];\n        chan[m]=chan[n];\n        chan[n]=t;\n        return chan;`\n      `}`\n\nThe code below this text  shows correct one.LC must review their testcase.\n\n`vector<int> shuffle() `\n    `{`\n      ` vector<int>v=ori;`\n        `random_shuffle(v.begin(),v.end());`\n        `return v;`\n        \n   ` }`\n"
                    }
                ]
            },
            {
                "id": 2036994,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1972776,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1971596,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1945363,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1837552,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1828154,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1826487,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1805724,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1763721,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1724068,
                "content": [
                    {
                        "username": "yashpaneliya",
                        "content": "Can someone explain why this approach is giving wrong answer for few cases.\\n\\n**Passed cases:**\\n[\"Solution\",\"shuffle\",\"shuffle\",\"shuffle\",\"shuffle\"]\\n[[[0,-12893,128384]],[],[],[],[]]\\n\\n[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\\n[[[1,2,3]],[],[],[]]\\n\\n**Failed case:**\\n[\"Solution\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...\\n\\n\\n```\\nclass Solution {\\n    vector<int> arr;\\n    int i,j;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n        i=0;\\n        j=0;\\n    }\\n    \\n    vector<int> reset() {\\n        return arr;\\n    }\\n    \\n    vector<int> shuffle() {\\n        if(j==arr.size()){\\n            ++i;\\n            j=0;\\n        }\\n        if(i==arr.size()){\\n            i=0;\\n            j=0;\\n        }\\n        cout<<i<<\" \"<<j<<endl;\\n        vector<int> res(arr);\\n        swap(res[i], res[j]);\\n        ++j;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "pretty easy on Python"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Using random.shuffle gives a random permutation. But the question is where does it checking the probability of occurance."
                    },
                    {
                        "username": "user3706Tz",
                        "content": "Seems a test case is incorrect:\\n\\nInput:  \\n[\"Solution\",\"reset\",\"shuffle\"...]\\n[[[-6,10,184]],[],[]\\nMy output:\\n[null,[-6,10,184],[10,-6,184]...]\\nThe expected output:\\n[null,[-6,10,184],[-6,10,184]...]\\n\\nIn the expected output a shuffle step should not be applied or what is wrong? "
                    },
                    {
                        "username": "amankatiyar783597",
                        "content": "what is diffrence between these 2 code?\n\n'''\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        return ar2;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n'''\n\nthis solution is correct....\nbut i try to reset orginal by copy ar2 to ar , answer become wrong\n\nincorrect code down below , but why?\n\nclass Solution {\npublic:\n    int n;\n    vector<int> ar , ar2;;\n    Solution(vector<int>& nums) {\n        ar=ar2=nums;\n        n = nums.size();\n    }\n    vector<int> reset() {\n        ar= ar2;\n        return ar;\n    }\n    vector<int> shuffle() {\n        int a = rand()%n;\n        int b = rand()%n;\n        swap(ar[a],ar[b]);\n        return ar;\n    }\n};\n\ncan any one tell me?\n\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Solution section of this problem is messed up, more like shuffled up."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Warning to those using C++: Don\\'t use srand(time(0))\\n\\nWill totally screw ur code over, I learned that the hard way... TvT"
                    },
                    {
                        "username": "olifarhaan",
                        "content": "Can anyone tell me please, what's wrong in my code?\n ```\nclass Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums= nums;\n        this.random= new Random();\n    }\n    \n    public int[] reset() {\n        return nums;\n    }\n    \n    public int[] shuffle() {\n        for(int i=nums.length-1; i>=0; i--){\n            int index= random.nextInt(i+1);\n            int temp= nums[i];\n            nums[i]= nums[index];\n            nums[index]= temp;\n        }\n        return nums;\n    }\n}\n\n\n\n\n```"
                    },
                    {
                        "username": "iperg",
                        "content": "Why it\\'s not described that `original` array is not counted as shuffled? As I understand the description, `reset` and `shuffle` could just return `nums`."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    private int[] nums;\\n    private Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int[] reset() {\\n        return nums;\\n    }\\n    \\n    \\n    public int[] shuffle() {\\n        int n = nums.length;\\n        int[] copy =  Arrays.copyOf(nums, n);\\n        for (int i = 0 ; i < n; i++) {\\n            \\n            int r = i + rand.nextInt(n - i);\\n            \\n            swap(copy, i, r);\\n        }\\n        return copy;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```"
                    }
                ]
            }
        ]
    }
]