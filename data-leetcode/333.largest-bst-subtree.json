[
    {
        "title": "Search in Rotated Sorted Array",
        "question_content": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\n&nbsp;\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 5000\n\t-104 <= nums[i] <= 104\n\tAll values of nums are unique.\n\tnums is an ascending array that is possibly rotated.\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 14425,
                "title": "concise-o-log-n-binary-search-solution",
                "content": "    class Solution {\\n    public:\\n        int search(int A[], int n, int target) {\\n            int lo=0,hi=n-1;\\n            // find the index of the smallest value using binary search.\\n            // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.\\n            // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.\\n            while(lo<hi){\\n                int mid=(lo+hi)/2;\\n                if(A[mid]>A[hi]) lo=mid+1;\\n                else hi=mid;\\n            }\\n            // lo==hi is the index of the smallest value and also the number of places rotated.\\n            int rot=lo;\\n            lo=0;hi=n-1;\\n            // The usual binary search and accounting for rotation.\\n            while(lo<=hi){\\n                int mid=(lo+hi)/2;\\n                int realmid=(mid+rot)%n;\\n                if(A[realmid]==target)return realmid;\\n                if(A[realmid]<target)lo=mid+1;\\n                else hi=mid-1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(int A[], int n, int target) {\\n            int lo=0,hi=n-1;\\n            // find the index of the smallest value using binary search.\\n            // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.\\n            // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.\\n            while(lo<hi){\\n                int mid=(lo+hi)/2;\\n                if(A[mid]>A[hi]) lo=mid+1;\\n                else hi=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 14435,
                "title": "clever-idea-making-it-simple",
                "content": "This very nice idea is from [rantos22\\'s solution](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14443/C++-4-lines-4ms) who sadly only commented *\"You are not expected to understand that :)\"*, which I guess is the reason it\\'s now it\\'s hidden among the most downvoted solutions. I present an explanation and a more usual implementation.\\n\\n---\\n\\n**Explanation**\\n\\nLet\\'s say `nums` looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nBecause it\\'s not fully sorted, we can\\'t do normal binary search. But here comes the trick:\\n\\n- If target is let\\'s say 14, then we adjust `nums` to this, where \"inf\" means infinity:  \\n[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]  \\n\\n- If target is let\\'s say 7, then we adjust `nums` to this:  \\n[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nAnd then we can simply do ordinary binary search.\\n\\nOf course we don\\'t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0].\\n\\n---\\n\\n**Code**\\n\\nIf `nums[mid]` and `target` are *\"on the same side\"* of `nums[0]`, we just take `nums[mid]`. Otherwise we use -infinity or +infinity as needed.\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            \\n            double num = (nums[mid] < nums[0]) == (target < nums[0])\\n                       ? nums[mid]\\n                       : target < nums[0] ? -INFINITY : INFINITY;\\n                       \\n            if (num < target)\\n                lo = mid + 1;\\n            else if (num > target)\\n                hi = mid;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "This very nice idea is from [rantos22\\'s solution](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14443/C++-4-lines-4ms) who sadly only commented *\"You are not expected to understand that :)\"*, which I guess is the reason it\\'s now it\\'s hidden among the most downvoted solutions. I present an explanation and a more usual implementation.\\n\\n---\\n\\n**Explanation**\\n\\nLet\\'s say `nums` looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nBecause it\\'s not fully sorted, we can\\'t do normal binary search. But here comes the trick:\\n\\n- If target is let\\'s say 14, then we adjust `nums` to this, where \"inf\" means infinity:  \\n[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]  \\n\\n- If target is let\\'s say 7, then we adjust `nums` to this:  \\n[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nAnd then we can simply do ordinary binary search.\\n\\nOf course we don\\'t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0].\\n\\n---\\n\\n**Code**\\n\\nIf `nums[mid]` and `target` are *\"on the same side\"* of `nums[0]`, we just take `nums[mid]`. Otherwise we use -infinity or +infinity as needed.\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            \\n            double num = (nums[mid] < nums[0]) == (target < nums[0])\\n                       ? nums[mid]\\n                       : target < nums[0] ? -INFINITY : INFINITY;\\n                       \\n            if (num < target)\\n                lo = mid + 1;\\n            else if (num > target)\\n                hi = mid;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14436,
                "title": "revised-binary-search",
                "content": "    public class Solution {\\n    public int search(int[] A, int target) {\\n        int lo = 0;\\n        int hi = A.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (A[mid] == target) return mid;\\n            \\n            if (A[lo] <= A[mid]) {\\n                if (target >= A[lo] && target < A[mid]) {\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            } else {\\n                if (target > A[mid] && target <= A[hi]) {\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        return A[lo] == target ? lo : -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int search(int[] A, int target) {\\n        int lo = 0;\\n        int hi = A.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (A[mid] == target) return mid;\\n            \\n            if (A[lo] <= A[mid]) {\\n                if (target >= A[lo] && target < A[mid]) {\\n                    hi = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 154836,
                "title": "the-inf-and-inf-method-but-with-a-better-explanation-for-dummies-like-me",
                "content": "[Solution and explanation from StefanPochmann](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple) but I\\'m such a dummy I could not understand it for a whole day. I had to think of it intuitively for a long time before I got it and thought I\\'d write an explanation for dummies like me\\n**Explanation**\\nThink of the problem in this. We cannot do regular binary search because of the rotation.\\n* Example: ```nums```: [12, 13, 14, 15, 16, 17, 0, 1, 2, 3, 4, 5, 6, 7]\\n* Ideally this would have looked as [0, 1, 2, 3, 4, 5, 6, 7, **12**, 13, 14, 15, 16, 17]\\nBut it is rotated at a pivot number: 12. This is ```nums[0]```. Let\\'s call it  pivot number for this explanation.\\n\\nLet\\'s call the left increasing sub sequence as **left half** and right increasing subsequence as **right half**. \\n\\n**HERE\\'S THE GIST OF THE SOLUTION LOGIC: THE PROBLEM IN NOT BEING ABLE TO DO REGULAR BINARY SEARCH IS: WHEN YOUR MID POINT AND TARGET END UP BEING IN DIFFERENT HALVES (ONE IS IN LEFT AND OTHER IN RIGHT OR VICE VERSA). IF THEY ARE BOTH IN SAME HALF, IT\\'S JUST LIKE REGULAR BINARY SEARCH BECAUSE YOU WILL CONVERGE TOWARDS THE TARGET ON THAT STEP OF THE BINARY SEARCH. IF YOU ENDED UP IN SEPARATE HALVES, WE CAN CONVERGE TOWARDS THE TARGET BY MAKING IT -INF OR INF LIKE SHOWN BELOW.**\\nHere\\'s the trick:\\n* If ```target``` is say in the left half, then when searching we need to make the numbers as \\n\\t*  [12, 13, 14, 15, 16, 17, inf, inf, inf, inf, inf, inf, inf, inf] \\n*  if ```target``` is in right half then we need to make it as \\n\\t*  [-inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7]\\n\\nWe don\\'t need to edit the actual array like that, we just need to make the comparator number(in regular case, the mid point that we select) to INF or -INF based on which side the ```target``` is and which side the mid point number is.\\n\\nOkay, but we don\\'t need to always use the comparator as -inf or inf. Think of the case when that is possible?\\nThat\\'s when your ```target``` and ```nums[mid]``` are on the same half side (left or right half). THis means that your mid point and target are on the same half and you are converging towards the target. So then just keep doing regular binary for that step and let the comparator be ```nums[mid]```.\\n* How do we check if they both (```nums[mid]``` and ```target```) are on the same half? We have to check if they are both greater than the pivot number or both smaller than pivot number \\n\\t* ```if (((nums[mid] > nums[0]) && (target > nums[0])) || ((nums[mid] <= nums[0]) && (target <= nums[0])))```.\\n\\t* This can also be done as ```if ((target > nums[0]) == (nums[mid] > nums[0]))```.\\n\\t* Ok, so if they both are on the same half let our comparator be ```nums[mid]```, because we are converging towards the target and are on the same half at the moment of comparision.\\n\\t*  ```comparator = nums[mid]```\\n\\t*  proceed with comparing how you do regular binary search comparision.\\n\\nBut, what if ```nums[mid]``` and ```target``` are on different halves? Then we have to not use the ```nums[mid]``` as comparator. We have to use -INF or INF. How can we decide whether to make comparator as  -INF or INF instead of ```nums[mid]```?\\n* target and ```nums[mid]``` are on different halves. we have to change ```nums[mid]``` to -INF or INF.\\n* Let\\'s find out which side ```nums[mid]``` is. If we know which half (left or right) it is in, we know whether to select -INF or INF.\\n* Compare target to ```nums[0]```. (Why compare ```target``` and not ```nums[mid]``` because we want to make the numbers on ```nums[mid]``` \\'s side as -INF or INF when comparing, not on ```target```\\'s side, so we use target as the reference)\\n* if ```target``` is greater than ```nums[0]```, target is on the **left half**. Look at the example above and you can see this.\\n\\t* For example: ```target``` is 14, it is greater than 12 so it belongs in **left half**\\n\\t* This means that ```nums[mid]``` is on the other half: **right half**. Make comparator as INF.\\n* if ```target``` is less than nums[0], target is on the **right half**. Look at the example above:\\n\\t* For example if ```target``` is 5, it is less than 12 so it belongs in **right half**\\n\\t* This means that ```nums[mid]``` is on the other half. **left half**. make comparator as -INF.\\n\\nNow you can go ahead and do binary search\\n______________________________________________________________________________________________________________________________________________________\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n            int l = 0, r = nums.size()-1;\\n            while(l <= r)\\n            {\\n                int mid = (r - l)/2 + l;\\n                int comparator = nums[mid];\\n                // Checking if both target and nums[mid] are on same side.\\n                if((target < nums[0]) && (nums[mid] < nums[0]) || (target >= nums[0]) && (nums[mid] >= nums[0]))\\n                    comparator = nums[mid];\\n                else\\n                {\\n                    // Trying to figure out where nums[mid] is and making comparator as -INF or INF\\n                    if(target <nums[0])\\n                        comparator = -INFINITY;\\n                    else \\n                        comparator = INFINITY;\\n\\n                }\\n                if(target == comparator) return mid;\\n                if(target > comparator)            \\n                    l = mid+1;            \\n                else\\n                    r = mid-1;\\n\\n            }\\n            return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```nums```\n```nums[0]```\n```target```\n```target```\n```target```\n```target```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```target```\n```if (((nums[mid] > nums[0]) && (target > nums[0])) || ((nums[mid] <= nums[0]) && (target <= nums[0])))```\n```if ((target > nums[0]) == (nums[mid] > nums[0]))```\n```nums[mid]```\n```comparator = nums[mid]```\n```nums[mid]```\n```target```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[0]```\n```target```\n```nums[mid]```\n```nums[mid]```\n```target```\n```target```\n```nums[0]```\n```target```\n```nums[mid]```\n```target```\n```target```\n```nums[mid]```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n            int l = 0, r = nums.size()-1;\\n            while(l <= r)\\n            {\\n                int mid = (r - l)/2 + l;\\n                int comparator = nums[mid];\\n                // Checking if both target and nums[mid] are on same side.\\n                if((target < nums[0]) && (nums[mid] < nums[0]) || (target >= nums[0]) && (nums[mid] >= nums[0]))\\n                    comparator = nums[mid];\\n                else\\n                {\\n                    // Trying to figure out where nums[mid] is and making comparator as -INF or INF\\n                    if(target <nums[0])\\n                        comparator = -INFINITY;\\n                    else \\n                        comparator = INFINITY;\\n\\n                }\\n                if(target == comparator) return mid;\\n                if(target > comparator)            \\n                    l = mid+1;            \\n                else\\n                    r = mid-1;\\n\\n            }\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14472,
                "title": "java-ac-solution-using-once-binary-search",
                "content": "The idea is that when rotating the array, there must be one half of the array that is still in sorted order. \\nFor example,  6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. \\n    \\n    \\n\\n    public class Solution {\\n        public int search(int[] nums, int target) {\\n            int start = 0;\\n            int end = nums.length - 1;\\n            while (start <= end){\\n                int mid = (start + end) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n            \\n                if (nums[start] <= nums[mid]){\\n                     if (target < nums[mid] && target >= nums[start]) \\n                        end = mid - 1;\\n                     else\\n                        start = mid + 1;\\n                } \\n            \\n                if (nums[mid] <= nums[end]){\\n                    if (target > nums[mid] && target <= nums[end])\\n                        start = mid + 1;\\n                     else\\n                        end = mid - 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int search(int[] nums, int target) {\\n            int start = 0;\\n            int end = nums.length - 1;\\n            while (start <= end){\\n                int mid = (start + end) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n            \\n                if (nums[start] <= nums[mid]){\\n                     if (target < nums[mid] && target >= nums[start]) \\n                        end = mid - 1;\\n                     else\\n                        start = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14437,
                "title": "python-binary-search-solution-o-logn-48ms",
                "content": "    class Solution:\\n        # @param {integer[]} numss\\n        # @param {integer} target\\n        # @return {integer}\\n        def search(self, nums, target):\\n            if not nums:\\n                return -1\\n    \\n            low, high = 0, len(nums) - 1\\n    \\n            while low <= high:\\n                mid = (low + high) / 2\\n                if target == nums[mid]:\\n                    return mid\\n    \\n                if nums[low] <= nums[mid]:\\n                    if nums[low] <= target <= nums[mid]:\\n                        high = mid - 1\\n                    else:\\n                        low = mid + 1\\n                else:\\n                    if nums[mid] <= target <= nums[high]:\\n                        low = mid + 1\\n                    else:\\n                        high = mid - 1\\n    \\n            return -1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 14616,
                "title": "c-binary-search-with-comments-easy-to-read-and-understand",
                "content": "    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size()-1;\\n            while (l <= r) {\\n                int mid = (l+r) / 2;\\n                if (target == nums[mid])\\n                    return mid;\\n                // there exists rotation; the middle element is in the left part of the array\\n                if (nums[mid] > nums[r]) {\\n                    if (target < nums[mid] && target >= nums[l])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }\\n                // there exists rotation; the middle element is in the right part of the array\\n                else if (nums[mid] < nums[l]) {\\n                    if (target > nums[mid] && target <= nums[r])\\n                        l = mid + 1;\\n                    else\\n                        r = mid - 1;\\n                }\\n                // there is no rotation; just like normal binary search\\n                else {\\n                    if (target < nums[mid])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size()-1;\\n            while (l <= r) {\\n                int mid = (l+r) / 2;\\n                if (target == nums[mid])\\n                    return mid;\\n                // there exists rotation; the middle element is in the left part of the array\\n                if (nums[mid] > nums[r]) {\\n                    if (target < nums[mid] && target >= nums[l])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 273622,
                "title": "javascript-simple-o-log-n-binary-search-solution",
                "content": "Let\\'s take some examples and see how we can simplify the condition.\\n\\nOriginal sorted array\\n[1, 2, 3, 4, 5, 6, 7] \\n\\nAfter rotation, it might be something like\\n[3, 4, 5, 6, 7, 1, 2]\\n[6, 7, 1, 2, 3, 4, 5]\\n[1, 2, 3, 4, 5, 6, 7] <-- rotated and end up the same\\nand etc..\\n\\nWhen you divide the rotated array into two halves, using `mid` index, **at least one of subarray should remain sorted ALWAYS**.\\n\\n[3, 4, 5, 6, 7, 1, 2] \\n-> **[3, 4, 5]** [ 6, 7, 1, 2] \\nthe left side remains sorted\\n\\n[6, 7, 1, 2, 3, 4, 5]\\n-> [6, 7, 1] **[2, 3, 4, 5]**\\n the right side remains sorted\\n\\n[1, 2, 3, 4, 5, 6, 7]\\n-> **[1, 2, 3]** **[4, 5, 6, 7]**\\nBoth sides remain sorted.\\n\\nIf you know one side is sorted, the rest of logic becomes very simple. \\nIf one side is sorted, check if the `target` is in the boundary, otherwise it\\'s on the other side.\\n```\\nIF smallest <= target <= biggest\\n  then target is here\\nELSE\\n  then target is on the other side\\n```\\n\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n    \\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    }\\n    \\n    // When dividing the roated array into two halves, one must be sorted.\\n    \\n    // Check if the left side is sorted\\n    if (nums[left] <= nums[mid]) {\\n      if (nums[left] <= target && target <= nums[mid]) {\\n        // target is in the left\\n        right = mid - 1;\\n        \\n      } else {\\n        // target is in the right\\n        left = mid + 1;\\n      }\\n    } \\n    \\n    // Otherwise, the right side is sorted\\n    else {\\n      if (nums[mid] <= target && target <= nums[right]) {\\n        // target is in the right\\n        left = mid + 1;\\n\\n      } else {\\n        // target is in the left\\n        right = mid - 1;\\n      }\\n    }\\n    \\n    \\n  }\\n    \\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nIF smallest <= target <= biggest\\n  then target is here\\nELSE\\n  then target is on the other side\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n    \\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    }\\n    \\n    // When dividing the roated array into two halves, one must be sorted.\\n    \\n    // Check if the left side is sorted\\n    if (nums[left] <= nums[mid]) {\\n      if (nums[left] <= target && target <= nums[mid]) {\\n        // target is in the left\\n        right = mid - 1;\\n        \\n      } else {\\n        // target is in the right\\n        left = mid + 1;\\n      }\\n    } \\n    \\n    // Otherwise, the right side is sorted\\n    else {\\n      if (nums[mid] <= target && target <= nums[right]) {\\n        // target is in the right\\n        left = mid + 1;\\n\\n      } else {\\n        // target is in the left\\n        right = mid - 1;\\n      }\\n    }\\n    \\n    \\n  }\\n    \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879263,
                "title": "100-binary-search-easy-video-o-log-n-optimal-solution",
                "content": "# Problem Understanding\\n\\nThe task is to search for a target integer in a sorted array that has been rotated at an unknown pivot. \\n\\nFor instance, the array $$[0,1,2,4,5,6,7]$$ could be rotated at the 4th position to give $$[4,5,6,7,0,1,2]$$. The challenge is to find the position of the target integer in this rotated array. \\n\\n![example.png](https://assets.leetcode.com/users/images/368df713-a386-4fd6-92eb-72d7606ac16f_1691456157.2050898.png)\\n\\n- The top section shows the `nums` array with a red rectangle highlighting the current \"mid\" value being considered in each step.\\n- The bottom section displays a table that presents the steps of the binary search. Each row corresponds to a step, detailing:\\n  - The step number.\\n  - The indices of the low (L), mid (M), and high (R) pointers.\\n  - The values at the low (L), mid (M), and high (R) positions.\\n\\n# Live Coding & Explenation\\nhttps://youtu.be/hywGbVJldj0\\n\\n# Approach\\n\\nGiven the properties of the array, it\\'s tempting to perform a linear search. However, that would result in a time complexity of $$O(n)$$. Instead, we can use the properties of the array to our advantage and apply a binary search to find the target with time complexity of $$ O(\\\\log n) $$ only.\\n\\n## Treating the Rotated Array\\n\\nAlthough the array is rotated, it retains some properties of sorted arrays that we can leverage. Specifically, one half of the array (either the left or the right) will always be sorted. This means we can still apply binary search by determining which half of our array is sorted and whether the target lies within it.\\n\\n## Binary Search\\n\\nBinary search is an efficient algorithm for finding a target value within a sorted list. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.\\n\\n## Initialization\\n\\nWe start with two pointers:\\n\\n- $$ \\\\text{left} $$ - This represents the beginning of the array. We initialize it to 0, the index of the first element.\\n- $$ \\\\text{right} $$ - This represents the end of the array. It\\'s set to $$ n - 1 $$, the index of the last element, where $$ n $$ is the length of the array.\\n\\n## Iterative Binary Search\\n\\nWe perform the binary search within a while loop until $$ \\\\text{left} $$ exceeds $$ \\\\text{right} $$. In each iteration, we calculate the midpoint between $$ \\\\text{left} $$ and $$ \\\\text{right} $$.\\n\\n### Deciding the Sorted Half:\\n\\nAt any point during the search in the rotated array, one half (either the left or the right) will always be sorted. Determining which half is sorted is crucial for our modified binary search. \\n\\n- **If left half $$[low...mid]$$ is sorted**: We know this if the element at $$ \\\\text{low} $$ is less than or equal to the element at $$ \\\\text{mid} $$. In a normally sorted array, if the start is less than or equal to the midpoint, it means all elements till the midpoint are in the correct increasing order.\\n\\n  - **If the target lies within this sorted left half**: We know this if the target is greater than or equal to the element at $$ \\\\text{low} $$ and less than the element at $$ \\\\text{mid} $$. If this is the case, we then move our search to this half, meaning, we update $$ \\\\text{high} $$ to $$ \\\\text{mid} - 1 $$.\\n\\n  - **Otherwise**: The target must be in the right half. So, we update $$ \\\\text{low} $$ to $$ \\\\text{mid} + 1 $$.\\n\\n- **If right half $$[mid...high]$$ is sorted**: This is the else part. If the left half isn\\'t sorted, the right half must be!\\n\\n  - **If the target lies within this sorted right half**: We know this if the target is greater than the element at $$ \\\\text{mid} $$ and less than or equal to the element at $$ \\\\text{high} $$. If so, we move our search to this half by updating $$ \\\\text{low} $$ to $$ \\\\text{mid} + 1 $$.\\n\\n  - **Otherwise**: The target must be in the left half. So, we update $$ \\\\text{high} $$ to $$ \\\\text{mid} - 1 $$.\\n\\n### Rationale:\\n\\nThe beauty of this approach lies in its ability to determine with certainty which half of the array to look in, even though the array is rotated. By checking which half of the array is sorted and then using the sorted property to determine if the target lies in that half, we can effectively eliminate half of the array from consideration at each step, maintaining the $$ O(\\\\log n) $$ time complexity of the binary search.\\n\\n## Complexity\\n\\n**Time Complexity**: The time complexity is $$ O(\\\\log n) $$ since we\\'re performing a binary search over the elements of the array.\\n\\n**Space Complexity**: The space complexity is $$ O(1) $$ because we only use a constant amount of space to store our variables ($$ \\\\text{left} $$, $$\\\\text{right} $$, $$ \\\\text{mid} $$), regardless of the size of the input array.\\n\\n# Performance\\n\\n![33-per.png](https://assets.leetcode.com/users/images/1306fe69-ec15-427c-90e0-c641ed275b2f_1691455472.463153.png)\\n\\n\\n# Code\\n\\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Check if left half is sorted\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            # Otherwise, right half is sorted\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n``` Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\\n``` Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n\\n        if (nums[mid] === target) {\\n            return mid;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\nI hope this explanation provides clarity on the \"Search in Rotated Sorted Array\" problem. If you have any more questions, feel free to ask! If you found this helpful, consider giving it a thumbs up. Happy coding! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Check if left half is sorted\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            # Otherwise, right half is sorted\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n``` Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n\\n        if (nums[mid] === target) {\\n            return mid;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894031,
                "title": "python-o-logn-detailed-explanation",
                "content": "#### Idea:\\nWe have an ascending array, which is rotated at some pivot.\\nLet\\'s call the rotation the `inflection point`. (IP)\\nOne characteristic the inflection point holds is: `arr[IP] > arr[IP + 1] and arr[IP] > arr[IP - 1]`\\nSo if we had an array like: `[7, 8, 9, 0, 1, 2, 3, 4]` the inflection point, `IP` would be the number `9`.\\n\\nOne thing we can see is that values until the IP are ascending. And values from IP + 1 until end are also ascending (`binary search`, wink, wink).\\nAlso the values from [0, IP] are always bigger than [IP + 1, n].\\n\\n#### intuition:\\nWe can perform a Binary Search.\\nIf **A[mid] is bigger than A[left]** we know the inflection point will be to the right of us, meaning values from a[left]...a[mid] **are ascending**.\\n\\nSo if `target` is between that range we just `cut our search space to the left`.\\nOtherwise go right.\\n\\n**The other condition is that A[mid] is not bigger than A[left]** meaning **a[mid]...a[right] is ascending**.\\nIn the same manner we can check if target is in that range and cut the search space correspondingly.\\n\\n##### Time complexity: O(logn)\\n##### Space complexity: O(1)\\n<hr/>\\n\\n### Algorithm:\\n\\n```\\nclass Solution:\\n    def search(self, A: List[int], target: int) -> int:\\n        n = len(A)\\n        left, right = 0, n - 1\\n        if n == 0: return -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if A[mid] == target: return mid\\n            \\n            # inflection point to the right. Left is strictly increasing\\n            if A[mid] >= A[left]:\\n                if A[left] <= target < A[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n                    \\n            # inflection point to the left of me. Right is strictly increasing\\n            else:\\n                if A[mid] < target <= A[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, A: List[int], target: int) -> int:\\n        n = len(A)\\n        left, right = 0, n - 1\\n        if n == 0: return -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if A[mid] == target: return mid\\n            \\n            # inflection point to the right. Left is strictly increasing\\n            if A[mid] >= A[left]:\\n                if A[left] <= target < A[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n                    \\n            # inflection point to the left of me. Right is strictly increasing\\n            else:\\n                if A[mid] < target <= A[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14419,
                "title": "pretty-short-c-java-ruby-python",
                "content": "Explanation below the codes.\\n\\n**Ruby:**\\n\\n    def search(nums, target)\\n      i = (0...nums.size).bsearch { |i|\\n        (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n      }\\n      nums[i || 0] == target ? i : -1\\n    end\\n\\n**Ruby Golf**, just once for fun:\\n\\n    def search(n, t)\\n      i=(0...n.size).bsearch{|i|(n[0]<=t)^(n[0]>n[i])^(t>n[i])};n[i||0]==t ?i:-1\\n    end\\n\\n**Python:**\\n\\n    def search(self, nums, target):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            if (nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo if target in nums[lo:lo+1] else -1\\n\\n**Python using `bisect`:**\\n\\n    class Solution:\\n        def search(self, nums, target):\\n            self.__getitem__ = lambda i: \\\\\\n                (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n            i = bisect.bisect_left(self, True, 0, len(nums))\\n            return i if target in nums[i:i+1] else -1\\n\\n**C++:**\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = int(nums.size()) - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo == hi && nums[lo] == target ? lo : -1;\\n    }\\n\\n**Java:**\\n\\n    public int search(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo == hi && nums[lo] == target ? lo : -1;\\n    }\\n\\n---\\n\\nExplanation\\n-\\n\\nMy solutions use binary search guided by the following thoughts:\\n\\nRemember the array is sorted, except it might drop at one point.\\n\\n- **If nums[0] <= nums[i]**, then nums[0..i] is sorted (in case of \"**==**\" it's just one element, and in case of \"**<**\" there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if `nums[0] <= target <= nums[i]`.\\n\\n- **If nums[i] < nums[0]**, then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target *doesn't* lie strictly between them, i.e., if `target <= nums[i] < nums[0]` or `nums[i] < nums[0] <= target`\\n\\nThose three cases look cyclic:\\n\\n        nums[0] <= target <= nums[i]\\n                   target <= nums[i] < nums[0]\\n                             nums[i] < nums[0] <= target\\n\\nSo I have the three checks `(nums[0] <= target)`, `(target <= nums[i])` and `(nums[i] < nums[0])`, and I want to know whether exactly two of them are true. They can't all be true or all be false (check it), so I just need to distinguish between \"two true\" and \"one true\". Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those don't let me add booleans but do let me xor them.\\n\\n(Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "class Solution:\\n        def search(self, nums, target):\\n            self.__getitem__ = lambda i: \\\\\\n                (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n            i = bisect.bisect_left(self, True, 0, len(nums))\\n            return i if target in nums[i:i+1] else -1\\n\\n**C++:**\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = int(nums.size()) - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3283609,
                "title": "easy-to-understand-c-100-beats",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function search takes in a vector nums representing the rotated sorted array and an integer target that we need to find.\\nIt initializes the variables left and right to the start and end indices of the array, respectively.\\nThe variable mid is calculated as the middle index of the array using the formula (left + right) / 2.\\nThe while loop is executed as long as the left pointer is less than or equal to the right pointer. This ensures that the search space is not empty.\\nInside the while loop, we check if the middle element nums[mid] is equal to the target. If it is, we return the index mid.\\nIf the middle element is greater than or equal to the left element, it means the left part of the array is non-rotated.\\nWe then check if the target is within the range of the left non-rotated part. If it is, we update the right pointer to mid - 1 to search in the left part.\\nIf the target is not within the range, we update the left pointer to mid + 1 to search in the right part.\\nIf the middle element is less than the left element, it means the right part of the array is rotated.\\nWe then check if the target is within the range of the right rotated part. If it is, we update the left pointer to mid + 1 to search in the right part.\\nIf the target is not within the range, we update the right pointer to mid - 1 to search in the left part.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n     int n = nums.size();\\n      int left = 0;\\n      int right = n-1;\\n      int mid= left + (right - left) / 2;\\n      while(left <= right){\\n        if(nums[mid] == target)\\n         return mid;\\n        if(nums[mid] >= nums[left]) {\\n          if(target >= nums[left] && target <= nums[mid])\\n            {\\n                right = mid - 1;\\n            }\\n           else left = mid + 1;\\n        } \\n        else {\\n          if(target >= nums[mid] && target <= nums[right]) \\n            left = mid + 1;\\n          else right = mid - 1;\\n        }\\n          mid = left + (right - left) / 2;\\n      }\\n      return -1;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/c8840309-29a1-4863-bf1b-90c2f8bd1387_1678528531.5008342.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n     int n = nums.size();\\n      int left = 0;\\n      int right = n-1;\\n      int mid= left + (right - left) / 2;\\n      while(left <= right){\\n        if(nums[mid] == target)\\n         return mid;\\n        if(nums[mid] >= nums[left]) {\\n          if(target >= nums[left] && target <= nums[mid])\\n            {\\n                right = mid - 1;\\n            }\\n           else left = mid + 1;\\n        } \\n        else {\\n          if(target >= nums[mid] && target <= nums[right]) \\n            left = mid + 1;\\n          else right = mid - 1;\\n        }\\n          mid = left + (right - left) / 2;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427469,
                "title": "c-very-easy-to-understand-100-faster-binary-search-solution",
                "content": "**PSUEDOCODE**\\n1) Find middle point mid = (l + h)/2\\n2) If key is present at middle point, return mid.\\n3) Else If arr[l..mid] is sorted\\n    a) If key to be searched lies in range from arr[l]\\n       to arr[mid], recur for arr[l..mid].\\n    b) Else recur for arr[mid+1..h]\\n4) Else (arr[mid+1..h] must be sorted)\\n    a) If key to be searched lies in range from arr[mid+1]\\n       to arr[h], recur for arr[mid+1..h].\\n    b) Else recur for arr[l..mid] \\n**PS:** The psuedocode is taken from geeksfor geeks to help someone reading understand better, But code is mine!!\\n```\\nint beg=0,end=nums.size()-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[beg]<=nums[mid])\\n            {\\n                if(target<=nums[mid] && target>=nums[beg])\\n                    end=mid-1;\\n                else\\n                    beg=mid+1;\\n            }\\n            \\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[end])\\n                   beg=mid+1;\\n                else\\n                    end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint beg=0,end=nums.size()-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[beg]<=nums[mid])\\n            {\\n                if(target<=nums[mid] && target>=nums[beg])\\n                    end=mid-1;\\n                else\\n                    beg=mid+1;\\n            }\\n            \\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[end])\\n                   beg=mid+1;\\n                else\\n                    end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690820,
                "title": "efficient-approach-modified-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/b652beed-4dbf-4e9c-b10a-bcf7d81ada74_1666416201.2681432.png)\\n\\n```\\n/* This is always possible when we are at mid either left half is sorted or right haldf is sorted */\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low = 0, high = n-1;\\n        long int mid = -1;\\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            if(arr[mid] == target) return  mid;\\n            if(arr[mid] >= arr[low]){\\n                /* left half sorted */\\n                if(target >= arr[low] && target < arr[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                /* right half is sorted */\\n                if( target > arr[mid] && target <= arr[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n/*  If you like the solution please upvote thanku*/\\n```\\n\\nIf you like the solution please upvote thanku",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/* This is always possible when we are at mid either left half is sorted or right haldf is sorted */\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low = 0, high = n-1;\\n        long int mid = -1;\\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            if(arr[mid] == target) return  mid;\\n            if(arr[mid] >= arr[low]){\\n                /* left half sorted */\\n                if(target >= arr[low] && target < arr[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                /* right half is sorted */\\n                if( target > arr[mid] && target <= arr[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n/*  If you like the solution please upvote thanku*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14601,
                "title": "java-intuitive-closest-to-unflavored-binary-search",
                "content": "I have looked at popular solutions like [this][1], [this][2] and [this][3] , and found that the top-level logic is not consistent with binary search, because they compare nums[left] or nums[right] against nums[mid], instead of against target.\\n\\nIf we keep the logic of binary search, and just checking monotonicity inside the if block, the logic will be closest to unflavored binary search. Easier to understand and connect to binary search.\\n\\n\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] > target) {\\n                // the left half is monotonic, yet still does not satisfy\\n                if (nums[left] <= nums[mid] && nums[left] > target) { \\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                // the right half is monotonic, yet still does not satisfy\\n                if (nums[right] >= nums[mid] && nums[right] < target) { \\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/41134/java-ac-solution-using-once-binary-search\\n  [2]: https://leetcode.com/discuss/25389/binary-search-java-solusion-o-log-n\\n  [3]: https://leetcode.com/discuss/22678/revised-binary-search",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "I have looked at popular solutions like [this][1], [this][2] and [this][3] , and found that the top-level logic is not consistent with binary search, because they compare nums[left] or nums[right] against nums[mid], instead of against target.\\n\\nIf we keep the logic of binary search, and just checking monotonicity inside the if block, the logic will be closest to unflavored binary search. Easier to understand and connect to binary search.\\n\\n\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] > target) {\\n                // the left half is monotonic, yet still does not satisfy\\n                if (nums[left] <= nums[mid] && nums[left] > target) { \\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                // the right half is monotonic, yet still does not satisfy\\n                if (nums[right] >= nums[mid] && nums[right] < target) { \\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/41134/java-ac-solution-using-once-binary-search\\n  [2]: https://leetcode.com/discuss/25389/binary-search-java-solusion-o-log-n\\n  [3]: https://leetcode.com/discuss/22678/revised-binary-search",
                "codeTag": "Unknown"
            },
            {
                "id": 3416630,
                "title": "c-java-python-javascript-fully-explained-binary-search",
                "content": "# Intuition:\\nThe given problem asks us to find the index of the target element in the given rotated sorted array.\\n\\n# Approach:\\n- The solution provided in the code implements two approaches, Brute force and Binary search.\\n\\n    - The Brute force approach: \\n        1. Iterates through the array and checks if the current element is equal to the target. If it is, then it returns the index of that element, otherwise, it returns -1. This approach has a time complexity of O(n).\\n\\n    - The Binary search approach is based on the fact that a rotated sorted array can be divided into two sorted arrays.\\n        1. The approach starts with finding the mid element and compares it with the target element. \\n        2. If they are equal, it returns the mid index. If the left half of the array is sorted, then it checks if the target lies between the start and the mid, and updates the end pointer accordingly. \\n        3. Otherwise, it checks if the target lies between mid and end, and updates the start pointer accordingly. \\n        4. If the right half of the array is sorted, then it checks if the target lies between mid and end, and updates the start pointer accordingly. \\n        5. Otherwise, it checks if the target lies between start and mid, and updates the end pointer accordingly. \\n        6. This process continues until the target element is found, or the start pointer becomes greater than the end pointer, in which case it returns -1. \\n        7. This approach has a time complexity of O(log n).\\n\\n# Complexity:\\n\\n- Time Complexity:\\n    1. The time complexity of the Brute force approach is O(n), where n is the size of the input array.\\n    2. The time complexity of the Binary search approach is O(log n), where n is the size of the input array.\\n\\n- Space Complexity:\\nThe space complexity of both approaches is O(1) as we are not using any extra space to store any intermediate results.\\n\\n---\\n\\n\\n# Code:  C++\\n## Brute Force:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(target==nums[i]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n## Binary Search:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        int mid= (start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            if(nums[start]<=nums[mid]){\\n                if(nums[start]<=target && nums[mid]>=target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else{\\n                if(nums[end]>=target && nums[mid]<=target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n# Code: Java\\n## Binary Search:\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && nums[mid] >= target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[end] >= target && nums[mid] <= target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Code: Python\\n## Binary Search:\\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        mid = (start + end) / 2\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                return mid\\n            if nums[start] <= nums[mid]:\\n                if nums[start] <= target and nums[mid] >= target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if nums[end] >= target and nums[mid] <= target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n\\n```\\n\\n---\\n\\n# Code: JavaScript\\n## Binary Search:\\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let mid = Math.floor((start + end) / 2);\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        }\\n        if (nums[start] <= nums[mid]) {\\n            if (nums[start] <= target && nums[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else {\\n            if (nums[end] >= target && nums[mid] <= target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n```\\n> # ***Thanks For Voting***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(target==nums[i]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        int mid= (start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            if(nums[start]<=nums[mid]){\\n                if(nums[start]<=target && nums[mid]>=target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else{\\n                if(nums[end]>=target && nums[mid]<=target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && nums[mid] >= target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[end] >= target && nums[mid] <= target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        mid = (start + end) / 2\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                return mid\\n            if nums[start] <= nums[mid]:\\n                if nums[start] <= target and nums[mid] >= target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if nums[end] >= target and nums[mid] <= target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n\\n```\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let mid = Math.floor((start + end) / 2);\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        }\\n        if (nums[start] <= nums[mid]) {\\n            if (nums[start] <= target && nums[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else {\\n            if (nums[end] >= target && nums[mid] <= target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14443,
                "title": "c-4-lines-4ms",
                "content": "    int search(vector<int>& nums, int target) \\n    {\\n            auto skip_left  = [&]( int x) { return x >= nums[0] ? numeric_limits<int>::min() : x; };\\n            auto skip_right = [&] (int x) { return x < nums[0] ? numeric_limits<int>::max() : x; };\\n            auto adjust = [&] (int x) { return target < nums[0] ? skip_left(x) : skip_right(x); };\\n      \\n            auto it = lower_bound( nums.begin(), nums.end(), target, [&] (int x, int y) { return adjust(x) < adjust(y); } );\\n                \\n            return it != nums.end() && *it == target ? it-nums.begin() : -1;\\n    }\\n\\n\\n\\nYou are not expected to understand that :)",
                "solutionTags": [],
                "code": "    int search(vector<int>& nums, int target) \\n    {\\n            auto skip_left  = [&]( int x) { return x >= nums[0] ? numeric_limits<int>::min() : x; };\\n            auto skip_right = [&] (int x) { return x < nums[0] ? numeric_limits<int>::max() : x; };\\n            auto adjust = [&] (int x) { return target < nums[0] ? skip_left(x) : skip_right(x); };\\n      \\n            auto it = lower_bound( nums.begin(), nums.end(), target, [&] (int x, int y) { return adjust(x) < adjust(y); } );\\n                \\n            return it != nums.end() && *it == target ? it-nums.begin() : -1;\\n    }\\n\\n\\n\\nYou are not expected to understand that :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1369541,
                "title": "c-binary-search-logic-explanation",
                "content": "## Logic Explanation:\\n* **Core Observation** - As we are are given a sorted and rotated array, it is guranteed that ***either 1/2 of the array is going to be sorted*** (If you aren\\'t getting this try taking different combinations of provided example array)\\n* Now our first job is to find that sorted half. To do this we can do a simple comparison of mid (```mid = (low+high)/2```) element with the starting element (```low```) of the array. \\n* Comparison (do this with pen and paper in hand)\\n\\t* ```if(nums[mid] >= nums[low])``` -> the left half of array is sorted.\\n\\t* ```else```  -> the right half of array is sorted.\\n* Now if left half of array is sorted:\\n\\t* check if provided ```target``` element lies in the range ```[low, mid)```.\\n\\t* If it does then update ```high = mid-1``` (hence skipping the part present on right of mid). \\n\\t* else update ```low = mid+1``` (hence skipping the part present on left of mid)\\n* else as the right array is sorted:\\n\\t* check if provided ```target``` element lies in the range ```(mid, high]```.\\n\\t* If it does then update ```low = mid+1``` (hence skipping the part present on left of mid). \\n\\t* else update ```high = mid-1``` (hence skipping the part present on right of mid)\\n* If still not found then ```return -1``` (duh!)\\n```\\nint search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            \\n            if(nums[mid]>=nums[low]){\\n                //left half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else{\\n                //right half is sorted\\n                if(target>nums[mid] && target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\nHapping coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```mid = (low+high)/2```\n```low```\n```if(nums[mid] >= nums[low])```\n```else```\n```target```\n```[low, mid)```\n```high = mid-1```\n```low = mid+1```\n```target```\n```(mid, high]```\n```low = mid+1```\n```high = mid-1```\n```return -1```\n```\\nint search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            \\n            if(nums[mid]>=nums[low]){\\n                //left half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else{\\n                //right half is sorted\\n                if(target>nums[mid] && target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350076,
                "title": "c-python-binary-search-clean-concise",
                "content": "**Idea**\\n- Please note that, this binary search only works when all elements in the array are distict.\\n- Binary search to find the pivot index, which is the index of the minimum element, exactly same with [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1436502)\\n- Then binary search to search the `target` in two increasing subarrays `[0..pivot-1]` and `[pivot...n-1]`.\\n<iframe src=\"https://leetcode.com/playground/n6K4c8SR/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\nComplexity:\\n- Time: `O(logN)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Please note that, this binary search only works when all elements in the array are distict.\\n- Binary search to find the pivot index, which is the index of the minimum element, exactly same with [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1436502)\\n- Then binary search to search the `target` in two increasing subarrays `[0..pivot-1]` and `[pivot...n-1]`.\\n<iframe src=\"https://leetcode.com/playground/n6K4c8SR/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\nComplexity:\\n- Time: `O(logN)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 14608,
                "title": "c-binary-search-solution",
                "content": "        \\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else {\\n                if(nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "        \\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else {\\n                if(nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1739104,
                "title": "c-binary-search-approach-0ms",
                "content": "Kindly **upvote**, if you find it helpful : )\\n\\n![image](https://assets.leetcode.com/users/images/2de76340-7386-457c-b049-e96982ad8d53_1643800067.1715698.jpeg)\\n\\nImplementation in C++:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getPivot(vector<int>& nums, int n){\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return s;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int s, int e, int target){\\n        int m = s + (e-s)/2;\\n        while(s <= e){\\n            if(nums[m]== target){\\n                return m;\\n            }\\n            else if(nums[m]< target){\\n                s = m+1;\\n            }\\n            else{\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int pivot = getPivot(nums, n);\\n        if(target >= nums[pivot] && target <= nums[n-1]){\\n            return binarySearch(nums, pivot, n-1, target);\\n        }\\n        else{\\n            return binarySearch(nums, 0, pivot-1, target);\\n        }\\n    }\\n    \\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getPivot(vector<int>& nums, int n){\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return s;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int s, int e, int target){\\n        int m = s + (e-s)/2;\\n        while(s <= e){\\n            if(nums[m]== target){\\n                return m;\\n            }\\n            else if(nums[m]< target){\\n                s = m+1;\\n            }\\n            else{\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int pivot = getPivot(nums, n);\\n        if(target >= nums[pivot] && target <= nums[n-1]){\\n            return binarySearch(nums, pivot, n-1, target);\\n        }\\n        else{\\n            return binarySearch(nums, 0, pivot-1, target);\\n        }\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14572,
                "title": "share-my-pretty-neat-java-bs-solution",
                "content": "I had different versions for this problem and read several other people's solutions and I came up with this neat solution. I want to share it here and hope you like it. The idea is to compare the middle element with the left element to decide which part is in order.\\n\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) return -1;\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= nums[l]) {\\n                if (target <= nums[m] && target >= nums[l]) r = m;\\n                else l = m + 1;\\n            } else {\\n                if (target > nums[m] && target <= nums[r]) l = m + 1;\\n                else r = m;\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I had different versions for this problem and read several other people's solutions and I came up with this neat solution. I want to share it here and hope you like it. The idea is to compare the middle element with the left element to decide which part is in order.\\n\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) return -1;\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= nums[l]) {\\n                if (target <= nums[m] && target >= nums[l]) r = m;\\n                else l = m + 1;\\n            } else {\\n                if (target > nums[m] && target <= nums[r]) l = m + 1;\\n                else r = m;\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3347991,
                "title": "100-beats-java-solutions-clean-and-easy-to-understand-code-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# simple binary search \\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n      int start=0;\\n        int end=nums.length-1;\\n        \\n        while(start<=end){\\n        int mid= start+(end-start) /2;\\n        if(nums[mid]==target) return mid;\\n        if(nums[start]<=nums[mid]){\\n            if(target<=nums[mid] && target>=nums[start]){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        else{\\n            if(target>=nums[mid] && target<=nums[end]){  \\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/6e20163e-37d4-448f-b574-21bd83baf6cd_1679927244.280445.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n      int start=0;\\n        int end=nums.length-1;\\n        \\n        while(start<=end){\\n        int mid= start+(end-start) /2;\\n        if(nums[mid]==target) return mid;\\n        if(nums[start]<=nums[mid]){\\n            if(target<=nums[mid] && target>=nums[start]){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        else{\\n            if(target>=nums[mid] && target<=nums[end]){  \\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432678,
                "title": "commented-easy-to-understand-simple-binary-search-javascript-submission",
                "content": "**Please do upvote, this motivates me to write better posts\\uD83D\\uDE05**\\n\\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    while(start<end){\\n        let mid = Math.floor((start+end)/2);\\n        if(nums[mid]===target) return mid;\\n//         If the left part is sorted\\n        if(nums[mid]>nums[start]){\\n//             if target lies in the range of left part\\n            if(target>=nums[start] && target<nums[mid]) end = mid-1;\\n            else start = mid+1;\\n        }\\n//         if the right part is sorted\\n        else if(nums[mid]<nums[end]){\\n//             if the target lies in the range of right part\\n            if(target>nums[mid] && target<=nums[end]) start = mid+1;\\n            else end = mid-1;\\n                \\n        }\\n//         otherwise break out of the loop\\n        else break;\\n    }\\n    return nums[end]===target?end:-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    while(start<end){\\n        let mid = Math.floor((start+end)/2);\\n        if(nums[mid]===target) return mid;\\n//         If the left part is sorted\\n        if(nums[mid]>nums[start]){\\n//             if target lies in the range of left part\\n            if(target>=nums[start] && target<nums[mid]) end = mid-1;\\n            else start = mid+1;\\n        }\\n//         if the right part is sorted\\n        else if(nums[mid]<nums[end]){\\n//             if the target lies in the range of right part\\n            if(target>nums[mid] && target<=nums[end]) start = mid+1;\\n            else end = mid-1;\\n                \\n        }\\n//         otherwise break out of the loop\\n        else break;\\n    }\\n    return nums[end]===target?end:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879488,
                "title": "binary-search-easy-to-understand-code-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nArray is sorted and rotated if we are able to find in which part target is present and also whether it is sorted or not then we can search easily by binary search.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/hZOtEvTCAvQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize two pointers `i` and `j` to represent the current search interval, where `i` is the left boundary and `j` is the right boundary.\\n\\n2. Enter a loop that continues as long as `i` is less than or equal to `j`.\\n\\n3. Calculate the middle index `mid` as `i + (j - i) / 2`.\\n\\n4. Check if the element at index `mid` is equal to the target. If it is, return `mid` as the index where the target is found.\\n\\n5. Check if the left part of the interval (from `i` to `mid`) is sorted:\\n\\n   a. If `nums[mid] >= nums[i]`, then the left part is sorted.\\n\\n   b. Check if the target is within the range of values in the left sorted part (`nums[i]` to `nums[mid]`). If yes, update `j = mid - 1` to search in the left part; otherwise, update `i = mid + 1` to search in the right part.\\n\\n6. Check if the right part of the interval (from `mid` to `j`) is sorted:\\n\\n   a. If `nums[mid] <= nums[j]`, then the right part is sorted.\\n\\n   b. Check if the target is within the range of values in the right sorted part (`nums[mid]` to `nums[j]`). If yes, update `i = mid + 1` to search in the right part; otherwise, update `j = mid - 1` to search in the left part.\\n\\n7. If none of the conditions above is satisfied, return `-1` to indicate that the target element is not found in the array.\\n\\n8. After the loop ends (when `i > j`), return `-1` to indicate that the target element is not found in the rotated sorted array.\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                    i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&&target<=nums[j])\\n                    i=mid+1;\\n                else\\n                j=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return -1\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                    i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&&target<=nums[j])\\n                    i=mid+1;\\n                else\\n                j=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14470,
                "title": "python-44ms-solution-binary-search-o-logn",
                "content": "    class Solution:\\n    # @param {integer[]} nums\\n    # @param {integer} target\\n    # @return {integer}\\n    def search(self, nums, target):\\n        if not nums:\\n            return -1\\n        return self.binarySearch(nums, target, 0, len(nums)-1)\\n        \\n    def binarySearch(self, nums, target, start, end):\\n        if end < start:\\n            return -1\\n        mid = (start+end)/2\\n        if nums[mid] == target:\\n            return mid\\n        if nums[start] <= target < nums[mid]: # left side is sorted and has target\\n            return self.binarySearch(nums, target, start, mid-1)\\n        elif nums[mid] < target <= nums[end]: # right side is sorted and has target\\n            return self.binarySearch(nums, target, mid+1, end)\\n        elif nums[mid] > nums[end]: # right side is pivoted\\n            return self.binarySearch(nums, target, mid+1, end)\\n        else: # left side is pivoted\\n            return self.binarySearch(nums, target, start, mid-1)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 1349313,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = (rhs - lhs) / 2 + lhs\\n            let val = (l: n[lhs], m: n[mid], r: n[rhs])\\n            if val.m == t { return mid }\\n            func setR() { rhs = mid - 1 }\\n            func setL() { lhs = mid + 1 }\\n            if val.m >= val.l {\\n                val.m > t && t >= val.l ? setR() : setL()\\n            } else {\\n                val.m < t && t <= val.r ? setL() : setR()\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.010) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.search([4,5,6,7,0,1,2], 0)\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test1() {\\n        let res = solution.search([4,5,6,7,0,1,2], 3)\\n        XCTAssertEqual(res, -1)\\n    }\\n    \\n    func test2() {\\n        let res = solution.search([1], 0)\\n        XCTAssertEqual(res, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = (rhs - lhs) / 2 + lhs\\n            let val = (l: n[lhs], m: n[mid], r: n[rhs])\\n            if val.m == t { return mid }\\n            func setR() { rhs = mid - 1 }\\n            func setL() { lhs = mid + 1 }\\n            if val.m >= val.l {\\n                val.m > t && t >= val.l ? setR() : setL()\\n            } else {\\n                val.m < t && t <= val.r ? setL() : setR()\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.search([4,5,6,7,0,1,2], 0)\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test1() {\\n        let res = solution.search([4,5,6,7,0,1,2], 3)\\n        XCTAssertEqual(res, -1)\\n    }\\n    \\n    func test2() {\\n        let res = solution.search([1], 0)\\n        XCTAssertEqual(res, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183146,
                "title": "python3-solution-using-binary-search-faster-than-98-and-uses-the-least-memory",
                "content": "```\\n#This solution is for the O(logn) complexity.....28ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)-1\\n        while left<=right:\\n            mid = left+(right-left)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid]<nums[right]:\\n                if nums[mid]<target<=nums[right]:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right=mid-1\\n                else:\\n                    left = mid+1\\n        return -1\\n\\n```\\n```\\n#This solution is for the O(n) complexity......32 ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return(-1)\\n        else:\\n            return(nums.index(target)) \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#This solution is for the O(logn) complexity.....28ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)-1\\n        while left<=right:\\n            mid = left+(right-left)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid]<nums[right]:\\n                if nums[mid]<target<=nums[right]:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right=mid-1\\n                else:\\n                    left = mid+1\\n        return -1\\n\\n```\n```\\n#This solution is for the O(n) complexity......32 ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return(-1)\\n        else:\\n            return(nums.index(target)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410249,
                "title": "c-2-approaches-easy-linear-binary-o-logn",
                "content": "\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /****************************** LINEAR APPROACH  ******************************/\\n    /*\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int index = -1;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }*/\\n\\n    /****************************** BINARY SEARCH APPROACH  ******************************/\\n    int search(vector<int>& nums, int target)\\n    {\\n        int i = 0 ; int j = nums.size()-1;\\n        while(i <= j)\\n        {\\n            int mid =  (i+j)/2;\\n\\n            if(nums[mid] == target) // if target is found return\\n            {\\n                return mid;\\n            }\\n\\n            if (nums[i] <= nums[mid])\\n            {\\n                if (nums[i] <= target && nums[mid] >= target)\\n                    j = mid - 1; \\n                else\\n                    i = mid + 1;\\n            } \\n            else\\n            { \\n                if (nums[mid] <= target && target <= nums[j])\\n                    i = mid + 1;\\n                else\\n                    j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n\\n\\n\\n```\\n```\\n![c8840309-29a1-4863-bf1b-90c2f8bd1387_1678528531.5008342.jpeg](https://assets.leetcode.com/users/images/94f8ec63-f298-4744-a9e2-f8f24cd17f2e_1681329169.909031.jpeg)\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456125,
                "title": "c-linear-search-to-binary-search-detailed-solution",
                "content": "**Rotated Sorted Array Search**\\n\\nwe have a sorted array and it is rotated by a some factor (say k)\\n\\n[1,2,3,4,5,6,7]   if rotated by  k=3 it becomes  [4,5,6,7,1,2,3]\\n\\nwe have given a **target** value if it is present in our array or not ,\\n\\nif we have the target value in our array then we have to return **index** \\n\\nat which target is present ,if not we simply return -1.\\n\\n__________________________________________________________________-\\n\\nLet\\'s start from the most naive approach and gradually progress towards the optimal approach.\\n\\nas our problem is about searching so first thing came into mind is **LINEAR SEARCH.**\\n\\n**Approach 1: Linear Search**\\n\\nwe can simply traverse on our array and compare each element of our array one by one with the target value and decide our result on the basis of is **current value of array is equals to target or not .\\n**\\nDRY RUN :\\n\\nnums: [4,5,6,7,1,2,3]     target=2\\n\\n![image](https://assets.leetcode.com/users/images/7748e614-385f-4a81-8b6e-0de9a2dc101e_1631302063.761646.png)\\n\\n\\n```cpp\\n\\nint search(vector<int> nums, int target)\\n{\\n\\tint n = nums.size();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tint currElement = nums[i];\\n\\t\\tif (currElement == target)\\n\\t\\t{\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;   // if target is not present \\n}\\n```\\n\\nTime Complexity: O(N)\\n\\nSpace Complexity: O(1)\\n\\n**Approach 2:  Binary Search:**\\n\\nAs our array is sorted then we can think of binary search.\\n\\nWe apply a modified version of binary search here.\\n\\n**Algorithm :**\\n\\n1. If nums[mid]==target then we got the result!\\n2. if not .. then we can observe that\\n\\n           one of the left or right subarray about mid is always sorted.\\n\\n   2.1:  If the left part of mid is sorted  i.e(nums[start] \\u2264nums[mid])\\n\\n            a: now we check is our target value falls in the left range then we move our \\n\\n              End pointer to mid-1 , by doing this we reduce half of search space in one go.\\n\\n            b: if target does not fall into left range then we check into right part.\\n\\n   2.2    if the right part of mid is sorted i.e,(nums[mid]\\u2264nums[end])\\n\\n            a: we check target value falls into right range then we start pointer to mid+1,\\n      \\n            b: else we move to left part\\n\\t\\t\\t\\n___________________________________________________________________________________________________________________________\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/63a590ff-ddee-43f3-8a42-6362f1a7bb1c_1631302089.6877496.png)\\n\\n_________________________________________________________________________________________________________\\n![image](https://assets.leetcode.com/users/images/c538e183-5490-4222-8280-08382ce63476_1631302089.3599315.png)\\n\\n\\n \\n\\n```cpp\\nint search(vector<int> &nums, int target)\\n{\\n\\tint n = nums.size();\\n\\tint start = 0;\\n\\tint end = n - 1;\\n\\n\\twhile (start <= end)\\n\\t{\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t{\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\telse if (nums[start] <= nums[mid])           // is left part sorted \\n\\t\\t{\\n\\t\\t\\tif (nums[start] <= target && nums[mid] > target)  // is target is in left range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (nums[end] >= target && nums[mid] < target)   // is target is in right range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n\\n}\\n```\\n\\nTime Complexity: O(logN)\\n\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```cpp\\n\\nint search(vector<int> nums, int target)\\n{\\n\\tint n = nums.size();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tint currElement = nums[i];\\n\\t\\tif (currElement == target)\\n\\t\\t{\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;   // if target is not present \\n}\\n```\n```cpp\\nint search(vector<int> &nums, int target)\\n{\\n\\tint n = nums.size();\\n\\tint start = 0;\\n\\tint end = n - 1;\\n\\n\\twhile (start <= end)\\n\\t{\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t{\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\telse if (nums[start] <= nums[mid])           // is left part sorted \\n\\t\\t{\\n\\t\\t\\tif (nums[start] <= target && nums[mid] > target)  // is target is in left range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (nums[end] >= target && nums[mid] < target)   // is target is in right range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3774690,
                "title": "c-hinglish-easy-explanation-binary-search-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1\\n       \\t1.Simplest way is to traverse the array and find that number.\\n       \\tO(N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n       \\t1.Why? Binary Search is used when\\n       \\t-Array is Sorted\\n       \\t- for finding target we have to eliminate the half\\n       \\t- reduces the search space by half\\n       \\t2. Here whole array is not sorted but we can figure out 2 sorted halves.\\n       \\t3 We just have to identify the sorted half and eliminate the other half\\n\\n       \\tlow--------mid----T----high\\n       \\t4.Like in the above case the target is in the 2nd half then we will eliminate the first half completely.\\n       \\t5.So Binary Search is applied in halves.\\n\\n       \\tTC\\n       \\tO(logn)\\n//-------------------------------------------------------------------------------------------------------------------------\\n        int search(vector<int> &nums, int target)\\n        {\\n            int n = nums.size();\\n            int low = 0;\\n            int high = n - 1;\\n            while (low <= high)\\n            {\\n                int mid = (low + high) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n               \\t//Index found\\n                else if (nums[low] <= nums[mid])\\n               \\t//Left half\\n                {\\n                    if (nums[low] <= target && target <= nums[mid])\\n                    {\\n                    //right half eliminated\\n                        high = mid - 1;\\n                    }\\n                    else\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                }\\n                else\\n                {\\n                   \\t//right half\\n                    if (nums[mid] <= target && target <= nums[high])\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                   \\t//right half eliminated\\n                    else\\n                    {\\n                        high = mid - 1;\\n                    }\\n                }\\n            }\\n            //Index not found\\n            return -1;\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity:$O(logn)$ Binary Search\\n\\n- Space complexity:$O(1)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1\\n       \\t1.Simplest way is to traverse the array and find that number.\\n       \\tO(N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n       \\t1.Why? Binary Search is used when\\n       \\t-Array is Sorted\\n       \\t- for finding target we have to eliminate the half\\n       \\t- reduces the search space by half\\n       \\t2. Here whole array is not sorted but we can figure out 2 sorted halves.\\n       \\t3 We just have to identify the sorted half and eliminate the other half\\n\\n       \\tlow--------mid----T----high\\n       \\t4.Like in the above case the target is in the 2nd half then we will eliminate the first half completely.\\n       \\t5.So Binary Search is applied in halves.\\n\\n       \\tTC\\n       \\tO(logn)\\n//-------------------------------------------------------------------------------------------------------------------------\\n        int search(vector<int> &nums, int target)\\n        {\\n            int n = nums.size();\\n            int low = 0;\\n            int high = n - 1;\\n            while (low <= high)\\n            {\\n                int mid = (low + high) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n               \\t//Index found\\n                else if (nums[low] <= nums[mid])\\n               \\t//Left half\\n                {\\n                    if (nums[low] <= target && target <= nums[mid])\\n                    {\\n                    //right half eliminated\\n                        high = mid - 1;\\n                    }\\n                    else\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                }\\n                else\\n                {\\n                   \\t//right half\\n                    if (nums[mid] <= target && target <= nums[high])\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                   \\t//right half eliminated\\n                    else\\n                    {\\n                        high = mid - 1;\\n                    }\\n                }\\n            }\\n            //Index not found\\n            return -1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227761,
                "title": "beats-100-easy-approach-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is implementing the Binary Search algorithm to find an element in a rotated sorted array. The approach to solving this problem is to modify the regular Binary Search algorithm to handle the rotated sorted array.\\n\\nThe intuition behind this approach is that the rotated sorted array can be divided into two parts, one part is still sorted, and the other part is also sorted, but the minimum element of the array is somewhere in the middle of the array. We can identify which part of the array is still sorted by comparing the middle element of the array with the first element of the array. If the middle element is greater than or equal to the first element, then the left part of the array is sorted, and if the middle element is less than the first element, then the right part of the array is sorted.\\n\\nOnce we have identified which part of the array is sorted, we can check if the target element is present in the sorted part of the array using the regular Binary Search algorithm. If the target element is not present in the sorted part of the array, we can search for it in the other part of the array by recursively calling the same Binary Search algorithm on that part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n        \\n    int search(vector<int>& nums, int target) {\\n        int size=nums.size();\\n       int s=0,e=size-1,m=0;\\n        while(s<=e){\\n                m=s+(e-s)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[s]){\\n                if(nums[m]>=target && nums[s]<=target) e=m-1;\\n                else s=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[e]>=target) s=m+1;\\n                    else e=m-1;\\n                }\\n        }\\n        return -1;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n        \\n    int search(vector<int>& nums, int target) {\\n        int size=nums.size();\\n       int s=0,e=size-1,m=0;\\n        while(s<=e){\\n                m=s+(e-s)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[s]){\\n                if(nums[m]>=target && nums[s]<=target) e=m-1;\\n                else s=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[e]>=target) s=m+1;\\n                    else e=m-1;\\n                }\\n        }\\n        return -1;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146832,
                "title": "clear-java-solution-in-o-log-n",
                "content": "The interesting property of a sorted + rotated array is that when you divide it into two halves, atleast one of the two halves will always be sorted.\\n\\n```\\nLet input array arr = [4,5,6,7,8,9,1,2,3]\\nnumber of elements  = 9\\nmid index = (0+8)/2 = 4\\n\\n[4,5,6,7,8,9,1,2,3]\\n         ^\\n left   mid  right\\n```\\n\\nit seems right sub-array is not sorted while left sub-array is sorted.\\n\\nIf mid happens to be the point of rotation them both left and right sub-arrays will be sorted.\\n\\n```\\n[6,7,8,9,1,2,3,4,5]\\n         ^\\n```\\n\\nBut in any case **one half(sub-array) must be sorted.**\\n\\nWe can easily know which half is sorted by comparing start and end element of each half.\\n\\nOnce we find which half is sorted we can see if the key is present in that half - simple comparison with the extremes.\\n\\nIf the key is present in that half we recursively call the function on that half else we recursively call our search on the other half.\\n\\nWe are discarding one half of the array in each call which makes this algorithm O(logN).\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length -1;\\n        return search(nums, target, low, high);\\n    }\\n    \\n    private int search(int[] nums, int target, int low, int high) {\\n        int mid = (low + high)/2;\\n        \\n        // key not present\\n        if(low > high) {\\n            return -1;\\n        }\\n        \\n        // Key is found\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        \\n        // if left half is sorted\\n        if(nums[low] <= nums[mid]) {\\n            // if key is present in left half.\\n            if(nums[low] <= target && nums[mid] >=target) {\\n                return search(nums, target, low, mid-1);\\n            }else{\\n                // if key is not present in left half. Search the right half\\n                return search(nums, target, mid+1, high);\\n            }\\n        }\\n        // if right half is sorted\\n        else {\\n            \\n            // if key is present in right half.\\n            if(nums[mid] <= target && nums[high] >=target) {\\n                return search(nums, target, mid+1, high);\\n            }else{\\n                // if key is not present in right half. Search the left half\\n                return search(nums, target, low, mid-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nLet input array arr = [4,5,6,7,8,9,1,2,3]\\nnumber of elements  = 9\\nmid index = (0+8)/2 = 4\\n\\n[4,5,6,7,8,9,1,2,3]\\n         ^\\n left   mid  right\\n```\n```\\n[6,7,8,9,1,2,3,4,5]\\n         ^\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length -1;\\n        return search(nums, target, low, high);\\n    }\\n    \\n    private int search(int[] nums, int target, int low, int high) {\\n        int mid = (low + high)/2;\\n        \\n        // key not present\\n        if(low > high) {\\n            return -1;\\n        }\\n        \\n        // Key is found\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        \\n        // if left half is sorted\\n        if(nums[low] <= nums[mid]) {\\n            // if key is present in left half.\\n            if(nums[low] <= target && nums[mid] >=target) {\\n                return search(nums, target, low, mid-1);\\n            }else{\\n                // if key is not present in left half. Search the right half\\n                return search(nums, target, mid+1, high);\\n            }\\n        }\\n        // if right half is sorted\\n        else {\\n            \\n            // if key is present in right half.\\n            if(nums[mid] <= target && nums[high] >=target) {\\n                return search(nums, target, mid+1, high);\\n            }else{\\n                // if key is not present in right half. Search the left half\\n                return search(nums, target, low, mid-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609488,
                "title": "explained-binary-search-python",
                "content": "# Binary Search\\n### Using Python :\\n- Best Explaination Ever\\n```py\\n#----------Method-1------------>\\nclass Solution:            \\n    def search(self, nums: List[int], target: int) -> int:\\n        # left pointer\\n        start=0  \\n        # right pointer\\n        end=len(nums)-1\\n        # until both comes not equal\\n        while start<=end:\\n            mid=(start+end)>>1      # Calculating mid point\\n            # checking if mid is target then return  index\\n            if nums[mid]==target:\\n                return mid\\n            #   checking first half array is sorted or not\\n            elif nums[mid]>=nums[start]:\\n                # checking target is exist in first half or not\\n                if (target>=nums[start] and target<nums[mid]):\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                # checking for target exist in second half or not\\n                if (target<=nums[end] and target>nums[mid]):\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```py\\n#----------Method-1------------>\\nclass Solution:            \\n    def search(self, nums: List[int], target: int) -> int:\\n        # left pointer\\n        start=0  \\n        # right pointer\\n        end=len(nums)-1\\n        # until both comes not equal\\n        while start<=end:\\n            mid=(start+end)>>1      # Calculating mid point\\n            # checking if mid is target then return  index\\n            if nums[mid]==target:\\n                return mid\\n            #   checking first half array is sorted or not\\n            elif nums[mid]>=nums[start]:\\n                # checking target is exist in first half or not\\n                if (target>=nums[start] and target<nums[mid]):\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                # checking for target exist in second half or not\\n                if (target<=nums[end] and target>nums[mid]):\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920511,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763245,
                "title": "0ms-100-faster-o-log-n-binary-search-easy-with-explaination-in-comments",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while(l<r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[l] <= nums[mid]){ //checking if first half array is sorted if so\\n                if(nums[l] <= target && target < nums[mid]){ //check if target lies in the range if so\\n                    r = mid - 1;                              // search in first half only\\n                }else                                         //else search in second half\\n                    l = mid + 1;\\n            }else{  //if first half isn\\'t sorted go and check for second\\n                if(nums[mid] < target && target <= nums[r]){ //check if target lies in second half\\n                    l = mid + 1;                             //if so search in second half\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while(l<r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[l] <= nums[mid]){ //checking if first half array is sorted if so\\n                if(nums[l] <= target && target < nums[mid]){ //check if target lies in the range if so\\n                    r = mid - 1;                              // search in first half only\\n                }else                                         //else search in second half\\n                    l = mid + 1;\\n            }else{  //if first half isn\\'t sorted go and check for second\\n                if(nums[mid] < target && target <= nums[r]){ //check if target lies in second half\\n                    l = mid + 1;                             //if so search in second half\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14659,
                "title": "binary-search-java-solusion-o-log-n",
                "content": "    public int search(int[] A, int target) {\\n        if (A.length == 0) return -1;\\n        int L = 0, R = A.length-1;\\n        //\\n        if (target < A[L] && target > A[R]) return -1;\\n        \\n        while (L < R) {\\n            int M = (L + R)/2;\\n            if (A[M] <= A[R]) {\\n                if (target > A[M] && target <= A[R]) {\\n                    L = M+1;\\n                } else {\\n                    R = M;\\n                }\\n                \\n            } else {\\n                if (target <= A[M] && target >= A[L]) {\\n                        R = M;\\n                } else {\\n                    L = M+1;\\n                }\\n            }\\n        }\\n        if (A[L] == target) return L;\\n        else return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public int search(int[] A, int target) {\\n        if (A.length == 0) return -1;\\n        int L = 0, R = A.length-1;\\n        //\\n        if (target < A[L] && target > A[R]) return -1;\\n        \\n        while (L < R) {\\n            int M = (L + R)/2;\\n            if (A[M] <= A[R]) {\\n                if (target > A[M] && target <= A[R]) {\\n                    L = M+1;\\n                } else {\\n                    R = M;\\n                }\\n                \\n            } else {\\n                if (target <= A[M] && target >= A[L]) {\\n                        R = M;\\n                } else {\\n                    L = M+1;\\n                }\\n            }\\n        }\\n        if (A[L] == target) return L;\\n        else return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 406621,
                "title": "super-easy-python-solution-find-pivot-using-bin-search-run-bin-search-on-both-sides-of-pivot",
                "content": "1) Binary search to find index of pivot (where the array has been rotated).\\n2) Normal Binary search on both sides of pivot to find element\\n\\nCode uses the property that the last element of array will be smaller than all elements before the pivot. See example below to clarify:\\n**example: in rotated array: 8,9,11,5,6,7. We know 5 is the pivot.\\nAll elements on left side of pivot are larger than last element, 7\\nAll elements on right side of pivot including pivot are smaller than last element, 7.**\\nWe can use this property to binary search and find pivot, once we have pivot, run normal bin_search on both sides of pivot and we\\'re done woohoo! \\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        if(not nums):\\n            return -1\\n        pivot_index = self.find_pivot(nums) \\n        result = self.bin_search(nums, target, 0, pivot_index-1)\\n        if(result!=-1):\\n            return result\\n        else:\\n            return self.bin_search(nums, target, pivot_index, len(nums)-1)\\n        \\n    def find_pivot(self, arr):\\n\\t#compare last element to mid element. \\n\\t#If mid element is greater than last element, pivot must be on right move low to mid+1\\n\\t#If mid element is less than last element, move high to mid-1\\n        element_to_compare = arr[-1]\\n        low = 0\\n        high = len(arr)-1    \\n        while(low <= high):\\n            mid = (low+high)//2\\n            if element_to_compare < arr[mid]:\\n                low = mid+1\\n            elif element_to_compare >= arr[mid]:\\n                high = mid-1\\n        return low    \\n\\n    def bin_search(self, arr, value, low, high):     \\n        while(low <= high):\\n            mid = (low+high)/2\\n            if value<arr[mid]:\\n                high = mid-1\\n            elif value>arr[mid]:\\n                low = mid+1\\n            else:\\n                return mid\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        if(not nums):\\n            return -1\\n        pivot_index = self.find_pivot(nums) \\n        result = self.bin_search(nums, target, 0, pivot_index-1)\\n        if(result!=-1):\\n            return result\\n        else:\\n            return self.bin_search(nums, target, pivot_index, len(nums)-1)\\n        \\n    def find_pivot(self, arr):\\n\\t#compare last element to mid element. \\n\\t#If mid element is greater than last element, pivot must be on right move low to mid+1\\n\\t#If mid element is less than last element, move high to mid-1\\n        element_to_compare = arr[-1]\\n        low = 0\\n        high = len(arr)-1    \\n        while(low <= high):\\n            mid = (low+high)//2\\n            if element_to_compare < arr[mid]:\\n                low = mid+1\\n            elif element_to_compare >= arr[mid]:\\n                high = mid-1\\n        return low    \\n\\n    def bin_search(self, arr, value, low, high):     \\n        while(low <= high):\\n            mid = (low+high)/2\\n            if value<arr[mid]:\\n                high = mid-1\\n            elif value>arr[mid]:\\n                low = mid+1\\n            else:\\n                return mid\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173843,
                "title": "javascript-solution",
                "content": "# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n\\n```js\\nvar search = function(nums, target) {\\n  if (nums.length === 0) return -1; // check empty\\n\\n  let left = 0;\\n  let right = nums.length - 1;\\n\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (nums[mid] === target) return mid;\\n\\n    // left sorted\\n    if (nums[left] <= nums[mid]) {\\n      // check if itarget is in the left sorted part\\n      if (nums[left] <= target && target < nums[mid]) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    // right sorted\\n    } else {\\n      // check if target is in the right sorted part\\n      if (nums[mid] < target && target <= nums[right]) {\\n        left = mid + 1;\\n      } else {\\n        right = mid - 1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```js\\nvar search = function(nums, target) {\\n  if (nums.length === 0) return -1; // check empty\\n\\n  let left = 0;\\n  let right = nums.length - 1;\\n\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (nums[mid] === target) return mid;\\n\\n    // left sorted\\n    if (nums[left] <= nums[mid]) {\\n      // check if itarget is in the left sorted part\\n      if (nums[left] <= target && target < nums[mid]) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    // right sorted\\n    } else {\\n      // check if target is in the right sorted part\\n      if (nums[mid] < target && target <= nums[right]) {\\n        left = mid + 1;\\n      } else {\\n        right = mid - 1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529302,
                "title": "java-tc-o-logn-sc-o-1-modified-binary-search-optimal-solution",
                "content": "```java\\n/**\\n * Modified binary search. This solution cannot handle duplicates in the input\\n * array.\\n *\\n * Time Complexity: O(log N) --> Search space is reduced by half in every\\n * iteration.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            // Left side is sorted and Right side is unsorted.\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted and Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Rotated Sorted Array questions on LeetCode:\\n- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/1529305/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1529313/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Optimal-Binary-Search-with-Early-Exit)\\n- [154. Find Minimum in Rotated Sorted Array II + FollowUp](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/1529323/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimal-Binary-Search-w-Early-Exit-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Modified binary search. This solution cannot handle duplicates in the input\\n * array.\\n *\\n * Time Complexity: O(log N) --> Search space is reduced by half in every\\n * iteration.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            // Left side is sorted and Right side is unsorted.\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted and Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587261,
                "title": "python-recursion-o-log-n-11-lines-easy-to-understand",
                "content": "Hi there,\\n\\nwanted to share a - in my opinion - quite clean and self-explanatory solution. Here it is:\\n\\n``` \\n      def search(self, nums: List[int], target: int) -> int:\\n        def helper(l,r):\\n            if l > r:\\n                return -1\\n            m = (r+l)//2\\n            if nums[m] == target:\\n                return m\\n            # follow left half if it is sorted and target is in its range or if right half is sorted but target is not in its range\\n            if nums[l] <= target < nums[m] or (nums[m] <= nums[r]  and not nums[m] < target <= nums[r]):\\n                return helper(l,m-1)\\n            else: \\n                return helper(m+1, r)\\n        return helper(0,len(nums)-1)",
                "solutionTags": [],
                "code": "Hi there,\\n\\nwanted to share a - in my opinion - quite clean and self-explanatory solution. Here it is:\\n\\n``` \\n      def search(self, nums: List[int], target: int) -> int:\\n        def helper(l,r):\\n            if l > r:\\n                return -1\\n            m = (r+l)//2\\n            if nums[m] == target:\\n                return m\\n            # follow left half if it is sorted and target is in its range or if right half is sorted but target is not in its range\\n            if nums[l] <= target < nums[m] or (nums[m] <= nums[r]  and not nums[m] < target <= nums[r]):\\n                return helper(l,m-1)\\n            else: \\n                return helper(m+1, r)\\n        return helper(0,len(nums)-1)",
                "codeTag": "Python3"
            },
            {
                "id": 14589,
                "title": "java-binary-search-with-recursion",
                "content": "We can take advantage of the fact that the array is sorted (although rotated). \\n1. Figure out if left half is sorted\\n1.1. If the target is on left side, continue binary search on left half.\\n1.2 If not, it must of in the right half. <br>\\n2. Similarly figure out if right half is sorted\\n2.1. If the target is on right side, continue binary search on right half.\\n2.2 If not, it must of in the left half.\\n```\\n\\n    public int search(int[] nums, int target) {\\n        return search(nums, 0, nums.length-1, target);\\n    }\\n    \\n    //6,7,1,2,3,4,5\\n    public int search (int[] nums, int first, int last, int target){\\n        if (first > last) return -1;\\n        \\n        int mid = (first + last) / 2;\\n        if (nums[mid] == target) return mid;\\n        \\n        if (nums[first] <= nums[mid]) // Left half is sorted\\n            if (nums[first] <= target && target <= nums[mid]) // target is in this sorted (left) half\\n                return search (nums, first, mid - 1, target);\\n            else // target must be in the right half\\n                return search (nums, mid + 1, last, target);\\n        if (nums[mid] <= nums[last])// Right half is sorted\\n            if (nums[mid] <= target && target <= nums[last]) // target is in this sorted (right) half\\n                return search (nums, mid + 1, last, target);\\n            else // target must be in left half\\n                return search (nums, first, mid - 1, target);\\n        \\n        return -1;\\n                \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\n    public int search(int[] nums, int target) {\\n        return search(nums, 0, nums.length-1, target);\\n    }\\n    \\n    //6,7,1,2,3,4,5\\n    public int search (int[] nums, int first, int last, int target){\\n        if (first > last) return -1;\\n        \\n        int mid = (first + last) / 2;\\n        if (nums[mid] == target) return mid;\\n        \\n        if (nums[first] <= nums[mid]) // Left half is sorted\\n            if (nums[first] <= target && target <= nums[mid]) // target is in this sorted (left) half\\n                return search (nums, first, mid - 1, target);\\n            else // target must be in the right half\\n                return search (nums, mid + 1, last, target);\\n        if (nums[mid] <= nums[last])// Right half is sorted\\n            if (nums[mid] <= target && target <= nums[last]) // target is in this sorted (right) half\\n                return search (nums, mid + 1, last, target);\\n            else // target must be in left half\\n                return search (nums, first, mid - 1, target);\\n        \\n        return -1;\\n                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14654,
                "title": "c-solution-with-explanation",
                "content": "With scrutiny on a rotated sorted array, it\\'s not hard to find that for every index i, either the part [0, i] is sorted or the part [i, n - 1] is sorted.\\nThe idea is that we can always divide the array into two parts L, R. If L is sorted and the key is in the range we can simply throw R away, if key is not in the range then we know the key must be in the unsorted part(i.e. R). If key is in R, we are back to the same problem with the size halved, so we can apply the same idea on R.\\n```\\nclass Solution {\\npublic:\\n    int search(int A[], int n, int target) {\\n        int l = 0, r = n - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if (A[m] == target)\\n                return m;\\n            else if (A[l] <= A[m]) { /* left part is sorted */\\n                if (A[l] <= target && target < A[m]) /* target is in the left part */\\n                    r = m - 1;\\n                else  /* target is in the right part */\\n                    l = m + 1;                               \\n            } else {/* right part is sorted */\\n                if (A[m] < target && target <= A[r]) /* target is in the right part */\\n                    l = m + 1;\\n                else /* target is in the left part */\\n                    r = m - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(int A[], int n, int target) {\\n        int l = 0, r = n - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if (A[m] == target)\\n                return m;\\n            else if (A[l] <= A[m]) { /* left part is sorted */\\n                if (A[l] <= target && target < A[m]) /* target is in the left part */\\n                    r = m - 1;\\n                else  /* target is in the right part */\\n                    l = m + 1;                               \\n            } else {/* right part is sorted */\\n                if (A[m] < target && target <= A[r]) /* target is in the right part */\\n                    l = m + 1;\\n                else /* target is in the left part */\\n                    r = m - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905767,
                "title": "100-fastest-swift-solution-o-log-n-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //     - time: O(log n), where n is the length of nums.\\n    //     - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n            guard nums[mid] != target else { return mid }\\n\\n            if nums[start] < nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else if nums[start] > nums[mid] {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n\\n            } else {\\n                start = mid + 1\\n            }\\n\\n        }\\n        return -1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //     - time: O(log n), where n is the length of nums.\\n    //     - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n            guard nums[mid] != target else { return mid }\\n\\n            if nums[start] < nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else if nums[start] > nums[mid] {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n\\n            } else {\\n                start = mid + 1\\n            }\\n\\n        }\\n        return -1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082643,
                "title": "very-simple-c-solution-easy-to-read-and-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0,h = n-1;\\n        // First find the index of lowest element\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]>nums[h]) l = m+1;\\n            else h = m; \\n        }\\n        int r = l; // store it in r\\n        \\n\\t\\tif(target==nums[r]) return r;\\n\\t\\telse if(r==0) l=0,h=n-1; // In this case the whole array is sorted ..as our lowest element is at first index..that\\'s why we\\'ll search in our whole array .. 0 ... n-1\\n\\t\\telse if(target>=nums[0]) l=0,h = r;  // If our target is greater than our first element , then target will present in array before our lowest element ,so range is 0 ..... r \\n\\t\\telse if(target<nums[0]) l = r,h=n-1; // if our target is less than our first element, then target will be after our lowest element , r ..... n-1\\n        \\n        //Simple Binary Search\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]>target) h = m -1;\\n            else l = m+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n        \\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0,h = n-1;\\n        // First find the index of lowest element\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]>nums[h]) l = m+1;\\n            else h = m; \\n        }\\n        int r = l; // store it in r\\n        \\n\\t\\tif(target==nums[r]) return r;\\n\\t\\telse if(r==0) l=0,h=n-1; // In this case the whole array is sorted ..as our lowest element is at first index..that\\'s why we\\'ll search in our whole array .. 0 ... n-1\\n\\t\\telse if(target>=nums[0]) l=0,h = r;  // If our target is greater than our first element , then target will present in array before our lowest element ,so range is 0 ..... r \\n\\t\\telse if(target<nums[0]) l = r,h=n-1; // if our target is less than our first element, then target will be after our lowest element , r ..... n-1\\n        \\n        //Simple Binary Search\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]>target) h = m -1;\\n            else l = m+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 14629,
                "title": "python-o-lgn-solution-it-needs-a-pen-and-some-paper-to-figure-it-out-at-the-first-time",
                "content": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[l] <= nums[mid]:  # here should include \"==\" case\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[l] <= nums[mid]:  # here should include \"==\" case\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 3880735,
                "title": "c-binary-search-day-8",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m]==target)return m;\\n            if(v[m]>=v[l]){\\n                if(target>=v[l] && v[m]>=target)r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(v[r]>=target && v[m]<=target)l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/17354111-24a1-45f8-bbf4-835bbf3f60c2_1691482271.5097225.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m]==target)return m;\\n            if(v[m]>=v[l]){\\n                if(target>=v[l] && v[m]>=target)r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(v[r]>=target && v[m]<=target)l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435461,
                "title": "binary-search-implementation-o-logn-complexity-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1 \\n\\n        low = 0\\n        high = len(nums)-1\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if target == nums[mid]:\\n                return mid\\n\\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            \\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1 \\n\\n        low = 0\\n        high = len(nums)-1\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if target == nums[mid]:\\n                return mid\\n\\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            \\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740157,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Searching for the minimum element and binary search both take O(logN base 2). Hence time taken is O(logN base 2).\\nSpace Complexity - Space taken is O(1).\\nExplanation - A prerequisite to this problem would be the following 2 problems:\\nProblem 1: https://leetcode.com/problems/binary-search/\\nSolution: https://github.com/Arya-Gupta/LeetCode/blob/main/704.%20Binary%20Search/Solution\\nProblem 2: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\nSolution: https://github.com/Arya-Gupta/LeetCode/blob/main/153.%20Find%20Minimum%20in%20Rotated%20Sorted%20Array/Binary%20Search\\n\\n**Now we can reduce our current problem to a simple variation of these problems.**\\nA rotated array can be divided into 2 sorted parts on the basis of its minimum element.\\nFor example: 4, 5, 6, 1, 2, 3 can be divided into 4, 5, 6 and 1, 2, 3.\\nNow we apply the regular binary search algorithm on both of these parts and search for our target element.\\nIf they aren\\'t present in either part, we return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid;\\n        while(start <= end){\\n            if(nums[start] < nums[end]) return start;\\n            mid = start + (end - start) / 2;\\n            if(nums[mid] <= nums[(mid + n - 1) % n]) return mid;\\n            else if(nums[start] <= nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int target, int start, int end) {\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(target > nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target){\\n        int n = nums.size(), minPos = findMin(nums);\\n        if(binarySearch(nums, target, 0, minPos - 1) != -1) return binarySearch(nums, target, 0, minPos - 1);\\n        return binarySearch(nums, target, minPos, n - 1);\\n    }\\n};\\n```\\n\\n**Kindly upvote if you found the solution helpful :)**\\nFor more such explanations of LeetCode problems along with their C++ solutions:\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid;\\n        while(start <= end){\\n            if(nums[start] < nums[end]) return start;\\n            mid = start + (end - start) / 2;\\n            if(nums[mid] <= nums[(mid + n - 1) % n]) return mid;\\n            else if(nums[start] <= nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int target, int start, int end) {\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(target > nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target){\\n        int n = nums.size(), minPos = findMin(nums);\\n        if(binarySearch(nums, target, 0, minPos - 1) != -1) return binarySearch(nums, target, 0, minPos - 1);\\n        return binarySearch(nums, target, minPos, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186585,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(rotated, target) {\\n    var left = 0;\\n    var right = rotated.length - 1;\\n    \\n    // Just a straight binary search.\\n    while (left <= right) {\\n        var middle = Math.floor((right + left) / 2);\\n    \\n        // We have found our target.\\n        if (rotated[middle] === target) {\\n            return middle;\\n        }\\n    \\n        // The clever part starts here:\\n        if (rotated[left] <= rotated[middle]) {\\n            // If the middle element is greater than the element to the left\\n            // of it, then that means that the bottom half is strictly increasing\\n            // from left to middle, i.e. it is sorted and we can just do a normal\\n            // binary search.\\n    \\n            // Is the target in this range?\\n            if (rotated[left] <= target && target < rotated[middle]) {\\n                // \\'recurse\\' down this side\\n                right = middle - 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                left = middle + 1;\\n            }\\n        } else {\\n            // This means that the *top* half must be sorted, because\\n            // there can only be one place in the entire array where\\n            // the order is not sorted, and it\\'s on the bottom half.\\n    \\n            if (rotated[middle] < target && target <= rotated[right]) {\\n                // \\'recurse\\' down this side\\n                left = middle + 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                right = middle - 1;\\n            }\\n    \\n        }\\n    }\\n  \\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(rotated, target) {\\n    var left = 0;\\n    var right = rotated.length - 1;\\n    \\n    // Just a straight binary search.\\n    while (left <= right) {\\n        var middle = Math.floor((right + left) / 2);\\n    \\n        // We have found our target.\\n        if (rotated[middle] === target) {\\n            return middle;\\n        }\\n    \\n        // The clever part starts here:\\n        if (rotated[left] <= rotated[middle]) {\\n            // If the middle element is greater than the element to the left\\n            // of it, then that means that the bottom half is strictly increasing\\n            // from left to middle, i.e. it is sorted and we can just do a normal\\n            // binary search.\\n    \\n            // Is the target in this range?\\n            if (rotated[left] <= target && target < rotated[middle]) {\\n                // \\'recurse\\' down this side\\n                right = middle - 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                left = middle + 1;\\n            }\\n        } else {\\n            // This means that the *top* half must be sorted, because\\n            // there can only be one place in the entire array where\\n            // the order is not sorted, and it\\'s on the bottom half.\\n    \\n            if (rotated[middle] < target && target <= rotated[right]) {\\n                // \\'recurse\\' down this side\\n                left = middle + 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                right = middle - 1;\\n            }\\n    \\n        }\\n    }\\n  \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890634,
                "title": "c-binary-search-commented-solution-easy-to-understand",
                "content": "# C++ Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    //there exists atleast one strictly increasing subarray due to pivot element\\n    //using modified binary search \\n        int n=nums.size();\\n        int s=0;\\n        int e=n-1;\\n        \\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n  //else if left subarray is str increasing then search only in the LEFT SUBARRAY          \\n            else if(nums[mid]>=nums[s]){\\n                if(target>=nums[s] && target <=nums[mid]){\\n                    \\n                    e =mid-1;//update the right pointer\\n                    \\n                }\\n                else\\n                    s=mid+1;//update the left pointer\\n            }\\n //else search in the RIGHT SUBARRAY\\n            else{\\n                if(target>=nums[mid] && target<=nums[e]){\\n                    \\n                    s=mid+1;\\n                    \\n                }\\n                else\\n                    e=mid-1;\\n            }\\n            \\n        }\\n        \\n        return -1;//if it is not PRESENT\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote if you liked the solution !**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    //there exists atleast one strictly increasing subarray due to pivot element\\n    //using modified binary search \\n        int n=nums.size();\\n        int s=0;\\n        int e=n-1;\\n        \\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n  //else if left subarray is str increasing then search only in the LEFT SUBARRAY          \\n            else if(nums[mid]>=nums[s]){\\n                if(target>=nums[s] && target <=nums[mid]){\\n                    \\n                    e =mid-1;//update the right pointer\\n                    \\n                }\\n                else\\n                    s=mid+1;//update the left pointer\\n            }\\n //else search in the RIGHT SUBARRAY\\n            else{\\n                if(target>=nums[mid] && target<=nums[e]){\\n                    \\n                    s=mid+1;\\n                    \\n                }\\n                else\\n                    e=mid-1;\\n            }\\n            \\n        }\\n        \\n        return -1;//if it is not PRESENT\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283472,
                "title": "java-simple-intuitive-solution-faster-than-100-explained",
                "content": "Approach:\\n- The idea here is quite simple and on basic intuition. It\\'s simple Binary Search with a few added conditions.\\n\\n- Generally, if `target > nums[mid]`, we\\'d know to go to `[mid+1, end]` but here, it could even lie in `[start, mid-1]` because we could be on the other side of pivot.\\n\\n- Hence, we do the added checks, to check which range we are currently standing in, i.e.\\n\\t- If `nums[start] <= nums[mid]` => We are in the first part of pivot.\\n\\t- If `nums[start] > nums[mid]` => We are in the second part of pivot.\\n\\n- Post deciding which part of pivot we are in, we simply have to check if `target` lies in current part of pivot or not, and update `start/end` pointers accordingly.\\n\\n- The code is pretty intuitive, so you should be able to get the hang of it from the code now.\\n\\n\\nHere is the code:\\n**Runtime:** 0 ms **(Faster than 100%)**\\n**Memory Usage:** 38.5 MB **(Beats 32.42%)**\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1, mid;\\n\\n        while (start <= end) {\\n            mid = (start+end)/2;\\n            if (target == nums[mid])\\n                return mid;\\n\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            else {\\n                if (target > nums[mid] && target <= nums[end]) \\n                        start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n----------------------------------------------------------------------------------------------------------------------------------\\n\\nIf you find this post helpful, do upvote!\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1, mid;\\n\\n        while (start <= end) {\\n            mid = (start+end)/2;\\n            if (target == nums[mid])\\n                return mid;\\n\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            else {\\n                if (target > nums[mid] && target <= nums[end]) \\n                        start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422098,
                "title": "python-40ms-o-logn-one-pass-binary-search",
                "content": "One pass python solution using binary search. Time: O(logN). Space: O(1)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums) - 1\\n       \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid]<target:\\n                if nums[start]<= target and nums[start] > nums[mid]:\\n                    end = mid -1\\n                else:\\n                    start = mid+1\\n            \\n            elif nums[mid]>target:\\n                if target<=nums[end] and nums[end]<nums[mid]:\\n                    start = mid+1\\n                else:\\n                    end = mid -1 \\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums) - 1\\n       \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid]<target:\\n                if nums[start]<= target and nums[start] > nums[mid]:\\n                    end = mid -1\\n                else:\\n                    start = mid+1\\n            \\n            elif nums[mid]>target:\\n                if target<=nums[end] and nums[end]<nums[mid]:\\n                    start = mid+1\\n                else:\\n                    end = mid -1 \\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14571,
                "title": "10-lines-simple-and-concise-c-solution-with-detailed-explanation-and-thought-process",
                "content": "**THOUGHT**:\\n\\nWe know that a normal sorted array has an increasing trend from beginning to the end, but a rotated array may have some point that break the trend. For example, 4 5 6 7 1 2 3, if you look at 4 5 6 7 and 1 2 3 separately, you see two increasing sub-array, and the observation is: \\n\\n**The rightmost number of the second sub-array is smaller than the leftmost number of the first sub-array if there exists and rotated position**\\n\\nSo every time, when we get the mid position, compare to nums[r] to see if the rotated position is on the right half:\\n1) If nums[mid] > nums[r], which not follows the increasing trend, so we know that the rotated position (smallest number in this array) is on the right side of mid position, so please have some thought here, what kind of numbers will be on the right side? It should be either numbers greater than nums[mid] or less than or equal to nums[r]. So check if target is in this range, if yes, we pick the right side by updating index l to mid + 1, otherwise, we pick the left side. Giving an example here, \\n4 5 6 7 **8 1 2 3**. So here, nums[mid] = 7, nums[r] = 3, you'll see numbers greater than 7 (number 8) and numbers <= nums[r] (number 1, 2, 3) are on the right side of mid. \\n\\n2) If nums[mid] < nums[r], we know that  the numbers on the right side are in pure increasing order now, and if target falls into this range, we pick the right side, otherwise, we pick the left side.\\n\\nHope this makes sense.\\n\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l <= r){ \\n                int mid = l + (r - l) / 2;\\n                \\n                if(nums[mid] == target) return mid;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;   // condition for pick right side\\n                    else r = mid - 1;    // else, pick left side\\n                }else{\\n                    if(target <= nums[r] && target > nums[mid]) l = mid + 1;  // condition for pick right side\\n                    else r = mid - 1;     // else, pick left side\\n                } \\n            }\\n            \\n            return -1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l <= r){ \\n                int mid = l + (r - l) / 2;\\n                \\n                if(nums[mid] == target) return mid;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;   // condition for pick right side\\n                    else r = mid - 1;    // else, pick left side\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14581,
                "title": "javascript-ac-code",
                "content": "The idea is: the rotated array has to fall into 2 categories: smallest on the left side or right side:\\n4, 5, 6, 7 | 8, 1, 2, 3\\n7, 8, 1, 2 | 3, 4, 5, 6\\nThis can be determined by comparing:\\nIf nums[head] < nums[mid], first case;\\nIf nums[head] > nums[mid], second case;\\nThen we just need to determine: in which situation, target falls onto left side; Else, it must be on right side; The long \"else if\" case in the code is doing exactly that.\\n\\nNote that the edge cases like: only 1 element or or elements are automatically handled, because of \"else\". In those cases, we first need to compare nums[mid] and target, if mid is not target, we just need to advance the head/tail, so head > tail, then we can return -1;\\n\\n    /**\\n     * @param {number[]} nums\\n     * @param {number} target\\n     * @return {number}\\n     */\\n    var search = function(nums, target) {\\n      if (nums.length === 0) return -1;\\n      \\n      var index = -1,\\n        head = 0,\\n        tail = nums.length - 1,\\n        mid;\\n      \\n      while (head <= tail) {\\n        mid = Math.floor((head + tail) / 2);\\n        if (nums[mid] === target) {\\n          index = mid;\\n          break;\\n        } else if ((nums[head] <= target && target < nums[mid]) ||\\n                   (nums[head] > nums[mid] && (nums[head] <= target || target < nums[mid]))) {\\n          tail = mid - 1;\\n        } else {\\n          head = mid + 1;\\n        }\\n      }\\n      \\n      return index;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "The idea is: the rotated array has to fall into 2 categories: smallest on the left side or right side:\\n4, 5, 6, 7 | 8, 1, 2, 3\\n7, 8, 1, 2 | 3, 4, 5, 6\\nThis can be determined by comparing:\\nIf nums[head] < nums[mid], first case;\\nIf nums[head] > nums[mid], second case;\\nThen we just need to determine: in which situation, target falls onto left side; Else, it must be on right side; The long \"else if\" case in the code is doing exactly that.\\n\\nNote that the edge cases like: only 1 element or or elements are automatically handled, because of \"else\". In those cases, we first need to compare nums[mid] and target, if mid is not target, we just need to advance the head/tail, so head > tail, then we can return -1;\\n\\n    /**\\n     * @param {number[]} nums\\n     * @param {number} target\\n     * @return {number}\\n     */\\n    var search = function(nums, target) {\\n      if (nums.length === 0) return -1;\\n      \\n      var index = -1,\\n        head = 0,\\n        tail = nums.length - 1,\\n        mid;\\n      \\n      while (head <= tail) {\\n        mid = Math.floor((head + tail) / 2);\\n        if (nums[mid] === target) {\\n          index = mid;\\n          break;\\n        } else if ((nums[head] <= target && target < nums[mid]) ||\\n                   (nums[head] > nums[mid] && (nums[head] <= target || target < nums[mid]))) {\\n          tail = mid - 1;\\n        } else {\\n          head = mid + 1;\\n        }\\n      }\\n      \\n      return index;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 2228304,
                "title": "faster-than-90-solutions-best-interview-code",
                "content": "![image](https://assets.leetcode.com/users/images/f6cbf215-fc9c-4069-9d8a-a9c125fa2bb4_1656777163.082676.png)\\n\\nLet\\'s start with an important observation that:\\n``` \\n\\t\\t\\t\\n\\t\\t\\tnums = [5, 6, 7, 1, 2, 3, 4] \\n\\t\\t\\t\\t\\t\\t \\uD83D\\uDD3A\\n\\t\\t\\t\\t\\t    Pivot\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\n```\\n\\n* the rotated array has **two sorted** parts\\n\\t* Part 1: \\n\\t\\t* nums[i] <= nums[n-1]\\n\\t\\t* i.e. : 1,2,3,4\\n\\t\\t\\n\\t* Part 2:\\n\\t\\t* nums[i] > nums[n-1]\\n\\t\\t*  i.e. : 5,6,7\\n\\n* Understand that if we somehow we know the index of the element that seprates the two parts (Pivot) then we will have an idea about - in which part our target element is present\\n\\t* In the given example, firstly we need to find the index of \\'7\\' which is the pivot element\\n\\n### **How to find the index of Pivot element?**\\n\\n* We will use the same property that defined Part1 and Part2 to find the pivot index\\n* Reminder \\n\\t* \"Pivot is in Part2\"\\n\\t* the unique property of pivot is that, the pivot element is greater than next index element ( 7 > 1)\\n\\t\\t* **nums[idx] > nums[idx+1]** (idx = index of pivot)\\n\\t\\t\\n* As we want optimized approach so we will use binary search to find the pivot index\\n```\\n def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:           # we are in part 1 but pivot is in part2, move left\\n                    high = m-1\\n                else:                                              # we are in part2\\n                    if nums[m] > nums[m+1]:        # using the property of pivot element, if on pivot element\\n                        return m\\n                    else:\\n                        low = m+1                           # still in part2 but in left of pivot element, need to move to right\\n\\t\\t\\t\\t\\t\\t\\n            return high\\n```\\n\\n* Now, we exactly know that \\n\\t* part2 : [0, pivot]\\n\\t* part1 : [pivot+1, n-1]\\n\\t\\n* We will not blindly run binary search, we will compare the target and nums[n-1], this step will tell us our target is present in part1 or part2. (use if-else condition)\\n\\n* Now, we just need to pass the start and end position of binary search based on target in part1 or part2\\n\\n* **Edge Case:** You might miss this case so be careful about the fact that maybe the nums array is not rotated, that is rotation = 0, ex: [1,2,3,4,5,6,7]\\n\\n\\t* In this case, we need to run binary search on whole nums array\\n\\t\\n\\t* this case needs to be handled, the comment in the code indicates how we have handled this case\\n\\n### Complete Code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n        \\n        if len(nums) == 1 and nums[0] == target:\\n            return 0\\n        \\n        # pivot index finding\\n        \\n        # [PART2 with pivot, PART1]\\n        \\n        def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:\\n                    high = m-1\\n                else:\\n                    if nums[m] > nums[m+1]:\\n                        return m\\n                    else:\\n                        low = m+1\\n                    \\n            return high\\n        \\n        pivot = pivotIndex(nums)\\n            \\n        def binarySearch(start, end):\\n            while start <= end:\\n                m = (start+end)//2\\n                if nums[m] == target:\\n                    return m\\n                elif nums[m] > target:\\n                    end = m-1\\n                elif nums[m] < target:\\n                    start = m+1\\n            return -1\\n        \\n\\t\\t\\n        if target <= nums[n-1]:\\n            if pivot == -1:           # if edge case: number of rotation in array = 0, either check low > high or pivot = -1\\n                ans = binarySearch(0, n-1)\\n            else:\\n                ans = binarySearch(pivot+1, n-1)   # search part 1\\n        else:\\n            ans = binarySearch(0, pivot)               # search part2\\n            \\n        return ans\\n       \\n```\\n**Time Complexity: O(logN)**\\n**Space Complexity: O(1)**\\n\\n***I hope this explanation was helpful, please make sure to UPVOTE so that it can rank higher in discussion***",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "``` \\n\\t\\t\\t\\n\\t\\t\\tnums = [5, 6, 7, 1, 2, 3, 4] \\n\\t\\t\\t\\t\\t\\t \\uD83D\\uDD3A\\n\\t\\t\\t\\t\\t    Pivot\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\n```\n```\\n def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:           # we are in part 1 but pivot is in part2, move left\\n                    high = m-1\\n                else:                                              # we are in part2\\n                    if nums[m] > nums[m+1]:        # using the property of pivot element, if on pivot element\\n                        return m\\n                    else:\\n                        low = m+1                           # still in part2 but in left of pivot element, need to move to right\\n\\t\\t\\t\\t\\t\\t\\n            return high\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n        \\n        if len(nums) == 1 and nums[0] == target:\\n            return 0\\n        \\n        # pivot index finding\\n        \\n        # [PART2 with pivot, PART1]\\n        \\n        def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:\\n                    high = m-1\\n                else:\\n                    if nums[m] > nums[m+1]:\\n                        return m\\n                    else:\\n                        low = m+1\\n                    \\n            return high\\n        \\n        pivot = pivotIndex(nums)\\n            \\n        def binarySearch(start, end):\\n            while start <= end:\\n                m = (start+end)//2\\n                if nums[m] == target:\\n                    return m\\n                elif nums[m] > target:\\n                    end = m-1\\n                elif nums[m] < target:\\n                    start = m+1\\n            return -1\\n        \\n\\t\\t\\n        if target <= nums[n-1]:\\n            if pivot == -1:           # if edge case: number of rotation in array = 0, either check low > high or pivot = -1\\n                ans = binarySearch(0, n-1)\\n            else:\\n                ans = binarySearch(pivot+1, n-1)   # search part 1\\n        else:\\n            ans = binarySearch(0, pivot)               # search part2\\n            \\n        return ans\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023121,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-binary-search-o-log-n",
                "content": "Ayo, here\\'s another solution! Pretty simple if you get the idea.\\n\\nHere\\'s what\\'s important:\\n- We do regular binary search on the array. We need to find a target but the array is rotated. What do we do?\\n- Did you see how there are 2 parts in the array that are sorted?\\n- For array [4,5,6,7,0,1,2]\\n\\t- Part 1: [4,5,6,7]\\n\\t- Part 2: [0,1,2]\\n- This is the only thing that\\'s going to help us solve the problem.\\n\\nApply regular binary search on the array, but here\\'s what we\\'re going to change:\\n1. Calculate mid as usual.\\n2. First, check if the array has been rotated by checking if you\\'re in the 1st or 2nd part of the array.\\n3. If you\\'re in first part, your arr[low] will be smaller than arr[mid] because remember, the 1st part of the array is sorted.\\n\\n4. If the number at low is indeed smaller than mid, then we search for the target in this low->mid range. \\n\\t**A.** So, check if target is greater/equal to low and target is smaller than mid (but not smaller or equal because if it were equal to mid, we would have returned the answer). If it does lie between low and mid, let\\'s narrow search down to low to mid by making our high equal to mid.\\n\\t**B.** If the target doesn\\'t lie between low and mid, then surely it must lie beyond mid. So we narrow search down to `mid+1` to `high` by setting `low = mid + 1`.\\n\\n7. Similarly, check again for array rotation. If mid is not greater than low, then it must be smaller than low. Which means we\\'re in the 2nd sorted part of the array.\\n\\t**A.** So, check if target is greater than mid and target is smaller/equal to high. If it does lie between mid and high, let\\'s narrow search down to mid to mid by making our low equal to mid+1.\\n\\t**B.** If the target doesn\\'t lie between mid and high, then it\\'s probably because it\\'s greater than both mid and high, meaning that it belongs in the 1st part of rotated sorted array. So we narrow search down to `low` to `mid` by setting `low = mid`.\\n\\nSo basically, binary search stuff comes later, we just first check what part of the rotation we\\'re in before making any moves.\\n\\t\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            \\n            // if low is less than mid (not less or equal because equal is handled by the previous if statement), then low to mid is sorted\\n            if (nums[low] <= nums[mid]){\\n                // if target is between low to mid,\\n                // narrow search down to low to mid\\n                if(target >= nums[low] and target <= nums[mid]){\\n                    high = mid;\\n                } else {\\n                    // if target is beyond mid\\n                    // narrow search down to mid + 1 to high\\n                    low = mid + 1;\\n                }\\n                // if low is greater than mid,\\n                // then we\\'re in the rotated part\\n            } else if (nums[low] > nums[mid]){\\n                // if target is between mid to high\\n                // narrow search down to mid to high\\n                if(target >= nums[mid] and target <= nums[high]){\\n                    low = mid + 1;\\n                } else {\\n                    // if target is greater than high and mid both\\n                    // narrow search down to the second part before\\n                    // mid. So low to mid.\\n                    high = mid;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            \\n            // if low is less than mid (not less or equal because equal is handled by the previous if statement), then low to mid is sorted\\n            if (nums[low] <= nums[mid]){\\n                // if target is between low to mid,\\n                // narrow search down to low to mid\\n                if(target >= nums[low] and target <= nums[mid]){\\n                    high = mid;\\n                } else {\\n                    // if target is beyond mid\\n                    // narrow search down to mid + 1 to high\\n                    low = mid + 1;\\n                }\\n                // if low is greater than mid,\\n                // then we\\'re in the rotated part\\n            } else if (nums[low] > nums[mid]){\\n                // if target is between mid to high\\n                // narrow search down to mid to high\\n                if(target >= nums[mid] and target <= nums[high]){\\n                    low = mid + 1;\\n                } else {\\n                    // if target is greater than high and mid both\\n                    // narrow search down to the second part before\\n                    // mid. So low to mid.\\n                    high = mid;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943288,
                "title": "c-double-binary-search-solution-explained-100-time-40-space",
                "content": "Nice one to practice a bit binary searches, since with my approach we will need it not once, but twice - one to find the rotational pivot, one to find the actual element.\\n\\nWe will need first of all a few support variables:\\n* `len` will store the lenght of `nums`;\\n* `l`, `r` and `mid` will be the cogs of our binary search, witht the first 2 initialised to be `0` and `len`, respectively.\\n\\nOne peculiar case is when `l == len`, which means the array is fully sorted, so we have to check inside all of it, resetting `l` to `0`.\\n\\nWe proceed then with the first binary search to find the pivot around which the vector/array was rotated, looping as long as `l < r`:\\n* at each step we compute first of all `mid` as the average of `l` and `r`;\\n* if `nums[mid]` is greater than or equal to the first element, it means we need to keep looking to the right to find a pivot, so we update the value of `l`;\\n* conversely, it means we need to search to the left, so we update `r` before iterating again.\\n\\nOnce we move out of the first search, we have the index of what would be the first element in a fully sorted vector - and that is also the smallest one, so at this point we can decide if we want to search either in the `[0 - l)` or in the `[l - len)` range.\\n\\nWe proceed rather trivially with a similar approach to the previous to look for `target` in the interval we just decided, with an extra step:\\n* we check if `mid` is by any chance already pointing at the value of `target` - this might not be ideal in terms of performance, but I noticed that it avoided me a few annoying edge cases. If so, we just return `mid`;\\n* depending on the value of `nums[mid]` compared to `target`, we either move right (updating `l`) or left (updating `r`).\\n\\nProvided we did not encounter it already as a value of `mid`, once we exit the loop we return `l` if it points to `target`, `-1` othewise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // support variables\\n        int len = nums.size(), l = 0, r = len, mid;\\n        // finding the pivot\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // current element > first elemen: we move the window right\\n            if (nums[mid] >= nums[0]) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        // checking for edge case - pivot at the end = sorted vector\\n        if (l == len) l = 0;\\n        // preparing for the next BS: target is between pivot and the last element\\n        if (target >= nums[l] && target <= nums.back()) r = len;\\n        // target is between the first element and the one before pivot\\n        else r = l, l = 0;\\n        // all other cases\\n        // finding the element\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // mid matches the target element: we return it\\n            if (nums[mid] == target) return mid;\\n            // mid matches an element smaller than target: we move the window right\\n            else if (nums[mid] < target) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // support variables\\n        int len = nums.size(), l = 0, r = len, mid;\\n        // finding the pivot\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // current element > first elemen: we move the window right\\n            if (nums[mid] >= nums[0]) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        // checking for edge case - pivot at the end = sorted vector\\n        if (l == len) l = 0;\\n        // preparing for the next BS: target is between pivot and the last element\\n        if (target >= nums[l] && target <= nums.back()) r = len;\\n        // target is between the first element and the one before pivot\\n        else r = l, l = 0;\\n        // all other cases\\n        // finding the element\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // mid matches the target element: we return it\\n            if (nums[mid] == target) return mid;\\n            // mid matches an element smaller than target: we move the window right\\n            else if (nums[mid] < target) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615822,
                "title": "java-binary-search-o-logn-explanation-in-detail",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        // define pointers\\n        int left = 0, right = nums.length - 1;\\n        \\n\\t\\t// Loop while to narrow down left and right pointer\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            // These line of code will do:\\n            // From middle, we will look from LEFT and RIGHT to know LEFT portion is SORTED or RIGHT portion is SORTED\\n            // Besides, we use target to narrow down left and right pointer\\n            if(nums[left] <= nums[mid]){\\n                // from left to mid, all elements are sorted. It means LEFT portion of mid are SORTED\\n                // find target belong to THIS LEFT portion or not\\n                // [4,5,6,7,8,9,0,1,2]\\n                //  l       m       r\\n                //  l     r            (Ex: target = 5) - YES                \\n                //            l     r. (Ex: target = 1) - NO   \\n                if(nums[left] <= target && target < nums[mid]){ // Why we check target < nums[mid] (NOT target <= nums[mid]) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to LEFT portion that sorted\\n                    right = mid - 1;\\n                } else {\\n                    // NO: target belong to RIGHT portion (BUT we not sort it is sorted or not)\\n                    left = mid + 1;\\n                }                \\n            } else if (nums[mid] <= nums[right]) {\\n                // from mid to right, all elements are sorted. It means RIGHT portion of mid are SORTED\\n                // find target belong to THIS RIGHT portion or not\\n                // [7,8,0,1,2,4,5,6,9]\\n                //  l       m       r\\n                //            l     r. (Ex: target = 5) - YES\\n                //  l     r            (Ex: target = 1) - NO\\n                if(nums[mid] < target && target <= nums[right]){ // Why we check &&  nums[mid] < target (NOT nums[mid] <= target) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to RIGHT portion that sorted\\n                    left = mid + 1;\\n                } else {\\n                    // NO: target belong to LEFT portion (BUT we not sort it is sorted or not)\\n                    right = mid - 1;\\n                }\\n            }\\n            \\n            // When we go here, we DID narrow down left and right pointer. \\n\\t\\t\\t// The loop while will continue AND left and right pointer will be NARROW down again and again (In worst case, left = right = middle)\\n\\t\\t\\t// If target found on array, we will found it at MIDDLE and return. (at line - if(nums[mid] == target) return mid;)\\n            // If not, we will go out of loop and RETURN -1 at the end.\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        // define pointers\\n        int left = 0, right = nums.length - 1;\\n        \\n\\t\\t// Loop while to narrow down left and right pointer\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            // These line of code will do:\\n            // From middle, we will look from LEFT and RIGHT to know LEFT portion is SORTED or RIGHT portion is SORTED\\n            // Besides, we use target to narrow down left and right pointer\\n            if(nums[left] <= nums[mid]){\\n                // from left to mid, all elements are sorted. It means LEFT portion of mid are SORTED\\n                // find target belong to THIS LEFT portion or not\\n                // [4,5,6,7,8,9,0,1,2]\\n                //  l       m       r\\n                //  l     r            (Ex: target = 5) - YES                \\n                //            l     r. (Ex: target = 1) - NO   \\n                if(nums[left] <= target && target < nums[mid]){ // Why we check target < nums[mid] (NOT target <= nums[mid]) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to LEFT portion that sorted\\n                    right = mid - 1;\\n                } else {\\n                    // NO: target belong to RIGHT portion (BUT we not sort it is sorted or not)\\n                    left = mid + 1;\\n                }                \\n            } else if (nums[mid] <= nums[right]) {\\n                // from mid to right, all elements are sorted. It means RIGHT portion of mid are SORTED\\n                // find target belong to THIS RIGHT portion or not\\n                // [7,8,0,1,2,4,5,6,9]\\n                //  l       m       r\\n                //            l     r. (Ex: target = 5) - YES\\n                //  l     r            (Ex: target = 1) - NO\\n                if(nums[mid] < target && target <= nums[right]){ // Why we check &&  nums[mid] < target (NOT nums[mid] <= target) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to RIGHT portion that sorted\\n                    left = mid + 1;\\n                } else {\\n                    // NO: target belong to LEFT portion (BUT we not sort it is sorted or not)\\n                    right = mid - 1;\\n                }\\n            }\\n            \\n            // When we go here, we DID narrow down left and right pointer. \\n\\t\\t\\t// The loop while will continue AND left and right pointer will be NARROW down again and again (In worst case, left = right = middle)\\n\\t\\t\\t// If target found on array, we will found it at MIDDLE and return. (at line - if(nums[mid] == target) return mid;)\\n            // If not, we will go out of loop and RETURN -1 at the end.\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338285,
                "title": "python-o-log-n-solution-with-explanation-beats-98-time-and-space-complexity",
                "content": "To solve this question, we need to apply binary search with a twist which is that the list is pivoted.\\n\\nIn order to account for the pivot, we introduce the following conditions:\\n1. If start is less than mid than the list is in increasing order:\\n\\t* \\tIf Start <= target < mid: The target must be between start and mid\\n\\t* \\tElse: Target must be between mid and end\\n\\t \\t\\n2. Start is greater than mid, list is pivoted somewhere in the middle of start and mid\\n\\t* \\tIf mid < target < start: The target must be between mid and end\\n\\t* \\tElse: Target must be between start and mid\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start = 0\\n        end = len(nums) - 1\\n\\n        while ( start <= end ):\\n            mid = ( start + end ) // 2\\n            # found the element\\n            if nums[mid] == target:\\n                return mid\\n            # Couldn\\'t find the element in the list\\n            elif( start == mid == end ):\\n                return -1\\n            \\n            # start is less than mid, list is in increasing order                \\n            elif ( nums[start] <= nums[mid] ):\\n                \\n                # target is greater than equal to start & smaller than mid\\n                if( nums[start] <= target < nums[mid] ):\\n                    end = mid\\n                \\n                # target is smaller than start & mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    start = mid + 1\\n            \\n            # start is greater than mid, list is pivoted\\n            else: #( nums[start] > nums[mid] ):\\n                # target is smaller than start & greater than mid\\n                if ( nums[mid] < target < nums[start] ):\\n                    start = mid + 1\\n                \\n                # target is smaller than start & smaller than mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    end = mid\\n\\n        return -1\\n```\\n\\nSome helpful test cases:\\n\\n```\\n[4,5,6,7,0,1,2]\\n4\\n[4,5,6,7,0,1,2]\\n5\\n[4,5,6,7,0,1,2]\\n6\\n[4,5,6,7,0,1,2]\\n7\\n[4,5,6,7,0,1,2]\\n0\\n[4,5,6,7,0,1,2]\\n1\\n[4,5,6,7,0,1,2]\\n2\\n[6,7,0,1,2,4,5]\\n4\\n[6,7,0,1,2,4,5]\\n5\\n[6,7,0,1,2,4,5]\\n6\\n[6,7,0,1,2,4,5]\\n7\\n[6,7,0,1,2,4,5]\\n0\\n[6,7,0,1,2,4,5]\\n1\\n[6,7,0,1,2,4,5]\\n2\\n[6,7,0,1,2,4,5]\\n3\\n[0,1,2,3,4,5,6,7]\\n4\\n[0,1,2,3,4,5,6,7]\\n5\\n[0,1,2,3,4,5,6,7]\\n6\\n[0,1,2,3,4,5,6,7]\\n7\\n[0,1,2,3,4,5,6,7]\\n0\\n[0,1,2,3,4,5,6,7]\\n1\\n[0,1,2,3,4,5,6,7]\\n2\\n[0,1,2,3,4,5,6,7]\\n3\\n[4,5,6,7,0,1,2,3]\\n4\\n[4,5,6,7,0,1,2,3]\\n5\\n[4,5,6,7,0,1,2,3]\\n6\\n[4,5,6,7,0,1,2,3]\\n7\\n[4,5,6,7,0,1,2,3]\\n0\\n[4,5,6,7,0,1,2,3]\\n1\\n[4,5,6,7,0,1,2,3]\\n2\\n[4,5,6,7,0,1,2,3]\\n3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start = 0\\n        end = len(nums) - 1\\n\\n        while ( start <= end ):\\n            mid = ( start + end ) // 2\\n            # found the element\\n            if nums[mid] == target:\\n                return mid\\n            # Couldn\\'t find the element in the list\\n            elif( start == mid == end ):\\n                return -1\\n            \\n            # start is less than mid, list is in increasing order                \\n            elif ( nums[start] <= nums[mid] ):\\n                \\n                # target is greater than equal to start & smaller than mid\\n                if( nums[start] <= target < nums[mid] ):\\n                    end = mid\\n                \\n                # target is smaller than start & mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    start = mid + 1\\n            \\n            # start is greater than mid, list is pivoted\\n            else: #( nums[start] > nums[mid] ):\\n                # target is smaller than start & greater than mid\\n                if ( nums[mid] < target < nums[start] ):\\n                    start = mid + 1\\n                \\n                # target is smaller than start & smaller than mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    end = mid\\n\\n        return -1\\n```\n```\\n[4,5,6,7,0,1,2]\\n4\\n[4,5,6,7,0,1,2]\\n5\\n[4,5,6,7,0,1,2]\\n6\\n[4,5,6,7,0,1,2]\\n7\\n[4,5,6,7,0,1,2]\\n0\\n[4,5,6,7,0,1,2]\\n1\\n[4,5,6,7,0,1,2]\\n2\\n[6,7,0,1,2,4,5]\\n4\\n[6,7,0,1,2,4,5]\\n5\\n[6,7,0,1,2,4,5]\\n6\\n[6,7,0,1,2,4,5]\\n7\\n[6,7,0,1,2,4,5]\\n0\\n[6,7,0,1,2,4,5]\\n1\\n[6,7,0,1,2,4,5]\\n2\\n[6,7,0,1,2,4,5]\\n3\\n[0,1,2,3,4,5,6,7]\\n4\\n[0,1,2,3,4,5,6,7]\\n5\\n[0,1,2,3,4,5,6,7]\\n6\\n[0,1,2,3,4,5,6,7]\\n7\\n[0,1,2,3,4,5,6,7]\\n0\\n[0,1,2,3,4,5,6,7]\\n1\\n[0,1,2,3,4,5,6,7]\\n2\\n[0,1,2,3,4,5,6,7]\\n3\\n[4,5,6,7,0,1,2,3]\\n4\\n[4,5,6,7,0,1,2,3]\\n5\\n[4,5,6,7,0,1,2,3]\\n6\\n[4,5,6,7,0,1,2,3]\\n7\\n[4,5,6,7,0,1,2,3]\\n0\\n[4,5,6,7,0,1,2,3]\\n1\\n[4,5,6,7,0,1,2,3]\\n2\\n[4,5,6,7,0,1,2,3]\\n3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283384,
                "title": "simple-java-solution-beats-100-with-explanation",
                "content": "Basically - the difference from a noraml Binary Search, is the decision to choose the left side or the right side of the array, other than that is pretty much the same.\\n    \\nAs yo probably know, one side has to be in ascendant order, so in order to search on the left side of the array, it has to be in either of those 2 set of conditions:\\n1. \\tThe first and last element of the left side array is in asc order AND the target val is in between those first and last values.\\n1. \\tThe frist and last element of the right side array is in asc order AND the target val is NOT in between those first and last values.\\n\\nOtherwise search for the right side of the array\\n    \\n    public int search(int[] nums, int target) {\\n        \\n        int from = 0;\\n        int to = nums.length -1;\\n        \\n        while(from<=to){\\n\\n            int mid = from + (to-from)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n               \\n            if( isInLeftSide(nums[from], nums[to], nums[mid], target) ){\\n                to = mid-1;\\n            }else {\\n                from = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n     //Left side is asc order AND is between the target OR  R side is asc order AND is NOT between the target\\n    private boolean isInLeftSide(int from, int to, int mid, int target){\\n        return (from <= mid && isBetweenInclusive(target,from,mid)) || (mid <= to && !isBetweenInclusive(target,mid,to));\\n    }\\n    \\n    private boolean isBetweenInclusive(int target, int from, int to){\\n        return from <=target && to >= target;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Basically - the difference from a noraml Binary Search, is the decision to choose the left side or the right side of the array, other than that is pretty much the same.\\n    \\nAs yo probably know, one side has to be in ascendant order, so in order to search on the left side of the array, it has to be in either of those 2 set of conditions:\\n1. \\tThe first and last element of the left side array is in asc order AND the target val is in between those first and last values.\\n1. \\tThe frist and last element of the right side array is in asc order AND the target val is NOT in between those first and last values.\\n\\nOtherwise search for the right side of the array\\n    \\n    public int search(int[] nums, int target) {\\n        \\n        int from = 0;\\n        int to = nums.length -1;\\n        \\n        while(from<=to){\\n\\n            int mid = from + (to-from)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n               \\n            if( isInLeftSide(nums[from], nums[to], nums[mid], target) ){\\n                to = mid-1;\\n            }else {\\n                from = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n     //Left side is asc order AND is between the target OR  R side is asc order AND is NOT between the target\\n    private boolean isInLeftSide(int from, int to, int mid, int target){\\n        return (from <= mid && isBetweenInclusive(target,from,mid)) || (mid <= to && !isBetweenInclusive(target,mid,to));\\n    }\\n    \\n    private boolean isBetweenInclusive(int target, int from, int to){\\n        return from <=target && to >= target;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 174076,
                "title": "binary-search-thinking-process",
                "content": "**Rotated sorted array property**\\nIf we split a `rotated sorted array` in half, one half is monotonic-increasing, the other half itself is a `rotated sorted array`. We can compare the start and end element in a half to tell whether it is monotonic-increasing.\\n\\n**To search for an element in rotated sorted array,**\\n1. Divide `rotated sorted array` in half, \\n2. If `target` in monotonic-increasing half, do **Binary Search**;\\nOtherwise, re-apply the first step on the other half\\n\\n**To reason about the loop**\\n```\\nLoop Invariant: the index of target is in [lo, hi] if target exists in nums (i.e., [lo, hi] is the searching space)\\n\\n// Loop Invariant is true here.\\nwhile searching space is not exhausted,\\n    if nums[mi] == target, return mi\\n\\tif nums[lo] <= nums[mi]\\n\\t\\tif target is in [lo, mi - 1], normal binary search on [lo, mi - 1]\\n\\t\\telse, lo = mi + 1\\n\\telse\\n\\t\\tif target is in [mi + 1, hi], normal binary search on [mi + 1, hi]\\n\\t\\telse, hi = mi - 1 \\n\\t// Loop Invariant is true here.\\nreturn -1\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] == target:\\n                return m\\n            if nums[m] <= nums[r]:\\n                # [m, r] is monotonic increasing\\n                if nums[m] < target <= nums[r]:\\n                    return self.bs(nums, m, r, target)\\n                else:\\n                    r = m - 1\\n            elif nums[l] <= nums[m]:\\n                # [l, r] is monotonic increasing\\n                if nums[l] <= target < nums[m]:\\n                    return self.bs(nums, l, m, target)\\n                else:\\n                    l = m + 1\\n        return -1\\n  \\n\\n    def bs(self, nums, st, en, target):\\n        while st <= en:\\n            mi = (st + en) // 2\\n            if target == nums[mi]:\\n                return mi\\n            elif target < nums[mi]:\\n                en = mi - 1\\n            else:\\n                st = mi + 1\\n        return -1\\n```\\n\\n\\n**Java**\\n```\\n    public int search(int[] nums, int target) {\\n        if (nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            \\n            if (nums[mid] < nums[right]) { // right half sorted\\n                if (nums[mid] < target && target <= nums[right]) { // target within right half\\n                    left = mid + 1; \\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else { // left half sorted\\n                if (nums[left] <= target && target < nums[mid]) { // target within left half\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nLoop Invariant: the index of target is in [lo, hi] if target exists in nums (i.e., [lo, hi] is the searching space)\\n\\n// Loop Invariant is true here.\\nwhile searching space is not exhausted,\\n    if nums[mi] == target, return mi\\n\\tif nums[lo] <= nums[mi]\\n\\t\\tif target is in [lo, mi - 1], normal binary search on [lo, mi - 1]\\n\\t\\telse, lo = mi + 1\\n\\telse\\n\\t\\tif target is in [mi + 1, hi], normal binary search on [mi + 1, hi]\\n\\t\\telse, hi = mi - 1 \\n\\t// Loop Invariant is true here.\\nreturn -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] == target:\\n                return m\\n            if nums[m] <= nums[r]:\\n                # [m, r] is monotonic increasing\\n                if nums[m] < target <= nums[r]:\\n                    return self.bs(nums, m, r, target)\\n                else:\\n                    r = m - 1\\n            elif nums[l] <= nums[m]:\\n                # [l, r] is monotonic increasing\\n                if nums[l] <= target < nums[m]:\\n                    return self.bs(nums, l, m, target)\\n                else:\\n                    l = m + 1\\n        return -1\\n  \\n\\n    def bs(self, nums, st, en, target):\\n        while st <= en:\\n            mi = (st + en) // 2\\n            if target == nums[mi]:\\n                return mi\\n            elif target < nums[mi]:\\n                en = mi - 1\\n            else:\\n                st = mi + 1\\n        return -1\\n```\n```\\n    public int search(int[] nums, int target) {\\n        if (nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            \\n            if (nums[mid] < nums[right]) { // right half sorted\\n                if (nums[mid] < target && target <= nums[right]) { // target within right half\\n                    left = mid + 1; \\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else { // left half sorted\\n                if (nums[left] <= target && target < nums[mid]) { // target within left half\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14619,
                "title": "simple-and-easy-understanding-java-solution",
                "content": "    public int search(int[] nums, int target) {\\n\\t\\t        int pivot = findPivot(nums);\\n\\t\\t        return binarySearch(nums, 0, pivot, target) + binarySearch(nums, pivot + 1, nums.length - 1, target) + 1;\\n\\t\\t    }\\n\\t\\t \\t\\n\\t\\t \\tpublic int findPivot(int nums[]){\\n\\t\\t \\t\\tint i = 0, j = nums.length - 1;\\n\\t\\t\\t\\twhile(i < j - 1){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[mid] && nums[j] < nums[mid]){\\n\\t\\t\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\tj = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t \\t\\treturn i;\\n\\t\\t \\t}\\n\\t\\t \\t\\n\\t\\t \\tpublic int binarySearch(int a[], int start, int end, int key){\\n\\t\\t\\t\\tint i = start, j = end;\\n\\t\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(a[mid] > key){\\n\\t\\t\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t\\t\\t}else if(a[mid] < key){\\n\\t\\t\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse return mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int search(int[] nums, int target) {\\n\\t\\t        int pivot = findPivot(nums);\\n\\t\\t        return binarySearch(nums, 0, pivot, target) + binarySearch(nums, pivot + 1, nums.length - 1, target) + 1;\\n\\t\\t    }\\n\\t\\t \\t\\n\\t\\t \\tpublic int findPivot(int nums[]){\\n\\t\\t \\t\\tint i = 0, j = nums.length - 1;\\n\\t\\t\\t\\twhile(i < j - 1){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[mid] && nums[j] < nums[mid]){\\n\\t\\t\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\tj = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t \\t\\treturn i;\\n\\t\\t \\t}\\n\\t\\t \\t\\n\\t\\t \\tpublic int binarySearch(int a[], int start, int end, int key){\\n\\t\\t\\t\\tint i = start, j = end;\\n\\t\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(a[mid] > key){\\n\\t\\t\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t\\t\\t}else if(a[mid] < key){\\n\\t\\t\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse return mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1732232,
                "title": "python-using-bisect-with-a-key-function",
                "content": "At Python 3.10 you can supply a `key` function to `bisect`. The input array is sorted suitably for a binary search if we use `(num < nums[0], num)` as this key since the first element takes the value `False=0` until the rotation point and then `True=1`   \\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        key = lambda num: (num < nums[0], num)\\n        i = bisect_left(nums, key(target), key=key)\\n        return i if (i < len(nums) and nums[i] == target) else -1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        key = lambda num: (num < nums[0], num)\\n        i = bisect_left(nums, key(target), key=key)\\n        return i if (i < len(nums) and nums[i] == target) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170180,
                "title": "c-binary-search-full-explanation",
                "content": "## **Concept**:\\nNo matter how many times the array\\'s rotated,\\nIt is guaranteed that **one half of array will always be sorted**.\\n\\n## **Finding a pattern**:\\n\\n\\t consider\\n\\t (fs) = first element of array, (mi) = mid element of array, (ls) = last element of array,\\n\\t (!<) = not less than, (>!) = not greater than\\n\\n\\todd number array: \\n    [1,2,3,4,5,6,7] fs < mi < ls => all sorted (mi = 4)\\n    [7,1,2,3,4,5,6] fs !< mi, but mi < ls => right half sorted (mi = 3)\\n    [6,7,1,2,3,4,5] fs !< mi, but m < ls => right half sorted (mi = 2)\\n    [5,6,7,1,2,3,4] fs !< mi, but m < ls => right half sorted (mi = 1)\\n    [4,5,6,7,1,2,3] fs < mi and m !< ls => left half sorted (mi = 7)\\n    [3,4,5,6,7,1,2] fs < mi and m !< ls => left half sorted (mi = 6)\\n    [2,3,4,5,6,7,1] fs < mi and m !< ls => left half sorted (mi = 5)\\n     \\n     even number array: \\n     [1,2,3,4,5,6] fs < mi < ls => all sorted (mi = 3)\\n     [6,1,2,3,4,5] fs !< mi but, mi < ls => right half sorted (mi = 2)\\n     [5,6,1,2,3,4] fs !< mi but, mi < ls => right half sorted (mi = 1)\\n     [4,5,6,1,2,3] fs < mi and mi !< ls => left half sorted (mi = 6)\\n     [3,4,5,6,1,2] fs < mi and mi !< ls => left half sorted (mi = 5)\\n     [2,3,4,5,6,1] fs < mi and mi !< ls => left half sorted (mi = 4)\\n\\t \\n\\t \\n## **Algorithm**:\\n\\n_low = index of first element, mid = (low+high)/2, high = index of last element_\\n\\n**case 1** **:**\\n* if left half is sorted **(arr[low] <= arr[mid])** and target lies in this range **(target >= nums[low] and target < nums[mid])**, Search in this half **(high = mid - 1)**\\n* otherwise search for right half **(low = mid+1)**\\n\\n**case 2** **:**\\n* if left half is not sorted that means right half is sorted. Now if target lies in this range **(target > nums[mid] and target <= nums[high])**, Search in this half **(low = mid + 1)**\\n* otherwise search for left half **(high = mid -1 )**\\n\\n## **Example**:\\n* let nums = [6, 7, 1, 2, 3, 4, 5], target = 6\\n* Iteration 1:\\n\\t*  low = 0, high = 6, mid = 3\\n\\t*  on comparing arr[low] and arr[mid] => right half is sorted\\n\\t*  does target lie in range of right half => NO\\n\\t*  search for left half\\n* Iteration 2:\\n\\t* low = 0, high = 2, mid = 1\\n\\t* on comparing arr[low] and arr[mid] => left half sorted\\n\\t* does target lie in this range => YES\\n\\t* search in this half\\n* Iteration 3:\\n\\t* low = 0, high = 0, mid = 0\\n\\t* this is the required element\\n\\n**code:**\\n\\n```\\n// search an element in a sorted and rotated array. O(logn)\\nint search(int nums[], int size, int target)\\n{\\n    // initialize low and high variables\\n    int low = 0, high = size - 1;\\n\\n    // logic\\n    while (low <= high)\\n    {\\n        // compute mid\\n        int mid = (low + high) / 2;\\n\\n        // check middle element (base case)\\n        if (nums[mid] == target)\\n            return mid;\\n\\n        // left half is sorted\\n        if (nums[low] <= nums[mid])\\n        {\\n            if (target >= nums[low] && target < nums[mid]) // notice target <= nums[mid] is not required because equality has already been checked earlier\\n                high = mid - 1; // go to left half\\n            else\\n                low = mid + 1; // go to right half\\n        }\\n        // right half is sorted\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[high]) // notice target >= nums[mid] is not required because equality has already been checked earlier\\n                low = mid + 1; // go to right half\\n            else\\n                high = mid - 1; // go to left half\\n        }\\n    }\\n\\n    // if element not found\\n    return -1;\\n}\\n```\\n\\n**Upvote if you found it useful! Thank you**",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n// search an element in a sorted and rotated array. O(logn)\\nint search(int nums[], int size, int target)\\n{\\n    // initialize low and high variables\\n    int low = 0, high = size - 1;\\n\\n    // logic\\n    while (low <= high)\\n    {\\n        // compute mid\\n        int mid = (low + high) / 2;\\n\\n        // check middle element (base case)\\n        if (nums[mid] == target)\\n            return mid;\\n\\n        // left half is sorted\\n        if (nums[low] <= nums[mid])\\n        {\\n            if (target >= nums[low] && target < nums[mid]) // notice target <= nums[mid] is not required because equality has already been checked earlier\\n                high = mid - 1; // go to left half\\n            else\\n                low = mid + 1; // go to right half\\n        }\\n        // right half is sorted\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[high]) // notice target >= nums[mid] is not required because equality has already been checked earlier\\n                low = mid + 1; // go to right half\\n            else\\n                high = mid - 1; // go to left half\\n        }\\n    }\\n\\n    // if element not found\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1001111,
                "title": "javascript-o-logn-time-o-1-space",
                "content": "```\\nvar search = function(nums, target) {\\n    let l = 0\\n    let r = nums.length -1\\n    while (l <= r) {\\n        let mid = Math.floor((r - l) / 2 + l)\\n        if (nums[mid] === target) return mid\\n        if (nums[l] <= nums[mid]) {\\n            // left sorted\\n            if (target >= nums[l] && target < nums[mid]) {\\n                // target in sorted\\n                r = mid - 1                \\n            } else {\\n                // target in unsorted\\n                l = mid + 1\\n            }\\n        } else {\\n            // right sorted\\n            if (target <= nums[r] && target > nums[mid]) {\\n                // target in sorted\\n                l = mid + 1\\n            } else {\\n                // target in unsorted\\n                r = mid - 1\\n            }            \\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    let l = 0\\n    let r = nums.length -1\\n    while (l <= r) {\\n        let mid = Math.floor((r - l) / 2 + l)\\n        if (nums[mid] === target) return mid\\n        if (nums[l] <= nums[mid]) {\\n            // left sorted\\n            if (target >= nums[l] && target < nums[mid]) {\\n                // target in sorted\\n                r = mid - 1                \\n            } else {\\n                // target in unsorted\\n                l = mid + 1\\n            }\\n        } else {\\n            // right sorted\\n            if (target <= nums[r] && target > nums[mid]) {\\n                // target in sorted\\n                l = mid + 1\\n            } else {\\n                // target in unsorted\\n                r = mid - 1\\n            }            \\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593263,
                "title": "go-two-binary-searches",
                "content": "```\\nfunc search(nums []int, target int) int {\\n    n := len(nums)\\n    \\n    // Find the pivot.\\n    left, right := 0, n-1\\n    for left < right {\\n        mid := left+(right-left)/2\\n        if nums[mid] > nums[right] {\\n            left = mid+1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    \\n    pivot := left\\n    \\n\\t// Regular binary search\\n    left, right = pivot, pivot-1+n\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        midVal := nums[mid % n]\\n        \\n        if midVal > target {\\n            right = mid-1\\n        } else if midVal < target {\\n            left = mid+1\\n        } else {\\n            return mid % n\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {\\n    n := len(nums)\\n    \\n    // Find the pivot.\\n    left, right := 0, n-1\\n    for left < right {\\n        mid := left+(right-left)/2\\n        if nums[mid] > nums[right] {\\n            left = mid+1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    \\n    pivot := left\\n    \\n\\t// Regular binary search\\n    left, right = pivot, pivot-1+n\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        midVal := nums[mid % n]\\n        \\n        if midVal > target {\\n            right = mid-1\\n        } else if midVal < target {\\n            left = mid+1\\n        } else {\\n            return mid % n\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14623,
                "title": "binary-search-case-by-case",
                "content": "The difficulty of applying binary search to this problem lies in how to determine the correct half for `target`. \\n\\nWhen we do binary search, we start wtih a `l` pointer and a `r` pointer. Then we compute the `m` pointer, if `nums[m]` happens to be `target`, then we are of luck. Otherwise, `nums[m]` can be either to the left or right of `target`. If `nums[m]` is to the left of `target`, we search for the right half; otherwise the left half. So we need to figure out how to check whether `nums[m]` is to the left or right of `target`.\\n\\nWhen `nums[m]` is to the left of `target`: `nums[l] nums[m] target nums[r]`, we will have three cases:\\n\\n1. `nums[l] > nums[m] < target`;\\n2. `nums[l] <= nums[m] > target`;\\n3. `nums[l] <= nums[m] < target`.\\n\\nNote that `m` may be just `l` since the division to compute `m` is a floor division.\\n\\nSimilarly, when `nums[m]` is to the right of `target`: `nums[l] target nums[m] nums[r]`, we will have other three cases:\\n\\n4. `nums[l] > target < nums[m]`;\\n5. `nums[l] <= target > nums[m]`;\\n6. `nums[l] <= target < nums[m]`.\\n\\nYou may just code either cases 1, 2, 3 or cases 4, 5, 6 to determine whether to check the left or right half. The code is as follows.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (left(nums[l], nums[m], target)) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool left(int l, int m, int t) {\\n        return (l > m && l > t && m < t) || (l <= m && l > t && m > t) || (l <= m && l < t && m < t);\\n    }\\n};\\n```\\n\\nIn general binary search, we will compare `nums[m]` with `target` to determine the half.\\n\\nWhen `nums[m] > target`, it corresponds to cases 2, 4, and 6. In case 2, we need to check for the right half while in cases 4 and 6 the left. And cases 4 and 6 can be compressed into `nums[l] <= target || nums[l] > nums[m]`.\\n\\nSimilarly, when `nums[m] < target`, it corresponds to cases 1, 3, and 5. In case 5, we need to check the left while in cases 1 and 3 the right. And cases 1 and 3 can be compressed into `nums[l] > target || nums[l] <= nums[m]`.\\n\\nUsing the above compressed checks, we will come to the following code.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] <= target || nums[l] > nums[m]) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] > target || nums[l] <= nums[m]) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nYou may wonder, for example, when `nums[m] > target`, why don\\'t we need a check for case 2 before entering `l = m + 1`? Actually, when `nums[l] <= target || nums[l] > nums[m]` does not hold, it is just case 2. Similarly you can explain why we don\\'t need to check for case 5 before entering `r = m - 1` below.\\n\\nAnother simple approach is to use the sorted version of the array by applying some tricks to the indices. It is not easy to search in `4, 5, 6, 7, 0, 1, 2`, but it is very easy to search in `0, 1, 2, 4, 5, 6, 7`. Suppose you would like to visit the `3`-rd element in the sorted array, in this case, it is just the `(3 + 4) % 7 = 0`-th element in the rotated array. The `4` is just the index of the minimum. You can find it out using the same idea of [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1, idx = findMinIdx(nums);\\n        while (l <= r) {\\n            int m = l + (r - l) / 2, mid = (m + idx) % nums.size();\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int findMinIdx(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (left(nums[l], nums[m], target)) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool left(int l, int m, int t) {\\n        return (l > m && l > t && m < t) || (l <= m && l > t && m > t) || (l <= m && l < t && m < t);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] <= target || nums[l] > nums[m]) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] > target || nums[l] <= nums[m]) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1, idx = findMinIdx(nums);\\n        while (l <= r) {\\n            int m = l + (r - l) / 2, mid = (m + idx) % nums.size();\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int findMinIdx(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14646,
                "title": "my-accepted-c-codes-o-logn-4ms",
                "content": "Binary search. \\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            if(nums.size() == 0)\\n                return -1;\\n            int left = 0;\\n            int right = nums.size()-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if(target == nums[mid])\\n                    return mid;\\n                if((nums[mid]>=nums[left] && (target>nums[mid] || (target<nums[left]))) || (nums[mid]<nums[left] && target>nums[mid] && target<=nums[right]))\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            if(nums.size() == 0)\\n                return -1;\\n            int left = 0;\\n            int right = nums.size()-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if(target == nums[mid])\\n                    return mid;\\n                if((nums[mid]>=nums[left] && (target>nums[mid] || (target<nums[left]))) || (nums[mid]<nums[left] && target>nums[mid] && target<=nums[right]))\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3882526,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int search(int[] nums, int target) {\\n    int low = 0;\\n    int high = nums.length - 1;\\n\\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n\\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] >= nums[low]) { \\n            if (target >= nums[low] && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (target > nums[mid] && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/6e9839aa-d5b7-4d19-a954-e7a09921a6e4_1691510628.7730532.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int search(int[] nums, int target) {\\n    int low = 0;\\n    int high = nums.length - 1;\\n\\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n\\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] >= nums[low]) { \\n            if (target >= nums[low] && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (target > nums[mid] && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879891,
                "title": "100-faster-c-java-simple-explanation-beginner-friendly-binary-search",
                "content": "## We\\'ll be checking only for the first part after dividing the array from mid.\\n##### There are two possible conditions\\n- if the first part is like `[4,5,7,0,1]` (rotated elements are in first part).\\n- or the first part is like `[3,4,5,6]` (simple sorted in first part)\\n##### Let\\'s handle first condition.\\n- `target <= nums[mid] || target >= nums[start]` then call with `start=start` and `end=mid`.\\n- Otherwise element does not lie in `[start, mid]` therefore call with `start=mid+1` and `end=end`.\\n##### Second condition\\n- check only if the target lies in between `[start, mid]`, then call `start=start` and `end=mid`.\\n- otehrwise call with `start=mid+1` and `end=end`.\\n\\n# Code (Below \\uD83D\\uDC47)\\n<img src=\"https://assets.leetcode.com/users/images/cde42097-431d-4683-963b-d488af508080_1681230761.754524.png\" width=\"400\">\\n\\n### C++ \\n```\\nclass Solution {\\n\\n    int binary_search(vector<int>& nums, int target, int start, int end){\\n        if(start > end || (start==end && nums[start]!=target)) return -1;\\n        if(start == end) return start;\\n        int mid = (start + end)/2;\\n        if(nums[mid]<nums[start]){\\n            if(target >= nums[start] || target <= nums[mid]) \\n                return binary_search(nums, target, start, mid);\\n            else \\n                return binary_search(nums, target, mid+1, end);\\n        }else{\\n            if(target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid+1, end);\\n        }\\n    }\\n\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return binary_search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\\n### Java\\n```\\npublic class Solution {\\n\\n    private int binary_search(int[] nums, int target, int start, int end) {\\n        if (start > end || (start == end && nums[start] != target)) return -1;\\n        if (start == end) return start;\\n        int mid = (start + end) / 2;\\n        if (nums[mid] < nums[start]) {\\n            if (target >= nums[start] || target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        } else {\\n            if (target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        }\\n    }\\n\\n    public int search(int[] nums, int target) {\\n        return binary_search(nums, target, 0, nums.length - 1);\\n    }\\n}\\n\\n```\\n\\n\\n\\n\\n\\n### Thank you :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    int binary_search(vector<int>& nums, int target, int start, int end){\\n        if(start > end || (start==end && nums[start]!=target)) return -1;\\n        if(start == end) return start;\\n        int mid = (start + end)/2;\\n        if(nums[mid]<nums[start]){\\n            if(target >= nums[start] || target <= nums[mid]) \\n                return binary_search(nums, target, start, mid);\\n            else \\n                return binary_search(nums, target, mid+1, end);\\n        }else{\\n            if(target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid+1, end);\\n        }\\n    }\\n\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return binary_search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\n```\\npublic class Solution {\\n\\n    private int binary_search(int[] nums, int target, int start, int end) {\\n        if (start > end || (start == end && nums[start] != target)) return -1;\\n        if (start == end) return start;\\n        int mid = (start + end) / 2;\\n        if (nums[mid] < nums[start]) {\\n            if (target >= nums[start] || target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        } else {\\n            if (target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        }\\n    }\\n\\n    public int search(int[] nums, int target) {\\n        return binary_search(nums, target, 0, nums.length - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343236,
                "title": "short-concise-crispy-easy-self-explanatory-solution",
                "content": "# Intuition\\nTo make Medium Code very Easy\\nHERE I AM PRESENTING JAVA CODE FOR C++ USE VECTOR INSTEAD OF ARRAY\\n\\n# Approach\\nSS \\nJust Smile and Solve\\n\\n# Complexity\\nNothing Complex\\n\\n# Please Upvote\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] arr, int x) {\\n        int l=arr.length;\\n        int i=0;\\n        while(i+1<l&&arr[i]<arr[i+1])\\n        {\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n         int beg=0,end=l-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(x==arr[mid])\\n            {\\n                if((mid+i)>=(l-1))\\n                return mid+i-l+1;\\n                return mid+i+1;\\n            }\\n            else if(arr[mid]<x)\\n            beg=mid+1;\\n            else\\n            end=mid-1;\\n        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] arr, int x) {\\n        int l=arr.length;\\n        int i=0;\\n        while(i+1<l&&arr[i]<arr[i+1])\\n        {\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n         int beg=0,end=l-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(x==arr[mid])\\n            {\\n                if((mid+i)>=(l-1))\\n                return mid+i-l+1;\\n                return mid+i+1;\\n            }\\n            else if(arr[mid]<x)\\n            beg=mid+1;\\n            else\\n            end=mid-1;\\n        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137660,
                "title": "fully-explained-step-by-step-which-line-to-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin question, it is given we have to solve it in lon n times. which means we have to use divide and conquer technique.\\n    if in question complexity is not mentioned , then it is obvious since array is rotated and sorted that is both parts are sorted. we have to eliminate one part so that we can search in right part.\\n\\n# WHAT IS PIVOT OF AN ROTATED SORTED ARRAY.\\nIt is the index of the array at which array get sorted in two halves. example- [4,5,6,7,8]->[8,4,5,6,7], pivot is 4\\n# WHY PIVOT????\\n we are finding pivot so that we can eliminate the second half and apply search in the correct part.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. firstly we have to find pivot using binary search.\\n2. then we have to check whether target is less or greater than pivot.\\n3. if target is greater than pivot apply search on right half else left half.  [4,5,6,7,8]->[8,4,5,6,7] , target is 6.... search is done on [4,5,6,7]\\n4 apply binary search on the half.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(lon n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)- constant \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int>& arr, int s,int e,int k)\\n    {\\n      while(s<=e)\\n      {\\n        int mid=(s+e)/2;\\n        if(arr[mid]==k)\\n          return mid;\\n        else if(arr[mid]<k)\\n        {\\n          s=mid+1;\\n        }\\n        else\\n          e=mid-1;\\n      }\\n       return -1;\\n    }\\n     int getPivot(vector<int>& arr)\\n     {\\n       int s=0,e=arr.size()-1;\\n       int mid=(s+e)/2;\\n       while(s<e)\\n       {\\n         if(arr[mid] >= arr[0])\\n            s=mid+1;\\n          else\\n            e=mid;\\n        mid=(s+e)/2;\\n       }\\n       return s;\\n     }\\n    int search(vector<int>& arr, int target) {\\n        int pivot =getPivot(arr);\\n        if(arr[pivot]<=target && target <= arr[arr.size()-1])\\n        {\\n          return BinarySearch(arr,pivot,arr.size()-1,target);\\n        }\\n        else\\n          return BinarySearch(arr,0,pivot-1,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int>& arr, int s,int e,int k)\\n    {\\n      while(s<=e)\\n      {\\n        int mid=(s+e)/2;\\n        if(arr[mid]==k)\\n          return mid;\\n        else if(arr[mid]<k)\\n        {\\n          s=mid+1;\\n        }\\n        else\\n          e=mid-1;\\n      }\\n       return -1;\\n    }\\n     int getPivot(vector<int>& arr)\\n     {\\n       int s=0,e=arr.size()-1;\\n       int mid=(s+e)/2;\\n       while(s<e)\\n       {\\n         if(arr[mid] >= arr[0])\\n            s=mid+1;\\n          else\\n            e=mid;\\n        mid=(s+e)/2;\\n       }\\n       return s;\\n     }\\n    int search(vector<int>& arr, int target) {\\n        int pivot =getPivot(arr);\\n        if(arr[pivot]<=target && target <= arr[arr.size()-1])\\n        {\\n          return BinarySearch(arr,pivot,arr.size()-1,target);\\n        }\\n        else\\n          return BinarySearch(arr,0,pivot-1,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105482,
                "title": "binary-search-approach-c-easy-solution",
                "content": "\\n\\n# Approach\\nBinary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int k) {\\n       int l=0;\\n       int h=a.size()-1;\\n       while(l<h){\\n            int mid=(l+h)/2;\\n            if(a[mid]==k) return mid;\\n            if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        if(a[l]==k)\\n        return l;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int k) {\\n       int l=0;\\n       int h=a.size()-1;\\n       while(l<h){\\n            int mid=(l+h)/2;\\n            if(a[mid]==k) return mid;\\n            if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        if(a[l]==k)\\n        return l;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067008,
                "title": "0ms-java-beats-100-easy-modified-binary-search",
                "content": "# Approach\\nIt is a Modified Binary Search in which from the middle element we are dividing array into two halves and checking which half is in sorted order as it is easy to find a element in a sorted array and if the element is not present in sorted half then we will go for another half, and discard the half which does not contains the element, repeat it until you find the target or if it is not present print -1.\\n*Note -- it is guranted that one of the half will be always in sorted order.*\\n\\n# Time complexity:\\nO(log n) -- as we are dividing array into two parts every time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int len = nums.length;\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j)\\n        {\\n            int mid = (i + j) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[i] <= nums[mid]) // checking whether first half is in sorted order or not\\n            {\\n                if(target < nums[mid] && target >= nums[i]) //if the element is in first half then we will discard second half\\n                    j = mid - 1;\\n                else\\n                    i = mid + 1;\\n            }\\n            else\\n            {\\n                    if(target > nums[mid] && target <= nums[j])\\n                        i = mid + 1;\\n                    else\\n                        j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int len = nums.length;\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j)\\n        {\\n            int mid = (i + j) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[i] <= nums[mid]) // checking whether first half is in sorted order or not\\n            {\\n                if(target < nums[mid] && target >= nums[i]) //if the element is in first half then we will discard second half\\n                    j = mid - 1;\\n                else\\n                    i = mid + 1;\\n            }\\n            else\\n            {\\n                    if(target > nums[mid] && target <= nums[j])\\n                        i = mid + 1;\\n                    else\\n                        j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690428,
                "title": "faster-than-100-easy-java-solution",
                "content": "Feel free to ask and point out a better approach \\nAlso upvote if it was helpful\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid;\\n        while(left<=right){\\n            mid = left+(right-left)/2;\\n            if(nums[mid] == target) return mid;\\n            // condition for left side is sort\\n            if(nums[left]<=nums[mid]){\\n                if(target>=nums[left] && target <=nums[mid]){\\n                    right = mid-1;\\n                }else {\\n                    left = mid+1;\\n                }\\n            }\\n            else{\\n                if(target>=nums[mid] && target <=nums[right]){\\n                    left = mid+1;\\n                }else{\\n                    right = mid-1;\\n                }\\n            }\\n    }\\n     return -1;   \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid;\\n        while(left<=right){\\n            mid = left+(right-left)/2;\\n            if(nums[mid] == target) return mid;\\n            // condition for left side is sort\\n            if(nums[left]<=nums[mid]){\\n                if(target>=nums[left] && target <=nums[mid]){\\n                    right = mid-1;\\n                }else {\\n                    left = mid+1;\\n                }\\n            }\\n            else{\\n                if(target>=nums[mid] && target <=nums[right]){\\n                    left = mid+1;\\n                }else{\\n                    right = mid-1;\\n                }\\n            }\\n    }\\n     return -1;   \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595571,
                "title": "my-solution",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938870,
                "title": "c-very-easy-to-understand-4-ms",
                "content": "In this example, we have to search in **rotated sorted array**. So simple idea comes in mind for searching, either we can use linear search or binary seach.\\nTo use linear seach is also one approach to solve this problem but if we use linear search technique than it takes **O(N)** time complexity to solve this problem. But in problem description we have given that solve in **O(logn)** time complexity. So we need to think some idea about binary search.\\nOur simple Binary Seach only works for sorted array but here we have given **rotated sorted array** so we need to modify binary seach slighty.\\nOne important observation in rotated sorted array.\\n**At any point we have atleast one half of array which is sorted (another half may or may not sorted).**\\nBy using this observation this problem is very easy to solve using binary seach.\\n\\n**Code**\\n```\\nint search(vector<int>& arr, int key) {\\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(arr[mid] == key)\\n                return mid;\\n            \\n\\t\\t// find which half is sorted.\\n            if(arr[low] <= arr[mid])\\n            {\\n\\t\\t\\t\\t// If left half is sorted\\n\\t\\t\\t\\t// then find key in left half\\n                if(key <= arr[mid] && key >= arr[low])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// if right half is sorted\\n\\t\\t\\t\\t// then find key in right half.\\n                if(key >= arr[mid] && key <= arr[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n**Time Complexity : O(logn)\\nSpace Complexity : O(1)**\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& arr, int key) {\\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(arr[mid] == key)\\n                return mid;\\n            \\n\\t\\t// find which half is sorted.\\n            if(arr[low] <= arr[mid])\\n            {\\n\\t\\t\\t\\t// If left half is sorted\\n\\t\\t\\t\\t// then find key in left half\\n                if(key <= arr[mid] && key >= arr[low])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// if right half is sorted\\n\\t\\t\\t\\t// then find key in right half.\\n                if(key >= arr[mid] && key <= arr[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487949,
                "title": "python-binary-search-beats-99-simple-and-efficient-solutions-with-explanation",
                "content": "### Solution 1\\n```\\nclass Solution:\\n    def findPivot(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return mid\\n            elif mid > start and nums[mid] < nums[mid - 1]:\\n                return mid - 1\\n            elif nums[mid] > nums[start]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n\\n    def binarySearch(self, nums, start, end, target):\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n    \\n    def search(self, nums: List[int], target: int) -> int:\\n        pivotIndex = self.findPivot(nums)\\n        targetIndex = self.binarySearch(nums, 0, pivotIndex, target)\\n        return targetIndex if targetIndex != -1 else self.binarySearch(nums, pivotIndex+1, len(nums)-1, target)\\n```\\n\\n### Solution 2 - Elegant Solution\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tUpdate start and end pointers based on the different parts of array where target may lie.\\n\\t\\t\\t\\tFor example - Consider the following array:\\n\\t\\t\\t\\tarr = [4, 5, 6, 7, 8, 1, 2, 3] \\n\\t\\t\\t\\tparts of array would be:\\n\\t\\t\\t\\t1st part: 4-7\\n\\t\\t\\t\\t2nd part: 8\\n\\t\\t\\t\\t3rd part: 1-3\\n\\t\\t\\t\"\"\"\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[start] <= nums[mid]:\\n\\t\\t\\t\\t# 1st part of array i.e, if target lies in first part of array then search only in that part Else search in the remaining parts\\n                if nums[start] <= target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t\\t# 3rd part of array i.e, if target lies in 3rd part then search only in that part Else search in the remaining parts.\\n                if nums[mid] < target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPivot(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return mid\\n            elif mid > start and nums[mid] < nums[mid - 1]:\\n                return mid - 1\\n            elif nums[mid] > nums[start]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n\\n    def binarySearch(self, nums, start, end, target):\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n    \\n    def search(self, nums: List[int], target: int) -> int:\\n        pivotIndex = self.findPivot(nums)\\n        targetIndex = self.binarySearch(nums, 0, pivotIndex, target)\\n        return targetIndex if targetIndex != -1 else self.binarySearch(nums, pivotIndex+1, len(nums)-1, target)\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tUpdate start and end pointers based on the different parts of array where target may lie.\\n\\t\\t\\t\\tFor example - Consider the following array:\\n\\t\\t\\t\\tarr = [4, 5, 6, 7, 8, 1, 2, 3] \\n\\t\\t\\t\\tparts of array would be:\\n\\t\\t\\t\\t1st part: 4-7\\n\\t\\t\\t\\t2nd part: 8\\n\\t\\t\\t\\t3rd part: 1-3\\n\\t\\t\\t\"\"\"\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[start] <= nums[mid]:\\n\\t\\t\\t\\t# 1st part of array i.e, if target lies in first part of array then search only in that part Else search in the remaining parts\\n                if nums[start] <= target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t\\t# 3rd part of array i.e, if target lies in 3rd part then search only in that part Else search in the remaining parts.\\n                if nums[mid] < target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201394,
                "title": "c-modify-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0, R = nums.size() - 1, M;\\n        while (L <= R) {\\n            M = (L + R) / 2;\\n            if (nums[M] == target) {\\n                return M;\\n            }\\n            // If Left is sorted\\n            if (nums[L] <= nums[M]) {\\n                // If the target lays on the left part\\n                if (nums[L] <= target and target <= nums[M]) {\\n                    R = M - 1;\\n                } \\n                else {\\n                    L = M + 1;\\n                }\\n            }\\n            // If Right is sorted\\n            else {\\n                // If the target lays on the right part\\n                if (nums[M] <= target and target <= nums[R]) {\\n                    L = M + 1;\\n                } \\n                else {\\n                    R = M - 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0, R = nums.size() - 1, M;\\n        while (L <= R) {\\n            M = (L + R) / 2;\\n            if (nums[M] == target) {\\n                return M;\\n            }\\n            // If Left is sorted\\n            if (nums[L] <= nums[M]) {\\n                // If the target lays on the left part\\n                if (nums[L] <= target and target <= nums[M]) {\\n                    R = M - 1;\\n                } \\n                else {\\n                    L = M + 1;\\n                }\\n            }\\n            // If Right is sorted\\n            else {\\n                // If the target lays on the right part\\n                if (nums[M] <= target and target <= nums[R]) {\\n                    L = M + 1;\\n                } \\n                else {\\n                    R = M - 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588195,
                "title": "c-binary-search-solution",
                "content": "An array is sorted in ascending or descending order and then rotated at some unknown pivots. For convenience, here we only talk about cases where the array was originally sorted in ascending order. Below digram shows all the rotated sorted arrays that are generated by the same array.\\n![image](https://assets.leetcode.com/users/images/ca7fda6b-1272-4210-a896-9c47f4dded29_1595998493.391367.png)\\n\\n\\nIn math, an inflection point is a point on a curve at which the sign of curvature changes. In a rotated sorted array, we call a point inflection point (red line shown as below) such that all the elements in its left interval are greater than the first element, and all the elements in its right interval are less than the first element.\\n![image](https://assets.leetcode.com/users/images/e4a78dcb-2be8-4f17-88cf-9f6e7698c2e3_1595998500.6699812.png)\\n\\n\\n### Alogrithm\\n\\nSame as the regular binary search, the idea of solving this problem is keep narrowing down the search range until the target is found. However, we can\\'t eliminate half of the elements every time by just comparing target and nums[mid] since the entire array is neither in ascending order nor in descending order after the rotation. But we can still find a monotone interval and use it to narrow down the search range. \\n\\n   - If nums[mid] >= nums[left], then [left, mid] is a monotone interval in which all the elements are sorted in ascending order. In this case, if target is within range [left, mid), then we narrow down the search range to [left, mid-1], therwise we narrow down search range to [mid+1, right]. \\n   - If nums[mid] < nums[left], then [mid, right] is a monotone interval in which all the elements are sorted in ascending order. In this case, if target is within range (mid,right] then we narrow down the search range to [mid+1, right], otherwise we narrow down search range to [left, mid-1].\\n   \\n![image](https://assets.leetcode.com/users/images/b505483b-24b2-4db3-a603-7cc4aa1dce51_1595920273.5792851.png)\\n\\n### Implementation\\n```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int left = 0, right = nums.Length - 1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] >= nums[left])\\n            {\\n                if(target >= nums[left] && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int left = 0, right = nums.Length - 1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] >= nums[left])\\n            {\\n                if(target >= nums[left] && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417017,
                "title": "java-binary-search-with-explanations-and-examples",
                "content": "```java\\n\\n    // Since the array is partially sorted, there are only 2 scenarios to consider.\\n    // let m = (left+right)/2. \\n    // (1) the subarray from left to m_th index is sorted\\n    // (2) the subarray from m_th to right index is sorted\\n    // eg. [4,5,6,7,0,1,2]\\n    // left = 0, right = 6, m = 3\\n    // either [4,5,6,7] or [7,0,1,2] must be sorted\\n    // this can be checked comparing subarray[0] and subarray[length-1]\\n    // if subarray[length-1] >= subarray[0], the subarray is sorted\\n    // for each each scenario, we consider if the target is in the range of {subarray[0], subarray[length-1]}.\\n    // if it is, we do normal binary search. else, we search in the other half\\n    \\n    // walk through\\n    // [4,5,6,7,0,1,2], target = 0\\n    // l=0, r=6, m=3\\n    // nums[3]=7, left subarray is sorted since nums[3] >= nums[0] and target 0 is not in range. therefore, we search the other half.\\n    // l=m+1=4, r=6, m=5\\n    // nums[5]=1, left subarray is sorted since nums[5] >= nums[4] and target 0 is in range. therefore, we search in the left half.\\n    // l=4, r=5, m=4\\n    // nums[4]=0, target = 0, therefore, return 4;\\n    \\n    // what if target is not in the array\\n    // [4,5,6,8,0,1,2], target = 7\\n    // l=0, r=6, m=3\\n    // l=0, r=3, m=1\\n    // l=2, r=3, m=2\\n    // l=3, r=3, m=3\\n    // since nums[l] and nums[m] both point to 8 and 7 != 8, l = 4\\n    // l=4, r=3. exits loop\\n\\t\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left <= right && left < nums.length && right >= 0) {\\n            int mid = left + (right-left)/2;\\n            if (target == nums[mid]) {    //condition 1\\n                return mid;\\n            }\\n            if (nums[left] <= nums[mid] && nums[left] <= target && target <= nums[mid]) {     //condition 2\\n                right = mid;\\n            }\\n            else if (nums[left] <= nums[mid]) {     //condition 3\\n                left = mid + 1;\\n            }\\n            else if (nums[right] >= nums[mid] && nums[mid] <= target && target <= nums[right]) {     //condition 4\\n                left = mid;\\n            }\\n            else {     //condition 5\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n```\\nupdate: \\n i think the key is to grasp boundary conditions is to makes ure that after each iteration, the problem size decreases. the only time the problem size doesn\\'t have to decrease is when you have found the answer.\\n if condition 3 or 5 is met, the problem size is guaranteed to decrease. if condition 1 is met, we exit the loop.\\nhowever, for condition 2 and 4, the problem size only decreases when the subarray contains 2 or more numbers.\\nassuming subarray contains [1,2,3], target = 1. l=0, r=2, m=1, condition 2 is met.\\nthe subarray becomes [1,2] , l=0, r=1, m=0. if condition 1 didn\\'t exist, condition 2 would have been met, subarray would become [1], l=0, r=0, m=0, then we go into an infinite loop.\\ntherefore, condition 1 ensures that the problem size will always decrease in the case where the subarray contained only 1 element and condition 2 or 4 are met.\\ntherefore, it is ensured that the problem size decreases after each iteration. i think that\\'s the key to solving binary search problems.\\n\\nanother thing is to keep track of your left and right pointers.\\nif you set the condition as (nums[mid] < target) instead of (nums[mid] <= target), you also need to change the instructions along with the condition.\\nif the condition is (nums[mid] <= target) and it is met, the next step would be to search in a subarray that starts at mid.\\nif the condition is (nums[mid] < target) and it is met, the next step would be to search in a subarray that starts at (mid+1).\\n",
                "solutionTags": [],
                "code": "```java\\n\\n    // Since the array is partially sorted, there are only 2 scenarios to consider.\\n    // let m = (left+right)/2. \\n    // (1) the subarray from left to m_th index is sorted\\n    // (2) the subarray from m_th to right index is sorted\\n    // eg. [4,5,6,7,0,1,2]\\n    // left = 0, right = 6, m = 3\\n    // either [4,5,6,7] or [7,0,1,2] must be sorted\\n    // this can be checked comparing subarray[0] and subarray[length-1]\\n    // if subarray[length-1] >= subarray[0], the subarray is sorted\\n    // for each each scenario, we consider if the target is in the range of {subarray[0], subarray[length-1]}.\\n    // if it is, we do normal binary search. else, we search in the other half\\n    \\n    // walk through\\n    // [4,5,6,7,0,1,2], target = 0\\n    // l=0, r=6, m=3\\n    // nums[3]=7, left subarray is sorted since nums[3] >= nums[0] and target 0 is not in range. therefore, we search the other half.\\n    // l=m+1=4, r=6, m=5\\n    // nums[5]=1, left subarray is sorted since nums[5] >= nums[4] and target 0 is in range. therefore, we search in the left half.\\n    // l=4, r=5, m=4\\n    // nums[4]=0, target = 0, therefore, return 4;\\n    \\n    // what if target is not in the array\\n    // [4,5,6,8,0,1,2], target = 7\\n    // l=0, r=6, m=3\\n    // l=0, r=3, m=1\\n    // l=2, r=3, m=2\\n    // l=3, r=3, m=3\\n    // since nums[l] and nums[m] both point to 8 and 7 != 8, l = 4\\n    // l=4, r=3. exits loop\\n\\t\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left <= right && left < nums.length && right >= 0) {\\n            int mid = left + (right-left)/2;\\n            if (target == nums[mid]) {    //condition 1\\n                return mid;\\n            }\\n            if (nums[left] <= nums[mid] && nums[left] <= target && target <= nums[mid]) {     //condition 2\\n                right = mid;\\n            }\\n            else if (nums[left] <= nums[mid]) {     //condition 3\\n                left = mid + 1;\\n            }\\n            else if (nums[right] >= nums[mid] && nums[mid] <= target && target <= nums[right]) {     //condition 4\\n                left = mid;\\n            }\\n            else {     //condition 5\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279439,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[left] <= nums[mid]) {\\n                // NOTE: left might equal to mid [3,1], single number matches the rule, so need nums[left] <= nums[mid]\\n                // increasing on the left\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // increasing on the right\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[left] <= nums[mid]) {\\n                // NOTE: left might equal to mid [3,1], single number matches the rule, so need nums[left] <= nums[mid]\\n                // increasing on the left\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // increasing on the right\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879510,
                "title": "c-o-logn-binary-search-pictorial-representation",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n![image](https://assets.leetcode.com/users/images/99f8d605-726f-45d7-8df1-28376d128ea5_1691462070.3995874.jpeg)\\n\\n**Approach:**\\n* identify in which segment our current *mid* is present \\n* Present in left segment: a[m]>a[n-1]\\n\\t* Move right side: if target is in right segment or target is greater than mid\\n\\t* else move left\\n* Present in right segment: a[m]<a[n-1]\\n\\t* Move left side: if target is in left segment or target is smaller than mid\\n\\t* else move right\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int n=a.size();\\n        int l=0, r=n-1;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(a[m]==target) return m;\\n            if(a[m]>a[n-1]){ // left side of peak element\\n                if(target>a[m] || target<a[0]){\\n                    l=m+1;\\n                }else{\\n                    r=m-1;\\n                }\\n            }else{ // right side of peak element\\n                if(target<a[m] || target>a[n-1]){\\n                    r=m-1;\\n                }else{\\n                    l=m+1;\\n                }\\n            }\\n        }\\n      return -1;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int n=a.size();\\n        int l=0, r=n-1;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(a[m]==target) return m;\\n            if(a[m]>a[n-1]){ // left side of peak element\\n                if(target>a[m] || target<a[0]){\\n                    l=m+1;\\n                }else{\\n                    r=m-1;\\n                }\\n            }else{ // right side of peak element\\n                if(target<a[m] || target>a[n-1]){\\n                    r=m-1;\\n                }else{\\n                    l=m+1;\\n                }\\n            }\\n        }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780314,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\nIntuition\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nVideo link for question:\\nhttps://youtu.be/DnNyh3WIdpg\\n\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        // 4 5 6 7 0 1 2 \\n\\n    bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? left:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        // 4 5 6 7 0 1 2 \\n\\n    bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? left:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221484,
                "title": "rotated-array-binary-search-finding-targets-in-style-with-o-log-n-time-complexity",
                "content": "To solve this problem with O(log n) time complexity, we can use a modified binary search algorithm.\\n\\n1. First, we find the pivot point where the array is rotated. This can be done using binary search. We start with the middle element and check if it is greater than the last element. If it is, then the pivot must be in the right half of the array. If it is not, then the pivot must be in the left half of the array. We continue this process until we find the pivot element.\\n\\n2. Once we know the pivot point, we can perform binary search on the appropriate half of the array. If the target is less than or equal to the last element in the left half, then we search the left half. Otherwise, we search the right half.\\n\\n3. In each iteration of the binary search, we check the middle element of the current range. If it is equal to the target, we return its index. If it is greater than the target, we search the left half. Otherwise, we search the right half. If we reach the end of the range without finding the target, we return -1.\\n\\n# Complexity\\n- Time complexity: The algorithm uses binary search twice, once to find the pivot and once to find the target. Both binary searches take $$O(log n)$$ time. Therefore, the total time complexity is $$O(log n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a constant amount of extra space for variables such as left, right, mid, and pivot. Therefore, the space complexity is $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        # find the pivot point\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        pivot = left\\n    \\n    # perform binary search on the appropriate half of the array\\n        if target >= nums[pivot] and target <= nums[-1]:\\n            left, right = pivot, len(nums) - 1\\n        else:\\n            left, right = 0, pivot - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        # find the pivot point\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        pivot = left\\n    \\n    # perform binary search on the appropriate half of the array\\n        if target >= nums[pivot] and target <= nums[-1]:\\n            left, right = pivot, len(nums) - 1\\n        else:\\n            left, right = 0, pivot - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100908,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return i;\\n        return -1;          \\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return nums[low] == target ? low : -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return i;\\n        return -1;          \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return nums[low] == target ? low : -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303961,
                "title": "c-1-time-binary-search-solution-runtime-faster-than-100-00-memory-usage-less-than-75-00",
                "content": "Without finding the pivot point , from where the array is rotated...\\nthere are only two possibilities ..\\n1.The mid of our search space will be greater than start of our search space.\\n*    now array will be sorted from start to mid\\n*    here are two possibilities ...target can be between start to mid or on the right part of mid.\\n\\n2.The mid of our search space will be smaller than start of our search space \\n* now the array will be sorted from mid to end \\n* here are other two possiblities ...target can be in between the mid to end or on the left part of mid\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int m=(s+e)/2;\\n            if(target==nums[m])return m;\\n            if(s==m){s+=1;continue;}\\n            if(nums[m]>nums[s]){\\n                if(target>=nums[s] and target<nums[m]) e=m-1;\\n                else s=m+1;\\n            }\\n            else{\\n                 if(target>nums[m] and target<=nums[e]) s=m+1;\\n                else e=m-1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int m=(s+e)/2;\\n            if(target==nums[m])return m;\\n            if(s==m){s+=1;continue;}\\n            if(nums[m]>nums[s]){\\n                if(target>=nums[s] and target<nums[m]) e=m-1;\\n                else s=m+1;\\n            }\\n            else{\\n                 if(target>nums[m] and target<=nums[e]) s=m+1;\\n                else e=m-1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842472,
                "title": "c-simple-code-easy-o-log-n-search",
                "content": "**Please upvote if you like this approach \\\\ solution \\uD83D\\uDE0A**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\twhile(start <= end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\t\\t\\tif(nums[mid] == target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\tif(nums[mid] >= nums[start])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[start] <= target && target < nums[mid])\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[mid] < target && target <= nums[end])\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t} \\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\twhile(start <= end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\t\\t\\tif(nums[mid] == target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\tif(nums[mid] >= nums[start])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[start] <= target && target < nums[mid])\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1654277,
                "title": "python-binary-search-with-explanation-3-cases",
                "content": "**Idea:** There are three cases for when we search on the right half of each step.\\n\\n1. If target is between mid and right (easiest case, we know it might be in the right half b/c target is greater than mid but less than right)\\n2. If target is greater than mid, and left is less than/equal to mid (even though right will be less than mid, we know it\\'s not in the left half as left is smaller than mid)\\n3. If target is less than left, and left is less than/equal to mid (left is smaller than mid, we know it\\'s not iin the left half as target is smaller than left)\\n\\n**left = `nums[l]`, right = `nums[r]`, mid = `nums[mid]`.\\n\\nCase 1 relies on the proof that target can only be in right half. Cases 2 and 3 relies on the proof that target can not be in left half. Each case also relies on the precondition that the array is strictly increasing (from some index i to n - 1 and continued from 0 to i - 1).\\n\\nSmall example is listed for each case below in form of # [nums], target\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif (nums[mid] < target <= nums[r] or # eg. [2, 0, 1],    1 (0 < 1)\\n                  nums[l] <= nums[mid] < target or # eg. [1, 2, 3, 0], 3 (1 <= 2)\\n                  target < nums[l] <= nums[mid]):  # eg. [1, 2, 0],    0 (1 <= 2)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif (nums[mid] < target <= nums[r] or # eg. [2, 0, 1],    1 (0 < 1)\\n                  nums[l] <= nums[mid] < target or # eg. [1, 2, 3, 0], 3 (1 <= 2)\\n                  target < nums[l] <= nums[mid]):  # eg. [1, 2, 0],    0 (1 <= 2)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174197,
                "title": "python-simple-explanation-2-approaches",
                "content": "**Approach 1:**\\nFind the minimum value index in the array and use this to identify the 2 ascending parts of the array. (Regular binary search in each part)\\nThe key is figuring out how to find the min_value_index.\\n**Key idea to find min_value_index:** \\nIf arr[mid] is greater than arr[end], it means our min_value would be on the right of mid (and it is definitely not mid). Hence go right => start = mid + 1\\nElse if arr[mid] is less than arr[end], it means our min_value is on the left (and it also could be present at mid). Hence go left => end = mid.\\nDo this while start<end. \\nWhen loop ends, start == end, and start will be pointing to min_value_index.\\nUse the min_value_index as the partition point to binary search on the 2 ascending parts.\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        min_value_index = self.find_min_value_index(nums)\\n        result = self.binary_search(nums, target, min_value_index, len(nums)-1)\\n        if result == -1 and min_value_index != 0:\\n            result = self.binary_search(nums, target, 0, min_value_index-1)\\n        return result\\n               \\n    def binary_search(self, nums, target, start, end):\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == nums[mid]:\\n                return mid\\n            if target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n        \\n    def find_min_value_index(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] > nums[end]:\\n                # go right\\n                start = mid + 1\\n            else:\\n                # go left and do not eliminate mid\\n                end = mid\\n        return start\\n```\\n\\n**Approach 2:**\\n**Key idea:** \\nRealizing that after finding the mid, we need to find if sorted part lies on the left or on the right.\\nOnce we know which part is sorted, for this part, we ask the question: does the key lie in this part? \\nIf yes, go into this part. If not, go to the other part.\\n\\t\\t\\t\\t\\t \\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target: return mid\\n\\t\\t\\t\\n            if nums[start] <= nums[mid]:\\n\\t\\t\\t# If left part is sorted ascending\\n\\t\\t\\t# Note: We need to have <= for a case where array size is 2, in which case mid == start is also possible.\\n\\t\\t\\t# Now we ask the question:  does the key exist in this sorted part? Adjust bounds accordingly.\\n                if target >= nums[start] and target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t# Else right part is the sorted ascending part. \\n\\t\\t\\t# Ask the same question with respect to this part and adjust bounds accordingly.\\n                if target > nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        min_value_index = self.find_min_value_index(nums)\\n        result = self.binary_search(nums, target, min_value_index, len(nums)-1)\\n        if result == -1 and min_value_index != 0:\\n            result = self.binary_search(nums, target, 0, min_value_index-1)\\n        return result\\n               \\n    def binary_search(self, nums, target, start, end):\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == nums[mid]:\\n                return mid\\n            if target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n        \\n    def find_min_value_index(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] > nums[end]:\\n                # go right\\n                start = mid + 1\\n            else:\\n                # go left and do not eliminate mid\\n                end = mid\\n        return start\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target: return mid\\n\\t\\t\\t\\n            if nums[start] <= nums[mid]:\\n\\t\\t\\t# If left part is sorted ascending\\n\\t\\t\\t# Note: We need to have <= for a case where array size is 2, in which case mid == start is also possible.\\n\\t\\t\\t# Now we ask the question:  does the key exist in this sorted part? Adjust bounds accordingly.\\n                if target >= nums[start] and target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t# Else right part is the sorted ascending part. \\n\\t\\t\\t# Ask the same question with respect to this part and adjust bounds accordingly.\\n                if target > nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042562,
                "title": "java-binary-search-calls-basic-binary-search-with-picture-expanation",
                "content": "### Find mid index, three senarios:\\n### senario 1 : nums[mid] == target\\n### senario 2 (left picture) : nums[mid] > nums[left]\\nif (target >= nums[left] && target < nums[mid]):  calls Binary search\\nelse left = mid + 1;\\n### senario 3 (right picture) : nums[mid] <= nums[left]\\nif (target > nums[mid] && target <= nums[right]):  calls Binary search\\nelse right = mid - 1;\\n![image](https://assets.leetcode.com/users/images/afbdafb4-3d42-41f9-ba5f-af2a08583d96_1612041019.4078958.png)\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < nums[left]) {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    return biSearch(nums, target, mid + 1, right);\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    return biSearch(nums, target, left, mid - 1);\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private int biSearch(int[] nums, int target, int left, int right) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < nums[left]) {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    return biSearch(nums, target, mid + 1, right);\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    return biSearch(nums, target, left, mid - 1);\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private int biSearch(int[] nums, int target, int left, int right) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408046,
                "title": "javascript-1pass-approach-w-explanation",
                "content": "#### The idea\\nIn order to fullfill the condition of a running time of `O(logn)`, we must use the binary search algorithm. However, Binary search algorithm only works if all the element in the array is sorted, when we have a `pivot` or `rotate` point in our array, we will find that the array is splited in to two parts, 1 to the left of the `rotate` point where everything is sorterd, and 1 to the right(included the `rotate` point) where everything is sorted. In order to apply binary search to find our `target`, we need to figure our which part of the sorted array does the `target` belong to, and from there everything is just standard binary search. \\n\\n*How can we find which part is it in?*\\nwe can make sure a part of the array is all sorted, if the beginning number is smaller than the end number, other wise, there must be a `rotate` point in between\\n\\n``` javascript\\nvar search1pass = function(nums, target) {\\n    if (nums.length == 0) {\\n        return -1;\\n    }\\n    if (nums.length == 1) {\\n        return nums[0] == target?0:-1;\\n    }\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        mid = parseInt((low + (high - low)/2))\\n        if (target == nums[mid]) {\\n            return mid\\n        } else if (nums[low] <= nums[mid]) { // this means everything in between `low` & `mid` is in correct order\\n            // if target is bigger than nums[low] (the smallest # in this partial array) and smaller than nums[mid](the biggest # in this partial array)\\n            if (target >= nums[low] && target < nums[mid]) { \\n                high = mid - 1; // shift the right boundary to left of mid\\n            } else {\\n                // otherwise, our target is in the other end, shift the left boundary to right of mid\\n                low = mid + 1;\\n            }\\n        } else { // there must be a rotate point in between `low` and `mid`, and in between `mid` and `high`, the numbers should be in correct order\\n            // if the target is in between `mid` and `high`\\n            if (target <= nums[high] && target > nums[mid]) {\\n                low = mid + 1; // shift the left boundary to the right of mid\\n            } else {\\n                high = mid - 1 // shift the right boudary to the left of mid, \\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n**I think this version is better since it\\'s more consistent and easier to understand**\\n```\\nvar search = function(nums, target) {\\n    let left=0, right=nums.length-1;\\n    while(left < right) {\\n        let mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < nums[right]) {\\n            if (target > nums[mid] && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        } else {\\n            if (target > nums[mid] || target < nums[left]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n    }\\n    return nums[left]==target?left:-1;\\n};\\n```\\nIf you wan to read more on how to write consisntent binary search code, check out my tutorial [here](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "``` javascript\\nvar search1pass = function(nums, target) {\\n    if (nums.length == 0) {\\n        return -1;\\n    }\\n    if (nums.length == 1) {\\n        return nums[0] == target?0:-1;\\n    }\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        mid = parseInt((low + (high - low)/2))\\n        if (target == nums[mid]) {\\n            return mid\\n        } else if (nums[low] <= nums[mid]) { // this means everything in between `low` & `mid` is in correct order\\n            // if target is bigger than nums[low] (the smallest # in this partial array) and smaller than nums[mid](the biggest # in this partial array)\\n            if (target >= nums[low] && target < nums[mid]) { \\n                high = mid - 1; // shift the right boundary to left of mid\\n            } else {\\n                // otherwise, our target is in the other end, shift the left boundary to right of mid\\n                low = mid + 1;\\n            }\\n        } else { // there must be a rotate point in between `low` and `mid`, and in between `mid` and `high`, the numbers should be in correct order\\n            // if the target is in between `mid` and `high`\\n            if (target <= nums[high] && target > nums[mid]) {\\n                low = mid + 1; // shift the left boundary to the right of mid\\n            } else {\\n                high = mid - 1 // shift the right boudary to the left of mid, \\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```\\nvar search = function(nums, target) {\\n    let left=0, right=nums.length-1;\\n    while(left < right) {\\n        let mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < nums[right]) {\\n            if (target > nums[mid] && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        } else {\\n            if (target > nums[mid] || target < nums[left]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n    }\\n    return nums[left]==target?left:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880652,
                "title": "simple-c-solution-using-binary-search-o-logn",
                "content": "# Intuition\\nDistinguish problem\\'s scenario between two cases: rotated array (where last element can\\'t be greater than the first, i.e., `first` >= `last`) and sorted array (where `first` < `last`).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize `i` = 0 and `j` = size - 1.\\n2. Iterate while `i` <= `j`.\\n3. If the array is rotated (`first element` >= `last element`), check target against `i` and `j`. Return index if found, otherwise increment `i` and decrement `j`.\\nNote: Reason behind `i++` and `j--` is to gradually narrow down to a potentially sorted subarray (`nums[i]` < `nums[j]`). This transition indicates moving from the rotated part to a sorted section, where the target could be found.\\n4. If the array is sorted (`first element` < `last element`), apply **Binary search**.\\n5. `Return -1` if the target is not found.\\n\\nThis approach handles both rotated and sorted arrays efficiently to find the target index or return -1 if the target is not present.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\nbecause used a modified binary search, which reduces the search space by half in each iteration.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        while(i<=j)\\n        {\\n            //For rotated arrays (Case 1), \\n            if(nums[i]>=nums[j])\\n            {\\n                //check if the target matches at ith or jth\\n                if(target==nums[i])\\n                return i;\\n                else if(target==nums[j])\\n                return j;\\n                //if not, iteratively increment i and decrement j.\\n                else\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                //nums[i]<nums[j], array is sorted between ith and jth index\\n                //apply binary search\\n                int mid = i + (j - i) / 2;\\n                if(nums[mid]<target)\\n                    i=mid+1;\\n                else if(nums[mid]>target)\\n                    j=mid-1;\\n                else\\n                return mid;\\n            }\\n        }\\n        //if Element is not found return -1.\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        while(i<=j)\\n        {\\n            //For rotated arrays (Case 1), \\n            if(nums[i]>=nums[j])\\n            {\\n                //check if the target matches at ith or jth\\n                if(target==nums[i])\\n                return i;\\n                else if(target==nums[j])\\n                return j;\\n                //if not, iteratively increment i and decrement j.\\n                else\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                //nums[i]<nums[j], array is sorted between ith and jth index\\n                //apply binary search\\n                int mid = i + (j - i) / 2;\\n                if(nums[mid]<target)\\n                    i=mid+1;\\n                else if(nums[mid]>target)\\n                    j=mid-1;\\n                else\\n                return mid;\\n            }\\n        }\\n        //if Element is not found return -1.\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058206,
                "title": "easy-c-solution-binary-search-basic-approach",
                "content": "# Intuition\\nNeed to find sorted part and use binary search in it.\\n\\n# Approach\\nFind sorted part of array.Then check if target lies in that sorted part using binary search. If no, then go to unsorted part and search in its sorted subpart. If yes , return ans else return -1;\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int s = 0 , e = n-1;\\n\\n        while(s <= e){\\n            int mid = s +(e-s)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            //if left half is sorted \\n            if(nums[s] <= nums[mid]){\\n                // check if target lies in left side\\n                if(target <= nums[mid] && target >= nums[s]) e = mid-1;\\n                else s = mid + 1;\\n            }    \\n            //if right side is sorted \\n            else{\\n                // check if target lies in right side\\n                if(target >= nums[mid] && target <= nums[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int s = 0 , e = n-1;\\n\\n        while(s <= e){\\n            int mid = s +(e-s)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            //if left half is sorted \\n            if(nums[s] <= nums[mid]){\\n                // check if target lies in left side\\n                if(target <= nums[mid] && target >= nums[s]) e = mid-1;\\n                else s = mid + 1;\\n            }    \\n            //if right side is sorted \\n            else{\\n                // check if target lies in right side\\n                if(target >= nums[mid] && target <= nums[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859654,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            if (nums[mid] >= nums[l]) {\\n                if(target >= nums[l] && target < nums[mid]) r = mid - 1;\\n                else l = mid + 1;\\n            }\\n            else {\\n                if(target > nums[mid] && target <= nums[r]) l = mid + 1;\\n                else r = mid - 1;   \\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            if (nums[mid] >= nums[l]) {\\n                if(target >= nums[l] && target < nums[mid]) r = mid - 1;\\n                else l = mid + 1;\\n            }\\n            else {\\n                if(target > nums[mid] && target <= nums[r]) l = mid + 1;\\n                else r = mid - 1;   \\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883147,
                "title": "python-easiest-solution-95-04-faster-binary-search-beg-to-adv",
                "content": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums) - 1 \\n        \\n        while left <= right:\\n            \\n            mid = (right + left ) // 2\\n            \\n            if nums[mid] == target:\\n                return mid \\n            # LEFT SORTED PORTION\\n            elif nums[left]<=nums[mid]:\\n                if target > nums[mid] or target < nums[left]:\\n                     left = mid + 1\\n                else:\\n                    right = mid -1\\n            # RIGHT SORTED PORTION\\n            else:\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid -1 \\n                else:\\n                     left = mid+1\\n                    \\n        \\n        return -1\\n            \\n```\\n\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums) - 1 \\n        \\n        while left <= right:\\n            \\n            mid = (right + left ) // 2\\n            \\n            if nums[mid] == target:\\n                return mid \\n            # LEFT SORTED PORTION\\n            elif nums[left]<=nums[mid]:\\n                if target > nums[mid] or target < nums[left]:\\n                     left = mid + 1\\n                else:\\n                    right = mid -1\\n            # RIGHT SORTED PORTION\\n            else:\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid -1 \\n                else:\\n                     left = mid+1\\n                    \\n        \\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399442,
                "title": "c-binary-search-simple-solution",
                "content": "Please upvote if it was helpful.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint first = 0, last = nums.size() - 1;\\n\\t\\t\\t\\n\\t\\t\\twhile(first <= last){\\n\\t\\t\\t\\tint mid = first + (last - first) / 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(target == nums[mid]) return mid;\\n\\t\\t\\t\\tif(nums[first] <= nums[mid]){\\n\\t\\t\\t\\t\\tif(target >= nums[first] && target <= nums[mid])\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif(target <= nums[last] && target >= nums[mid])\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\nThank You !!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint first = 0, last = nums.size() - 1;\\n\\t\\t\\t\\n\\t\\t\\twhile(first <= last){\\n\\t\\t\\t\\tint mid = first + (last - first) / 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(target == nums[mid]) return mid;\\n\\t\\t\\t\\tif(nums[first] <= nums[mid]){\\n\\t\\t\\t\\t\\tif(target >= nums[first] && target <= nums[mid])\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1322975,
                "title": "java-binary-search-solution-important-to-interview",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int low = 0,high = nums.length-1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target <= nums[mid])\\n                    high = mid-1;\\n                else    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int low = 0,high = nums.length-1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target <= nums[mid])\\n                    high = mid-1;\\n                else    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684828,
                "title": "python-binary-search-explained-the-logic",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        #   1. have to find rotation point\\n        #   2. make mid = pivot element, start and end\\n        #   3. IMP : If Pivot element is larger than the first element in the array, i.e. the part of array from the first element to the pivot one is non-rotated.\\n        #   4. If the target is in that non-rotated part as well: go left: otherwise go right.\\n        #   5. Pivot element is smaller than the first element of the array, i.e. the rotation index is somewhere between 0 and mid. That means that the part of array from the pivot element to the last one is non-rotated.\\n        #   6. If target is in that non-rotated part as well: go right: else left.\\n        \\n        start, end = 0, len(nums)-1\\n        \\n        while(start <= end):\\n            mid = start + (end - start) // 2                        # watch out\\n            \\n            if(target == nums[mid]): return mid\\n            \\n            if(nums[mid] >= nums[start]):                           # indicates non-rotated array\\n                \\n                if(target < nums[mid] and target >= nums[start]):   # check for target in non-rotated part\\n                    end = mid -1\\n                else:\\n                    start = mid + 1\\n            else:                                                   # indicates otated array\\n                if(target <= nums[end] and target > nums[mid]):     # check for target in non-rotated part\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        #   1. have to find rotation point\\n        #   2. make mid = pivot element, start and end\\n        #   3. IMP : If Pivot element is larger than the first element in the array, i.e. the part of array from the first element to the pivot one is non-rotated.\\n        #   4. If the target is in that non-rotated part as well: go left: otherwise go right.\\n        #   5. Pivot element is smaller than the first element of the array, i.e. the rotation index is somewhere between 0 and mid. That means that the part of array from the pivot element to the last one is non-rotated.\\n        #   6. If target is in that non-rotated part as well: go right: else left.\\n        \\n        start, end = 0, len(nums)-1\\n        \\n        while(start <= end):\\n            mid = start + (end - start) // 2                        # watch out\\n            \\n            if(target == nums[mid]): return mid\\n            \\n            if(nums[mid] >= nums[start]):                           # indicates non-rotated array\\n                \\n                if(target < nums[mid] and target >= nums[start]):   # check for target in non-rotated part\\n                    end = mid -1\\n                else:\\n                    start = mid + 1\\n            else:                                                   # indicates otated array\\n                if(target <= nums[end] and target > nums[mid]):     # check for target in non-rotated part\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557476,
                "title": "python3-modified-bs-explained-and-faster-than-64-77",
                "content": "*Runtime: 40 ms, faster than 64.77% of Python3 online submissions for Search in Rotated Sorted Array.\\nMemory Usage: 13.3 MB, less than 43.36% of Python3 online submissions for Search in Rotated Sorted Array.*\\n\\n```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums: return -1\\n        # almost standard bs\\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            m = (l+r)//2\\n            if target == nums[m]: return m\\n            # is the left sorted?\\n            if nums[l] < nums[m]:\\n                if nums[l] <= target <= nums[m]: r = m\\n                else: l = m+1\\n            # then right is sorted...\\n            else: \\n                if nums[m+1] <= target <= nums[r]: l = m+1\\n                else: r = m\\n        return l if nums[l] == target else -1\\n```\\n\\nIs almost the standard **BS**, we just need to stop before applying the BS on an interval and ask if it is sorted (`nums[l] < nums[r]`), and if our target can actually be inside that sorted interval (`nums[l] <= target <= nums[r]`) if both are true we do the usual binary search here, and if not we do it in the other half.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums: return -1\\n        # almost standard bs\\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            m = (l+r)//2\\n            if target == nums[m]: return m\\n            # is the left sorted?\\n            if nums[l] < nums[m]:\\n                if nums[l] <= target <= nums[m]: r = m\\n                else: l = m+1\\n            # then right is sorted...\\n            else: \\n                if nums[m+1] <= target <= nums[r]: l = m+1\\n                else: r = m\\n        return l if nums[l] == target else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164948,
                "title": "javascript-o-logn-100-explained-cracking-the-code-interview-binary-search",
                "content": "All but the right condition is exactly the same as in the Cracking The Code Interview Binary Search sample code.\\n\\nHow to know when the value is located on the right side:\\n\\n`<low> <mid> <high>`\\nDescending condition: `4 7 2`, target 0 (i.e. `[4,5,6,7,0,1,2]`)\\n- We are looking for values that are over 7 and less/eq than 2.\\n- `const descendingCondition = target >= nums[mid] || target <= nums[high];`\\n\\nAscending condition: `0 1 2`, target = 2 (i.e. `[0 1 2 3 4 5 6]`)\\n- We are looking for values that are within 1 and 2 (2 included).\\n- `const ascendingCondition = target >= nums[mid] && target <= nums[high];`\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        // <low> <mid> <high>\\n        // Descending condition: 4 7 2, target 0\\n        // - We are looking for values that are over 7 and less/eq than 2.\\n        // Ascending condition: 0 1 2, target = 2\\n        // - We are looking for values that are within 1 and 2 (2 included).\\n        const descendingCondition = target >= nums[mid] || target <= nums[high];\\n        const ascendingCondition = target >= nums[mid] && target <= nums[high];\\n        const isRight = nums[high] - nums[mid] >= 0 ? ascendingCondition : descendingCondition;\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (isRight) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        // <low> <mid> <high>\\n        // Descending condition: 4 7 2, target 0\\n        // - We are looking for values that are over 7 and less/eq than 2.\\n        // Ascending condition: 0 1 2, target = 2\\n        // - We are looking for values that are within 1 and 2 (2 included).\\n        const descendingCondition = target >= nums[mid] || target <= nums[high];\\n        const ascendingCondition = target >= nums[mid] && target <= nums[high];\\n        const isRight = nums[high] - nums[mid] >= 0 ? ascendingCondition : descendingCondition;\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (isRight) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880197,
                "title": "c-very-easy-and-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to utilize the binary search approach, but with a twist to handle the rotation. We divide the array into two parts: one that is sorted and the other that isn\\'t. By comparing the target with the elements at the middle and adjusting the pointers based on whether the left or right side is sorted, we can efficiently narrow down the search range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two pointers, left and right, to the start and end indices of the array.\\n- Enter a binary search loop while left is less than or equal to right.\\n- Calculate the middle index, mid, using the formula (left + right) / 2.\\n- Check if the element at mid is the target. If so, return mid.\\n- Determine which side of the array is sorted: the left side (from left to mid) or the right side (from mid to right).\\n- Depending on which side is sorted, check if the target falls within the range of that side. If it does, adjust the pointers to narrow down the search range accordingly.\\n- If the target is not found in the current search range, update the pointers and repeat the process.\\n- If the loop ends and the target is not found, return -1.\\n\\n# Complexity\\n- Time complexity: **O(log n)** - The algorithm halves the search range in each step, resulting in a logarithmic number of steps.\\n\\n\\n- Space complexity: **O(1)** - The algorithm uses a constant amount of extra space for variables regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid; // Found the target\\n            }\\n            \\n            // Check which side is sorted\\n            if (nums[left] <= nums[mid]) {\\n                // Left side is sorted\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    // Target is in the left sorted side\\n                    right = mid - 1;\\n                } else {\\n                    // Target is in the right unsorted side\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // Right side is sorted\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    // Target is in the right sorted side\\n                    left = mid + 1;\\n                } else {\\n                    // Target is in the left unsorted side\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1; // Target not found\\n    }\\n};\\n\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/b55c25eb-7c93-4665-82c4-29df36f019d8_1691474602.022517.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid; // Found the target\\n            }\\n            \\n            // Check which side is sorted\\n            if (nums[left] <= nums[mid]) {\\n                // Left side is sorted\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    // Target is in the left sorted side\\n                    right = mid - 1;\\n                } else {\\n                    // Target is in the right unsorted side\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // Right side is sorted\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    // Target is in the right sorted side\\n                    left = mid + 1;\\n                } else {\\n                    // Target is in the left unsorted side\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1; // Target not found\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879481,
                "title": "beats-100-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rGJPl03mAPc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int search(int[] A, int B) {\\n        int l = 0;\\n        int r = A.length-1;\\n        int m;\\n        while(l<=r){\\n            m = (l+r)/2;\\n            if(A[m] == B) return m;\\n            if(A[m]>=A[0]){\\n                if(B>=A[0] && B<=A[m]) r = m-1;\\n                else l = m+1;\\n            }else{\\n                if(B>=A[m] && B<=A[A.length-1]) l = m+1;\\n                else r = m-1;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& A, int B) {\\n        int l = 0;\\n        int r = A.size() - 1;\\n        int m;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            if (A[m] == B) return m;\\n            if (A[m] >= A[0]) {\\n                if (B >= A[0] && B <= A[m]) r = m - 1;\\n                else l = m + 1;\\n            } else {\\n                if (B >= A[m] && B <= A[A.size() - 1]) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def search(self, A: List[int], B: int) -> int:\\n        l = 0\\n        r = len(A) - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if A[m] == B:\\n                return m\\n            if A[m] >= A[0]:\\n                if B >= A[0] and B <= A[m]:\\n                    r = m - 1\\n                else:\\n                    l = m + 1\\n            else:\\n                if B >= A[m] and B <= A[-1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] A, int B) {\\n        int l = 0;\\n        int r = A.length-1;\\n        int m;\\n        while(l<=r){\\n            m = (l+r)/2;\\n            if(A[m] == B) return m;\\n            if(A[m]>=A[0]){\\n                if(B>=A[0] && B<=A[m]) r = m-1;\\n                else l = m+1;\\n            }else{\\n                if(B>=A[m] && B<=A[A.length-1]) l = m+1;\\n                else r = m-1;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& A, int B) {\\n        int l = 0;\\n        int r = A.size() - 1;\\n        int m;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            if (A[m] == B) return m;\\n            if (A[m] >= A[0]) {\\n                if (B >= A[0] && B <= A[m]) r = m - 1;\\n                else l = m + 1;\\n            } else {\\n                if (B >= A[m] && B <= A[A.size() - 1]) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def search(self, A: List[int], B: int) -> int:\\n        l = 0\\n        r = len(A) - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if A[m] == B:\\n                return m\\n            if A[m] >= A[0]:\\n                if B >= A[0] and B <= A[m]:\\n                    r = m - 1\\n                else:\\n                    l = m + 1\\n            else:\\n                if B >= A[m] and B <= A[-1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879257,
                "title": "c-python-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is solved by using binary search several times.\\nFirstly, it is suggested to find the location for the peak which can be done by binary search.\\nSecondly, using binary search to find location for the target which is possible before the peak or after the peak.\\n\\nBe careful for the boundary cases when n=1 and n=2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the location for the peak, it needs to build a binary searching function for this special purpose. Once the location of the peak is sure, then use the built-in  C++ lower_bound to find the target.\\n\\nThe python solution uses bisect_left.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(\\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> x;\\n    int findK() {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l=0, r=n, m;\\n        while(l<r){\\n            m=(r+l)/2;\\n            if (m==n-1 || x[m]>x[m+1]) return m;\\n            if (x[m]>x[l]) l=m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        x=nums;\\n        n=nums.size();\\n        int k=findK();\\n    //    cout<<\"k=\"<<k<<endl;\\n        auto it=x.begin();\\n        if (target>=x[0] || k==n-1){\\n            int i=lower_bound(it,it+k+1,target)-it;\\n            if (i == k+1 || x[i] != target) return -1;\\n            return i;\\n        }     \\n        else{\\n            int i=lower_bound(it+k+1,it+n,target)-it;\\n            if (i == n || x[i] != target) return -1;\\n            return i;\\n        }\\n    }\\n};\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def search(self, x: List[int], target: int) -> int:\\n        n = len(x)\\n        \\n        def findK():\\n            if n == 1:\\n                return 0\\n            if n==2:\\n                if x[0]<x[1]: return 1\\n                else: return 0\\n            l=0\\n            r=n\\n            while l < r:\\n                m = (r + l) // 2\\n                if m==n-1 or x[m]>x[m+1]: return m\\n                if x[m]>x[l]: l=m\\n                else: r=m\\n            return m\\n        \\n        k=findK()\\n        \\n        if target >= x[0]:\\n            i = bisect_left(x, target, hi=k)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n        else:\\n            i = bisect_left(x, target, lo=k+1)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n```\\n# findK() uses bisect_right()\\n```\\ndef findK():\\n  if n == 1:\\n    return 0\\n  return bisect_right(x, False, key=lambda y: y < x[0])\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> x;\\n    int findK() {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l=0, r=n, m;\\n        while(l<r){\\n            m=(r+l)/2;\\n            if (m==n-1 || x[m]>x[m+1]) return m;\\n            if (x[m]>x[l]) l=m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        x=nums;\\n        n=nums.size();\\n        int k=findK();\\n    //    cout<<\"k=\"<<k<<endl;\\n        auto it=x.begin();\\n        if (target>=x[0] || k==n-1){\\n            int i=lower_bound(it,it+k+1,target)-it;\\n            if (i == k+1 || x[i] != target) return -1;\\n            return i;\\n        }     \\n        else{\\n            int i=lower_bound(it+k+1,it+n,target)-it;\\n            if (i == n || x[i] != target) return -1;\\n            return i;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def search(self, x: List[int], target: int) -> int:\\n        n = len(x)\\n        \\n        def findK():\\n            if n == 1:\\n                return 0\\n            if n==2:\\n                if x[0]<x[1]: return 1\\n                else: return 0\\n            l=0\\n            r=n\\n            while l < r:\\n                m = (r + l) // 2\\n                if m==n-1 or x[m]>x[m+1]: return m\\n                if x[m]>x[l]: l=m\\n                else: r=m\\n            return m\\n        \\n        k=findK()\\n        \\n        if target >= x[0]:\\n            i = bisect_left(x, target, hi=k)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n        else:\\n            i = bisect_left(x, target, lo=k+1)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n```\n```\\ndef findK():\\n  if n == 1:\\n    return 0\\n  return bisect_right(x, False, key=lambda y: y < x[0])\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2999171,
                "title": "c-intuitive-o-logn-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can easily see intitutively, if we are somehow able to find the peak or the index from where the rotation is happening, then we can easily apply Binary Search in the given rotated array.\\nBut how to find the peak in `O(logn)` time? else the complexity of problem may not be `O(logn)`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **To Find Peak Element in rotated array**\\n\\t\\tWe can return the mid, if we found the peak in the mid i.e `nums[mid-1]<nums[mid]>nums[mid+1]` else       we\\'ll check if the peak can be found in right subarray or left subarray.\\n\\t\\tIf the left subarray is unsorted that means peak is in the left subarray i.e if `nums[low]>nums[mid]`\\n\\t\\telse the peak is in the right subarray.\\n2. **To find the target after peak (k)**\\n\\t  Once the peak is found i.e `k` then we can easily search for elements with updated mid index as \\n\\t\\t`(mid+k+1)%n` , where k is the peak or point from where array is rotated.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$, where `peak` function also takes $$O(logn)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peak(vector<int>& nums){\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if((mid==0||nums[mid]>nums[mid-1])&&(mid==n-1||nums[mid]>nums[mid+1]))\\n            return mid;\\n            else\\n            if(nums[low]>nums[mid])\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        int k = peak(nums);\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            int z=(mid+k+1)%n;\\n            if(nums[z]==target)\\n            return z;\\n            else\\n            if(nums[z]>target)\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peak(vector<int>& nums){\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if((mid==0||nums[mid]>nums[mid-1])&&(mid==n-1||nums[mid]>nums[mid+1]))\\n            return mid;\\n            else\\n            if(nums[low]>nums[mid])\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        int k = peak(nums);\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            int z=(mid+k+1)%n;\\n            if(nums[z]==target)\\n            return z;\\n            else\\n            if(nums[z]>target)\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759124,
                "title": "most-efficient-solution-binary-search-modified-for-rotated-sorted-list",
                "content": "Order - O(log n)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return searchlist(nums,target)\\n      \\ndef searchlist(nums,target):\\n  low,high = 0,len(nums)-1\\n  while low<=high:\\n    mid = (low+high)//2\\n    if nums[mid]==target:\\n      return mid\\n    #check if mid in left sorted arr\\n    if nums[mid]>=nums[low]:\\n      if target>=nums[low] and target<nums[mid]:\\n        high = mid - 1\\n      else:\\n        low = mid + 1\\n        \\n    #check if mid in right sorted arr    \\n    else:\\n      if target<=nums[high] and target>nums[mid]:\\n        low = mid+1\\n      else:\\n        high = mid-1\\n        \\n  return -1 \\n  ```\\n  \\n  Hope this helps!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return searchlist(nums,target)\\n      \\ndef searchlist(nums,target):\\n  low,high = 0,len(nums)-1\\n  while low<=high:\\n    mid = (low+high)//2\\n    if nums[mid]==target:\\n      return mid\\n    #check if mid in left sorted arr\\n    if nums[mid]>=nums[low]:\\n      if target>=nums[low] and target<nums[mid]:\\n        high = mid - 1\\n      else:\\n        low = mid + 1\\n        \\n    #check if mid in right sorted arr    \\n    else:\\n      if target<=nums[high] and target>nums[mid]:\\n        low = mid+1\\n      else:\\n        high = mid-1\\n        \\n  return -1 \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2625839,
                "title": "python-o-log-n-solution-super-easy",
                "content": "\\t\\tstart, end = 0, len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end-start) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid] >= nums[start]:\\n                if target <= nums[mid] and target >=nums[start]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if target >= nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "\\t\\tstart, end = 0, len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end-start) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid] >= nums[start]:\\n                if target <= nums[mid] and target >=nums[start]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if target >= nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1",
                "codeTag": "Unknown"
            },
            {
                "id": 2450337,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=e-84rG-c8AE",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=e-84rG-c8AE",
                "codeTag": "Unknown"
            },
            {
                "id": 2228217,
                "title": "c-100-faster-o-log-n-binary-search-modification",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(r>=l)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[l]<=nums[mid])\\n            {\\n                if(target>=nums[l] && target<=nums[mid])\\n                    r=mid-1;\\n                else\\n                   l=mid+1;          \\n            }\\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[r])\\n                    l=mid+1; \\n                else\\n                    r=mid-1;\\n            }     \\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nTime Complexity: O(log n)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(r>=l)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[l]<=nums[mid])\\n            {\\n                if(target>=nums[l] && target<=nums[mid])\\n                    r=mid-1;\\n                else\\n                   l=mid+1;          \\n            }\\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[r])\\n                    l=mid+1; \\n                else\\n                    r=mid-1;\\n            }     \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194609,
                "title": "python-soln-beats-93-in-time",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        while(start<=end):\\n            mid=int((start + end)/2)\\n            if nums[mid]==target: return mid\\n            elif nums[start]<=nums[mid]:\\n                if target>=nums[start] and target<nums[mid]: end=mid-1\\n                else: start=mid+1\\n            else:\\n                if target<=nums[end] and target>nums[mid]: start=mid+1\\n                else: end=mid-1\\n        return -1\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        while(start<=end):\\n            mid=int((start + end)/2)\\n            if nums[mid]==target: return mid\\n            elif nums[start]<=nums[mid]:\\n                if target>=nums[start] and target<nums[mid]: end=mid-1\\n                else: start=mid+1\\n            else:\\n                if target<=nums[end] and target>nums[mid]: start=mid+1\\n                else: end=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924327,
                "title": "python-most-efficient-binary-search-simple-comments-o-log-n",
                "content": "```\\n\\'\\'\\'\\nApproach: Binary Search\\n\\nPoint to note: In a rotated sorted array, when doing binary search, one side will always be sorted and other side will always be incorrectly sorted if \\npivot index k (1 <= k < nums.length)\\n\\n\\n1. find mid. \\n2. if left side is sorted\\n    - if target is within left limits, binary search on left\\n    - else binary search on right\\n3 else (if left side is not sorted, right side is sorted)\\n    - if target is within right limits, binary search on right\\n    - else binary search on left\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left,right = 0,len(nums)-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[left]>nums[mid]:\\n                if nums[mid]<target<=nums[right]:\\n                    left = mid+1\\n                else:\\n                    right = mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n                    \\n        return -1\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n\\'\\'\\'\\nApproach: Binary Search\\n\\nPoint to note: In a rotated sorted array, when doing binary search, one side will always be sorted and other side will always be incorrectly sorted if \\npivot index k (1 <= k < nums.length)\\n\\n\\n1. find mid. \\n2. if left side is sorted\\n    - if target is within left limits, binary search on left\\n    - else binary search on right\\n3 else (if left side is not sorted, right side is sorted)\\n    - if target is within right limits, binary search on right\\n    - else binary search on left\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left,right = 0,len(nums)-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[left]>nums[mid]:\\n                if nums[mid]<target<=nums[right]:\\n                    left = mid+1\\n                else:\\n                    right = mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n                    \\n        return -1\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698723,
                "title": "python3-runtime-28-ms-faster-than-99-69-memory-14-mb-less-than-99-97",
                "content": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        if not nums:\\n        \\treturn -1\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n        \\tmid = int((left + right) / 2)\\n        \\tif nums[mid] == target:\\n        \\t\\treturn mid\\n        \\tif nums[left] <= nums[mid]:\\n        \\t\\tif target >= nums[left] and target <= nums[mid]:\\n        \\t\\t\\tright = mid - 1\\n        \\t\\telse:\\n        \\t\\t\\tleft = mid + 1\\n        \\telse:\\n        \\t\\tif target >= nums[mid] and target <= nums[right]:\\n        \\t\\t\\tleft = mid + 1\\n        \\t\\telse:\\n        \\t\\t\\tright = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        if not nums:\\n        \\treturn -1\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n        \\tmid = int((left + right) / 2)\\n        \\tif nums[mid] == target:\\n        \\t\\treturn mid\\n        \\tif nums[left] <= nums[mid]:\\n        \\t\\tif target >= nums[left] and target <= nums[mid]:\\n        \\t\\t\\tright = mid - 1\\n        \\t\\telse:\\n        \\t\\t\\tleft = mid + 1\\n        \\telse:\\n        \\t\\tif target >= nums[mid] and target <= nums[right]:\\n        \\t\\t\\tleft = mid + 1\\n        \\t\\telse:\\n        \\t\\t\\tright = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427928,
                "title": "explained-solution-with-diagrams-language-friendly",
                "content": "The rotated array can be thought as a composition of two arrays as the picture below shows. We first selected the middle element  and we have to figure in which part of the array we are in. If the nums[mid]>=nums[start], then we are in the red part. If not, we are in the blue part. \\n\\n![image](https://assets.leetcode.com/users/images/999f2060-2765-4281-88a5-9fe39777e929_1630004936.2318954.png)\\n\\nIf we are in the red zone we know that the elements in the range [start, mid] are bounded below by nums[start] and are bounded above by nums[mid]. If target is in this range, then it must be located between start and mid so we update the end pointer to point to mid-1. If it is not within this range, then we can disregard every element in the range [start, mid] and we can update the start pointer to point to mid+1. A similar argument works if we happen to be in the blue zone. \\n\\nA python implementation is shown below:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        \\n        while start <= end:\\n            ind = start + (end-start)//2\\n            if nums[ind] == target:\\n                return ind\\n            \\n            if nums[ind] >= nums[start]:\\n                if nums[start] <= target < nums[ind]:\\n                    end = ind - 1\\n                else:\\n                    start = ind + 1\\n            \\n            else:\\n                if nums[ind] < target <= nums[end]:\\n                    start = ind + 1\\n                else:\\n                    end = ind - 1\\n            \\n            \\n        return -1\\n```\\n\\nPlease consider liking if you found this post helpful :)",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        \\n        while start <= end:\\n            ind = start + (end-start)//2\\n            if nums[ind] == target:\\n                return ind\\n            \\n            if nums[ind] >= nums[start]:\\n                if nums[start] <= target < nums[ind]:\\n                    end = ind - 1\\n                else:\\n                    start = ind + 1\\n            \\n            else:\\n                if nums[ind] < target <= nums[end]:\\n                    start = ind + 1\\n                else:\\n                    end = ind - 1\\n            \\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213154,
                "title": "c-binary-search-approach-o-log-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int l=0,h=a.size()-1,m;\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(a[m]==target) return m;\\n            else if(a[m]>=a[l]){\\n                if(target>=a[l] && target<=a[m]) h=m-1;\\n                else l=m+1;\\n            }\\n            else{\\n                if(target>=a[m] && target<=a[h]) l=m+1;\\n                else h=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int l=0,h=a.size()-1,m;\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(a[m]==target) return m;\\n            else if(a[m]>=a[l]){\\n                if(target>=a[l] && target<=a[m]) h=m-1;\\n                else l=m+1;\\n            }\\n            else{\\n                if(target>=a[m] && target<=a[h]) l=m+1;\\n                else h=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926473,
                "title": "go-binary-search",
                "content": "<b>By Tag</b>\\n#BinarySearch - [github](https://github.com/idiotleon/lc-problem-by-tag-leon/tree/main/txt/by_algorithm/search/binary_search)\\n\\n```\\nfunc search(nums []int, target int) int {    \\n    var lo, hi int = 0, len(nums) - 1\\n    \\n    for lo <= hi {\\n        var mid = lo + (hi - lo) / 2\\n        \\n        if nums[mid] == target {\\n            return mid\\n        }\\n        \\n        if nums[lo] <= nums[mid]{\\n            if target >= nums[lo] && target <= nums[mid] {\\n                hi = mid - 1\\n            } else {\\n                lo = mid + 1\\n            }\\n        }else if nums[mid] < nums[hi]{\\n            if target > nums[mid] && target <= nums[hi] {\\n                lo = mid + 1\\n            }else {\\n                hi = mid - 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {    \\n    var lo, hi int = 0, len(nums) - 1\\n    \\n    for lo <= hi {\\n        var mid = lo + (hi - lo) / 2\\n        \\n        if nums[mid] == target {\\n            return mid\\n        }\\n        \\n        if nums[lo] <= nums[mid]{\\n            if target >= nums[lo] && target <= nums[mid] {\\n                hi = mid - 1\\n            } else {\\n                lo = mid + 1\\n            }\\n        }else if nums[mid] < nums[hi]{\\n            if target > nums[mid] && target <= nums[hi] {\\n                lo = mid + 1\\n            }else {\\n                hi = mid - 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689417,
                "title": "easy-python-binary-search-solution-with-additional-conditions",
                "content": "\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while(start<=end):\\n            mid = (start+end)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(target < nums[mid]):\\n                if(target < nums[start] and nums[start] <= nums[mid]):\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            elif(target > nums[mid]):\\n                if(target > nums[end] and nums[end] > nums[mid]):\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while(start<=end):\\n            mid = (start+end)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(target < nums[mid]):\\n                if(target < nums[start] and nums[start] <= nums[mid]):\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            elif(target > nums[mid]):\\n                if(target > nums[end] and nums[end] > nums[mid]):\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 374841,
                "title": "beat-100-100-java-binary-search",
                "content": "\\n    public int search(int[] nums, int target) {     \\n        int left = 0, right = nums.length-1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (target == nums[mid]) return mid;\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int search(int[] nums, int target) {     \\n        int left = 0, right = nums.length-1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (target == nums[mid]) return mid;\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 14625,
                "title": "recursive-solution-for-java",
                "content": "```\\npublic int search(int[] nums, int target) {\\n\\treturn binarySearch(0, nums.length - 1, nums, target);\\n}\\n\\npublic int binarySearch(int low, int high, int[] nums, int target){\\n\\tint mid = (low + high)/2;\\n\\tif(nums[mid] == target)\\n\\t\\treturn mid;\\n\\tif(low > high)\\n\\t\\treturn -1;\\n\\n\\tif(nums[mid] >= nums[low]){//array between nums[low] and nums[mid] are sorted\\n\\t\\tif( nums[low] <= target && target < nums[mid])//target is between nums[low] and nums[mid]\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t} else{//unsorted part of array\\n\\t\\tif(nums[mid] < target && target <= nums[high])\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int search(int[] nums, int target) {\\n\\treturn binarySearch(0, nums.length - 1, nums, target);\\n}\\n\\npublic int binarySearch(int low, int high, int[] nums, int target){\\n\\tint mid = (low + high)/2;\\n\\tif(nums[mid] == target)\\n\\t\\treturn mid;\\n\\tif(low > high)\\n\\t\\treturn -1;\\n\\n\\tif(nums[mid] >= nums[low]){//array between nums[low] and nums[mid] are sorted\\n\\t\\tif( nums[low] <= target && target < nums[mid])//target is between nums[low] and nums[mid]\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t} else{//unsorted part of array\\n\\t\\tif(nums[mid] < target && target <= nums[high])\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14649,
                "title": "c-binary-search-8ms-always-check-the-half-portion-that-is-in-order",
                "content": " The idea is to do binary search. Since due to the shift, the two halfs may not be both in order but at least one of them is in order, so always check the in-order half and see if the target is in the range of that half.\\nOne mistake I made is I used \\n\\n                        if(nums[left]<nums[mid])\\n  instead of\\n \\n\\n               if(nums[left]<=nums[mid])\\n\\nThat causes an error in the case [3,1] since when the length is 2, mid is equal to left\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int res, left =0, right= nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid= (left+right)/2;\\n                if(nums[mid] == target) return mid;\\n                if(nums[left]<=nums[mid])\\n                {// if the first half is in-order, <= since mid may be equal to left when there are only two elements\\n                    if(target>=nums[left] && target < nums[mid] ) right = mid -1;  // if target is in the range of the first half\\n                    else left = mid + 1;\\n                }\\n                else\\n                {// if the second half is in order\\n                    if(target > nums[mid] && target <= nums[right] ) left = mid + 1; // target is in the range of the second half\\n                    else right = mid - 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    };\\n\\n\\nI revised the above version to make it more neat\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int left=0, right=nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid = (left+right)/2;\\n                if(target==nums[mid]) return mid;\\n                if( (nums[left]<= target && target < nums[mid]) || (nums[mid]< nums[right] && (nums[mid]>target || nums[right]<target)) )  right = mid-1; // if it the first half is in order and target is in that range or the second half is in order and target is not in the second half\\n                else left = mid+1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int res, left =0, right= nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid= (left+right)/2;\\n                if(nums[mid] == target) return mid;\\n                if(nums[left]<=nums[mid])\\n                {// if the first half is in-order, <= since mid may be equal to left when there are only two elements\\n                    if(target>=nums[left] && target < nums[mid] ) right = mid -1;  // if target is in the range of the first half\\n                    else left = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14670,
                "title": "solution-o-logn-binary-search-solution-with-explanation-java",
                "content": "    public class Solution {\\n        public int searchHelper(int[] A, int target, int start, int end){\\n            if(start>end){\\n                return -1;\\n            }\\n            int mid = (start+end)/2;\\n            if(A[mid] == target){\\n                return mid;\\n            }\\n            \\n            //Case 1: Left half is sorted\\n            if(A[mid] >= A[start]){\\n                if(target >= A[start] && target <= A[mid]){\\n                    return searchHelper(A,target,start,mid-1);    \\n                }\\n                else{\\n                    return searchHelper(A,target,mid+1,end);\\n                }\\n            }\\n            //Case 2: Right half is sorted\\n            if(A[end]>=A[mid]){\\n                if(target>=A[mid] && target<=A[end]){\\n                    return searchHelper(A,target,mid+1,end);\\n                }\\n                else{\\n                    return searchHelper(A,target,start,mid-1);\\n                }\\n            }\\n            return -1;\\n        }\\n        \\n        public int search(int[] A, int target) {\\n            return searchHelper(A,target,0,A.length-1);\\n        }\\n    }\\n\\nGiven the assumption of unique elements, there are 2 possibilities:\\n1. Left half is sorted i.e. pivot is in right half\\n2. Right half is sorted i.e. pivot is in left half\\n\\nIf target value is within the range of sorted half, binary search continues there. \\n\\nOtherwise, binary search continues in the half with the pivot.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int searchHelper(int[] A, int target, int start, int end){\\n            if(start>end){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3879413,
                "title": "rust-go-python-binary-search",
                "content": "# Intuition\\n\\nWhen faced with the challenge of searching for an element in a rotated sorted array, our instinct might initially direct us towards a linear search. However, since the array is initially sorted before rotation, we realize that at any given point, at least one half of the array must still be in sorted order. This observation is the key. We can utilize a binary search approach but with a few modifications to account for the rotation. Both Go and Rust, as systems programming languages, are particularly adept at handling such low-level manipulations efficiently.\\n\\n# Approach\\n\\n1. **Initialization**: We start with two pointers, `low` and `high`, indicating the start and the end of the array.\\n2. **Calculate Midpoint**: In every iteration of our loop, we find the midpoint of our current segment.\\n3. **Check for Target**: If the number at the midpoint is our target, we\\'ve found our number.\\n4. **Identify the Sorted Half**: We then determine which half of our current segment is sorted.\\n   - If the left half is sorted, we check if our target lies in this half by comparing it against the lowest and midpoint values. If it does, we adjust our `high` pointer to search in this segment. If not, it must be in the right half, so we adjust our `low` pointer accordingly.\\n   - Similarly, if the right half is sorted and the target lies within this half, we adjust our `low` pointer, else we adjust our `high` pointer.\\n5. **Repeat**: We then repeat the process in the identified half until we find our target or exhaust our search space.\\n\\n# Complexity\\n\\n- **Time complexity**: \\\\(O(\\\\log n)\\\\). The essence of this algorithm is still binary search. With each iteration, we halve our search space, leading to a logarithmic time complexity.\\n  \\n- **Space complexity**: \\\\(O(1)\\\\). We only use a constant amount of space for our variables (`low`, `high`, `mid`), irrespective of the size of the input array.\\n\\n# Code\\n```Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1 \\n\\n        while low <= high: \\n            mid = (low + high) // 2 \\n\\n            if nums[mid] == target: \\n                return mid \\n\\n            if nums[low] <= nums[mid]: \\n                if nums[low] <= target < nums[mid]: \\n                    high = mid - 1 \\n                else: \\n                    low = mid + 1 \\n            else: \\n                if nums[mid] < target <= nums[high]: \\n                    low = mid + 1 \\n                else: \\n                    high = mid - 1 \\n\\n        return -1 \\n```\\n\\nThe coding style in both Go and Rust is quite expressive. Go, with its simplicity and clear syntax, makes the logic straightforward. Rust, while having a bit more verbosity due to its strict type and ownership system, ensures memory safety without sacrificing performance. Both languages, with their static typing and powerful standard libraries, make it easier to implement such algorithms efficiently.",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\n```Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1 \\n\\n        while low <= high: \\n            mid = (low + high) // 2 \\n\\n            if nums[mid] == target: \\n                return mid \\n\\n            if nums[low] <= nums[mid]: \\n                if nums[low] <= target < nums[mid]: \\n                    high = mid - 1 \\n                else: \\n                    low = mid + 1 \\n            else: \\n                if nums[mid] < target <= nums[high]: \\n                    low = mid + 1 \\n                else: \\n                    high = mid - 1 \\n\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879398,
                "title": "python-3-7-lines-binary-searches-w-explanation-t-m-92-94",
                "content": "Here\\'s the intuition:\\n\\n1. If we can determine`k`, the so-called *unknown pivot index*, the solution becomes easier. The key is that `nums[k]` is the first element in `nums` that is strictly less than `nums[0]`, so we can find it in *O*(log*N*) time with a boolean binary search.\\n\\n1. We now have the two subrrays, `nums[:k]` and `nums[k:]`, and we easily deduce in which subarray `target` must lie  (if it indeed does lie in`nums`) by comparing `target` to `nums[0]`.\\n\\n1. We perform a numerical binary search on the appropriate subarray, return the index if we find`target`, otherwise we return`-1`.\\n\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        k = bisect_left(nums, True, key = lambda x: x < nums[0])  # <-- 1\\n \\n        if target  >= nums[0]:                                    # <-- 2\\n            \\n            left = bisect_left(nums, target, hi = k-1)            # \\n            return left if nums[left] == target else -1           #\\n                                                                  # <-- 3\\n        rght = bisect_left(nums, target, lo = k)                  #\\n        return rght if rght < len(nums                            # (this line to avoid index out of range)\\n                     ) and nums[rght] == target else -1           #\\n```\\n[https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/1015192078/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(log*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        k = bisect_left(nums, True, key = lambda x: x < nums[0])  # <-- 1\\n \\n        if target  >= nums[0]:                                    # <-- 2\\n            \\n            left = bisect_left(nums, target, hi = k-1)            # \\n            return left if nums[left] == target else -1           #\\n                                                                  # <-- 3\\n        rght = bisect_left(nums, target, lo = k)                  #\\n        return rght if rght < len(nums                            # (this line to avoid index out of range)\\n                     ) and nums[rght] == target else -1           #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510929,
                "title": "java-solution-for-search-in-a-rotated-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to utilize binary search to efficiently find the target element in the rotated sorted array. By comparing the target with the mid element, the code determines which half of the array to continue the search in.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code initializes the left and right pointers, representing the indices of the leftmost and rightmost elements in the search range.\\n. It enters a while loop where the search range is not empty (left <= right).\\n3. In each iteration, the code calculates the middle index mid as the average of the left and right indices.\\n4. If the target is equal to the element at the mid index, the function returns mid as the index of the target element.\\n5. If the element at the left index is less than or equal to the element at the mid index, it means the left half of the array is sorted in ascending order.\\n- If the target is within the range of the left half (between left and mid), the right pointer is updated to mid - 1 to continue the search in the left half.\\n- Otherwise, the left pointer is updated to mid + 1 to search in the right half.\\n6. If the element at the left index is greater than the element at the mid index, it means the right half of the array is sorted in ascending order.\\n- If the target is within the range of the right half (between mid and right), the left pointer is updated to mid + 1 to continue the search in the right half.\\n- Otherwise, the right pointer is updated to mid - 1 to search in the left half.\\n7. If the target is not found in the array, the while loop terminates, and the function returns -1 to indicate that the target is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search algorithm is O(log n), where n is the length of the input array. This is because the search range is halved in each iteration, resulting in a logarithmic time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it uses a constant amount of extra space for the variables left, right, and mid. The space does not depend on the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right= nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = left + (right-left)/2;\\n            if(target==nums[mid])\\n                return mid;\\n            if(nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(nums[mid]<target&& target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right= nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = left + (right-left)/2;\\n            if(target==nums[mid])\\n                return mid;\\n            if(nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(nums[mid]<target&& target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316342,
                "title": "java-100-faster-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (nums[mid] == target)\\n                return mid; \\n\\n            if (nums[low] <= nums[mid]) { \\n                if (nums[low] <= target && nums[mid] >= target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (nums[mid] == target)\\n                return mid; \\n\\n            if (nums[low] <= nums[mid]) { \\n                if (nums[low] <= target && nums[mid] >= target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296300,
                "title": "a-recursion-approach",
                "content": "# Intuition\\nCheck if the sub-array contains the pivot index and decide the next part to be searched\\n\\n# Approach\\nUse recursion with different condition handling\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return find(nums, 0, nums.length-1, target);\\n    }\\n\\n    public int find(int[] nums, int left, int right, int target) {\\n        if ((right - left) == 1 || left == right) {\\n            if (nums[left] == target) {\\n                return left;\\n            } else if(nums[right] == target) {\\n                return right;\\n            } else {\\n                return -1;\\n            }\\n        }\\n\\n        int mid = (left + right)/2;\\n        if (nums[left] <= nums[mid]) {\\n            if (target >= nums[left] && target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        } else {\\n            if (target >= nums[left] || target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return find(nums, 0, nums.length-1, target);\\n    }\\n\\n    public int find(int[] nums, int left, int right, int target) {\\n        if ((right - left) == 1 || left == right) {\\n            if (nums[left] == target) {\\n                return left;\\n            } else if(nums[right] == target) {\\n                return right;\\n            } else {\\n                return -1;\\n            }\\n        }\\n\\n        int mid = (left + right)/2;\\n        if (nums[left] <= nums[mid]) {\\n            if (target >= nums[left] && target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        } else {\\n            if (target >= nums[left] || target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220051,
                "title": "easy-java-solution-two-pointer-0ms-for-beginners",
                "content": "bin# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n    \\n    int start = 0;\\n    int end = nums.length-1;\\n    while(start <= end){\\n        if(nums[start] == target) return start;\\n        if(nums[end] == target) return end;\\n        start ++;\\n        end--;\\n        }\\n       return -1;    \\n    }\\n     \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n    \\n    int start = 0;\\n    int end = nums.length-1;\\n    while(start <= end){\\n        if(nums[start] == target) return start;\\n        if(nums[end] == target) return end;\\n        start ++;\\n        end--;\\n        }\\n       return -1;    \\n    }\\n     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166291,
                "title": "easiest-c-code-using-binary-search-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        while(l<=r){\\n                m=l+(r-l)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                    else r=m-1;\\n                }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        while(l<=r){\\n                m=l+(r-l)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                    else r=m-1;\\n                }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162650,
                "title": "easy-c-solution-love-babber-dsa-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]== target) return mid;\\n\\n            else if(nums[mid]>=nums[low])\\n            {\\n                if(nums[mid]>= target and nums[low]<= target) high=mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                if(nums[mid]<= target and nums[high]>= target) low=mid+1;\\n                else high=mid-1;\\n\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]== target) return mid;\\n\\n            else if(nums[mid]>=nums[low])\\n            {\\n                if(nums[mid]>= target and nums[low]<= target) high=mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                if(nums[mid]<= target and nums[high]>= target) low=mid+1;\\n                else high=mid-1;\\n\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138093,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using Linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1; \\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using Linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1; \\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018458,
                "title": "simple-go-solution-beats-100-and-99-performance",
                "content": "\\n# Approach\\nIn standard binary search, first we identify if the rotation is in left or right part. Check if target is in the range of the unrotated part to update search boundaries, `left` and `right`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc search(nums []int, target int) int {\\n    left := 0\\n    right := len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) / 2\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[left] > nums[mid] {\\n            if nums[mid] < target && target <= nums[right] {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        } else {\\n            if nums[left] <= target && target < nums[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {\\n    left := 0\\n    right := len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) / 2\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[left] > nums[mid] {\\n            if nums[mid] < target && target <= nums[right] {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        } else {\\n            if nums[left] <= target && target < nums[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010709,
                "title": "0ms-100-beats-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       int low=0,high=nums.length-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] == target) return mid;\\n           if(nums[low]<=nums[mid]){\\n           if(target>=nums[low] && target<=nums[mid] ){\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n           }\\n           else{\\n               if(target>=nums[mid] && target<=nums[high]){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-1;\\n               }\\n           }\\n           \\n       } return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       int low=0,high=nums.length-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] == target) return mid;\\n           if(nums[low]<=nums[mid]){\\n           if(target>=nums[low] && target<=nums[mid] ){\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n           }\\n           else{\\n               if(target>=nums[mid] && target<=nums[high]){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-1;\\n               }\\n           }\\n           \\n       } return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771076,
                "title": "2-easy-approaches-3-line-fast-short-easy",
                "content": "**Please voteup if you like.**\\n```Approach 1:```\\n\\n```\\n--> In this approach I am taking two integer variable and set value 0, size - 1 of vector( end of vector ) respectively.\\n--> Run a while loop till i <= j.\\n--> Each time check nums with index i and j .\\n--> If nums[i] == target than return i.\\n--> If nums[j] == target than return j.\\n--> At last if target not present in vector than return -1.\\n```\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i = 0,j = nums.size()-1;\\n        while(i<=j)\\n        {\\n            if(nums[i] == target)    return i;\\n            else if(nums[j] == target)   return j;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\n```\\n--> Run a Simple for loop and compare all elements with target one by one.\\n--> If elements match with target return the index value.\\n--> If target not available in vector than return -1.\\n```\\n\\t\\ncode:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nHope it will help you \\uD83D\\uDE4C.\\nThank you!.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```Approach 1:```\n```\\n--> In this approach I am taking two integer variable and set value 0, size - 1 of vector( end of vector ) respectively.\\n--> Run a while loop till i <= j.\\n--> Each time check nums with index i and j .\\n--> If nums[i] == target than return i.\\n--> If nums[j] == target than return j.\\n--> At last if target not present in vector than return -1.\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i = 0,j = nums.size()-1;\\n        while(i<=j)\\n        {\\n            if(nums[i] == target)    return i;\\n            else if(nums[j] == target)   return j;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Approach 2:```\n```\\n--> Run a Simple for loop and compare all elements with target one by one.\\n--> If elements match with target return the index value.\\n--> If target not available in vector than return -1.\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733041,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = ( start + end) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid -1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            else{\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid -1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = ( start + end) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid -1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            else{\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid -1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731478,
                "title": "search-in-rotated-sorted-array-easy-to-understand-simple-binary-search-approach",
                "content": "**Brute force:O(n)**\\n```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        \\n        int fix=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix;\\n    }\\n};\\n```\\n\\n\\n**Binary Search : O(log2n)**\\n\\n**We simply divide the array from point  where curr element is greater than equal to prev one and less than or equal to next one and apply binary search twice...\\none on first section and  another on right section**\\n\\n```\\nclass Solution {\\npublic:\\n    \\nint bs(vector<int>&arr,int n,int find,int start,int end)\\n{\\n \\n   \\n   \\n   int mid;\\n   \\n   while(start<=end)\\n   {\\n       mid=start+(end-start)/2;\\n       \\n       if(arr[mid]==find)\\n       {\\n           return mid;\\n       }\\n       else if(arr[mid]<find)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n   }\\n   \\n   return -1;\\n    \\n   \\n}\\n    \\n    \\n    int search(vector<int>&arr, int target)\\n    {\\n        \\n      int n=arr.size();\\n      int s=0;\\n\\t  int e=n-1;\\n\\t  int fix;\\n        \\n\\t  while(s<=e)\\n\\t  {\\n\\t      int mid=s+(e-s)/2;\\n\\t      \\n\\t      int prev=(mid-1+n)%n;\\n\\t      int next=(mid+1)%n;\\n\\t      \\n\\t      \\n\\t      if((arr[mid]<=arr[prev])&&(arr[mid]<=arr[next]))\\n\\t      {\\n\\t          fix=mid;\\n              break;\\n\\t      }\\n\\t      else if(arr[mid]<=arr[e])\\n\\t      {\\n\\t          e=mid-1;\\n\\t      }\\n\\t      else if(arr[mid]>=arr[s])\\n\\t      {\\n\\t          s=mid+1;\\n\\t      }\\n\\t  }\\n\\t  \\n        \\n        \\n        int x=bs(arr,n,target,0,fix-1);\\n        int y=bs(arr,n,target,fix,n-1);\\n       \\n        \\n        \\n        if((x==y)&&(x==-1))\\n        {\\n            return -1;\\n        }\\n        \\n        if(x!=-1)\\n        {\\n            return x;\\n        }\\n        \\n        \\n        return y;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n**Thank you**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        \\n        int fix=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\nint bs(vector<int>&arr,int n,int find,int start,int end)\\n{\\n \\n   \\n   \\n   int mid;\\n   \\n   while(start<=end)\\n   {\\n       mid=start+(end-start)/2;\\n       \\n       if(arr[mid]==find)\\n       {\\n           return mid;\\n       }\\n       else if(arr[mid]<find)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n   }\\n   \\n   return -1;\\n    \\n   \\n}\\n    \\n    \\n    int search(vector<int>&arr, int target)\\n    {\\n        \\n      int n=arr.size();\\n      int s=0;\\n\\t  int e=n-1;\\n\\t  int fix;\\n        \\n\\t  while(s<=e)\\n\\t  {\\n\\t      int mid=s+(e-s)/2;\\n\\t      \\n\\t      int prev=(mid-1+n)%n;\\n\\t      int next=(mid+1)%n;\\n\\t      \\n\\t      \\n\\t      if((arr[mid]<=arr[prev])&&(arr[mid]<=arr[next]))\\n\\t      {\\n\\t          fix=mid;\\n              break;\\n\\t      }\\n\\t      else if(arr[mid]<=arr[e])\\n\\t      {\\n\\t          e=mid-1;\\n\\t      }\\n\\t      else if(arr[mid]>=arr[s])\\n\\t      {\\n\\t          s=mid+1;\\n\\t      }\\n\\t  }\\n\\t  \\n        \\n        \\n        int x=bs(arr,n,target,0,fix-1);\\n        int y=bs(arr,n,target,fix,n-1);\\n       \\n        \\n        \\n        if((x==y)&&(x==-1))\\n        {\\n            return -1;\\n        }\\n        \\n        if(x!=-1)\\n        {\\n            return x;\\n        }\\n        \\n        \\n        return y;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398677,
                "title": "java-simple-0ms-faster-than-100",
                "content": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) /2;\\n            \\n            if(target == nums[mid])\\n                return mid;\\n            \\n            if(nums[start] <= nums[mid])\\n            {\\n                if(nums[mid] > target && nums[start] <= target)\\n                   end = mid -1; \\n                \\n                else \\n                   start = mid +1;\\n        }\\n            else\\n            {\\n                if(nums[end] >= target && nums[mid] < target)\\n                    start = mid +1;\\n                else\\n                    end = mid-1;\\n            }\\n    }\\n        return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) /2;\\n            \\n            if(target == nums[mid])\\n                return mid;\\n            \\n            if(nums[start] <= nums[mid])\\n            {\\n                if(nums[mid] > target && nums[start] <= target)\\n                   end = mid -1; \\n                \\n                else \\n                   start = mid +1;\\n        }\\n            else\\n            {\\n                if(nums[end] >= target && nums[mid] < target)\\n                    start = mid +1;\\n                else\\n                    end = mid-1;\\n            }\\n    }\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2301747,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "\\n``` java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] > nums[r]){\\n                if(nums[mid] < target || target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            } else{\\n                if(nums[mid] < target && target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar search = function(nums, target) {\\n    let l=0, r=nums.length-1\\n    while(l < r){\\n        let mid = Math.floor((l+r)/2)\\n        if(nums[mid] > nums[r]){\\n            if(nums[mid] < target || target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        } else{\\n            if(nums[mid] < target && target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        }\\n    }\\n    return nums[l] == target ? l : -1\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)/2\\n            if nums[mid] > nums[r]:\\n                if nums[mid] < target or target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            else:\\n                if nums[mid] < target and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n        return l if nums[l] == target else -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] > nums[r]){\\n                if(nums[mid] < target || target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            } else{\\n                if(nums[mid] < target && target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```\n```javascript []\\nvar search = function(nums, target) {\\n    let l=0, r=nums.length-1\\n    while(l < r){\\n        let mid = Math.floor((l+r)/2)\\n        if(nums[mid] > nums[r]){\\n            if(nums[mid] < target || target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        } else{\\n            if(nums[mid] < target && target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        }\\n    }\\n    return nums[l] == target ? l : -1\\n};\\n```\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)/2\\n            if nums[mid] > nums[r]:\\n                if nums[mid] < target or target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            else:\\n                if nums[mid] < target and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n        return l if nums[l] == target else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222958,
                "title": "c-binary-search-easy-two-pass-solution-o-logn",
                "content": "For those who have difficulties understanding one-pass binary search solution, I tried to divide the problem into two stages:\\n\\n1. Find the lowest value in array.\\n2. Find the target in left or right group.\\n\\nThe overall time complexity is still `O(log n)`, but much easier to come up with.\\n\\n```\\nclass Solution {\\npublic:\\n    int findLow(vector<int> &nums) {\\n        int lo = 0, hi = nums.size() - 1;\\n        while(lo < hi) {\\n            // case 1: mid > lo && mid > hi -> move lo\\n            // case 2: mid < lo && mid < hi -> move hi\\n            // case 3: mid > lo && mid < hi -> move hi\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] > nums[hi])\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n    int bs(vector<int> &nums, int target, int lo, int hi) {\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] > target) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int idx = findLow(nums);\\n        if(nums.back() < target)\\n            return bs(nums, target, 0, idx-1);\\n        else\\n            return bs(nums, target, idx, nums.size()-1);\\n    }\\n};\\n```\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLow(vector<int> &nums) {\\n        int lo = 0, hi = nums.size() - 1;\\n        while(lo < hi) {\\n            // case 1: mid > lo && mid > hi -> move lo\\n            // case 2: mid < lo && mid < hi -> move hi\\n            // case 3: mid > lo && mid < hi -> move hi\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] > nums[hi])\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n    int bs(vector<int> &nums, int target, int lo, int hi) {\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] > target) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int idx = findLow(nums);\\n        if(nums.back() < target)\\n            return bs(nums, target, 0, idx-1);\\n        else\\n            return bs(nums, target, idx, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196530,
                "title": "c-most-intuitive-approach-w-visual-breakdown-o-log-n",
                "content": "\\n# \"Brute force\" intuitive Approach O(log(n))\\n\\nIf you were ever stuck on this problem, you might\\'ve arrived at this optimal approach if you simply \"blindy\" drew out the possible cases. As you do so, you will notice that it just consists of a few if-statements and is not difficult too difficult to code up at all. This is the first approach which is still an optimal approach.\\n\\nHowever, as you can see from other posts or if you ponder on the problem long enough, the code (shown below) can surely be condensed as there\\'s repetitive logic somewhere in there. But here\\'s a good way to start as it still a **O(log(n))** solution. **I will show you what the non repetitive version is later**.\\n\\n**Case 1) The Array is Rotated**\\n* Case 1.1) The MID is in the **LEFT** subarray\\n\\t* 1.1.1) The target is between the (MID, LEFT] -> Only look at LEFT of MID -> *R = mid-1*\\n\\t* 1.1.2) Else only look at RIGHT of mid -> *L = mid+1*\\n* Case 1.2) The MID is in the **RIGHT** subarray\\n\\t* 1.2.1) The target is between the (MID, RIGHT] -> Only look at RIGHT of mid -> *L = mid+1*\\n\\t* 1.2.2) Else only look at LEFT of mid -> *R = mid-1*\\n\\t\\n**Case 2) The Array is NOT Rotated** (this is the logic that can be removed)\\n* Case 2.1) Do a regular binary search (you should know this)\\n\\t* 2.1) Target is between (MID, RIGHT] --> L = mid+1\\n\\t* 2.2) Else --> R = mid-1\\n\\n![image](https://assets.leetcode.com/users/images/636b2f48-85c1-4029-8c74-85bb57e692e5_1656176521.2446127.png)\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            // case1: rotated case\\n            if(nums[L] > nums[R]){\\n                \\n                // case 1.1: mid is in left subarray\\n                if(nums[mid] >= nums[L]){\\n                    if(target >= nums[L] && target < nums[mid]) // 1.1.1\\n                        R = mid-1;\\n                    else // 1.1.2\\n                        L = mid+1;\\n                    \\n                // case 1.2: mid is in right subarray\\n                } else {\\n                    if(target > nums[mid] && target <= nums[R]) // 1.2.1\\n                        L = mid+1;\\n                    else // 1.2.2\\n                        R = mid-1;\\n                }\\n                \\n            // case2: regular binary search\\n            } else {\\n                if(nums[mid] > target)\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n_________________\\n# Removed repetitive logic from intuitive Approach O(log(n))\\n\\nNow if you can notice it, the whole of case 2 where we do a regular binary search is actually not needed. We can compeltely remove case 2 and simply always run case 1. \\n\\nWhy is this?\\n\\nLook at Case 1.1. Our code logic for case 1.1 is: `if(nums[mid] >= nums[L])`. In a regular sorted array like [0,1,2,3,4,5], this if statement is always true. Now if we look at Cases 1.1.1 and 1.1.2 that fall under Case 1.1, this is just the same as a regular binary search. \\n* Case 1.1.1 says: \"If target is between (MID, LEFT] --> Look at LEFT of MID -> R = mid-1, ELSE look at RIGHT of mid ->L = mid+1\\n\\nThis is just another way to write the if statements in a regular binary search!\\nAs a result, we can remove Case 2 entirely and always run Case 1 only. You would\\'ve gotten to this solution if you realized that Case 1.1 is not just checking if MID is in the left subarray, but it is actually also checking if MID is in the SORTED portion of the array which is always the input in a regular binary search. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        // L   R\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n\\n            // case 1.1: mid is in left subarray aka the SORTED subarray\\n            if(nums[mid] >= nums[L]){\\n                if(target >= nums[L] && target < nums[mid])\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n\\n            // case 1.2: mid is in right subarray\\n            } else {\\n                if(target > nums[mid] && target <= nums[R])\\n                    L = mid+1;\\n                else\\n                    R = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            // case1: rotated case\\n            if(nums[L] > nums[R]){\\n                \\n                // case 1.1: mid is in left subarray\\n                if(nums[mid] >= nums[L]){\\n                    if(target >= nums[L] && target < nums[mid]) // 1.1.1\\n                        R = mid-1;\\n                    else // 1.1.2\\n                        L = mid+1;\\n                    \\n                // case 1.2: mid is in right subarray\\n                } else {\\n                    if(target > nums[mid] && target <= nums[R]) // 1.2.1\\n                        L = mid+1;\\n                    else // 1.2.2\\n                        R = mid-1;\\n                }\\n                \\n            // case2: regular binary search\\n            } else {\\n                if(nums[mid] > target)\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        // L   R\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n\\n            // case 1.1: mid is in left subarray aka the SORTED subarray\\n            if(nums[mid] >= nums[L]){\\n                if(target >= nums[L] && target < nums[mid])\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n\\n            // case 1.2: mid is in right subarray\\n            } else {\\n                if(target > nums[mid] && target <= nums[R])\\n                    L = mid+1;\\n                else\\n                    R = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144045,
                "title": "best-and-easy-c-code-binary-search-11ms",
                "content": "**A small story, if you want you can skip:**\\nIn the comment box of this post, @Malkeet_Levi asked me how I approached the logic of this question. So, I thought to share a small story with you. In one of my interviews, the interviewer asked me a similiar question. I solved that in O(n) time complexicity but he asked me to optimize. I got the idea that it will be solve using binary search but I was confusing how to shift pointers. He gave me a hint how to shift pointers. At that time, it hit my mind and I solved it. Basically, if we have given these type of array, we check which side we are getting increasing sequence. It means in which half the array is sorted.\\n\\n**PS:** During interviews, if you are not getting anything, try to be interactive with the interviewer. Ask as much as hints you want. \\n\\n**Main code starts from here:**\\nThis is my easy and simple binary seach code. Here what we are doing basically, first we use simple binary search as we do. Like first we found the mid of the array. Now, we will see this in three steps:\\n\\n* First , we check mid element with the target element. If it is the target element then we will return its index.\\n* Either  we will check that the sorted array is in left half or in right half by comparing with mid-indexed element.\\n* If it is in left half, we will reduced our high pointer **high=mid-1** or it is in a right half we will increased our low pointer **low=mid+1**.\\n\\nHere is my code:\\n\\n```\\nint search(vector<int>& nums, int tar) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            long long mid=((high+low)/2);\\n            \\n\\t\\t\\t// Check whether mid element is target element or not\\n            if(nums[mid]==tar)\\n            return mid;\\n            \\n            // To check that first half is sorted or not\\n            if(nums[low]<=nums[mid])\\n            {\\n                if(tar>=nums[low] and tar<nums[mid])\\n                high=mid-1;\\n                else\\n                low=mid+1;\\n            }\\n\\t\\t\\t\\n            // To check that second half is sorted or not\\n            else\\n            {\\n                if(tar>nums[mid] and tar<=nums[high])\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }     \\n        }\\n        \\n        return -1;        \\n    }\\n```\\n\\n**PS: Keep Coding...Keep Learning.**\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& nums, int tar) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            long long mid=((high+low)/2);\\n            \\n\\t\\t\\t// Check whether mid element is target element or not\\n            if(nums[mid]==tar)\\n            return mid;\\n            \\n            // To check that first half is sorted or not\\n            if(nums[low]<=nums[mid])\\n            {\\n                if(tar>=nums[low] and tar<nums[mid])\\n                high=mid-1;\\n                else\\n                low=mid+1;\\n            }\\n\\t\\t\\t\\n            // To check that second half is sorted or not\\n            else\\n            {\\n                if(tar>nums[mid] and tar<=nums[high])\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }     \\n        }\\n        \\n        return -1;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087043,
                "title": "simple-java-solution-with-algorithm-1ms-o-log-n",
                "content": "**Algorithm**\\n* The complete idea is very simple. The main approach is binary search. The array is already sorted, but it is rotated from some point. We need to find that pivot and use them as two arrays.\\n* First find the maximum element(pivot) using binary search method. \\n* Then send the sub array to the function binarySearch in which the target should be contained. \\n* The returned value is the answer.\\n\\nTime Complexity: O(log n)\\n\\n**Code**\\n```\\npublic int search(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n        int k=0;\\n        while(l<r){\\n            int mid = (int)(l+r)/2;\\n            if(nums[mid] > nums[l] && nums[mid] > nums[r]) l = mid;\\n            else  r = mid;\\n        }\\n        int res = 0;\\n        if(target <= nums[r] && target >= nums[0]) res = binarySearch(nums, 0, r, target);\\n        else res = binarySearch(nums, r+1, nums.length-1, target);\\n        \\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int l, int r, int target){\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid+1;\\n            else  r = mid-1;\\n        }\\n        return -1;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int search(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n        int k=0;\\n        while(l<r){\\n            int mid = (int)(l+r)/2;\\n            if(nums[mid] > nums[l] && nums[mid] > nums[r]) l = mid;\\n            else  r = mid;\\n        }\\n        int res = 0;\\n        if(target <= nums[r] && target >= nums[0]) res = binarySearch(nums, 0, r, target);\\n        else res = binarySearch(nums, r+1, nums.length-1, target);\\n        \\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int l, int r, int target){\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid+1;\\n            else  r = mid-1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006156,
                "title": "100-faster-than-all-online-solutions-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi])\\n                lo = mid+1;\\n            else\\n                hi = mid;\\n        }\\n        //We have divided the array into two parts\\n        int p = lo;\\n        hi = nums.size()-1;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = nums.size()-1;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n            {\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi])\\n                lo = mid+1;\\n            else\\n                hi = mid;\\n        }\\n        //We have divided the array into two parts\\n        int p = lo;\\n        hi = nums.size()-1;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = nums.size()-1;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n            {\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932901,
                "title": "java-0-ms-faster-than-100-00-of-java-online-submissions-binary-search",
                "content": "### Please upvote, if you like the solution\\n\\n\\tclass Solution {\\n\\t\\t\\tpublic int search(int[] arr, int target) {\\n\\t\\t\\t\\tint low = 0, high = arr.length-1;\\n\\n\\t\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\t\\tint mid = low +(high-low)/2;\\n\\t\\t\\t\\t\\tif(arr[mid]==target){ return mid; }\\n\\t\\t\\t\\t\\tif(arr[mid]>=arr[low]){\\n\\t\\t\\t\\t\\t\\tif(target<=arr[mid] && target>=arr[low]){\\n\\t\\t\\t\\t\\t\\t\\thigh = mid-1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tlow = mid+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(target>=arr[mid] && target<=arr[high]){\\n\\t\\t\\t\\t\\t\\t\\tlow = mid+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\thigh = mid-1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int search(int[] arr, int target) {\\n\\t\\t\\t\\tint low = 0, high = arr.length-1;\\n\\n\\t\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\t\\tint mid = low +(high-low)/2;\\n\\t\\t\\t\\t\\tif(arr[mid]==target){ return mid; }",
                "codeTag": "Java"
            },
            {
                "id": 1791418,
                "title": "detailed-approach-with-solution-c",
                "content": "# Modified Binary Search\\n### Approach\\n```\\nRun a loop till start element is smaller then end element\\n    if mid element is equal to target: return mid\\n    else if mid element is greater than start element -> array before mid element must be sorted\\n        if target is smaller than mid element and greater than start element: new end element is mid element -> unrotated part\\n        else : new start element is mid element -> rotated part\\n    else -> array after mid must be sorted\\n        if target is greater than mid element and smaller than end element: new start element is mid element -> unrotated side\\n        else : new end element is mid element -> rotated side\\nreturn -1 -> element not found in array\\n```\\n\\n **Time Complexity: *O(log(n))***\\n**Space Complexity: *O(1)***\\n\\n### Solution\\n```\\nclass Solution {\\n   public:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, mid, high = nums.size() - 1;\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[low]) {\\n                if (target < nums[mid] && target >= nums[low]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nRun a loop till start element is smaller then end element\\n    if mid element is equal to target: return mid\\n    else if mid element is greater than start element -> array before mid element must be sorted\\n        if target is smaller than mid element and greater than start element: new end element is mid element -> unrotated part\\n        else : new start element is mid element -> rotated part\\n    else -> array after mid must be sorted\\n        if target is greater than mid element and smaller than end element: new start element is mid element -> unrotated side\\n        else : new end element is mid element -> rotated side\\nreturn -1 -> element not found in array\\n```\n```\\nclass Solution {\\n   public:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, mid, high = nums.size() - 1;\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[low]) {\\n                if (target < nums[mid] && target >= nums[low]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729466,
                "title": "java-simple-easy-o-log-n-explained",
                "content": "<u>**BASIC IDEA:**</u>\\n\\n* **First check the edge case** i.e. if the **given array**(nums) is **not rotated** or we can say is already in **strictly increasing order**[eg: `nums = {3, 5, 13, 21}`], then **do the normal/standard binary search and return the index of target if present or else -1**\\n\\teg: \\n\\t`nums[] = {3, 5, 13, 21}` and `target = 13`, then `return 2` as index\\n\\tand if `target = 53`, then `return -1` as index because 53 in not present in nums.\\n\\n* **If the array is rotated, then find the index of minimum element to get the pivot**\\n\\teg: \\n\\t`nums[] = {4, 5, 6, 7, 8, 1, 2, 3}`, here the **minimum element in array nums is 1** and **it\\'s index is 5**\\n\\t\\n* **After getting the index of minimum element**(i.e. 5),\\n\\t*  **if the target is equal to minimum element, then directly return it\\'s index**\\n\\teg: \\n\\t`nums[] = {5, 6, 7, 8, 9, 1, 2, 3, 4}` and `target = 1`, **then directly return 5 as it\\'s index**\\n\\n\\t* **else find out whether to search in left sorted array**(i.e. {5, 6, 7, 8, 9}) **or right sorted array**(i.e. {1, 2, 3, 4})\\n\\teg: \\n\\t`nums[] = {5, 6, 7, 8, 9, 1, 2, 3, 4}` and `target = 3`, **then search in the right sorted array**(i.e. {1, 2, 3, 4})\\n\\t\\n* **Once it\\'s found which sorted part(i.e. left or right) to search, do the normal/standard binary search on that sorted part and return the index of target if found or else return -1.**\\n\\n<u>**JAVA COMMENTED SOLUTION:**</u>\\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n\\n    // if the array is not rotated i.e. if the array is strictly increasing[eg: {1,2,3,4}], then\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target); // directly return the index of target if present, else return -1\\n    }\\n\\n    // find the index of minimum element in nums\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      // if the current element is minimum, then store it\\'s index and stop iteration\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) { // to search in right sorted part\\n        start = mid + 1;\\n      } else { // to search in left sorted part\\n        end = mid;\\n      }\\n    }\\n\\n    // store the index of min element in nums\\n    int indexOfMinElement = start;\\n    // if the minimum element is equal to the the target, then\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement; //directly return it\\'s index\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n\\n    // if the target element is on the right sorted part, then\\n    if(target < firstElement) {\\n      start = indexOfMinElement; // search from index of minimum element to the end of the array(nums)\\n    } else { // if the target element is on the left side of the sorted array\\n      end = indexOfMinElement - 1; // search from 0 to one previous element from index of minimum element\\n    }\\n\\n    // now as we know which sorted part(left or right) to search, do standard binary search\\n    // search for the index of target if the target is present in the nums, else return -1\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  // standard binary search\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n\\n<u>**JAVA SOLUTION WITHOUT COMMENTS:**</u>\\n\\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target);\\n    }\\n\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) {\\n        start = mid + 1;\\n      } else {\\n        end = mid;\\n      }\\n    }\\n\\n    int indexOfMinElement = start;\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement;\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n    if(target < firstElement) {\\n      start = indexOfMinElement;\\n    } else {\\n      end = indexOfMinElement - 1;\\n    }\\n\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n\\n\\n<u>**COMPLEXITY ANALYSIS:**</u>\\n* **Time: O(log<sub>2</sub>n)**, where **n is the size** of the given array(nums) and **O(log<sub>2</sub>n) is the maximum number of possible iterations**\\n* **Space: O(1)**, in-place\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n\\n    // if the array is not rotated i.e. if the array is strictly increasing[eg: {1,2,3,4}], then\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target); // directly return the index of target if present, else return -1\\n    }\\n\\n    // find the index of minimum element in nums\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      // if the current element is minimum, then store it\\'s index and stop iteration\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) { // to search in right sorted part\\n        start = mid + 1;\\n      } else { // to search in left sorted part\\n        end = mid;\\n      }\\n    }\\n\\n    // store the index of min element in nums\\n    int indexOfMinElement = start;\\n    // if the minimum element is equal to the the target, then\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement; //directly return it\\'s index\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n\\n    // if the target element is on the right sorted part, then\\n    if(target < firstElement) {\\n      start = indexOfMinElement; // search from index of minimum element to the end of the array(nums)\\n    } else { // if the target element is on the left side of the sorted array\\n      end = indexOfMinElement - 1; // search from 0 to one previous element from index of minimum element\\n    }\\n\\n    // now as we know which sorted part(left or right) to search, do standard binary search\\n    // search for the index of target if the target is present in the nums, else return -1\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  // standard binary search\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target);\\n    }\\n\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) {\\n        start = mid + 1;\\n      } else {\\n        end = mid;\\n      }\\n    }\\n\\n    int indexOfMinElement = start;\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement;\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n    if(target < firstElement) {\\n      start = indexOfMinElement;\\n    } else {\\n      end = indexOfMinElement - 1;\\n    }\\n\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636185,
                "title": "binary-search-log-n-simple-and-easy-c",
                "content": "Implementation\\n\\n**Using Binary Search\\nTime Complexity = O(LogN), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            if(nums[left] <= nums[mid]){\\n                if(target >= nums[left] && target <= nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            }\\n            else{\\n                if(target >= nums[mid] && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            if(nums[left] <= nums[mid]){\\n                if(target >= nums[left] && target <= nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            }\\n            else{\\n                if(target >= nums[mid] && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616520,
                "title": "i-got-the-intuition-behind-the-approach-easy-to-understand",
                "content": "* We can have 2 halves (low to mid & mid to high) of Array if we divided b/w Middle.\\n\\n* We need to check in which side Target can present **But But** we can\\'t check directly by comparing with nums[mid] & Target.\\n\\n* So, We first check which side is Sorted(one of them will sorted) \\n* So,That we can check whether the target lies within that range. If Not, Move to other side of SubArray.\\n\\n\\n```\\nint search(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        \\n        int l=0,h=n-1;\\n        \\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            //check mid==t\\n            if(nums[mid]==t) return mid;\\n            \\n            //check whether left subarray is sorted\\n            else if(nums[l]<=nums[mid]){\\n                //if Yes, check whether Target lies b/w this Range else move to right SubArray\\n                if(t>=nums[l] && t<=nums[mid]){\\n                    h=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            \\n            //same for right array\\n            else{\\n                if(t>=nums[mid] && t<=nums[h]){\\n                    l=mid+1;\\n                }else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D Please upVote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        \\n        int l=0,h=n-1;\\n        \\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            //check mid==t\\n            if(nums[mid]==t) return mid;\\n            \\n            //check whether left subarray is sorted\\n            else if(nums[l]<=nums[mid]){\\n                //if Yes, check whether Target lies b/w this Range else move to right SubArray\\n                if(t>=nums[l] && t<=nums[mid]){\\n                    h=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            \\n            //same for right array\\n            else{\\n                if(t>=nums[mid] && t<=nums[h]){\\n                    l=mid+1;\\n                }else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519112,
                "title": "c-o-log-n-easy-to-understand-straightforward-c-solution-with-explanation",
                "content": "I have seen a lot of soutions which are over complicated. It\\'s hard to grasp especially for beginners.\\nOkay, let\\'s get into it\\n[ 4, 5, 6, 7, 0, 1, 2 ] // sorted but rotated so, we can\\'t apply binary search directly.\\n- In the array you can see two sorted subarray\\n- when we find the mid in array, we check if  mid == target if so, we return the mid index.\\n- else we check left is sorted ( arr[low] <= arr[mid] ) \\n\\t- if left if sorted we check wether target belongs to left half or right half\\n- if left half is not sorted it gurantees that right half is sorted therefore we check if element belong to right of left half again.\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        if(n==0)return -1;\\n        \\n        int low =0;\\n        int high = n-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            \\n            // check if left half is sorted\\n            if(nums[low] <= nums[mid]){\\n                if(target>=nums[low] && target<=nums[mid]){ // check if target belongs to left sorted subarray\\n                    high = mid-1;\\n                }else{\\n                    low = mid+1;\\n                }\\n            }else{\\n                // if left is not sorted it gurantees that right half if sorted\\n                \\n                if(target>=nums[mid] && target<=nums[high]){\\n                    low = mid+1;\\n                }else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n#### Upvote if it has helped you :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        if(n==0)return -1;\\n        \\n        int low =0;\\n        int high = n-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            \\n            // check if left half is sorted\\n            if(nums[low] <= nums[mid]){\\n                if(target>=nums[low] && target<=nums[mid]){ // check if target belongs to left sorted subarray\\n                    high = mid-1;\\n                }else{\\n                    low = mid+1;\\n                }\\n            }else{\\n                // if left is not sorted it gurantees that right half if sorted\\n                \\n                if(target>=nums[mid] && target<=nums[high]){\\n                    low = mid+1;\\n                }else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445594,
                "title": "15-line-cpp-code-0ms-by-divide-and-conquer-alorithm",
                "content": "simply apply divide and conquer as we get last element where low and high are same then check that value with target if they match then update isMatch variable is not then simply return from base case\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int target,int low,int high,int &isMatch){\\n        if(low>high) return;\\n        if(low==high ){\\n            if(target==nums[low])\\n                isMatch=low;\\n            return;\\n        }\\n        int mid=(high-low)/2+low;\\n        if(isMatch==-1 && mid>=0)\\n             helper(nums,target,low,mid,isMatch);\\n        if(isMatch==-1 && mid>=0) \\n            helper(nums,target,mid+1,high,isMatch);\\n            return;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int isMatch=-1;\\n        helper(nums,target,0,nums.size()-1,isMatch);\\n        return isMatch;\\n    }\\n};\\n```\\n**I think this code deserve a upvote. thankyou!!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int target,int low,int high,int &isMatch){\\n        if(low>high) return;\\n        if(low==high ){\\n            if(target==nums[low])\\n                isMatch=low;\\n            return;\\n        }\\n        int mid=(high-low)/2+low;\\n        if(isMatch==-1 && mid>=0)\\n             helper(nums,target,low,mid,isMatch);\\n        if(isMatch==-1 && mid>=0) \\n            helper(nums,target,mid+1,high,isMatch);\\n            return;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int isMatch=-1;\\n        helper(nums,target,0,nums.size()-1,isMatch);\\n        return isMatch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424130,
                "title": "100-c-with-explanation",
                "content": "The basic idea is that one half of the array will always be sorted. So check which part is sorted and then check if target is possible to occur in that range, if yes, update the low/high pointers accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            \\n            if(nums[mid]>=nums[low])//left side is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low])//if left side contains the target (range check)\\n                    high=mid-1;\\n                else//if doesn\\'t contains target, goto right half of the array\\n                    low=mid+1;\\n            }\\n            else//right side is sorted\\n            {\\n                if(target<=nums[high] && target>nums[mid])//if right side contains target\\n                    low=mid+1;\\n                else//else goto left part \\n                    high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            \\n            if(nums[mid]>=nums[low])//left side is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low])//if left side contains the target (range check)\\n                    high=mid-1;\\n                else//if doesn\\'t contains target, goto right half of the array\\n                    low=mid+1;\\n            }\\n            else//right side is sorted\\n            {\\n                if(target<=nums[high] && target>nums[mid])//if right side contains target\\n                    low=mid+1;\\n                else//else goto left part \\n                    high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567557,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576279,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1565736,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1909894,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566652,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566532,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576174,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567816,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1844246,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2004907,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567557,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576279,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1565736,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1909894,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566652,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566532,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576174,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567816,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1844246,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2004907,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2016109,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005097,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1568434,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1574236,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1572865,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2004937,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005112,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005067,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2004993,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1713453,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1575558,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574543,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1573246,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2056610,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2005057,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2004959,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1882199,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1797653,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1682346,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574648,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574180,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 1573064,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 1570282,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2064419,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2060635,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2057691,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2055258,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2053962,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2051610,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2049573,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2046504,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2044999,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2039423,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2036407,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2030239,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2023620,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2019312,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2018099,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2017805,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2016540,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2007649,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2006187,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2006133,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005899,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005868,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005855,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005824,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005787,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005780,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005658,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005518,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005411,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005343,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005318,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005229,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005175,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005124,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005085,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005068,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2004998,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 1998846,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1994510,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1978889,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1977884,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1975460,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1974882,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1974562,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1972613,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1966190,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1958850,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1958267,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1958265,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1950463,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1946950,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1941884,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1941772,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1938429,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1936050,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1899510,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890448,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890107,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1877585,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1876291,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1871194,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1858198,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1846450,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1844323,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1840853,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1836540,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1827179,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1812434,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1809646,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1807110,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1806109,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1803570,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1800366,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1797736,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1797599,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796857,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796422,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796303,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1793183,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1792022,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1780218,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1780019,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1779693,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1779228,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1777495,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1776630,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1772761,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1772688,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1754245,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1752599,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1748703,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1745551,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1743280,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1740788,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1737980,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1736924,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1733534,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1732369,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1730700,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1726990,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1726161,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1724793,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1723595,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1721248,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1716536,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1715179,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1713408,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1708843,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1708621,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1707994,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1706261,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1699812,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1698622,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1694716,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1673808,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1671299,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1648672,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Clone Graph",
        "question_content": "<p>Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n\n<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Test case format:</strong></p>\n\n<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>\n\n<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>\n\n<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 454px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>There are no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1792834,
                "title": "c-easy-explanation-dfs",
                "content": "\\n                               \\'I\\u2019ve got nothing to say but it\\u2019s okay, good morning, good morning\\uD83D\\uDE01\\uD83D\\uDE01\\'\\n\\t\\t\\t\\t\\t\\t\\t   \\n### OBSERVATIONS\\n```\\n1. Cloned Graph has all nodes as newnodes and don\\'t have node as reference to given original graph.\\n2. Graph has no practical edges, i.e no pointers for edges.\\n         (2,3)            (1,3)<---adj list\\n\\t\\t  (1)-------------(2)\\n\\t\\t    |              |\\n\\t\\t\\t|              |\\n\\t\\t\\t|              |\\n\\t\\t  (4)-------------(3)\\n\\t\\t  (1,3)          (2,4)\\nIf i say \\'1\\' is my starting point and how should i jump to \\'2\\' for that i have to iterate through this adjacency list.\\n```\\n### ALGORITHM TO USE\\n```\\nWe need to traverse all node of original graph and as soon as we reach a node, we will make a copy node.\\nAnd recur for rest of the graph.\\nThis is a typical recursion type problem implemented on Graph.\\nFor \\'Recursion\\' we use basically \\'DFS\\' or \\'BFS\\'.\\nI am using DFS\\n```\\n### KEY POINTS\\n```\\n1. We use HashMap to solve it and using DFS.\\n2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.\\n3. We start with any entry point.\\n4. I am using \\'1\\' as my entry point.\\n\\nNow lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.\\nWe are using DFS so algorithm is like \\'it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.\\nSo the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. \\nThen backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.\\'\\nSo we are using HashMap to put all the visited node or old node there with clone one to.\\n _________\\n| HashMap |\\n ----------\\n|Old|Clone| \\n| 1  | 1 |\\n|  2 | 2 |\\n|  3 | 3 |                                                     \\n|  4 | 4 |                                                                                                            \\n---------\\n\\nNow i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node\\nso accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,\\nand now its time for recursive call to go back and now from here we check from current node i can go where and where.\\nAnd follow the same rules over there.\\n\\nBUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. \\n\\nThats the only reason we are using hash map so that we don\\'t need to clone again and again.\\nFor every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or bfs traversal.\\n```\\n\\n## CODE\\n```\\n                                          \\'IF YOU LIKE IT THEN PLS UpVote\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\'\\nclass Solution {\\n    public:\\n    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp)\\n    {\\n        vector<Node*> neighbour;\\n        Node* clone=new Node(cur->val);\\n        mp[cur]=clone;\\n            for(auto it:cur->neighbors)\\n            {\\n                if(mp.find(it)!=mp.end())   //already clone and stored in map\\n                {\\n                    neighbour.push_back(mp[it]);    //directly push back the clone node from map to neigh\\n                }\\n                else\\n                    neighbour.push_back(dfs(it,mp));\\n            }\\n            clone->neighbors=neighbour;\\n            return clone;\\n    }\\n    Node* cloneGraph(Node* node) {\\n        unordered_map<Node*,Node*> mp;\\n        if(node==NULL)\\n            return NULL;\\n        if(node->neighbors.size()==0)   //if only one node present no neighbors\\n        {\\n            Node* clone= new Node(node->val);\\n            return clone; \\n        }\\n        return dfs(node,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. Cloned Graph has all nodes as newnodes and don\\'t have node as reference to given original graph.\\n2. Graph has no practical edges, i.e no pointers for edges.\\n         (2,3)            (1,3)<---adj list\\n\\t\\t  (1)-------------(2)\\n\\t\\t    |              |\\n\\t\\t\\t|              |\\n\\t\\t\\t|              |\\n\\t\\t  (4)-------------(3)\\n\\t\\t  (1,3)          (2,4)\\nIf i say \\'1\\' is my starting point and how should i jump to \\'2\\' for that i have to iterate through this adjacency list.\\n```\n```\\nWe need to traverse all node of original graph and as soon as we reach a node, we will make a copy node.\\nAnd recur for rest of the graph.\\nThis is a typical recursion type problem implemented on Graph.\\nFor \\'Recursion\\' we use basically \\'DFS\\' or \\'BFS\\'.\\nI am using DFS\\n```\n```\\n1. We use HashMap to solve it and using DFS.\\n2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.\\n3. We start with any entry point.\\n4. I am using \\'1\\' as my entry point.\\n\\nNow lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.\\nWe are using DFS so algorithm is like \\'it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.\\nSo the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. \\nThen backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.\\'\\nSo we are using HashMap to put all the visited node or old node there with clone one to.\\n _________\\n| HashMap |\\n ----------\\n|Old|Clone| \\n| 1  | 1 |\\n|  2 | 2 |\\n|  3 | 3 |                                                     \\n|  4 | 4 |                                                                                                            \\n---------\\n\\nNow i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node\\nso accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,\\nand now its time for recursive call to go back and now from here we check from current node i can go where and where.\\nAnd follow the same rules over there.\\n\\nBUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. \\n\\nThats the only reason we are using hash map so that we don\\'t need to clone again and again.\\nFor every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or bfs traversal.\\n```\n```\\n                                          \\'IF YOU LIKE IT THEN PLS UpVote\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\'\\nclass Solution {\\n    public:\\n    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp)\\n    {\\n        vector<Node*> neighbour;\\n        Node* clone=new Node(cur->val);\\n        mp[cur]=clone;\\n            for(auto it:cur->neighbors)\\n            {\\n                if(mp.find(it)!=mp.end())   //already clone and stored in map\\n                {\\n                    neighbour.push_back(mp[it]);    //directly push back the clone node from map to neigh\\n                }\\n                else\\n                    neighbour.push_back(dfs(it,mp));\\n            }\\n            clone->neighbors=neighbour;\\n            return clone;\\n    }\\n    Node* cloneGraph(Node* node) {\\n        unordered_map<Node*,Node*> mp;\\n        if(node==NULL)\\n            return NULL;\\n        if(node->neighbors.size()==0)   //if only one node present no neighbors\\n        {\\n            Node* clone= new Node(node->val);\\n            return clone; \\n        }\\n        return dfs(node,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792858,
                "title": "python3-iterative-bfs-beats-98-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nTo solve this problem we need two things: \\n\\n1. BFS to traverse the graph\\n2. A hash map to keep track of already visited and already cloned nodes\\n\\nWe push a node in the queue and make sure that the node is already cloned. Then we process neighbors. If a neighbor is already cloned and visited, we just append it to the current clone neighbors list, otherwise, we clone it first and append it to the queue to make sure that we can visit it in the next tick.\\n\\nTime: **O(V + E)** - for BFS\\nSpace: **O(V)** - for the hashmap\\n\\nRuntime: 32 ms, faster than **98.18%** of Python3 online submissions for Clone Graph.\\nMemory Usage: 14.4 MB, less than **91.72%** of Python3 online submissions for Clone Graph.\\n\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        q, clones = deque([node]), {node.val: Node(node.val, [])}\\n        while q:\\n            cur = q.popleft() \\n            cur_clone = clones[cur.val]            \\n\\n            for ngbr in cur.neighbors:\\n                if ngbr.val not in clones:\\n                    clones[ngbr.val] = Node(ngbr.val, [])\\n                    q.append(ngbr)\\n                    \\n                cur_clone.neighbors.append(clones[ngbr.val])\\n                \\n        return clones[node.val]\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        q, clones = deque([node]), {node.val: Node(node.val, [])}\\n        while q:\\n            cur = q.popleft() \\n            cur_clone = clones[cur.val]            \\n\\n            for ngbr in cur.neighbors:\\n                if ngbr.val not in clones:\\n                    clones[ngbr.val] = Node(ngbr.val, [])\\n                    q.append(ngbr)\\n                    \\n                cur_clone.neighbors.append(clones[ngbr.val])\\n                \\n        return clones[node.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793212,
                "title": "c-detailed-explanation-w-dfs-bfs-commented-code-with-extra-test-case",
                "content": "***Brief note about Question-***\\n* We have given a graph and we have to return the same copy of the graph.\\n```\\nLet\\'s take an example not given in question -\\nSuppose graph given to us is like : [[2,5],[1,3],[2,4],[3,5],[1,4]]\\nIt should look like -\\n                          1--------2\\n\\t\\t\\t\\t\\t\\t /         |\\n\\t\\t\\t\\t\\t    /          |\\n\\t\\t\\t\\t\\t   /           |\\n\\t\\t\\t\\t\\t  5            |\\n\\t\\t\\t\\t\\t   \\\\           |\\n\\t\\t\\t\\t\\t\\t\\\\          |\\n\\t\\t\\t\\t\\t\\t \\\\         |\\n\\t\\t\\t\\t\\t\\t  4--------3\\n\\t\\t\\t\\t\\t\\t  \\nNow, We have to return the clone\\nSo output should looks like: [[2,5],[1,3],[2,4],[3,5],[1,4]]\\n```\\n_________________\\n***Solution - I (Using DFS, Accepted)-***\\n* We are able to do this question using both DFS and BFS.\\n* **Just one important thing we have to consider here that, Suppose we are standing on any particular node and we want to make a copy of the node then we have to keep a record that whether the copy of this node is already created or not**.\\n* See, we try to move in neighbor and creating a copy of node, so if two nodes are neighbour of each other, say 1 and 2, then node 1 say okay, node 2 is my neighbour so when i move to this then i have to create a copy and we create a copy of node 2 and since we are on the node 1so for node 1 we also create a copy.\\n* Now, we move further to node 2, then node 2 say okay, i have to create my copy, but as well as since 1 is also my neighbour so i also have to create the copy of node1.\\n* In this way, for only both of the nodes, we create copies and this is the problem that we want to avoid.\\n* **Also, if we create a copy, then being a good neighbor, we find whether our neighbor have a copy or not, so we will travel all around our adjcant.**\\n* See commented code for more explanation.\\n______\\n**Code (C++)**\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL) // if node is null, then simply return null\\n        {\\n            return NULL;\\n        }\\n        \\n        // for a node, we will check whether we already creates a copy of thiis or not. If it is present in map that means we already creates a copy of this.\\n        //But if not present in map, that means we have not a copy of this.\\n        // Also, if we create a copy, then being a good neighbor, we find whether our neighbor have a copy or not, so we will travel all around our adjcant.\\n        \\n        if(mp.find(node) == mp.end()) // if not present in map\\n        {\\n            mp[node] = new Node(node -> val, {}); // make a copy\\n            \\n            for(auto adj: node -> neighbors) // travel in adjcant\\n            {\\n                mp[node] -> neighbors.push_back(cloneGraph(adj)); //add copy\\n            }\\n        }\\n        \\n        return mp[node]; // and at last, return mp[node] as till now we clone our whole graph\\n        \\n    }\\n};\\n```\\n_____________\\n***Solution - II (Using BFS, Accepted)-***\\n* Whole approach is same, just we are using BFS.\\n\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL) // if node is null, then simply return null\\n        {\\n            return NULL;\\n        }\\n        \\n        Node* first = new Node(node -> val, {}); // make a copy of first node\\n        mp[node] = first;\\n        \\n        queue<Node*> q; //For bfs, we create queue\\n        q.push(node); // push into queue\\n        \\n        while(q.empty() == false) // until q. empty == false\\n        {\\n            Node* curr = q.front(); // extract front node\\n            q.pop(); // pop that from queue\\n            \\n            for(auto adj: curr -> neighbors) // now travel in adjcant\\n            {\\n                if(mp.find(adj) == mp.end()) // if not present in map\\n                {\\n                    mp[adj] = new Node(adj -> val, {}); // then create copy\\n                    q.push(adj); // push nto the queue\\n                    \\n                }\\n                \\n                mp[curr] -> neighbors.push_back(mp[adj]); // in current node push adjcant node\\n            }\\n        }\\n        \\n        return mp[node];\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose graph given to us is like : [[2,5],[1,3],[2,4],[3,5],[1,4]]\\nIt should look like -\\n                          1--------2\\n\\t\\t\\t\\t\\t\\t /         |\\n\\t\\t\\t\\t\\t    /          |\\n\\t\\t\\t\\t\\t   /           |\\n\\t\\t\\t\\t\\t  5            |\\n\\t\\t\\t\\t\\t   \\\\           |\\n\\t\\t\\t\\t\\t\\t\\\\          |\\n\\t\\t\\t\\t\\t\\t \\\\         |\\n\\t\\t\\t\\t\\t\\t  4--------3\\n\\t\\t\\t\\t\\t\\t  \\nNow, We have to return the clone\\nSo output should looks like: [[2,5],[1,3],[2,4],[3,5],[1,4]]\\n```\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL) // if node is null, then simply return null\\n        {\\n            return NULL;\\n        }\\n        \\n        // for a node, we will check whether we already creates a copy of thiis or not. If it is present in map that means we already creates a copy of this.\\n        //But if not present in map, that means we have not a copy of this.\\n        // Also, if we create a copy, then being a good neighbor, we find whether our neighbor have a copy or not, so we will travel all around our adjcant.\\n        \\n        if(mp.find(node) == mp.end()) // if not present in map\\n        {\\n            mp[node] = new Node(node -> val, {}); // make a copy\\n            \\n            for(auto adj: node -> neighbors) // travel in adjcant\\n            {\\n                mp[node] -> neighbors.push_back(cloneGraph(adj)); //add copy\\n            }\\n        }\\n        \\n        return mp[node]; // and at last, return mp[node] as till now we clone our whole graph\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL) // if node is null, then simply return null\\n        {\\n            return NULL;\\n        }\\n        \\n        Node* first = new Node(node -> val, {}); // make a copy of first node\\n        mp[node] = first;\\n        \\n        queue<Node*> q; //For bfs, we create queue\\n        q.push(node); // push into queue\\n        \\n        while(q.empty() == false) // until q. empty == false\\n        {\\n            Node* curr = q.front(); // extract front node\\n            q.pop(); // pop that from queue\\n            \\n            for(auto adj: curr -> neighbors) // now travel in adjcant\\n            {\\n                if(mp.find(adj) == mp.end()) // if not present in map\\n                {\\n                    mp[adj] = new Node(adj -> val, {}); // then create copy\\n                    q.push(adj); // push nto the queue\\n                    \\n                }\\n                \\n                mp[curr] -> neighbors.push_back(mp[adj]); // in current node push adjcant node\\n            }\\n        }\\n        \\n        return mp[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793436,
                "title": "java-simple-code-with-heavy-comments",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node , Node copy , Node[] visited){\\n        visited[copy.val] = copy;// store the current node at it\\'s val index which will tell us that this node is now visited\\n        \\n//         now traverse for the adjacent nodes of root node\\n        for(Node n : node.neighbors){\\n//             check whether that node is visited or not\\n//              if it is not visited, there must be null\\n            if(visited[n.val] == null){\\n//                 so now if it not visited, create a new node\\n                Node newNode = new Node(n.val);\\n//                 add this node as the neighbor of the prev copied node\\n                copy.neighbors.add(newNode);\\n//                 make dfs call for this unvisited node to discover whether it\\'s adjacent nodes are explored or not\\n                dfs(n , newNode , visited);\\n            }else{\\n//                 if that node is already visited, retrieve that node from visited array and add it as the adjacent node of prev copied node\\n//                 THIS IS THE POINT WHY WE USED NODE[] INSTEAD OF BOOLEAN[] ARRAY\\n                copy.neighbors.add(visited[n.val]);\\n            }\\n        }\\n        \\n    }\\n    public Node cloneGraph(Node node) {\\n        if(node == null) return null; // if the actual node is empty there is nothing to copy, so return null\\n        Node copy = new Node(node.val); // create a new node , with same value as the root node(given node)\\n        Node[] visited = new Node[101]; // in this question we will create an array of Node(not boolean) why ? , because i have to add all the adjacent nodes of particular vertex, whether it\\'s visited or not, so in the Node[] initially null is stored, if that node is visited, we will store the respective node at the index, and can retrieve that easily.\\n        Arrays.fill(visited , null); // initially store null at all places\\n        dfs(node , copy , visited); // make a dfs call for traversing all the vertices of the root node\\n        return copy; // in the end return the copy node\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node , Node copy , Node[] visited){\\n        visited[copy.val] = copy;// store the current node at it\\'s val index which will tell us that this node is now visited\\n        \\n//         now traverse for the adjacent nodes of root node\\n        for(Node n : node.neighbors){\\n//             check whether that node is visited or not\\n//              if it is not visited, there must be null\\n            if(visited[n.val] == null){\\n//                 so now if it not visited, create a new node\\n                Node newNode = new Node(n.val);\\n//                 add this node as the neighbor of the prev copied node\\n                copy.neighbors.add(newNode);\\n//                 make dfs call for this unvisited node to discover whether it\\'s adjacent nodes are explored or not\\n                dfs(n , newNode , visited);\\n            }else{\\n//                 if that node is already visited, retrieve that node from visited array and add it as the adjacent node of prev copied node\\n//                 THIS IS THE POINT WHY WE USED NODE[] INSTEAD OF BOOLEAN[] ARRAY\\n                copy.neighbors.add(visited[n.val]);\\n            }\\n        }\\n        \\n    }\\n    public Node cloneGraph(Node node) {\\n        if(node == null) return null; // if the actual node is empty there is nothing to copy, so return null\\n        Node copy = new Node(node.val); // create a new node , with same value as the root node(given node)\\n        Node[] visited = new Node[101]; // in this question we will create an array of Node(not boolean) why ? , because i have to add all the adjacent nodes of particular vertex, whether it\\'s visited or not, so in the Node[] initially null is stored, if that node is visited, we will store the respective node at the index, and can retrieve that easily.\\n        Arrays.fill(visited , null); // initially store null at all places\\n        dfs(node , copy , visited); // make a dfs call for traversing all the vertices of the root node\\n        return copy; // in the end return the copy node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42313,
                "title": "c-bfs-dfs",
                "content": "To clone a graph, you will need to traverse it. Both BFS and DFS are for this purpose. But that is not all you need. To clone a graph, you need to have a copy of each node and you need to **avoid copying the same node for multiple times**. So you still need a mapping from an original node to its copy.\\n\\n**BFS**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return NULL;\\n        }\\n        Node* copy = new Node(node -> val, {});\\n        copies[node] = copy;\\n        queue<Node*> todo;\\n        todo.push(node);\\n        while (!todo.empty()) {\\n            Node* cur = todo.front();\\n            todo.pop();\\n            for (Node* neighbor : cur -> neighbors) {\\n                if (copies.find(neighbor) == copies.end()) {\\n                    copies[neighbor] = new Node(neighbor -> val, {});\\n                    todo.push(neighbor);\\n                }\\n                copies[cur] -> neighbors.push_back(copies[neighbor]);\\n            }\\n        }\\n        return copy;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\\n\\n**DFS**\\n\\nThe following succinct DFS code is taken from [this post](https://leetcode.com/problems/clone-graph/discuss/42362/9-line-c%2B%2B-DFS-Solution).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return NULL;\\n        }\\n        if (copies.find(node) == copies.end()) {\\n            copies[node] = new Node(node -> val, {});\\n            for (Node* neighbor : node -> neighbors) {\\n                copies[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return copies[node];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return NULL;\\n        }\\n        Node* copy = new Node(node -> val, {});\\n        copies[node] = copy;\\n        queue<Node*> todo;\\n        todo.push(node);\\n        while (!todo.empty()) {\\n            Node* cur = todo.front();\\n            todo.pop();\\n            for (Node* neighbor : cur -> neighbors) {\\n                if (copies.find(neighbor) == copies.end()) {\\n                    copies[neighbor] = new Node(neighbor -> val, {});\\n                    todo.push(neighbor);\\n                }\\n                copies[cur] -> neighbors.push_back(copies[neighbor]);\\n            }\\n        }\\n        return copy;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return NULL;\\n        }\\n        if (copies.find(node) == copies.end()) {\\n            copies[node] = new Node(node -> val, {});\\n            for (Node* neighbor : node -> neighbors) {\\n                copies[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return copies[node];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42309,
                "title": "depth-first-simple-java-solution",
                "content": "    public class Solution {\\n        private HashMap<Integer, UndirectedGraphNode> map = new HashMap<>();\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            return clone(node);\\n        }\\n    \\n        private UndirectedGraphNode clone(UndirectedGraphNode node) {\\n            if (node == null) return null;\\n            \\n            if (map.containsKey(node.label)) {\\n                return map.get(node.label);\\n            }\\n            UndirectedGraphNode clone = new UndirectedGraphNode(node.label);\\n            map.put(clone.label, clone);\\n            for (UndirectedGraphNode neighbor : node.neighbors) {\\n                clone.neighbors.add(clone(neighbor));\\n            }\\n            return clone;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private HashMap<Integer, UndirectedGraphNode> map = new HashMap<>();\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            return clone(node);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 42314,
                "title": "python-solutions-bfs-dfs-iteratively-dfs-recursively",
                "content": "```\\nclass Solution(object):\\n    # bfs\\n    def cloneGraph1(self, node):\\n        if not node:\\n            return node\\n        m, visited, queue = {}, set(), collections.deque([node])\\n        while queue:\\n            n = queue.popleft()\\n            if n in visited:\\n                continue\\n            visited.add(n)\\n            if n not in m:\\n                m[n] = Node(n.val)\\n            for neigh in n.neighbors:\\n                if neigh not in m:\\n                    m[neigh] = Node(neigh.val)\\n                m[n].neighbors.append(m[neigh])\\n                queue.append(neigh)\\n        return m[node]\\n    \\n    # dfs iteratively\\n    def cloneGraph2(self, node):\\n        if not node:\\n            return node\\n        m, visited, stack = dict(), set(), deque([node])\\n        while stack:\\n            n = stack.pop()\\n            if n in visited:\\n                continue\\n            visited.add(n)\\n            if n not in m:\\n                m[n] = Node(n.val)\\n            for neigh in n.neighbors:\\n                if neigh not in m:\\n                    m[neigh] = Node(neigh.val)\\n                m[n].neighbors.append(m[neigh])\\n                stack.append(neigh)\\n        return m[node]\\n    \\n    # dfs recursively \\n    def cloneGraph(self, node):\\n        if not node:\\n            return node\\n        m, visited = dict(), set()\\n        self.dfs(node, m, visited)\\n        return m[node]\\n        \\n    def dfs(self, n, m, visited):\\n        if n in visited:\\n            return \\n        visited.add(n)\\n        if n not in m:\\n            m[n] = Node(n.val)\\n        for neigh in n.neighbors:\\n            if neigh not in m:\\n                m[neigh] = Node(neigh.val)\\n            m[n].neighbors.append(m[neigh])\\n            self.dfs(neigh, m, visited)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    # bfs\\n    def cloneGraph1(self, node):\\n        if not node:\\n            return node\\n        m, visited, queue = {}, set(), collections.deque([node])\\n        while queue:\\n            n = queue.popleft()\\n            if n in visited:\\n                continue\\n            visited.add(n)\\n            if n not in m:\\n                m[n] = Node(n.val)\\n            for neigh in n.neighbors:\\n                if neigh not in m:\\n                    m[neigh] = Node(neigh.val)\\n                m[n].neighbors.append(m[neigh])\\n                queue.append(neigh)\\n        return m[node]\\n    \\n    # dfs iteratively\\n    def cloneGraph2(self, node):\\n        if not node:\\n            return node\\n        m, visited, stack = dict(), set(), deque([node])\\n        while stack:\\n            n = stack.pop()\\n            if n in visited:\\n                continue\\n            visited.add(n)\\n            if n not in m:\\n                m[n] = Node(n.val)\\n            for neigh in n.neighbors:\\n                if neigh not in m:\\n                    m[neigh] = Node(neigh.val)\\n                m[n].neighbors.append(m[neigh])\\n                stack.append(neigh)\\n        return m[node]\\n    \\n    # dfs recursively \\n    def cloneGraph(self, node):\\n        if not node:\\n            return node\\n        m, visited = dict(), set()\\n        self.dfs(node, m, visited)\\n        return m[node]\\n        \\n    def dfs(self, n, m, visited):\\n        if n in visited:\\n            return \\n        visited.add(n)\\n        if n not in m:\\n            m[n] = Node(n.val)\\n        for neigh in n.neighbors:\\n            if neigh not in m:\\n                m[neigh] = Node(neigh.val)\\n            m[n].neighbors.append(m[neigh])\\n            self.dfs(neigh, m, visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42319,
                "title": "simple-java-iterative-bfs-solution-with-hashmap-and-queue",
                "content": "Use HashMap to look up nodes and add connection to them while performing BFS.\\n\\n    public class Solution {\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            if (node == null) return null;\\n            \\n            UndirectedGraphNode newNode = new UndirectedGraphNode(node.label); //new node for return\\n            HashMap<Integer, UndirectedGraphNode> map = new HashMap(); //store visited nodes\\n            \\n            map.put(newNode.label, newNode); //add first node to HashMap\\n            \\n            LinkedList<UndirectedGraphNode> queue = new LinkedList(); //to store **original** nodes need to be visited\\n            queue.add(node); //add first **original** node to queue\\n            \\n            while (!queue.isEmpty()) { //if more nodes need to be visited\\n                UndirectedGraphNode n = queue.pop(); //search first node in the queue\\n                for (UndirectedGraphNode neighbor : n.neighbors) {\\n                    if (!map.containsKey(neighbor.label)) { //add to map and queue if this node hasn't been searched before\\n                        map.put(neighbor.label, new UndirectedGraphNode(neighbor.label));\\n                        queue.add(neighbor);\\n                    }\\n                    map.get(n.label).neighbors.add(map.get(neighbor.label)); //add neighbor to new created nodes\\n                }\\n            }\\n            \\n            return newNode;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            if (node == null) return null;\\n            \\n            UndirectedGraphNode newNode = new UndirectedGraphNode(node.label); //new node for return\\n            HashMap<Integer, UndirectedGraphNode> map = new HashMap(); //store visited nodes\\n            \\n            map.put(newNode.label, newNode); //add first node to HashMap\\n            \\n            LinkedList<UndirectedGraphNode> queue = new LinkedList(); //to store **original** nodes need to be visited\\n            queue.add(node); //add first **original** node to queue\\n            \\n            while (!queue.isEmpty()) { //if more nodes need to be visited\\n                UndirectedGraphNode n = queue.pop(); //search first node in the queue\\n                for (UndirectedGraphNode neighbor : n.neighbors) {\\n                    if (!map.containsKey(neighbor.label)) { //add to map and queue if this node hasn't been searched before\\n                        map.put(neighbor.label, new UndirectedGraphNode(neighbor.label));\\n                        queue.add(neighbor);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 42482,
                "title": "java-bfs-solution",
                "content": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a queue to help BFS\\n      Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\\n      queue.add(root);\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      while (!queue.isEmpty()) {\\n        UndirectedGraphNode node = queue.poll();\\n        \\n        // handle the neighbors\\n        for (UndirectedGraphNode neighbor : node.neighbors) {\\n          if (!map.containsKey(neighbor)) {\\n            // clone the neighbor\\n            map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n            // add it to the next level\\n            queue.add(neighbor);\\n          }\\n          \\n          // copy the neighbor\\n          map.get(node).neighbors.add(map.get(neighbor));\\n        }\\n      }\\n      \\n      return map.get(root);\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a queue to help BFS\\n      Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\\n      queue.add(root);\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      while (!queue.isEmpty()) {\\n        UndirectedGraphNode node = queue.poll();\\n        \\n        // handle the neighbors\\n        for (UndirectedGraphNode neighbor : node.neighbors) {\\n          if (!map.containsKey(neighbor)) {\\n            // clone the neighbor\\n            map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n            // add it to the next level\\n            queue.add(neighbor);\\n          }\\n          \\n          // copy the neighbor\\n          map.get(node).neighbors.add(map.get(neighbor));\\n        }\\n      }\\n      \\n      return map.get(root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 902767,
                "title": "python-dfs-recursive-solution-explained",
                "content": "When you see the problem about graph, the first thing you need to think about is some classical graph traversal: dfs or bfs. Usually, there are `3` options with same complexities you can choose from:\\n\\n1. Iterative dfs, that is dfs with stack\\n2. Recursive dfs, which is a bit simpler to code, but be careful if you have very deep graphs.\\n3. bfs - only iterative, there is no recursion version, because we use queue, not stack here.\\n\\nHere I choose method number 2 (because it is easy to code of course)\\n\\nLet us create global dictionary `mapping`, which will connect nodes from old graph with nodes from new graph and use recursive `dfs` function to construct these connections:\\n1. First, add connection `mapping[node] = Node(node.val)`\\n2. Traverse all neighbors of node and if node is not traversed, that is it is not in our `mapping`, then we run `dfs` for this neighbor. Also we add connection in new graph (we add it even if node is visited!)\\n\\n**Complexity**: time complexity is `O(E)`: this number of iterations we need for full dfs traversal. Space complexity is `O(E+V) = O(E)` for connected graph.\\n\\n```\\nclass Solution:\\n    def cloneGraph(self, node):\\n        def dfs(node):\\n            mapping[node] = Node(node.val)\\n            for neigh in node.neighbors:\\n                if neigh not in mapping: dfs(neigh)\\n                mapping[node].neighbors += [mapping[neigh]]\\n        \\n        if not node: return node\\n        mapping  = {}\\n        dfs(node)\\n        return mapping[node]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node):\\n        def dfs(node):\\n            mapping[node] = Node(node.val)\\n            for neigh in node.neighbors:\\n                if neigh not in mapping: dfs(neigh)\\n                mapping[node].neighbors += [mapping[neigh]]\\n        \\n        if not node: return node\\n        mapping  = {}\\n        dfs(node)\\n        return mapping[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42362,
                "title": "9-line-c-dfs-solution",
                "content": "The solution is same as https://oj.leetcode.com/discuss/22244/simple-c-solution-using-dfs-and-recursion\\nI just make it shorter;\\n\\n    /**\\n    *  author : s2003zy\\n    *  weibo  : http://weibo.com/songzy982\\n    *  blog   : s2003zy.com\\n    *  date   : 2015.02.27\\n    */\\n    class Solution {\\n    public:\\n        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> hash;\\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n           if (!node) return node;\\n           if(hash.find(node) == hash.end()) {\\n               hash[node] = new UndirectedGraphNode(node -> label);\\n               for (auto x : node -> neighbors) {\\n                    (hash[node] -> neighbors).push_back( cloneGraph(x) );\\n               }\\n           }\\n           return hash[node];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> hash;\\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n           if (!node) return node;\\n           if(hash.find(node) == hash.end()) {\\n               hash[node] = new UndirectedGraphNode(node -> label);\\n               for (auto x : node -> neighbors) {\\n                    (hash[node] -> neighbors).push_back( cloneGraph(x) );\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 42317,
                "title": "graph-representation",
                "content": "Problem statement says that this is an undirected graph, but how does the adjacency list correspond to it?\\n{0,1,2#1,2#2,2}\\nmeans that adjacency list for the give graph is:\\n\\n    0   1, 2\\n    1   2\\n    2   2\\n\\nIn an undirected graph, adjacency list for 1 should contain 0 as well, and 2 should contain 0 and 1. What I would expect is:\\n\\n    0   1, 2\\n    1   2, 0\\n    2   2, 0, 1\\n\\n\\nThe  first representation looks like directed graph, because there is an edge 0->1 but not 1->0.",
                "solutionTags": [],
                "code": "Problem statement says that this is an undirected graph, but how does the adjacency list correspond to it?\\n{0,1,2#1,2#2,2}\\nmeans that adjacency list for the give graph is:\\n\\n    0   1, 2\\n    1   2\\n    2   2\\n\\nIn an undirected graph, adjacency list for 1 should contain 0 as well, and 2 should contain 0 and 1. What I would expect is:\\n\\n    0   1, 2\\n    1   2, 0\\n    2   2, 0, 1\\n\\n\\nThe  first representation looks like directed graph, because there is an edge 0->1 but not 1->0.",
                "codeTag": "Unknown"
            },
            {
                "id": 494246,
                "title": "python-simple-bfs-dfs-with-detailed-explanation",
                "content": "\\nThis solution is inspired by @FranckNdame which can be found right -->  [here](https://leetcode.com/problems/clone-graph/discuss/493662/Python3-or-Simple-DFS-or-32ms-better-than-93.21-or-12.9mb-better-than-100http://)\\n\\n\\n**Idea**\\nThis problem is straightforward for the most part, however, the part that I struggled with is how to connect the nodes in the cloned graph together (SEE COMMENT [1]). Another issue I had was how to return the copy of the original input node once done cloning (SEE COMMENT [2]). Turns out that maintaining a dictipnary/hashmap that associates origianl node to its clone ``` {node: clone_node}``` makes this process very simple. This hashmap also serves as a ```visited``` set to make sure you don\\'t loop indefinitely while DFS/BFS\\n\\n![image](https://assets.leetcode.com/users/abadawi/image_1580399097.png)\\n\\n\\n**1. BFS**\\n\\n```\\n\\'\\'\\'\\nBFS - QUEUE\\n\\'\\'\\'\\n         if not node: return\\n         # map original nodes to their clones\\n         d = {node : Node(node.val)}\\n         q = deque([node])\\n        \\n         while q:\\n             for i in range(len(q)):\\n                 currNode = q.popleft()\\n                 for nei in currNode.neighbors:\\n                     if nei not in d:\\n                         # store copy of the neighboring node\\n                         d[nei] = Node(nei.val)\\n                         q.append(nei)\\n                     # connect the node copy at hand to its neighboring nodes (also copies) -------- [1]\\n                     d[currNode].neighbors.append(d[nei])\\n        \\n         # return copy of the starting node ------- [2]\\n         return d[node]\\n    \\n      \\n```\\n\\n\\n**2. DFS**\\n\\n```\\n \\'\\'\\'\\n DFS - STACK\\n \\'\\'\\'\\n        if not node: return\\n        d = {node: Node(node.val)}\\n        stack = [node]\\n        while stack:\\n            curNode = stack.pop()\\n            for nei in curNode.neighbors:\\n                if nei not in d:\\n                    d[nei] = Node(nei.val)\\n                    stack.append(nei)\\n                d[nei].neighbors.append(d[curNode])\\n        return d[node] # return the value of the original node which is a copy of that original node\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "``` {node: clone_node}```\n```visited```\n```\\n\\'\\'\\'\\nBFS - QUEUE\\n\\'\\'\\'\\n         if not node: return\\n         # map original nodes to their clones\\n         d = {node : Node(node.val)}\\n         q = deque([node])\\n        \\n         while q:\\n             for i in range(len(q)):\\n                 currNode = q.popleft()\\n                 for nei in currNode.neighbors:\\n                     if nei not in d:\\n                         # store copy of the neighboring node\\n                         d[nei] = Node(nei.val)\\n                         q.append(nei)\\n                     # connect the node copy at hand to its neighboring nodes (also copies) -------- [1]\\n                     d[currNode].neighbors.append(d[nei])\\n        \\n         # return copy of the starting node ------- [2]\\n         return d[node]\\n    \\n      \\n```\n```\\n \\'\\'\\'\\n DFS - STACK\\n \\'\\'\\'\\n        if not node: return\\n        d = {node: Node(node.val)}\\n        stack = [node]\\n        while stack:\\n            curNode = stack.pop()\\n            for nei in curNode.neighbors:\\n                if nei not in d:\\n                    d[nei] = Node(nei.val)\\n                    stack.append(nei)\\n                d[nei].neighbors.append(d[curNode])\\n        return d[node] # return the value of the original node which is a copy of that original node\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496599,
                "title": "java-tc-o-v-e-sc-o-v-both-bfs-dfs-solutions",
                "content": "```java\\n/**\\n * BFS - Iterative\\n *\\n * Time Complexity: O(V + E)\\n *\\n * Space Complexity: O(V). Both Queue and HashMap will take O(V) space\\n *\\n * V = Number of nodes. E = Number of edges in the graph.\\n */\\nclass Solution1 {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        HashMap<Node, Node> visited = new HashMap<>();\\n        Node newNode = new Node(node.val);\\n        visited.put(node, newNode);\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(node);\\n\\n        while (!queue.isEmpty()) {\\n            Node cur = queue.poll();\\n\\n            List<Node> newNeighbors = visited.get(cur).neighbors;\\n            for (Node n : cur.neighbors) {\\n                if (!visited.containsKey(n)) {\\n                    visited.put(n, new Node(n.val));\\n                    queue.offer(n);\\n                }\\n                newNeighbors.add(visited.get(n));\\n            }\\n        }\\n\\n        return newNode;\\n    }\\n}\\n\\n/**\\n * DFS - Recursive\\n *\\n * Time Complexity: O(V + E)\\n *\\n * Space Complexity: O(V). Both Recursion Stack and HashMap will take O(V) space\\n *\\n * V = Number of nodes. E = Number of edges in the graph.\\n */\\nclass Solution2 {\\n    public Node cloneGraph(Node node) {\\n        return cloneGraphDFSHelper(node, new HashMap<>());\\n    }\\n\\n    private Node cloneGraphDFSHelper(Node cur, HashMap<Node, Node> visited) {\\n        if (cur == null) {\\n            return null;\\n        }\\n        if (visited.containsKey(cur)) {\\n            return visited.get(cur);\\n        }\\n\\n        Node newNode = new Node(cur.val);\\n        visited.put(cur, newNode);\\n\\n        for (Node n : cur.neighbors) {\\n            newNode.neighbors.add(cloneGraphDFSHelper(n, visited));\\n        }\\n\\n        return newNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Queue"
                ],
                "code": "```java\\n/**\\n * BFS - Iterative\\n *\\n * Time Complexity: O(V + E)\\n *\\n * Space Complexity: O(V). Both Queue and HashMap will take O(V) space\\n *\\n * V = Number of nodes. E = Number of edges in the graph.\\n */\\nclass Solution1 {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        HashMap<Node, Node> visited = new HashMap<>();\\n        Node newNode = new Node(node.val);\\n        visited.put(node, newNode);\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(node);\\n\\n        while (!queue.isEmpty()) {\\n            Node cur = queue.poll();\\n\\n            List<Node> newNeighbors = visited.get(cur).neighbors;\\n            for (Node n : cur.neighbors) {\\n                if (!visited.containsKey(n)) {\\n                    visited.put(n, new Node(n.val));\\n                    queue.offer(n);\\n                }\\n                newNeighbors.add(visited.get(n));\\n            }\\n        }\\n\\n        return newNode;\\n    }\\n}\\n\\n/**\\n * DFS - Recursive\\n *\\n * Time Complexity: O(V + E)\\n *\\n * Space Complexity: O(V). Both Recursion Stack and HashMap will take O(V) space\\n *\\n * V = Number of nodes. E = Number of edges in the graph.\\n */\\nclass Solution2 {\\n    public Node cloneGraph(Node node) {\\n        return cloneGraphDFSHelper(node, new HashMap<>());\\n    }\\n\\n    private Node cloneGraphDFSHelper(Node cur, HashMap<Node, Node> visited) {\\n        if (cur == null) {\\n            return null;\\n        }\\n        if (visited.containsKey(cur)) {\\n            return visited.get(cur);\\n        }\\n\\n        Node newNode = new Node(cur.val);\\n        visited.put(cur, newNode);\\n\\n        for (Node n : cur.neighbors) {\\n            newNode.neighbors.add(cloneGraphDFSHelper(n, visited));\\n        }\\n\\n        return newNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404781,
                "title": "python-easy-clean-code",
                "content": "**PLEASE DO UPVOTE IF U GET THIS**\\n```\\n\\nclass Solution:\\n    \\n    def helper(self, node, visited):\\n        if node is None:\\n            return None\\n        \\n        newNode = Node(node.val)\\n        visited[node.val] = newNode\\n        \\n        for adjNode in node.neighbors:\\n            if adjNode.val not in visited:\\n                newNode.neighbors.append(self.helper(adjNode, visited))\\n            else:\\n                newNode.neighbors.append(visited[adjNode.val])\\n        \\n        return newNode\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        return self.helper(node, {})\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution:\\n    \\n    def helper(self, node, visited):\\n        if node is None:\\n            return None\\n        \\n        newNode = Node(node.val)\\n        visited[node.val] = newNode\\n        \\n        for adjNode in node.neighbors:\\n            if adjNode.val not in visited:\\n                newNode.neighbors.append(self.helper(adjNode, visited))\\n            else:\\n                newNode.neighbors.append(visited[adjNode.val])\\n        \\n        return newNode\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        return self.helper(node, {})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392096,
                "title": "image-explanation-bfs-dfs-colored-examples-code-c-java",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Clone Graph` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/049e0747-3254-41ef-99b0-b8eecf2c7e58_1680922934.4360454.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/031e61bd-49be-467c-8a3b-aa544b3e89f8_1680918830.5420208.png)\\n![image.png](https://assets.leetcode.com/users/images/6e851370-9bba-4294-9001-29753df3d02d_1680918854.9675906.png)\\n![image.png](https://assets.leetcode.com/users/images/3a35e990-4c4c-4509-b3d3-2836d6d9d07d_1680918866.6212337.png)\\n![image.png](https://assets.leetcode.com/users/images/80c232df-d8c5-473f-a8ec-e152e75ff6cd_1680918880.0702538.png)\\n![image.png](https://assets.leetcode.com/users/images/ba0b9904-a677-4b65-a43e-b1a0a5921b77_1680918893.9824536.png)\\n![image.png](https://assets.leetcode.com/users/images/eb15e176-daca-4c20-a1ae-ff88cca1f4fc_1680918904.5450613.png)\\n![image.png](https://assets.leetcode.com/users/images/3a1b4d07-51f7-408a-9444-29d0e5b18c98_1680918924.409639.png)\\n![image.png](https://assets.leetcode.com/users/images/f04bcade-e731-4e7a-8c8b-8bf0d1ba453b_1680918935.4300368.png)\\n![image.png](https://assets.leetcode.com/users/images/e35f7bca-a4c3-4a7e-8329-dffe9e6ab8ef_1680918947.2448053.png)\\n![image.png](https://assets.leetcode.com/users/images/625b586b-0227-4857-ad38-76bb6e07ef43_1680918960.8187852.png)\\n![image.png](https://assets.leetcode.com/users/images/db3a3baf-013f-4c63-a247-6a81ed580d18_1680918968.745915.png)\\n\\n\\n# BFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return NULL;\\n\\n        unordered_map<Node*, Node*> copies;\\n        Node* copy = new Node(node -> val, {});\\n        copies[node] = copy;\\n        queue<Node*> todo;\\n        todo.push(node);\\n        while (!todo.empty()) {\\n            Node* cur = todo.front();\\n            todo.pop();\\n            for (Node* neighbor : cur -> neighbors) {\\n                if (copies.find(neighbor) == copies.end()) {\\n                    copies[neighbor] = new Node(neighbor -> val, {});\\n                    todo.push(neighbor);\\n                }\\n                copies[cur] -> neighbors.push_back(copies[neighbor]);\\n            }\\n        }\\n        return copy;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n\\n        Node graph = new Node(node.val);\\n        HashMap<Node, Node> mp = new HashMap<>();\\n        mp.put(node, graph);\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(node);\\n        while (!queue.isEmpty()) {\\n            Node cur = queue.poll();\\n            for (Node val : cur.neighbors) {\\n                if (!mp.containsKey(val)) {\\n                    mp.put(val, new Node(val.val));\\n                    queue.offer(val);\\n                }\\n                mp.get(cur).neighbors.add(mp.get(val));\\n            }\\n        }\\n        return graph;\\n    }\\n}\\n```\\n\\n# DFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> copies;\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return NULL;\\n        \\n        if (copies.find(node) == copies.end()) {\\n            copies[node] = new Node(node -> val, {});\\n            for (Node* neighbor : node -> neighbors) {\\n                copies[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return copies[node];\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    HashMap<Node, Node> mp = new HashMap<>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n        if (mp.containsKey(node)) return mp.get(node);\\n\\n        mp.put(node, new Node(node.val));\\n        for (Node val : node.neighbors) {\\n            mp.get(node).neighbors.add(cloneGraph(val));\\n        }\\n\\n        return mp.get(node);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return NULL;\\n\\n        unordered_map<Node*, Node*> copies;\\n        Node* copy = new Node(node -> val, {});\\n        copies[node] = copy;\\n        queue<Node*> todo;\\n        todo.push(node);\\n        while (!todo.empty()) {\\n            Node* cur = todo.front();\\n            todo.pop();\\n            for (Node* neighbor : cur -> neighbors) {\\n                if (copies.find(neighbor) == copies.end()) {\\n                    copies[neighbor] = new Node(neighbor -> val, {});\\n                    todo.push(neighbor);\\n                }\\n                copies[cur] -> neighbors.push_back(copies[neighbor]);\\n            }\\n        }\\n        return copy;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n\\n        Node graph = new Node(node.val);\\n        HashMap<Node, Node> mp = new HashMap<>();\\n        mp.put(node, graph);\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(node);\\n        while (!queue.isEmpty()) {\\n            Node cur = queue.poll();\\n            for (Node val : cur.neighbors) {\\n                if (!mp.containsKey(val)) {\\n                    mp.put(val, new Node(val.val));\\n                    queue.offer(val);\\n                }\\n                mp.get(cur).neighbors.add(mp.get(val));\\n            }\\n        }\\n        return graph;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> copies;\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return NULL;\\n        \\n        if (copies.find(node) == copies.end()) {\\n            copies[node] = new Node(node -> val, {});\\n            for (Node* neighbor : node -> neighbors) {\\n                copies[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return copies[node];\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    HashMap<Node, Node> mp = new HashMap<>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n        if (mp.containsKey(node)) return mp.get(node);\\n\\n        mp.put(node, new Node(node.val));\\n        for (Node val : node.neighbors) {\\n            mp.get(node).neighbors.add(cloneGraph(val));\\n        }\\n\\n        return mp.get(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392175,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to perform a deep copy (clone) of the given graph. In a deep copy, we need to create a new instance of the graph that is independent of the original graph, and each of its nodes should have their copy.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo create a deep copy of a graph, we need to perform a traversal of the original graph and create a copy of each node we visit. We can use a depth-first search (DFS) approach for traversal of the graph. To ensure that we do not visit the same node twice, we can use a visited set.\\n\\nWe will start by creating an empty dictionary, where the keys will be the nodes of the original graph, and the values will be the corresponding nodes of the new graph. We can then use DFS to traverse the original graph and create the new graph. For each node, we create a copy of it and add it to the dictionary. We then recursively create the copies of all the neighbors of the node and add them to the neighbors list of the copy.\\n\\nTo ensure that we do not visit the same node twice, we can use a visited set to keep track of the nodes we have already visited.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(N+E), where N is the number of nodes and E is the number of edges in the graph. We traverse each node and edge once, and each operation takes O(1) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is also O(N+E). We use a dictionary to store the copies of the nodes, which takes O(N) space. We also use a visited set, which takes O(N) space in the worst case. Additionally, we need to store the neighbors of each node, which takes O(E) space.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        Map<Node, Node> visited = new HashMap<>();\\n        return cloneGraphHelper(node, visited);\\n    }\\n    \\n    private Node cloneGraphHelper(Node node, Map<Node, Node> visited) {\\n        Node copy = new Node(node.val);\\n        visited.put(node, copy);\\n        for (Node neighbor : node.neighbors) {\\n            if (visited.containsKey(neighbor)) {\\n                copy.neighbors.add(visited.get(neighbor));\\n            } else {\\n                Node neighborCopy = cloneGraphHelper(neighbor, visited);\\n                copy.neighbors.add(neighborCopy);\\n            }\\n        }\\n        return copy;\\n    }\\n}\\n```\\n\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        unordered_map<Node*, Node*> nodeMap;\\n        return clone(node, nodeMap);\\n    }\\n    \\n    Node* clone(Node* node, unordered_map<Node*, Node*>& nodeMap) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        if (nodeMap.count(node) > 0) {\\n            return nodeMap[node];\\n        }\\n        Node* cloneNode = new Node(node->val);\\n        nodeMap[node] = cloneNode;\\n        for (Node* neighbor : node->neighbors) {\\n            cloneNode->neighbors.push_back(clone(neighbor, nodeMap));\\n        }\\n        return cloneNode;\\n    }\\n};\\n```\\n\\n```Python []\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return None\\n        \\n        cloned = {}\\n        stack = [node]\\n        cloned[node] = Node(node.val)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            \\n            for neighbor in curr.neighbors:\\n                if neighbor not in cloned:\\n                    cloned[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n                \\n                cloned[curr].neighbors.append(cloned[neighbor])\\n        \\n        return cloned[node]\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        Map<Node, Node> visited = new HashMap<>();\\n        return cloneGraphHelper(node, visited);\\n    }\\n    \\n    private Node cloneGraphHelper(Node node, Map<Node, Node> visited) {\\n        Node copy = new Node(node.val);\\n        visited.put(node, copy);\\n        for (Node neighbor : node.neighbors) {\\n            if (visited.containsKey(neighbor)) {\\n                copy.neighbors.add(visited.get(neighbor));\\n            } else {\\n                Node neighborCopy = cloneGraphHelper(neighbor, visited);\\n                copy.neighbors.add(neighborCopy);\\n            }\\n        }\\n        return copy;\\n    }\\n}\\n```\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        unordered_map<Node*, Node*> nodeMap;\\n        return clone(node, nodeMap);\\n    }\\n    \\n    Node* clone(Node* node, unordered_map<Node*, Node*>& nodeMap) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        if (nodeMap.count(node) > 0) {\\n            return nodeMap[node];\\n        }\\n        Node* cloneNode = new Node(node->val);\\n        nodeMap[node] = cloneNode;\\n        for (Node* neighbor : node->neighbors) {\\n            cloneNode->neighbors.push_back(clone(neighbor, nodeMap));\\n        }\\n        return cloneNode;\\n    }\\n};\\n```\n```Python []\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return None\\n        \\n        cloned = {}\\n        stack = [node]\\n        cloned[node] = Node(node.val)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            \\n            for neighbor in curr.neighbors:\\n                if neighbor not in cloned:\\n                    cloned[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n                \\n                cloned[curr].neighbors.append(cloned[neighbor])\\n        \\n        return cloned[node]\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42459,
                "title": "javascript-solution",
                "content": "    function cloneGraph(graph) {\\n      var map = {};\\n      return traverse(graph);\\n    \\n      function traverse(node) {\\n        if (!node) return node;\\n        if (!map[node.label]) {\\n          map[node.label] = new UndirectedGraphNode(node.label);\\n          map[node.label].neighbors = node.neighbors.map(traverse);\\n        }\\n        return map[node.label];\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function cloneGraph(graph) {\\n      var map = {};\\n      return traverse(graph);\\n    \\n      function traverse(node) {\\n        if (!node) return node;\\n        if (!map[node.label]) {\\n          map[node.label] = new UndirectedGraphNode(node.label);\\n          map[node.label].neighbors = node.neighbors.map(traverse);\\n        }\\n        return map[node.label];\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42354,
                "title": "python-dfs-short-solution",
                "content": "Use a dictionary to store the UndirectedGraphNode\\n\\n    def cloneGraph(self, node):\\n        if not node:\\n            return node\\n        root = UndirectedGraphNode(node.label)\\n        stack = [node]\\n        visit = {}\\n        visit[node.label] = root\\n        while stack:\\n            top = stack.pop()\\n        \\n            for n in top.neighbors:\\n                if n.label not in visit:\\n                    stack.append(n)\\n                    visit[n.label] = UndirectedGraphNode(n.label)\\n                visit[top.label].neighbors.append(visit[n.label])\\n        \\n        return root",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "Use a dictionary to store the UndirectedGraphNode\\n\\n    def cloneGraph(self, node):\\n        if not node:\\n            return node\\n        root = UndirectedGraphNode(node.label)\\n        stack = [node]\\n        visit = {}\\n        visit[node.label] = root\\n        while stack:\\n            top = stack.pop()\\n        \\n            for n in top.neighbors:\\n                if n.label not in visit:\\n                    stack.append(n)\\n                    visit[n.label] = UndirectedGraphNode(n.label)\\n                visit[top.label].neighbors.append(visit[n.label])\\n        \\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1096141,
                "title": "javascript-bfs-solution-w-comments",
                "content": "```\\nvar cloneGraph = function(node) {\\n    // If start node is null then we can\\'t do any cloning\\n    let start = node; \\n    if (start === null) return null;\\n    // vertexMap is the original node reference to our node\\n    const vertexMap = new Map(); \\n    \\n    \\n    // Add the start node to the queue. Give the start node a clone in the vertex map\\n    const queue = [start]\\n    vertexMap.set(start, new Node(start.val)); \\n    \\n    /*\\n    * Breadth first search continues until we process all the vertices in the graph\\n    * In the original graph. We know this is done when queue is empty\\n    */\\n    \\n    while (queue.length > 0) {\\n        // We grab a node. We will express all of the edges coming off of this node.\\n        const currentVertex = queue.shift(); \\n        // Iterate over all adjacents.\\n        for (const neighbor of currentVertex.neighbors) {\\n          // Has this neighbor been given a clone?\\n            if (!vertexMap.has(neighbor)) {\\n                /*\\n                * No? Give it a mapping and add the original neighbor to the search queue so we\\n                * can express ITS edges later\\n                */\\n                vertexMap.set(neighbor, new Node(neighbor.val))\\n                queue.push(neighbor); \\n            }\\n            \\n            /*\\n            * Draw the edge from currVertex\\'s clone to neighbor\\'s clone. Do you see how our\\n            * hashtable makes this quick access possible?\\n            */\\n            vertexMap.get(currentVertex).neighbors.push(vertexMap.get(neighbor)); \\n        }\\n    }\\n   return vertexMap.get(start); \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cloneGraph = function(node) {\\n    // If start node is null then we can\\'t do any cloning\\n    let start = node; \\n    if (start === null) return null;\\n    // vertexMap is the original node reference to our node\\n    const vertexMap = new Map(); \\n    \\n    \\n    // Add the start node to the queue. Give the start node a clone in the vertex map\\n    const queue = [start]\\n    vertexMap.set(start, new Node(start.val)); \\n    \\n    /*\\n    * Breadth first search continues until we process all the vertices in the graph\\n    * In the original graph. We know this is done when queue is empty\\n    */\\n    \\n    while (queue.length > 0) {\\n        // We grab a node. We will express all of the edges coming off of this node.\\n        const currentVertex = queue.shift(); \\n        // Iterate over all adjacents.\\n        for (const neighbor of currentVertex.neighbors) {\\n          // Has this neighbor been given a clone?\\n            if (!vertexMap.has(neighbor)) {\\n                /*\\n                * No? Give it a mapping and add the original neighbor to the search queue so we\\n                * can express ITS edges later\\n                */\\n                vertexMap.set(neighbor, new Node(neighbor.val))\\n                queue.push(neighbor); \\n            }\\n            \\n            /*\\n            * Draw the edge from currVertex\\'s clone to neighbor\\'s clone. Do you see how our\\n            * hashtable makes this quick access possible?\\n            */\\n            vertexMap.get(currentVertex).neighbors.push(vertexMap.get(neighbor)); \\n        }\\n    }\\n   return vertexMap.get(start); \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902670,
                "title": "c-java-python-dfs-clean-concise-o-n",
                "content": "<iframe src=\"https://leetcode.com/playground/nQaqfTvq/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M + N)` where `N` is the number of nodes and `M` is the number of edges.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/nQaqfTvq/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M + N)` where `N` is the number of nodes and `M` is the number of edges.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1792812,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* Create a value to `Node` hash-map for visited nodes to avoid repeat processing nodes\\n* Create a new node in each recursive call if already not in the map (cache-miss). Return from map in case it does exist (cache-hit)\\n* Recurse (DFS) for each neighbor of the original node and add the clone-neighbor to the clone node\\n* [LC 1490. Clone N-ary Tree](https://leetcode.com/problems/clone-n-ary-tree/discuss/1793459/Java-or-Simple-or-Reuse-LC-133-or-Explained) is near identical to this problem. I\\'d recommend solving that after this for practice.\\n>**T/S:** O(n\\xB2)/O(n), where n = number of nodes in graph\\n```\\npublic Node cloneGraph(Node node) {\\n\\treturn (node == null) ? null : cloneGraph(node, new HashMap<>());\\n}\\n\\nprivate Node cloneGraph(Node node, Map<Integer, Node> nodeByVal) {\\n\\tif (nodeByVal.containsKey(node.val))\\n\\t\\treturn nodeByVal.get(node.val);\\n\\n\\tvar clone = nodeByVal.computeIfAbsent(node.val, k -> new Node(node.val));\\n\\tfor (var neighbor : node.neighbors)\\n\\t\\tclone.neighbors.add(cloneGraph(neighbor, nodeByVal));\\n\\t\\t\\n\\treturn clone;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic Node cloneGraph(Node node) {\\n\\treturn (node == null) ? null : cloneGraph(node, new HashMap<>());\\n}\\n\\nprivate Node cloneGraph(Node node, Map<Integer, Node> nodeByVal) {\\n\\tif (nodeByVal.containsKey(node.val))\\n\\t\\treturn nodeByVal.get(node.val);\\n\\n\\tvar clone = nodeByVal.computeIfAbsent(node.val, k -> new Node(node.val));\\n\\tfor (var neighbor : node.neighbors)\\n\\t\\tclone.neighbors.add(cloneGraph(neighbor, nodeByVal));\\n\\t\\t\\n\\treturn clone;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902692,
                "title": "python-by-dfs-w-diagram",
                "content": "Python by DFS.\\n\\n---\\n\\n**Review**:\\n\\nThis one is very similar to [Leetcode #138 Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)\\n\\nThe key idea behind is the same:\\n1. Create **deep copy for each node**, and **maintain the mapping relation**\\n![image](https://assets.leetcode.com/users/images/38bb4d11-8e1f-458f-ad7a-777a986f6897_1603180412.259184.png)\\n\\n\\n2. **Rebuild node linkage** by mapping relation\\n![image](https://assets.leetcode.com/users/images/d6bf4b24-ddc9-40c3-9ebd-446efad0db6d_1603180429.2965417.png)\\n\\n\\n---\\n\\n**Hint**:\\n\\nStage_1:\\n\\nCreate **deep copy for each node** in DFS\\nMaintain a **mapping relation** (i.e., hash map or dictionary) between **original ones** and **deep-copy ones**.\\n\\n---\\n\\nStage_2:\\n\\n**Rebuild neighbor list** in DFS with mapping relation.\\n\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        \\n        # key: memory id of original node\\n        # value: corresponding deep copy node\\n        mapping = {}\\n        \\n        # -----------------------------------------\\n        def helper( node: \\'Node\\' ) -> \\'Node\\':\\n            \\n            if not node:\\n    \\n                # empty node\\'s deep copy is still empty node\\n                return node\\n            \\n            elif id(node) in mapping:\\n                \\n                # current node already has deep copy\\n                return mapping[ id(node) ]\\n            \\n            # create deep copy for current node\\n            mapping[ id(node) ] = Node( val=node.val, neighbors=[] )\\n            \\n            for original_neighbor in node.neighbors:\\n                # update neighbor list for current node\\n                mapping[ id(node) ].neighbors.append( helper(original_neighbor) )\\n            \\n            return  mapping[ id(node) ]\\n        \\n        # -----------------------------------------\\n        return helper( node )\\n```\\n\\n---\\n\\nShare another implementation with stage 1 and stage 2 individually\\n\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        \\n\\t\\t## dictionary for mapping relation\\n\\t\\t# key: memory ID of original node\\n\\t\\t# value: corresponding deep-copy node\\n        mapping = {}\\n        \\n\\t\\t# record of nodes whose neighbor list has been rebuilt\\n        rebuild = set()\\n        \\n        # -----------------------------------------------------------\\n        \\n        def dfs_copy( node ):\\n            \\n            if id(node) in mapping:\\n                \\n                # current node has deep copy already\\n                return\\n            \\n            # create deep copy of current node\\n            mapping[id(node)] = Node(val=node.val, neighbors=[])\\n            \\n            for ori_neighbor in node.neighbors:\\n                \\n                # create deep copy for original neighbors\\n                dfs_copy( ori_neighbor )\\n                \\n        # -----------------------------------------------------------\\n        \\n        def dfs_rebuild_neighbor( node ):\\n            \\n            if node in rebuild:\\n                \\n                # neighbor list has been rebuilt already\\n                return\\n            \\n            for ori_neighbor in node.neighbors:\\n                # rebuild neighbor for deep-copy nodes\\n                mapping[id(node)].neighbors.append( mapping[id(ori_neighbor)] )\\n            \\n            # current node has been rebuilt with neighbors of deep-copy\\n            rebuild.add( node )\\n            \\n            for ori_neighbor in node.neighbors:\\n                # rebuild neighbor list in dfs\\n                dfs_rebuild_neighbor( ori_neighbor )\\n        \\n        # -----------------------------------------------------------\\n        \\n        if node:\\n            \\n            # non-empty node\\n\\t\\t\\t\\n\\t\\t\\t# create deep-copy and maintain mapping relation\\n            dfs_copy( node )\\n\\t\\t\\t\\n\\t\\t\\t# rebuild neighbor list\\n            dfs_rebuild_neighbor( node )\\n\\t\\t\\t\\n            return mapping[ id(node) ]\\n        \\n        else:\\n            \\n            # empty node (i.e., empty graph)\\n            return None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        \\n        # key: memory id of original node\\n        # value: corresponding deep copy node\\n        mapping = {}\\n        \\n        # -----------------------------------------\\n        def helper( node: \\'Node\\' ) -> \\'Node\\':\\n            \\n            if not node:\\n    \\n                # empty node\\'s deep copy is still empty node\\n                return node\\n            \\n            elif id(node) in mapping:\\n                \\n                # current node already has deep copy\\n                return mapping[ id(node) ]\\n            \\n            # create deep copy for current node\\n            mapping[ id(node) ] = Node( val=node.val, neighbors=[] )\\n            \\n            for original_neighbor in node.neighbors:\\n                # update neighbor list for current node\\n                mapping[ id(node) ].neighbors.append( helper(original_neighbor) )\\n            \\n            return  mapping[ id(node) ]\\n        \\n        # -----------------------------------------\\n        return helper( node )\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        \\n\\t\\t## dictionary for mapping relation\\n\\t\\t# key: memory ID of original node\\n\\t\\t# value: corresponding deep-copy node\\n        mapping = {}\\n        \\n\\t\\t# record of nodes whose neighbor list has been rebuilt\\n        rebuild = set()\\n        \\n        # -----------------------------------------------------------\\n        \\n        def dfs_copy( node ):\\n            \\n            if id(node) in mapping:\\n                \\n                # current node has deep copy already\\n                return\\n            \\n            # create deep copy of current node\\n            mapping[id(node)] = Node(val=node.val, neighbors=[])\\n            \\n            for ori_neighbor in node.neighbors:\\n                \\n                # create deep copy for original neighbors\\n                dfs_copy( ori_neighbor )\\n                \\n        # -----------------------------------------------------------\\n        \\n        def dfs_rebuild_neighbor( node ):\\n            \\n            if node in rebuild:\\n                \\n                # neighbor list has been rebuilt already\\n                return\\n            \\n            for ori_neighbor in node.neighbors:\\n                # rebuild neighbor for deep-copy nodes\\n                mapping[id(node)].neighbors.append( mapping[id(ori_neighbor)] )\\n            \\n            # current node has been rebuilt with neighbors of deep-copy\\n            rebuild.add( node )\\n            \\n            for ori_neighbor in node.neighbors:\\n                # rebuild neighbor list in dfs\\n                dfs_rebuild_neighbor( ori_neighbor )\\n        \\n        # -----------------------------------------------------------\\n        \\n        if node:\\n            \\n            # non-empty node\\n\\t\\t\\t\\n\\t\\t\\t# create deep-copy and maintain mapping relation\\n            dfs_copy( node )\\n\\t\\t\\t\\n\\t\\t\\t# rebuild neighbor list\\n            dfs_rebuild_neighbor( node )\\n\\t\\t\\t\\n            return mapping[ id(node) ]\\n        \\n        else:\\n            \\n            # empty node (i.e., empty graph)\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714323,
                "title": "c-dfs-and-bfs-solutions-with-step-by-step-explanations",
                "content": "The steps are simple. \\n\\n1. Check if root is NULL. return if yes \\n// Visited hashmap is needed to prevent cycles. Example, consider a undirected rectangle shape graph from A->B->C->D->A. If we dont\\' keep visited, it will keep on going.\\n2. If no, clone the node and add the entry pair to hashmap as `visited[node] = clonedNode;`\\n3. Iterate over neighbours and do dfs for each. While we are looping over this neighbour list, we can also fill neighbours of cloned node with the result from recursive calls.\\n4. Return clonedNode at each recursive call\\n\\n**DFS Solution**\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> visited;\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL)\\n            return node;\\n        if(visited[node])\\n            return visited[node];\\n        \\n        Node* cloned = new Node(node->val);\\n        visited[node] = cloned;\\n        \\n        for(auto nei: node->neighbors){\\n            cloned->neighbors.push_back(cloneGraph(nei));\\n        }\\n        return cloned;\\n        \\n    }\\n};\\n```\\n\\nSteps for BFS are almost same. Most of the things are relatable if you have studied trees level order traversal.\\n\\nSo instead of the stack here, we use queue to process the nodes and their neighbours.\\nvariable `curr` serves as the present root. We iterate over its children in the same way. \\nInside the neigbour loop, if the neighbour is not visited, we do two things\\n1. Clone the neighbour and Put the entry of `<neighbour, clonedNeighbour>` into `visited` hashmap.\\n2. push the neighbour into queue. This is to process the children of the neighbours children in future iterations over queue.\\n\\nWe fill the neigbours vector/list in the same way.\\n**BFS Solution**\\n\\n```\\nNode* cloneGraph(Node* node){\\n        if(node == NULL)\\n            return node;\\n        unordered_map<Node*, Node*> visited;\\n        queue<Node*> Q;\\n        Q.push(node);\\n        visited[node] = new Node(node->val);\\n        while(!Q.empty()){\\n            int n = Q.size();\\n            Node* curr = Q.front();\\n            Q.pop();\\n            for(auto nei: curr->neighbors){\\n                if(!visited[nei]){\\n                     visited[nei] = new Node(nei->val);\\n                     Q.push(nei);\\n                }\\n                visited[curr]->neighbors.push_back(visited[nei]);\\n            }\\n        }\\n        return visited[node];\\n\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> visited;\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL)\\n            return node;\\n        if(visited[node])\\n            return visited[node];\\n        \\n        Node* cloned = new Node(node->val);\\n        visited[node] = cloned;\\n        \\n        for(auto nei: node->neighbors){\\n            cloned->neighbors.push_back(cloneGraph(nei));\\n        }\\n        return cloned;\\n        \\n    }\\n};\\n```\n```\\nNode* cloneGraph(Node* node){\\n        if(node == NULL)\\n            return node;\\n        unordered_map<Node*, Node*> visited;\\n        queue<Node*> Q;\\n        Q.push(node);\\n        visited[node] = new Node(node->val);\\n        while(!Q.empty()){\\n            int n = Q.size();\\n            Node* curr = Q.front();\\n            Q.pop();\\n            for(auto nei: curr->neighbors){\\n                if(!visited[nei]){\\n                     visited[nei] = new Node(nei->val);\\n                     Q.push(nei);\\n                }\\n                visited[curr]->neighbors.push_back(visited[nei]);\\n            }\\n        }\\n        return visited[node];\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42481,
                "title": "java-dfs-solution-iterative",
                "content": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a stack to help DFS\\n      Stack<UndirectedGraphNode> stack = new Stack<UndirectedGraphNode>();\\n      stack.push(root);\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      while (!stack.isEmpty()) {\\n        UndirectedGraphNode node = stack.pop();\\n        \\n        // handle the neighbors\\n        for (UndirectedGraphNode neighbor : node.neighbors) {\\n          if (!map.containsKey(neighbor)) {\\n            // clone the neighbor\\n            map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n            // add it to the next level\\n            stack.push(neighbor);\\n          }\\n          \\n          // copy the neighbor\\n          map.get(node).neighbors.add(map.get(neighbor));\\n        }\\n      }\\n      \\n      return map.get(root);\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a stack to help DFS\\n      Stack<UndirectedGraphNode> stack = new Stack<UndirectedGraphNode>();\\n      stack.push(root);\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      while (!stack.isEmpty()) {\\n        UndirectedGraphNode node = stack.pop();\\n        \\n        // handle the neighbors\\n        for (UndirectedGraphNode neighbor : node.neighbors) {\\n          if (!map.containsKey(neighbor)) {\\n            // clone the neighbor\\n            map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n            // add it to the next level\\n            stack.push(neighbor);\\n          }\\n          \\n          // copy the neighbor\\n          map.get(node).neighbors.add(map.get(neighbor));\\n        }\\n      }\\n      \\n      return map.get(root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3391957,
                "title": "explained-code-with-comments-easy-bfs-queue-implementation",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- ### Use map and queue to make clone of graph. map is used to store the cloned node with original node as key so that whenever we approch original node, we can access it\\'s duplicate node also. \\n- ### Queue is used to implement bfs. We add the original node to a queue to keep track of which nodes we still need to visit. For each neighbor of the current node, we check if we have already visited it or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        map<Node*,Node*>m;\\n        \\n        if(node == NULL)\\n        {\\n            return NULL;\\n        }\\n\\n        // make clone of root node\\n        Node* root = new Node(node->val);\\n        m[node] = root;\\n\\n        queue<Node*>q;\\n        q.push(node);\\n\\n        while(!q.empty())\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n\\n            // we traverse through neighbors of original node\\n            for(Node* it : c->neighbors)\\n            {\\n                // if duplicate node of current node is present then we make a new one \\n                // and also add it in map and queue as it is not visited previously\\n                if(m.find(it) == m.end())\\n                {\\n                    Node* k = new Node(it->val);\\n                    m[it] = k;\\n                    q.push(it);\\n                }\\n                // connect duplicate node with its duplicate neighbors.\\n                m[c] -> neighbors.push_back(m[it]);\\n            }\\n        }\\n        return m[node];\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/36bf0cb9-9dc3-4377-9ae3-233a71916dad_1680912111.7851627.png)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        map<Node*,Node*>m;\\n        \\n        if(node == NULL)\\n        {\\n            return NULL;\\n        }\\n\\n        // make clone of root node\\n        Node* root = new Node(node->val);\\n        m[node] = root;\\n\\n        queue<Node*>q;\\n        q.push(node);\\n\\n        while(!q.empty())\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n\\n            // we traverse through neighbors of original node\\n            for(Node* it : c->neighbors)\\n            {\\n                // if duplicate node of current node is present then we make a new one \\n                // and also add it in map and queue as it is not visited previously\\n                if(m.find(it) == m.end())\\n                {\\n                    Node* k = new Node(it->val);\\n                    m[it] = k;\\n                    q.push(it);\\n                }\\n                // connect duplicate node with its duplicate neighbors.\\n                m[c] -> neighbors.push_back(m[it]);\\n            }\\n        }\\n        return m[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902840,
                "title": "c-dfs-solution-explained-100-time-99-space",
                "content": "This is a pretty straightforward solution, if you have some familiarity with a DFS approach; but I enjoyed how elegantly it all came together - and I think that is important to write code you like to read and use, as it helps you boost your confidence and makes other people more willingly read and use it as well :)\\n\\nFirst of all, in order to proceed, we can create `nodes`, an array of `Node` pointers, all with `NULL` value (I used `0` here just to make things more concise); noticee that we created `101` elements since the we know we will have up to `100` different nodes, each with a value matching its order; I might have created one less cell in the array, but this small memory consumption saves us the hassle of converting all the 1-indexed values into 0-indexed positions.\\n\\nThen in our core function we just check if `node` is not `NULL`:\\n* if it is, we move on and just return `nodes[1]`, which would similarly be `NULL`;\\n* if it is not, we call `createNode` passing `node` as a sole parameter - this will populate `nodes` and, then again, we can return `nodes[1]`.\\n\\nBut how does `createNode` behaves?\\n\\nFirst of all checks if we already had that node that we want to create - ie: the value of `nodes` at position `originalNode->val` is not `NULL`. If it is not there yet, we create it.\\n\\nThen, knowing that now we have it for sure, we proceed to populate it with neighbours (and I had my code falling again, since I keep using the UK spelling for it: I will never learn to unlearn it <_<) for every neighbour of `originalNode`, we first of all check if we already have it, otherwise we will create it.\\n\\nNotice that we are not using the `new` constructor here: we are creating it with recursive calls to `createNode`, so that the missing node will be not just created, but also recursively populated with all its neighbours, same for the neighbours of its neighbours and so on.\\n\\nNow that again we are sure the neighbouring node exist, we just push it in the `->neighbors` property of the node we just created at the previous step and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // our initial blank slate\\n    Node* nodes[101] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    void createNode(Node *originalNode) {\\n        // checking if we already created that node\\n\\t\\tif (!nodes[originalNode->val]) {\\n            nodes[originalNode->val] = new Node(originalNode->val);\\n        }\\n\\t\\t// adding neighbours\\n        for (auto n: originalNode->neighbors) {\\n            // checking if the neighbour exist, otherwise we create it\\n            if (!nodes[n->val]) createNode(n);\\n            // adding the neighbour\\n            nodes[originalNode->val]->neighbors.push_back(nodes[n->val]);\\n        }\\n    }\\n    Node* cloneGraph(Node* node) {\\n        if (node) createNode(node);\\n        return nodes[1];\\n    }\\n};\\n```\\n\\nAlternative version that has `createNode` actually returning new nodes - for some reason that eludes me at the moment (the compiler properly optimising tail recursion, maybe?) this performed a bit better than the previous:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // our initial blank slate\\n    Node* nodes[101] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    Node* createNode(Node *originalNode) {\\n        // checking if we already created that node\\n\\t\\tif (!nodes[originalNode->val]) {\\n            nodes[originalNode->val] = new Node(originalNode->val);\\n        }\\n\\t\\t// adding neighbours\\n        for (auto n: originalNode->neighbors) {\\n            // checking if the neighbour exist, otherwise we create it\\n            if (!nodes[n->val]) nodes[n->val] = createNode(n);\\n            // adding the neighbour\\n            nodes[originalNode->val]->neighbors.push_back(nodes[n->val]);\\n        }\\n        return nodes[originalNode->val];\\n    }\\n    Node* cloneGraph(Node* node) {\\n        if (node) nodes[1] = createNode(node);\\n        return nodes[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // our initial blank slate\\n    Node* nodes[101] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    void createNode(Node *originalNode) {\\n        // checking if we already created that node\\n\\t\\tif (!nodes[originalNode->val]) {\\n            nodes[originalNode->val] = new Node(originalNode->val);\\n        }\\n\\t\\t// adding neighbours\\n        for (auto n: originalNode->neighbors) {\\n            // checking if the neighbour exist, otherwise we create it\\n            if (!nodes[n->val]) createNode(n);\\n            // adding the neighbour\\n            nodes[originalNode->val]->neighbors.push_back(nodes[n->val]);\\n        }\\n    }\\n    Node* cloneGraph(Node* node) {\\n        if (node) createNode(node);\\n        return nodes[1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // our initial blank slate\\n    Node* nodes[101] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    Node* createNode(Node *originalNode) {\\n        // checking if we already created that node\\n\\t\\tif (!nodes[originalNode->val]) {\\n            nodes[originalNode->val] = new Node(originalNode->val);\\n        }\\n\\t\\t// adding neighbours\\n        for (auto n: originalNode->neighbors) {\\n            // checking if the neighbour exist, otherwise we create it\\n            if (!nodes[n->val]) nodes[n->val] = createNode(n);\\n            // adding the neighbour\\n            nodes[originalNode->val]->neighbors.push_back(nodes[n->val]);\\n        }\\n        return nodes[originalNode->val];\\n    }\\n    Node* cloneGraph(Node* node) {\\n        if (node) nodes[1] = createNode(node);\\n        return nodes[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902761,
                "title": "c-simplest-and-shortest-recursive-solution-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* rec(Node* node) {\\n        if (m_map.find(node->val) != m_map.end())\\n            return m_map[node->val];\\n        \\n        Node* new_node = new Node(node->val);\\n        m_map[node->val] = new_node;\\n        for (auto neighbor : node->neighbors) \\n            new_node->neighbors.push_back(rec(neighbor));\\n        return new_node;\\n    }\\n    \\n    Node* cloneGraph(Node* node) {\\n        if (!node)\\n            return NULL;\\n        return rec(node);\\n    }\\n    \\nprivate:\\n    unordered_map<int, Node*> m_map;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* rec(Node* node) {\\n        if (m_map.find(node->val) != m_map.end())\\n            return m_map[node->val];\\n        \\n        Node* new_node = new Node(node->val);\\n        m_map[node->val] = new_node;\\n        for (auto neighbor : node->neighbors) \\n            new_node->neighbors.push_back(rec(neighbor));\\n        return new_node;\\n    }\\n    \\n    Node* cloneGraph(Node* node) {\\n        if (!node)\\n            return NULL;\\n        return rec(node);\\n    }\\n    \\nprivate:\\n    unordered_map<int, Node*> m_map;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616376,
                "title": "intuitive-javascript-solution-with-dfs",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n  if (node === null) {\\n    return null;\\n  }\\n  const map = new Map();\\n  const clone = root => {\\n    if (!map.has(root.val)) {\\n      map.set(root.val, new Node(root.val));\\n      map.get(root.val).neighbors = root.neighbors.map(clone);\\n    }\\n    return map.get(root.val);\\n  }\\n  return clone(node);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n  if (node === null) {\\n    return null;\\n  }\\n  const map = new Map();\\n  const clone = root => {\\n    if (!map.has(root.val)) {\\n      map.set(root.val, new Node(root.val));\\n      map.get(root.val).neighbors = root.neighbors.map(clone);\\n    }\\n    return map.get(root.val);\\n  }\\n  return clone(node);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392017,
                "title": "java-easy-solution-with-explanation-100-faster-code",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\n\\nclass Solution {\\n    Node[] copyNodes = new Node[100];\\n    \\n    public Node cloneGraph(Node node) \\n    {\\n        if (node == null) return null; // stupid null nodes\\n        \\n        int ind = node.val-1; // So I don\\'t have to write \"node.val-1\" all the time\\n        if (copyNodes[ind] == null) \\n        {\\n            copyNodes[ind] = new Node(node.val); \\n            for (Node neighbor : node.neighbors) \\n                copyNodes[ind].neighbors.add(cloneGraph(neighbor));\\n        }\\n        return copyNodes[ind]; // Just return the copied node if it exists.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    Node[] copyNodes = new Node[100];\\n    \\n    public Node cloneGraph(Node node) \\n    {\\n        if (node == null) return null; // stupid null nodes\\n        \\n        int ind = node.val-1; // So I don\\'t have to write \"node.val-1\" all the time\\n        if (copyNodes[ind] == null) \\n        {\\n            copyNodes[ind] = new Node(node.val); \\n            for (Node neighbor : node.neighbors) \\n                copyNodes[ind].neighbors.add(cloneGraph(neighbor));\\n        }\\n        return copyNodes[ind]; // Just return the copied node if it exists.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621819,
                "title": "tip-if-you-re-oddly-getting-you-must-return-a-copy-of-all-the-nodes-in-the-original-graph",
                "content": "...is to check you\\'re **reusing previously instantiated copies** of Node\\'s in your copy of the graph\\n\\nI had mine 99% working, but in one place I always re-instantiated a copy of a Node\\n\\n      neighbor_copy = Node(neighbor.val, [])\\n\\ninstead of **retrieving a previously made copy** of a Node:\\n\\n       try:\\n            neighbor_copy = graph_copy[neighbor.val]\\n       except KeyError:\\n            neighbor_copy = graph_copy[neighbor.val] = Node(neighbor.val, [])\\n\\nits confusing because you can return the correct result value-wise, but not graph/node/neighbors wise!   (i\\'m curious to see how the validation code for this problem works =D",
                "solutionTags": [],
                "code": "...is to check you\\'re **reusing previously instantiated copies** of Node\\'s in your copy of the graph\\n\\nI had mine 99% working, but in one place I always re-instantiated a copy of a Node\\n\\n      neighbor_copy = Node(neighbor.val, [])\\n\\ninstead of **retrieving a previously made copy** of a Node:\\n\\n       try:\\n            neighbor_copy = graph_copy[neighbor.val]\\n       except KeyError:\\n            neighbor_copy = graph_copy[neighbor.val] = Node(neighbor.val, [])\\n\\nits confusing because you can return the correct result value-wise, but not graph/node/neighbors wise!   (i\\'m curious to see how the validation code for this problem works =D",
                "codeTag": "Unknown"
            },
            {
                "id": 250216,
                "title": "bfs-and-dfs-simple-java",
                "content": "```\\n//DFS\\nclass Solution {\\n    Map<Node, Node> map = new HashMap<Node, Node>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null)\\n            return null;\\n        if (map.containsKey(node))\\n            return map.get(node);\\n    \\n            Node temp = new Node(node.val, new ArrayList<Node>());\\n            map.put(node, temp);\\n            for (Node neighbor : node.neighbors) {\\n                temp.neighbors.add(cloneGraph(neighbor));\\n            }\\n        return map.get(node);\\n    }\\n}\\n\\n//BFS\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        \\n        if (node == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        Queue<Node> q = new LinkedList<Node>();\\n        map.put(node, new Node(node.val, new ArrayList<Node>()));\\n        q.add(node);\\n        \\n        while(!q.isEmpty()){\\n            Node top = q.remove();\\n            for (Node neighbor: top.neighbors) {\\n                // visited\\n                if (!map.containsKey(neighbor)) {\\n                    map.put(neighbor, new Node(neighbor.val, new ArrayList<Node>()));\\n                    q.add(neighbor);\\n                } \\n                map.get(top).neighbors.add(map.get(neighbor));\\n            }\\n        }\\n        return map.get(node);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//DFS\\nclass Solution {\\n    Map<Node, Node> map = new HashMap<Node, Node>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null)\\n            return null;\\n        if (map.containsKey(node))\\n            return map.get(node);\\n    \\n            Node temp = new Node(node.val, new ArrayList<Node>());\\n            map.put(node, temp);\\n            for (Node neighbor : node.neighbors) {\\n                temp.neighbors.add(cloneGraph(neighbor));\\n            }\\n        return map.get(node);\\n    }\\n}\\n\\n//BFS\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        \\n        if (node == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        Queue<Node> q = new LinkedList<Node>();\\n        map.put(node, new Node(node.val, new ArrayList<Node>()));\\n        q.add(node);\\n        \\n        while(!q.isEmpty()){\\n            Node top = q.remove();\\n            for (Node neighbor: top.neighbors) {\\n                // visited\\n                if (!map.containsKey(neighbor)) {\\n                    map.put(neighbor, new Node(neighbor.val, new ArrayList<Node>()));\\n                    q.add(neighbor);\\n                } \\n                map.get(top).neighbors.add(map.get(neighbor));\\n            }\\n        }\\n        return map.get(node);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42502,
                "title": "accepted-recursive-depth-first-search-solution",
                "content": "    class Solution {\\n    public:\\n    \\tUndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) \\n    \\t{\\n    \\t\\t// initialize marks\\n    \\t\\tmap<int, UndirectedGraphNode*> marks;\\n    \\t\\tif (node) return dfs(node, marks);\\n    \\t\\telse return NULL;\\n    \\t}\\n    \\n    \\tUndirectedGraphNode * dfs(UndirectedGraphNode *node, map<int, UndirectedGraphNode*> & marks)\\n    \\t{\\n    \\t\\t// create new node and search its all neighbors\\n    \\t\\tUndirectedGraphNode *p;\\n    \\t\\tp = new UndirectedGraphNode(node->label);\\n    \\t\\tmarks[p->label] = p;\\n    \\n    \\t\\t// loop all neighbors\\n    \\t\\tfor(UndirectedGraphNode* n : node->neighbors)\\n    \\t\\t{\\n    \\t\\t\\t// hook already created and searched node\\n    \\t\\t\\tif(marks.count(n->label) > 0)\\n    \\t\\t\\t\\t(p->neighbors).push_back(marks[n->label]);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t(p->neighbors).push_back(dfs(n,marks));\\n    \\t\\t}\\n    \\t\\treturn p;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tUndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) \\n    \\t{\\n    \\t\\t// initialize marks\\n    \\t\\tmap<int, UndirectedGraphNode*> marks;\\n    \\t\\tif (node) return dfs(node, marks);\\n    \\t\\telse return NULL;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1416436,
                "title": "javascript-dfs-hashmap-thought-process",
                "content": "## Thought Process ##\\n**Questions**\\n- How is our input graph represented?\\n\\n**Insights**\\n- We essentially want to just recreate our graph, and are allowed to use an auxiliary data structure to do so.\\n- We can construct an adjacency-list like structure, clone out and set references to neighbors, and return our new copied root node.\\n\\n**Approach**\\n- Create a hashmap to store copied nodes, references.\\n- Write recursive logic to help us clone each `node` (and its `neighbors`).\\n\\t- If our hashmap doesn\\'t already have a `key` with our `node.val`:\\n\\t\\t- Create a new `key/value` pair in our hashmap, set the value to a new node (`new Node(node.val)`).\\n\\t\\t- Recursively clone this entry\\'s neighbors (based on current `node.neighbors`) and add to hashmap.\\n\\t- Return the *copied/new* reference to our original node (`map.get(node.val)`).\\n- Return the hashmap entry of our copied input node.\\n\\n**Complexity**\\n```\\nTime: O(v + e)\\nSpace: O(v)\\n```\\n\\n## Solution ##\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\n\\nvar cloneGraph = function(node, copy = new Map()) {\\n    // Handle null case\\n    if (!node) return null;\\n        \\n    // If our graph hasn\\'t already copied the input node\\n    if (!copy.has(node.val)) {\\n        // Create new copy node (+ reference in map)\\n        copy.set(node.val, new Node(node.val));\\n        // Recursively clone neighbors\\n        copy.get(node.val).neighbors = node.neighbors.map((neighbor) => cloneGraph(neighbor, copy));\\n    }\\n        \\n    // Return copied/new node (* not * the original node passed in)\\n    return copy.get(node.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nTime: O(v + e)\\nSpace: O(v)\\n```\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\n\\nvar cloneGraph = function(node, copy = new Map()) {\\n    // Handle null case\\n    if (!node) return null;\\n        \\n    // If our graph hasn\\'t already copied the input node\\n    if (!copy.has(node.val)) {\\n        // Create new copy node (+ reference in map)\\n        copy.set(node.val, new Node(node.val));\\n        // Recursively clone neighbors\\n        copy.get(node.val).neighbors = node.neighbors.map((neighbor) => cloneGraph(neighbor, copy));\\n    }\\n        \\n    // Return copied/new node (* not * the original node passed in)\\n    return copy.get(node.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391953,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- We can traverse the graph in a BFS manner starting from the given node.\\n- For each node we visit, we create a copy of it and add it to a hashmap (or unordered_map) where the key is the original node and the value is the copy node.\\n- We also add the original node to a queue to keep track of which nodes we still need to visit.\\n- For each neighbor of the current node, we check if we have already visited it. If not, we create a copy of it and add it to the hashmap and the queue.\\n- Finally, we connect the copy nodes of each neighbor to the copy node of the current node.\\n- Once we have visited all nodes and created their copies, we return the copy of the original node.\\n\\n# Intuition:\\n\\n- The problem requires us to create a deep copy of the given graph, where each node in the new graph has the same value as the corresponding node in the original graph, but is a separate instance.\\n- We can achieve this by traversing the graph in a BFS manner and creating a copy of each node we visit.\\n- To ensure that we don\\'t create duplicate copies of the same node, we can use a hashmap to keep track of visited nodes and their copies.\\n- Since the graph can have cycles, we need to use a hashmap to ensure that we don\\'t get stuck in an infinite loop while traversing the graph.\\n- Once we have created the copies of all nodes and connected them in the same way as the original graph, we return the copy of the original node.\\n\\n\\n```Python []\\n\\nclass Solution:\\n    \\n\\n  def cloneGraph(self, node):\\n      if not node:\\n          return None\\n\\n      visited = {}\\n      queue = deque([node])\\n\\n      # Create a copy of the starting node and add it to visited\\n      visited[node] = Node(node.val)\\n\\n      while queue:\\n          # Get the next node from the queue\\n          curr_node = queue.popleft()\\n\\n          # Loop through the current node\\'s neighbors\\n          for neighbor in curr_node.neighbors:\\n              if neighbor not in visited:\\n                  # Create a copy of the neighbor and add it to visited\\n                  visited[neighbor] = Node(neighbor.val)\\n                  queue.append(neighbor)\\n\\n              # Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n              visited[curr_node].neighbors.append(visited[neighbor])\\n\\n      return visited[node]\\n\\n```\\n```Java []\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        HashMap<Node, Node> visited = new HashMap<>();\\n        Queue<Node> queue = new LinkedList<>();\\n\\n        // Create a copy of the starting node and add it to visited\\n        visited.put(node, new Node(node.val));\\n\\n        queue.offer(node);\\n\\n        while (!queue.isEmpty()) {\\n            // Get the next node from the queue\\n            Node currNode = queue.poll();\\n\\n            // Loop through the current node\\'s neighbors\\n            for (Node neighbor : currNode.neighbors) {\\n                if (!visited.containsKey(neighbor)) {\\n                    // Create a copy of the neighbor and add it to visited\\n                    visited.put(neighbor, new Node(neighbor.val));\\n                    queue.offer(neighbor);\\n                }\\n\\n                // Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n                visited.get(currNode).neighbors.add(visited.get(neighbor));\\n            }\\n        }\\n\\n        return visited.get(node);\\n    }\\n}\\n\\n```\\n```C++ []\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     vector<Node*> neighbors;\\n *     Node(int val) {\\n *         this->val = val;\\n *         neighbors = vector<Node*>();\\n *     }\\n * };\\n */\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n\\n        unordered_map<Node*, Node*> visited;\\n        queue<Node*> q;\\n\\n        // Create a copy of the starting node and add it to visited\\n        visited[node] = new Node(node->val);\\n\\n        q.push(node);\\n\\n        while (!q.empty()) {\\n            // Get the next node from the queue\\n            Node* currNode = q.front();\\n            q.pop();\\n\\n            // Loop through the current node\\'s neighbors\\n            for (Node* neighbor : currNode->neighbors) {\\n                if (!visited.count(neighbor)) {\\n                    // Create a copy of the neighbor and add it to visited\\n                    visited[neighbor] = new Node(neighbor->val);\\n                    q.push(neighbor);\\n                }\\n\\n                // Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n                visited[currNode]->neighbors.push_back(visited[neighbor]);\\n            }\\n        }\\n\\n        return visited[node];\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python []\\n\\nclass Solution:\\n    \\n\\n  def cloneGraph(self, node):\\n      if not node:\\n          return None\\n\\n      visited = {}\\n      queue = deque([node])\\n\\n      # Create a copy of the starting node and add it to visited\\n      visited[node] = Node(node.val)\\n\\n      while queue:\\n          # Get the next node from the queue\\n          curr_node = queue.popleft()\\n\\n          # Loop through the current node\\'s neighbors\\n          for neighbor in curr_node.neighbors:\\n              if neighbor not in visited:\\n                  # Create a copy of the neighbor and add it to visited\\n                  visited[neighbor] = Node(neighbor.val)\\n                  queue.append(neighbor)\\n\\n              # Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n              visited[curr_node].neighbors.append(visited[neighbor])\\n\\n      return visited[node]\\n\\n```\n```Java []\\n\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        HashMap<Node, Node> visited = new HashMap<>();\\n        Queue<Node> queue = new LinkedList<>();\\n\\n        // Create a copy of the starting node and add it to visited\\n        visited.put(node, new Node(node.val));\\n\\n        queue.offer(node);\\n\\n        while (!queue.isEmpty()) {\\n            // Get the next node from the queue\\n            Node currNode = queue.poll();\\n\\n            // Loop through the current node\\'s neighbors\\n            for (Node neighbor : currNode.neighbors) {\\n                if (!visited.containsKey(neighbor)) {\\n                    // Create a copy of the neighbor and add it to visited\\n                    visited.put(neighbor, new Node(neighbor.val));\\n                    queue.offer(neighbor);\\n                }\\n\\n                // Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n                visited.get(currNode).neighbors.add(visited.get(neighbor));\\n            }\\n        }\\n\\n        return visited.get(node);\\n    }\\n}\\n\\n```\n```C++ []\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     vector<Node*> neighbors;\\n *     Node(int val) {\\n *         this->val = val;\\n *         neighbors = vector<Node*>();\\n *     }\\n * };\\n */\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n\\n        unordered_map<Node*, Node*> visited;\\n        queue<Node*> q;\\n\\n        // Create a copy of the starting node and add it to visited\\n        visited[node] = new Node(node->val);\\n\\n        q.push(node);\\n\\n        while (!q.empty()) {\\n            // Get the next node from the queue\\n            Node* currNode = q.front();\\n            q.pop();\\n\\n            // Loop through the current node\\'s neighbors\\n            for (Node* neighbor : currNode->neighbors) {\\n                if (!visited.count(neighbor)) {\\n                    // Create a copy of the neighbor and add it to visited\\n                    visited[neighbor] = new Node(neighbor->val);\\n                    q.push(neighbor);\\n                }\\n\\n                // Add the copy of the neighbor to the copy of the current node\\'s neighbors\\n                visited[currNode]->neighbors.push_back(visited[neighbor]);\\n            }\\n        }\\n\\n        return visited[node];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938465,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-n",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var neighbors: [Node?]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.neighbors = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the number of nodes in the graph, and m is the number of edges in the graph.\\n    //   - space: O(n), where n is the number of nodes in the graph.\\n    \\n    func cloneGraph(_ node: Node?) -> Node? {\\n        var visited = [Int: Node]()\\n        return cloneGraphDFS(node, visited: &visited)\\n    }\\n\\n    \\n    func cloneGraphDFS(_ node: Node?, visited: inout [Int: Node]) -> Node? {\\n        guard let node = node else { return nil }\\n\\n        let newNode = Node(node.val)\\n        visited[node.val] = newNode\\n\\n        for neighbor in node.neighbors {\\n            guard let neighbor = neighbor else { continue }\\n\\n            if let n = visited[neighbor.val] {\\n                newNode.neighbors.append(n)\\n            } else {\\n                let n = cloneGraphDFS(neighbor, visited: &visited)\\n                newNode.neighbors.append(n)\\n            }\\n        }\\n\\n        return newNode\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var neighbors: [Node?]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.neighbors = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the number of nodes in the graph, and m is the number of edges in the graph.\\n    //   - space: O(n), where n is the number of nodes in the graph.\\n    \\n    func cloneGraph(_ node: Node?) -> Node? {\\n        var visited = [Int: Node]()\\n        return cloneGraphDFS(node, visited: &visited)\\n    }\\n\\n    \\n    func cloneGraphDFS(_ node: Node?, visited: inout [Int: Node]) -> Node? {\\n        guard let node = node else { return nil }\\n\\n        let newNode = Node(node.val)\\n        visited[node.val] = newNode\\n\\n        for neighbor in node.neighbors {\\n            guard let neighbor = neighbor else { continue }\\n\\n            if let n = visited[neighbor.val] {\\n                newNode.neighbors.append(n)\\n            } else {\\n                let n = cloneGraphDFS(neighbor, visited: &visited)\\n                newNode.neighbors.append(n)\\n            }\\n        }\\n\\n        return newNode\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865663,
                "title": "javascript-dfs-bfs",
                "content": "```\\n//DFS\\nvar cloneGraph = function(node, map = new Map()) {\\n  if(!node) return null\\n  if(map.has(node)) return map.get(node)\\n  const n = new Node(node.val)\\n  map.set(node, n)\\n  for(let k of node.neighbors){    \\n    n.neighbors.push(cloneGraph(k, map))\\n  }\\n  return n\\n};\\n\\n//BFS\\nvar cloneGraph = function(node, map = new Map()) {\\n  if(!node) return null\\n  map.set(node, new Node(node.val))\\n  const queue = [node]\\n  while(queue.length){\\n    const n = queue.shift()\\n    for(let k of n.neighbors){\\n      if(!map.has(k)){\\n        map.set(k, new Node(k.val))\\n        queue.push(k)        \\n      }      \\n      map.get(n).neighbors.push(map.get(k))\\n    }\\n  }\\n  return map.get(node)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//DFS\\nvar cloneGraph = function(node, map = new Map()) {\\n  if(!node) return null\\n  if(map.has(node)) return map.get(node)\\n  const n = new Node(node.val)\\n  map.set(node, n)\\n  for(let k of node.neighbors){    \\n    n.neighbors.push(cloneGraph(k, map))\\n  }\\n  return n\\n};\\n\\n//BFS\\nvar cloneGraph = function(node, map = new Map()) {\\n  if(!node) return null\\n  map.set(node, new Node(node.val))\\n  const queue = [node]\\n  while(queue.length){\\n    const n = queue.shift()\\n    for(let k of n.neighbors){\\n      if(!map.has(k)){\\n        map.set(k, new Node(k.val))\\n        queue.push(k)        \\n      }      \\n      map.get(n).neighbors.push(map.get(k))\\n    }\\n  }\\n  return map.get(node)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373682,
                "title": "python3-breadth-first-search",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        q = deque([node])\\n        mapping ={node : Node(node.val,[])}\\n        while q:\\n            n =q.popleft()\\n            for i in n.neighbors:\\n                if i not in mapping:\\n                    mapping[i] = Node(i.val,[])\\n                    q.append(i)\\n                mapping[n].neighbors.append(mapping[i])\\n        return mapping[node]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        q = deque([node])\\n        mapping ={node : Node(node.val,[])}\\n        while q:\\n            n =q.popleft()\\n            for i in n.neighbors:\\n                if i not in mapping:\\n                    mapping[i] = Node(i.val,[])\\n                    q.append(i)\\n                mapping[n].neighbors.append(mapping[i])\\n        return mapping[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42462,
                "title": "java-solution-with-dfs-and-bfs",
                "content": "    private Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n    // DFS\\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if (node == null) return null;\\n        if (map.containsKey(node)) return map.get(node);\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        for (UndirectedGraphNode n : node.neighbors)\\n            copy.neighbors.add(cloneGraph(n));\\n        return copy;\\n    }\\n    \\n    // BFS\\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if (node == null) return null;\\n        Queue<UndirectedGraphNode> q = new LinkedList<UndirectedGraphNode>();\\n        q.add(node);\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        while (!q.isEmpty()) {\\n            UndirectedGraphNode cur = q.poll();\\n            for (UndirectedGraphNode neigh : cur.neighbors) {\\n                if (map.containsKey(neigh)) map.get(cur).neighbors.add(map.get(neigh));\\n                else {\\n                    UndirectedGraphNode neighCopy = new UndirectedGraphNode(neigh.label);\\n                    map.put(neigh, neighCopy);\\n                    map.get(cur).neighbors.add(neighCopy);\\n                    q.add(neigh);\\n                }\\n            }\\n        }\\n        return copy;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "    private Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n    // DFS\\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if (node == null) return null;\\n        if (map.containsKey(node)) return map.get(node);\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        for (UndirectedGraphNode n : node.neighbors)\\n            copy.neighbors.add(cloneGraph(n));\\n        return copy;\\n    }\\n    \\n    // BFS\\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if (node == null) return null;\\n        Queue<UndirectedGraphNode> q = new LinkedList<UndirectedGraphNode>();\\n        q.add(node);\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        while (!q.isEmpty()) {\\n            UndirectedGraphNode cur = q.poll();\\n            for (UndirectedGraphNode neigh : cur.neighbors) {\\n                if (map.containsKey(neigh)) map.get(cur).neighbors.add(map.get(neigh));\\n                else {\\n                    UndirectedGraphNode neighCopy = new UndirectedGraphNode(neigh.label);\\n                    map.put(neigh, neighCopy);\\n                    map.get(cur).neighbors.add(neighCopy);\\n                    q.add(neigh);\\n                }\\n            }\\n        }\\n        return copy;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1794199,
                "title": "c-bfs-simplified-with-attached-approach-analysis-dry-run-code",
                "content": "Problem statement says we have to create deep copy of the graph (**Deep Copy : creating completely new graph that is similar to original graph but has no connection with it which means it is not using the node used in original graph** )\\nNode class has two members:\\n1. value of node\\n2. List containing address of nodes adjacent to current node \\n \\nInitially Node* node pointer is pointing to the node with val =1\\n**Approach:** I will be\\n* Using BFS queue.\\n* Using hashmap to keep track of visited nodes \\n    * I will be storing address of original node with is pointing to its copy node address  like:\\n    *  address(1) Ori---> address(1) new.copy\\n \\n **Pseudo code**  \\n1.  start with given source node creates its copy add its original address + new address into hashmap & push original address  into queue .\\n    ***Why Original?***\\n\\tBecause till now we only created copy of node but its adjacent nodes are not described till now.\\n\\twhat we will do is?\\n\\t* we will pop node at front of queue\\n\\t* check for its neighbors \\n\\t*if neighbours is not already existent in map create its copy and put its address in the new node neigbours vector.\\n\\t*if existent then \\n\\tput its address in the new node neigbours vector.\\n\\t\\n\\t\\n    \\n2.  Now ,Turn to its adjacent nodes \\n       * if adjacent node is not visited then\\n            * create its copy with val same as original adjacent node \\n            * Push original adjacent node address into queue\\n            * m[original address of adjacent]--> m[new address of adjacent]\\n            * store address of new adjacent node address into the neighbors vector of the new address of front node .\\n            ![image](https://assets.leetcode.com/users/images/888b1442-752c-4137-af85-8f9431223cb2_1645625768.9942315.jpeg)\\n\\n            \\n\\t\\t* else i.e. is already visited ,then \\n\\t\\t    * Simply   store address adready adjacent node  into the neighbors vector of the new address of front node . \\n\\t\\t\\n**Dry Run**\\n\\n![image](https://assets.leetcode.com/users/images/d7a8c152-4210-41aa-a035-82c3c369772f_1645626773.853613.jpeg)\\n![image](https://assets.leetcode.com/users/images/e1265e44-a47d-40f9-8f8b-5c7a9366feed_1645626773.883312.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL){\\n            return NULL;\\n        }\\n        queue<Node*>q;\\n        unordered_map<Node*,Node*>m;\\n        Node* src=new Node(node->val);\\n        m[node]=src;\\n        q.push(node);\\n        while(!q.empty()){\\n            auto fn=q.front();\\n            q.pop();\\n            for(auto it:fn->neighbors){\\n                if(m.find(it)==m.end()){\\n                    Node* ne=new Node(it->val);\\n                    q.push(it);\\n                    m[it]=ne;\\n                }\\n                m[fn]->neighbors.push_back(m[it]);\\n            }\\n        }\\n        return src;\\n    }\\n};\\n```\\n**Please Upvote if you like my effort and its of some use for you and kindly let me know if it need some improvement anywhere.**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL){\\n            return NULL;\\n        }\\n        queue<Node*>q;\\n        unordered_map<Node*,Node*>m;\\n        Node* src=new Node(node->val);\\n        m[node]=src;\\n        q.push(node);\\n        while(!q.empty()){\\n            auto fn=q.front();\\n            q.pop();\\n            for(auto it:fn->neighbors){\\n                if(m.find(it)==m.end()){\\n                    Node* ne=new Node(it->val);\\n                    q.push(it);\\n                    m[it]=ne;\\n                }\\n                m[fn]->neighbors.push_back(m[it]);\\n            }\\n        }\\n        return src;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42465,
                "title": "4-7-lines-python-7-lines-c-java",
                "content": "**The Good**\\n\\n    def cloneGraph(self, node):\\n        memo = {}\\n        def clone(node):\\n            if node not in memo:\\n                c = memo[node] = UndirectedGraphNode(node.label)\\n                c.neighbors = map(clone, node.neighbors)\\n            return memo[node]\\n        return node and clone(node)\\n\\n---\\n\\n**The Bad**\\n\\n    def cloneGraph(self, node, memo={None: None}):\\n        if node not in memo:\\n            c = memo[node] = UndirectedGraphNode(node.label)\\n            c.neighbors = map(self.cloneGraph, node.neighbors)\\n        return memo[node]\\n\\nThe OJ accepts it, but it's kinda unclean (added a default argument) and unsafe (memo is reused from one test case to the next).\\n\\n---\\n\\n**The Ugly**\\n\\nJava:\\n\\n    public class Solution {\\n        Map<Object,UndirectedGraphNode> clone = new HashMap<Object,UndirectedGraphNode>();\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            if (node != null && !clone.containsKey(node)) {\\n                clone.put(node, new UndirectedGraphNode(node.label));\\n                for (UndirectedGraphNode n : node.neighbors)\\n                    clone.get(node).neighbors.add(cloneGraph(n));\\n            }\\n            return clone.get(node);\\n        }\\n    }\\n\\nC++:\\n\\n    class Solution {\\n        unordered_map<UndirectedGraphNode*,UndirectedGraphNode*> clone;\\n    public:\\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n            if (node && !clone[node]) {\\n                clone[node] = new UndirectedGraphNode(node->label);\\n                for (auto n : node->neighbors)\\n                    clone[node]->neighbors.push_back(cloneGraph(n));\\n            }\\n            return clone[node];\\n        }\\n    };\\n\\nWould also be a bit unsafe if the OJ didn't create a new Solution object for each test case (I think it does). If necessary, I'd outsource the current cloneGraph code into a helper and in cloneGraph I'd initialize the map and then call the helper.\\n\\nAnd yes, joke's on me. After calling my Python solutions \"good\" and \"bad\", I decided to create an \"ugly\" one. So, naturally, I wrote one in Java. Unfortunately (?), it turned out to be not so ugly after all. Neither did the C++ version.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "class Solution {\\n        Map<Object,UndirectedGraphNode> clone = new HashMap<Object,UndirectedGraphNode>();\\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n            if (node != null && !clone.containsKey(node)) {\\n                clone.put(node, new UndirectedGraphNode(node.label));\\n                for (UndirectedGraphNode n : node.neighbors)\\n                    clone.get(node).neighbors.add(cloneGraph(n));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3392084,
                "title": "javascript-php-bfs-dfs-approaches",
                "content": "Here are two algorithms, BFS and DFS, for solving the deep copy (clone) of a graph in JavaScript and PHP.\\n\\n#### DFS Approach for Cloning a Graph\\n\\nThis approach uses a Depth-First Search (DFS) algorithm to clone a graph. \\nIt first creates a new node and adds it to a visited map. \\nThen it iterates over the node\\'s neighbors, creating a new node for each one if it is not already in the visited map. \\nFinally, it adds the new node to the neighbors of the new node. \\n\\n- *Time complexity* is $$O(V+E)$$ where V is the number of vertices and E is the number of edges in the graph, as the algorithm iterates over all the vertices and edges once. \\n- *Space complexity* is $$O(V)$$, as the visited map contains at most V amount of nodes.\\n\\n\\n```javascript []\\n// DFS approach\\nvar cloneGraph = function (node) {\\n    // DFS approach\\n    // 1. create a new node\\n    // 2. add the new node to the visited map\\n    // 3. for each neighbor of the node\\n    // 4.    if the neighbor is not in the visited map\\n    // 5.        create a new node\\n    // 6.        add the new node to the visited map\\n    // 7.    add the new node to the neighbors of the new node\\n    if (!node) return null;\\n\\n    let dfs = (node, visited) => {\\n        if (visited.has(node)) return visited.get(node);\\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        for (let neighbor of node.neighbors) {\\n            newNode.neighbors.push(dfs(neighbor, visited));\\n        }\\n        return newNode;\\n    }\\n    return dfs(node, new Map());\\n}\\n```\\n```php []\\n// DFS Approach\\nclass Solution\\n{\\n    function cloneGraph(?Node $node): ?Node {\\n        if ($node === null) return null;\\n        $visited = [];\\n        return $this->cloneGraphHelper($node, $visited);\\n    }\\n\\n    function cloneGraphHelper(?Node $node, array &$visited): ?Node {\\n        if (isset($visited[$node->val])) {\\n            return $visited[$node->val];\\n        }\\n        $newNode = new Node($node->val);\\n        $visited[$node->val] = $newNode;\\n        foreach ($node->neighbors as $neighbor) {\\n            $newNode->neighbors[] = $this->cloneGraphHelper($neighbor, $visited);\\n        }\\n        return $newNode;\\n    }\\n}\\n```\\n\\n\\n\\n\\n#### BFS Approach to Cloning a Graph\\nThis approach uses a Breadth-First Search (BFS) algorithm to clone a graph. \\nThe algorithm begins by creating a new node with the same value as the original node. \\nIt then adds the original node to a queue, and adds a mapping of the node to the new node to a visited map. \\nIt then loops through the queue, shifting off the first node in the queue each time. For each of the shifted node\\'s neighbors, the algorithm checks to see if the neighbor has been visited. \\nIf it hasn\\'t been, then a new node is created and added to the queue, and the neighbor is added to the visited map. \\nLastly, the new node\\'s neighbors array is updated with the new mapped node. Once the queue is empty, the new node is returned.\\n\\n- *Time complexity*: $$O(V + E)$$, where V is the number of nodes in the graph and E is the number of edges in the graph.\\n- *Space complexity*: $$O(V)$$, where V is the number of nodes in the graph. This is because the visited map and queue are both of size V.\\n\\n\\n```javascript []\\n// BFS approach\\nvar cloneGraph = function (node) {\\n    // BFS approach\\n    // 1. create a new node\\n    // 2. add the new node to the queue\\n    // 3. add the new node to the visited map\\n    // 4. while the queue is not empty\\n    // 5.    get the first node from the queue\\n    // 6.    for each neighbor of the node\\n    // 7.        if the neighbor is not in the visited map\\n    // 8.            create a new node\\n    // 9.            add the new node to the queue\\n    // 10.           add the new node to the visited map\\n    // 11.       add the new node to the neighbors of the new node\\n    if (!node) return null;\\n\\n    let newNode = new Node(node.val);\\n    let queue = [node];\\n    let visited = new Map();\\n    visited.set(node, newNode);\\n\\n    while (queue.length > 0) {\\n        let currentNode = queue.shift();\\n        for (let neighbor of currentNode.neighbors) {\\n            if (!visited.has(neighbor)) {\\n                let newNeighbor = new Node(neighbor.val);\\n                queue.push(neighbor);\\n                visited.set(neighbor, newNeighbor);\\n            }\\n            visited.get(currentNode).neighbors.push(visited.get(neighbor));\\n        }\\n    }\\n    return newNode;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    function cloneGraph(?Node $node): ?Node {\\n        if ($node === null) return null;\\n        $visited = [];\\n        $queue = new SplQueue();\\n        $queue->enqueue($node);\\n        $visited[$node->val] = new Node($node->val);\\n        while (!$queue->isEmpty()) {\\n            $current = $queue->dequeue();\\n            foreach ($current->neighbors as $neighbor) {\\n                if (!isset($visited[$neighbor->val])) {\\n                    $visited[$neighbor->val] = new Node($neighbor->val);\\n                    $queue->enqueue($neighbor);\\n                }\\n                $visited[$current->val]->neighbors[] = $visited[$neighbor->val];\\n            }\\n        }\\n        return $visited[$node->val];\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```javascript []\\n// DFS approach\\nvar cloneGraph = function (node) {\\n    // DFS approach\\n    // 1. create a new node\\n    // 2. add the new node to the visited map\\n    // 3. for each neighbor of the node\\n    // 4.    if the neighbor is not in the visited map\\n    // 5.        create a new node\\n    // 6.        add the new node to the visited map\\n    // 7.    add the new node to the neighbors of the new node\\n    if (!node) return null;\\n\\n    let dfs = (node, visited) => {\\n        if (visited.has(node)) return visited.get(node);\\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        for (let neighbor of node.neighbors) {\\n            newNode.neighbors.push(dfs(neighbor, visited));\\n        }\\n        return newNode;\\n    }\\n    return dfs(node, new Map());\\n}\\n```\n```php []\\n// DFS Approach\\nclass Solution\\n{\\n    function cloneGraph(?Node $node): ?Node {\\n        if ($node === null) return null;\\n        $visited = [];\\n        return $this->cloneGraphHelper($node, $visited);\\n    }\\n\\n    function cloneGraphHelper(?Node $node, array &$visited): ?Node {\\n        if (isset($visited[$node->val])) {\\n            return $visited[$node->val];\\n        }\\n        $newNode = new Node($node->val);\\n        $visited[$node->val] = $newNode;\\n        foreach ($node->neighbors as $neighbor) {\\n            $newNode->neighbors[] = $this->cloneGraphHelper($neighbor, $visited);\\n        }\\n        return $newNode;\\n    }\\n}\\n```\n```javascript []\\n// BFS approach\\nvar cloneGraph = function (node) {\\n    // BFS approach\\n    // 1. create a new node\\n    // 2. add the new node to the queue\\n    // 3. add the new node to the visited map\\n    // 4. while the queue is not empty\\n    // 5.    get the first node from the queue\\n    // 6.    for each neighbor of the node\\n    // 7.        if the neighbor is not in the visited map\\n    // 8.            create a new node\\n    // 9.            add the new node to the queue\\n    // 10.           add the new node to the visited map\\n    // 11.       add the new node to the neighbors of the new node\\n    if (!node) return null;\\n\\n    let newNode = new Node(node.val);\\n    let queue = [node];\\n    let visited = new Map();\\n    visited.set(node, newNode);\\n\\n    while (queue.length > 0) {\\n        let currentNode = queue.shift();\\n        for (let neighbor of currentNode.neighbors) {\\n            if (!visited.has(neighbor)) {\\n                let newNeighbor = new Node(neighbor.val);\\n                queue.push(neighbor);\\n                visited.set(neighbor, newNeighbor);\\n            }\\n            visited.get(currentNode).neighbors.push(visited.get(neighbor));\\n        }\\n    }\\n    return newNode;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    function cloneGraph(?Node $node): ?Node {\\n        if ($node === null) return null;\\n        $visited = [];\\n        $queue = new SplQueue();\\n        $queue->enqueue($node);\\n        $visited[$node->val] = new Node($node->val);\\n        while (!$queue->isEmpty()) {\\n            $current = $queue->dequeue();\\n            foreach ($current->neighbors as $neighbor) {\\n                if (!isset($visited[$neighbor->val])) {\\n                    $visited[$neighbor->val] = new Node($neighbor->val);\\n                    $queue->enqueue($neighbor);\\n                }\\n                $visited[$current->val]->neighbors[] = $visited[$neighbor->val];\\n            }\\n        }\\n        return $visited[$node->val];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504846,
                "title": "java-easy-13-line-solution-with-explanation",
                "content": "We use a HashMap to store the actual node and its duplicate. In order to check if we have already seen a node earlier or not, we check if it is present in out hashmap or not. I am using BFS to traverse the map, and for that I used a Queue. I have added comments on each line for better understanding. Feel free to drop a comment for a doubt or suggestion. :)\\n\\n```\\npublic Node cloneGraph(Node start) {\\n\\tif(start == null) return null;\\n\\tHashMap<Node, Node> map = new HashMap<>();                      // for each node in graph we create a new node\\n\\tmap.put(start, new Node(start.val, new ArrayList<Node>()));     // add starting node\\n\\tQueue<Node> q = new LinkedList<>();                             // queue for bfs\\n\\tq.offer(start);                                                 // add start node to queue\\n\\twhile(!q.isEmpty()) {                                           // iterate until queue is empty\\n\\t\\tNode curr = q.poll();                                       // get the first node in queue\\n\\t\\tfor(Node n : curr.neighbors) {                              // for every neighbor of first node\\n\\t\\t\\tif(!map.containsKey(n)) {                               // if neighbor not in map\\n\\t\\t\\t\\tmap.put(n, new Node(n.val, new ArrayList<Node>())); // create new node for neighbor\\n\\t\\t\\t\\tq.offer(n);                                         // also add neighbor to queue\\n\\t\\t\\t}\\n\\t\\t\\tmap.get(curr).neighbors.add(map.get(n));                // add neighbor to list of neighbors of first node  \\n\\t\\t}\\n\\t} \\n\\treturn map.get(start);                                          // return the duplicate of start node\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node cloneGraph(Node start) {\\n\\tif(start == null) return null;\\n\\tHashMap<Node, Node> map = new HashMap<>();                      // for each node in graph we create a new node\\n\\tmap.put(start, new Node(start.val, new ArrayList<Node>()));     // add starting node\\n\\tQueue<Node> q = new LinkedList<>();                             // queue for bfs\\n\\tq.offer(start);                                                 // add start node to queue\\n\\twhile(!q.isEmpty()) {                                           // iterate until queue is empty\\n\\t\\tNode curr = q.poll();                                       // get the first node in queue\\n\\t\\tfor(Node n : curr.neighbors) {                              // for every neighbor of first node\\n\\t\\t\\tif(!map.containsKey(n)) {                               // if neighbor not in map\\n\\t\\t\\t\\tmap.put(n, new Node(n.val, new ArrayList<Node>())); // create new node for neighbor\\n\\t\\t\\t\\tq.offer(n);                                         // also add neighbor to queue\\n\\t\\t\\t}\\n\\t\\t\\tmap.get(curr).neighbors.add(map.get(n));                // add neighbor to list of neighbors of first node  \\n\\t\\t}\\n\\t} \\n\\treturn map.get(start);                                          // return the duplicate of start node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42508,
                "title": "simple-c-solution-using-dfs-and-recursion",
                "content": "Create a new node if the node map doesn't already contain a node with this label, otherwise return the pointer to the node with that label from the node map. Add the children to new nodes recursively through BFS. \\n\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n        if(!node) return node;\\n        \\n        unordered_map<int, UndirectedGraphNode*>::iterator itr = mNodeMap.find(node->label);\\n        if(itr == mNodeMap.end()){\\n            UndirectedGraphNode* newNode = new UndirectedGraphNode(node->label);\\n            mNodeMap[node->label] = newNode;\\n            for(int i = 0; i < node->neighbors.size(); ++i){\\n                newNode->neighbors.push_back(cloneGraph(node->neighbors[i]));   \\n            }\\n            return newNode;\\n        }else{\\n            return itr->second;\\n        }\\n    }\\n    \\n    unordered_map<int, UndirectedGraphNode*> mNodeMap;",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "Create a new node if the node map doesn't already contain a node with this label, otherwise return the pointer to the node with that label from the node map. Add the children to new nodes recursively through BFS. \\n\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n        if(!node) return node;\\n        \\n        unordered_map<int, UndirectedGraphNode*>::iterator itr = mNodeMap.find(node->label);\\n        if(itr == mNodeMap.end()){\\n            UndirectedGraphNode* newNode = new UndirectedGraphNode(node->label);\\n            mNodeMap[node->label] = newNode;\\n            for(int i = 0; i < node->neighbors.size(); ++i){\\n                newNode->neighbors.push_back(cloneGraph(node->neighbors[i]));   \\n            }\\n            return newNode;\\n        }else{\\n            return itr->second;\\n        }\\n    }\\n    \\n    unordered_map<int, UndirectedGraphNode*> mNodeMap;",
                "codeTag": "Unknown"
            },
            {
                "id": 333936,
                "title": "java-15-line-dfs-1ms-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        return dfs(node, map);\\n    }\\n    private Node dfs(Node node, HashMap<Node, Node> map) {\\n        if (map.containsKey(node)) return map.get(node);\\n        Node clone = new Node(node.val, new ArrayList<Node>());\\n        map.put(node, clone);\\n        for (Node nb: node.neighbors) {\\n            clone.neighbors.add(dfs(nb, map));\\n        }\\n        return clone;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        return dfs(node, map);\\n    }\\n    private Node dfs(Node node, HashMap<Node, Node> map) {\\n        if (map.containsKey(node)) return map.get(node);\\n        Node clone = new Node(node.val, new ArrayList<Node>());\\n        map.put(node, clone);\\n        for (Node nb: node.neighbors) {\\n            clone.neighbors.add(dfs(nb, map));\\n        }\\n        return clone;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42384,
                "title": "i-believe-undirected-graph-neighbor-list-should-always-contain-each-other",
                "content": "It seems to me the input from OJ is problematic. When a and b are neighbors, b is in a's neighbor list but a is not in b's neighbor list. Under such condition only certain algorithm can generate correct output.\\n\\nI've pasted a BFS solution which is correct if a and b are put into to each other's neighbor list, but doesn't work properly under current OJ:\\n\\n\\n\\n\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n            //key -> old node, value -> the new copy\\n            unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> m;\\n            //the queue always contains old nodes that haven't been copied\\n            queue<UndirectedGraphNode*> q;\\n            if(node)\\n                q.push(node);\\n            \\n            while(!q.empty()) {\\n                \\n                UndirectedGraphNode* n = q.front();\\n                q.pop();\\n                if(m.count(n)) continue; // if the node is already copied, continue\\n                \\n                // create the copy\\n                m[n] = new UndirectedGraphNode(n->label);\\n                \\n                // loop through the neighbors, if it's copied already, add the new copy to new copy's neighbor list\\n                for(UndirectedGraphNode* oldNei : n->neighbors) {\\n    \\n                    if(m.count(oldNei)) {\\n                        \\n                        UndirectedGraphNode* newNei = m[oldNei];\\n                        \\n                        if(m[n]->neighbors.size()==n->neighbors.size())\\n                            continue;\\n                        \\n                        m[n]->neighbors.push_back(newNei);\\n                        newNei->neighbors.push_back(m[n]);\\n                    }\\n                    \\n                    else// if not in the map, it's not copied/visited yet\\n                    \\n                        q.push(oldNei);\\n                }\\n    \\n            }\\n            \\n            return m[node];\\n        } \\n\\nThis won't pass case {-1,1#1} since 1 is neighbor of -1, but -1 is not neighbor of 1.\\n\\nIf you think the above algorithm is wrong, please point it out. Otherwise I think the OJ needs to be fixed.",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "It seems to me the input from OJ is problematic. When a and b are neighbors, b is in a's neighbor list but a is not in b's neighbor list. Under such condition only certain algorithm can generate correct output.\\n\\nI've pasted a BFS solution which is correct if a and b are put into to each other's neighbor list, but doesn't work properly under current OJ:\\n\\n\\n\\n\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n            //key -> old node, value -> the new copy\\n            unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> m;\\n            //the queue always contains old nodes that haven't been copied\\n            queue<UndirectedGraphNode*> q;\\n            if(node)\\n                q.push(node);\\n            \\n            while(!q.empty()) {\\n                \\n                UndirectedGraphNode* n = q.front();\\n                q.pop();\\n                if(m.count(n)) continue; // if the node is already copied, continue\\n                \\n                // create the copy\\n                m[n] = new UndirectedGraphNode(n->label);\\n                \\n                // loop through the neighbors, if it's copied already, add the new copy to new copy's neighbor list\\n                for(UndirectedGraphNode* oldNei : n->neighbors) {\\n    \\n                    if(m.count(oldNei)) {\\n                        \\n                        UndirectedGraphNode* newNei = m[oldNei];\\n                        \\n                        if(m[n]->neighbors.size()==n->neighbors.size())\\n                            continue;\\n                        \\n                        m[n]->neighbors.push_back(newNei);\\n                        newNei->neighbors.push_back(m[n]);\\n                    }\\n                    \\n                    else// if not in the map, it's not copied/visited yet\\n                    \\n                        q.push(oldNei);\\n                }\\n    \\n            }\\n            \\n            return m[node];\\n        } \\n\\nThis won't pass case {-1,1#1} since 1 is neighbor of -1, but -1 is not neighbor of 1.\\n\\nIf you think the above algorithm is wrong, please point it out. Otherwise I think the OJ needs to be fixed.",
                "codeTag": "Unknown"
            },
            {
                "id": 42500,
                "title": "my-python-solution-with-dictionary",
                "content": "\\n       def cloneGraph(self, node):\\n            if not node:\\n                return None\\n            self.newNodeDict={}\\n            return self.createNode(node)\\n                    \\n        def createNode(self, oldNode):\\n            newNode = UndirectedGraphNode(oldNode.label)\\n            self.newNodeDict[newNode.label] = newNode\\n            \\n            for i in oldNode.neighbors:\\n                if i.label not in self.newNodeDict:\\n                    self.createNode(i) #recursively create nodes\\n                newNode.neighbors.append(self.newNodeDict[i.label])\\n            return newNode",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n       def cloneGraph(self, node):\\n            if not node:\\n                return None\\n            self.newNodeDict={}\\n            return self.createNode(node)\\n                    \\n        def createNode(self, oldNode):\\n            newNode = UndirectedGraphNode(oldNode.label)\\n            self.newNodeDict[newNode.label] = newNode\\n            \\n            for i in oldNode.neighbors:\\n                if i.label not in self.newNodeDict:\\n                    self.createNode(i) #recursively create nodes\\n                newNode.neighbors.append(self.newNodeDict[i.label])\\n            return newNode",
                "codeTag": "Python3"
            },
            {
                "id": 961112,
                "title": "java-bfs-w-high-level-explaination-and-video-walkthrough",
                "content": "We made a video to talk about BFS on the high level and how to implement it for Clone Graph: https://youtu.be/98hj6RdBwXg\\n\\nTo solve this problem we need to visit every node in the graph so we can make a deep copy of them and connect them teo each other. Two algorithms that can be used to achieve this is BFS and DFS. For this problem, we\\'ll use BFS.\\n\\n**High Level Algorithm**\\nA BFS algorithm requires 2 things:\\n1) A Queue datastructure to help traverse our node in a BFS order\\n2) A visited Set to keep track of the nodes that we visited so that we won\\u2019t explore them again.\\n\\nThere are 3 steps involved in a BFS (or DFS) algorithm.\\n1) Put the given starting node in queue and visited set\\n2) Iterate through the queue until emptied\\n3) Pop a node from the queue, iterate through its children and add them to the visited set and queue if we haven\\u2019t seen them before.\\n\\nThe only adaption that we need to do to solve the problem is that we will create the copy of the node and connect them when we are processing the node in step 3.\\n\\n**BFS Solution:**\\n```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        Queue<Node> queue = new LinkedList();\\n        Map<Integer, Node> cloneMap = new HashMap();\\n        queue.add(node);\\n        cloneMap.put(node.val, new Node(node.val));\\n       \\n        while (!queue.isEmpty()) {\\n            Node cur = queue.remove();\\n            Node clone = cloneMap.getOrDefault(cur.val, new Node(cur.val));\\n            cloneMap.put(cur.val, clone);\\n            for (Node child : cur.neighbors) {\\n                Node childClone = cloneMap.getOrDefault(child.val, new Node(child.val));\\n                clone.neighbors.add(childClone);\\n                if (!cloneMap.containsKey(child.val)) {\\n                    queue.add(child);\\n                }\\n                cloneMap.put(child.val, childClone);\\n            }\\n        }\\n        return cloneMap.get(node.val);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        Queue<Node> queue = new LinkedList();\\n        Map<Integer, Node> cloneMap = new HashMap();\\n        queue.add(node);\\n        cloneMap.put(node.val, new Node(node.val));\\n       \\n        while (!queue.isEmpty()) {\\n            Node cur = queue.remove();\\n            Node clone = cloneMap.getOrDefault(cur.val, new Node(cur.val));\\n            cloneMap.put(cur.val, clone);\\n            for (Node child : cur.neighbors) {\\n                Node childClone = cloneMap.getOrDefault(child.val, new Node(child.val));\\n                clone.neighbors.add(childClone);\\n                if (!cloneMap.containsKey(child.val)) {\\n                    queue.add(child);\\n                }\\n                cloneMap.put(child.val, childClone);\\n            }\\n        }\\n        return cloneMap.get(node.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832026,
                "title": "simple-java-dfs-using-a-single-map-with-easy-to-understand-comments",
                "content": "```\\nclass Solution {\\n    // map from node of original graph to cloned node in new graph\\n    Map<Node, Node> map = new HashMap<>();\\n    \\n    public Node cloneGraph(Node root) {\\n        if (root == null) return null;\\n        \\n        // if the clone of current node (ie, root) exists, return the clone\\n        if (map.containsKey(root)) return map.get(root);\\n        \\n        // else, create the clone and put it in the map\\n        ArrayList<Node> neighbors = new ArrayList<>();\\n        Node clone = new Node(root.val, neighbors);\\n        map.put(root, clone);\\n        \\n        // clone each neighbor and add it to the newly cloned node\\'s neighbors\\n        for (Node neighbor : root.neighbors) {\\n            clone.neighbors.add(cloneGraph(neighbor));\\n        }\\n        \\n        // return the newly cloned node\\n        return clone;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // map from node of original graph to cloned node in new graph\\n    Map<Node, Node> map = new HashMap<>();\\n    \\n    public Node cloneGraph(Node root) {\\n        if (root == null) return null;\\n        \\n        // if the clone of current node (ie, root) exists, return the clone\\n        if (map.containsKey(root)) return map.get(root);\\n        \\n        // else, create the clone and put it in the map\\n        ArrayList<Node> neighbors = new ArrayList<>();\\n        Node clone = new Node(root.val, neighbors);\\n        map.put(root, clone);\\n        \\n        // clone each neighbor and add it to the newly cloned node\\'s neighbors\\n        for (Node neighbor : root.neighbors) {\\n            clone.neighbors.add(cloneGraph(neighbor));\\n        }\\n        \\n        // return the newly cloned node\\n        return clone;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630130,
                "title": "c-solution-with-comments",
                "content": "```\\nWe use unordered map to clone the graph\\n\\n   Node* cloneGraph(Node* node) {\\n        if(!node)return NULL;\\n       unordered_map<Node*,Node*> map;\\n        Node* copy=new Node(node->val);    //We create a new node with the nodes value\\n        map[node]=copy;                    //We store it in the map so it will help get get access to tha element in o(1) time\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            Node* t=q.front();\\n            q.pop();\\n            for(Node* x:t->neighbors)     //We explore all of its neighbors to make copies of edges and its adjacent nodes\\n            {\\n                if(!map.count(x))        //This is to make sure we dont visit the node multiple times\\n                {\\n                    map[x]=new Node(x->val);   //We create the new nodes\\n                    q.push(x);\\n                }\\n                map[t]->neighbors.push_back(map[x]);   //This the creation of edges\\n            }\\n            \\n        }\\n        return copy;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe use unordered map to clone the graph\\n\\n   Node* cloneGraph(Node* node) {\\n        if(!node)return NULL;\\n       unordered_map<Node*,Node*> map;\\n        Node* copy=new Node(node->val);    //We create a new node with the nodes value\\n        map[node]=copy;                    //We store it in the map so it will help get get access to tha element in o(1) time\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            Node* t=q.front();\\n            q.pop();\\n            for(Node* x:t->neighbors)     //We explore all of its neighbors to make copies of edges and its adjacent nodes\\n            {\\n                if(!map.count(x))        //This is to make sure we dont visit the node multiple times\\n                {\\n                    map[x]=new Node(x->val);   //We create the new nodes\\n                    q.push(x);\\n                }\\n                map[t]->neighbors.push_back(map[x]);   //This the creation of edges\\n            }\\n            \\n        }\\n        return copy;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374863,
                "title": "python-up-to-date-bfs-dfs-solutions",
                "content": "1. DFS Recursively\\n```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.dfs(node)\\n        return node_copy\\n    \\n    def dfs(self, node):\\n        for neighbor in node.neighbors:\\n            if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                neighbor_copy = Node(neighbor.val, [])\\n                self.visited[neighbor] = neighbor_copy\\n                self.visited[node].neighbors.append(neighbor_copy)\\n                self.dfs(neighbor)\\n            else:   # use the neighbor node in the visited dict\\n                self.visited[node].neighbors.append(self.visited[neighbor])\\n```\\n\\n\\n2. DFS + Stack (Iteratively)\\n```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.stack = [node]\\n        \\n        while len(self.stack) > 0:\\n            node = self.stack.pop()\\n            for neighbor in node.neighbors:\\n                if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                    neighbor_copy = Node(neighbor.val, [])\\n                    self.visited[neighbor] = neighbor_copy\\n                    self.visited[node].neighbors.append(neighbor_copy)\\n                    self.stack.append(neighbor)\\n                else:   # use the neighbor node in the visited dict\\n                    self.visited[node].neighbors.append(self.visited[neighbor])\\n        \\n        return node_copy\\n```\\n\\n\\n3. BFS + Queue\\n```\\nimport collections\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.queue = collections.deque([node])\\n        \\n        while len(self.queue) > 0:\\n            node = self.queue.popleft()\\n            for neighbor in node.neighbors:\\n                if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                    neighbor_copy = Node(neighbor.val, [])\\n                    self.visited[neighbor] = neighbor_copy\\n                    self.visited[node].neighbors.append(neighbor_copy)\\n                    self.queue.append(neighbor)\\n                else:   # use the neighbor node in the visited dict\\n                    self.visited[node].neighbors.append(self.visited[neighbor])\\n        \\n        return node_copy\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.dfs(node)\\n        return node_copy\\n    \\n    def dfs(self, node):\\n        for neighbor in node.neighbors:\\n            if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                neighbor_copy = Node(neighbor.val, [])\\n                self.visited[neighbor] = neighbor_copy\\n                self.visited[node].neighbors.append(neighbor_copy)\\n                self.dfs(neighbor)\\n            else:   # use the neighbor node in the visited dict\\n                self.visited[node].neighbors.append(self.visited[neighbor])\\n```\n```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.stack = [node]\\n        \\n        while len(self.stack) > 0:\\n            node = self.stack.pop()\\n            for neighbor in node.neighbors:\\n                if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                    neighbor_copy = Node(neighbor.val, [])\\n                    self.visited[neighbor] = neighbor_copy\\n                    self.visited[node].neighbors.append(neighbor_copy)\\n                    self.stack.append(neighbor)\\n                else:   # use the neighbor node in the visited dict\\n                    self.visited[node].neighbors.append(self.visited[neighbor])\\n        \\n        return node_copy\\n```\n```\\nimport collections\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if node == None:\\n            return None\\n        \\n        self.visited = dict()\\n        node_copy = Node(node.val, [])\\n        self.visited[node] = node_copy\\n        self.queue = collections.deque([node])\\n        \\n        while len(self.queue) > 0:\\n            node = self.queue.popleft()\\n            for neighbor in node.neighbors:\\n                if neighbor not in self.visited:    # add the neighbor node to visited dict\\n                    neighbor_copy = Node(neighbor.val, [])\\n                    self.visited[neighbor] = neighbor_copy\\n                    self.visited[node].neighbors.append(neighbor_copy)\\n                    self.queue.append(neighbor)\\n                else:   # use the neighbor node in the visited dict\\n                    self.visited[node].neighbors.append(self.visited[neighbor])\\n        \\n        return node_copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265110,
                "title": "judge-complains-about-order-of-children",
                "content": "I think my solution is being rejected based on the order of the children.\\n\\nMy output is (newlines and indentation are mine):\\n\\n```\\n{\"$id\":\"1\",\"neighbors\":[\\n\\t{\"$id\":\"2\",\"neighbors\":[\\n\\t\\t{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[\\n\\t\\t\\t{\"$ref\":\"2\"},\\n\\t\\t\\t{\"$id\":\"4\",\"neighbors\":[ \\n\\t\\t\\t\\t{\"$ref\":\"1\"}, {\"$ref\":\"3\"}]   <-- children of 4 are [1, 3]\\n\\t\\t\\t\\t,\"val\":4}], \\n\\t\\t\\t\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\\n\\nThe expected output is:\\n\\n```\\n{\"$id\":\"1\",\"neighbors\":[\\n\\t{\"$id\":\"2\",\"neighbors\":[\\n\\t\\t{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[\\n\\t\\t\\t{\"$ref\":\"2\"},\\n\\t\\t\\t{\"$id\":\"4\",\"neighbors\":[\\n\\t\\t\\t\\t{\"$ref\":\"3\"},{\"$ref\":\"1\"}]    <-- children of 4 are [3, 1]\\n\\t\\t\\t,\"val\":4}],\\n\\t\\t\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\\n\\nWhy is my answer incorrect? Seems like a bug in the judging to me... :-(\\n",
                "solutionTags": [],
                "code": "```\\n{\"$id\":\"1\",\"neighbors\":[\\n\\t{\"$id\":\"2\",\"neighbors\":[\\n\\t\\t{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[\\n\\t\\t\\t{\"$ref\":\"2\"},\\n\\t\\t\\t{\"$id\":\"4\",\"neighbors\":[ \\n\\t\\t\\t\\t{\"$ref\":\"1\"}, {\"$ref\":\"3\"}]   <-- children of 4 are [1, 3]\\n\\t\\t\\t\\t,\"val\":4}], \\n\\t\\t\\t\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\n```\\n{\"$id\":\"1\",\"neighbors\":[\\n\\t{\"$id\":\"2\",\"neighbors\":[\\n\\t\\t{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[\\n\\t\\t\\t{\"$ref\":\"2\"},\\n\\t\\t\\t{\"$id\":\"4\",\"neighbors\":[\\n\\t\\t\\t\\t{\"$ref\":\"3\"},{\"$ref\":\"1\"}]    <-- children of 4 are [3, 1]\\n\\t\\t\\t,\"val\":4}],\\n\\t\\t\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238392,
                "title": "python-solution",
                "content": "BFS:\\n\\n```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        \\n        q = collections.deque([node])\\n        while q:\\n            u = q.popleft()\\n            for nei in u.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    q.append(nei)\\n                nodes[u.label].neighbors.append(nodes[nei.label])\\n        return source\\n```\\n\\nDFS recursive:\\n\\n```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        def dfs(node):\\n            for nei in node.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    dfs(nei)\\n                nodes[node.label].neighbors.append(nodes[nei.label])\\n            \\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        dfs(node)\\n        return source\\n```\\n\\nDFS iterative:\\n\\n```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        \\n        stack = [node]\\n        while stack:\\n            u = stack.pop()\\n            for nei in u.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    stack.append(nei)\\n                nodes[u.label].neighbors.append(nodes[nei.label])\\n        return source\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        \\n        q = collections.deque([node])\\n        while q:\\n            u = q.popleft()\\n            for nei in u.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    q.append(nei)\\n                nodes[u.label].neighbors.append(nodes[nei.label])\\n        return source\\n```\n```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        def dfs(node):\\n            for nei in node.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    dfs(nei)\\n                nodes[node.label].neighbors.append(nodes[nei.label])\\n            \\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        dfs(node)\\n        return source\\n```\n```\\nclass Solution:\\n    # @param node, a undirected graph node\\n    # @return a undirected graph node\\n    def cloneGraph(self, node):\\n        if not node:\\n            return\\n        nodes = {}\\n        source = UndirectedGraphNode(node.label)\\n        nodes[source.label] = source\\n        \\n        stack = [node]\\n        while stack:\\n            u = stack.pop()\\n            for nei in u.neighbors:\\n                if nei.label not in nodes:\\n                    new_node = UndirectedGraphNode(nei.label)\\n                    nodes[nei.label] = new_node\\n                    stack.append(nei)\\n                nodes[u.label].neighbors.append(nodes[nei.label])\\n        return source\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394171,
                "title": "fastest-c-python-java-solution-faster-than-100",
                "content": "**SOLUTION**\\n\\n<iframe src=\"https://leetcode.com/playground/PJSwFBVS/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n\\n**EXPLANATION**\\n\\n* The code is an implementation of the depth-first search algorithm to clone an undirected graph given a reference node.\\n* \\n* The class Node represents a node in the graph, which has an integer value and a list of its neighbors.\\n* The function cloneGraph takes a Node object and returns a deep copy (clone) of the graph.\\n* The function dfs is a recursive helper function that performs a depth-first traversal of the graph and clones each node along the way.\\n* The array visited is used to keep track of visited nodes to avoid infinite recursion.\\n* If the input node is null, the function returns null.\\n* The array visited is initialized to size 101, as the node values are in the range [1, 100].\\n* If a node has already been visited, its clone is returned from the visited array.\\n* Otherwise, a new node is created with the same value as the input node and added to the visited array.\\n* For each neighbor of the input node, the dfs function is called recursively to clone the neighbor and add it to the clone node\\'s neighbor list.\\n* Finally, the clone of the input node is returned from the visited array.\\n\\n**Time complexity:**\\n\\n**O(V + E)**, where V is the number of nodes in the graph and E is the number of edges in the graph. Each node and edge is visited once in the worst case.\\n\\n**Space complexity:**\\n\\n**O(V)**, where V is the number of nodes in the graph. The visited array and the recursion stack used by the depth-first search algorithm both have space complexity proportional to the number of nodes.\\n\\n**PLEASE UPVOTE \\u2B06\\uFE0F**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "**SOLUTION**\\n\\n<iframe src=\"https://leetcode.com/playground/PJSwFBVS/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n\\n**EXPLANATION**\\n\\n* The code is an implementation of the depth-first search algorithm to clone an undirected graph given a reference node.\\n* \\n* The class Node represents a node in the graph, which has an integer value and a list of its neighbors.\\n* The function cloneGraph takes a Node object and returns a deep copy (clone) of the graph.\\n* The function dfs is a recursive helper function that performs a depth-first traversal of the graph and clones each node along the way.\\n* The array visited is used to keep track of visited nodes to avoid infinite recursion.\\n* If the input node is null, the function returns null.\\n* The array visited is initialized to size 101, as the node values are in the range [1, 100].\\n* If a node has already been visited, its clone is returned from the visited array.\\n* Otherwise, a new node is created with the same value as the input node and added to the visited array.\\n* For each neighbor of the input node, the dfs function is called recursively to clone the neighbor and add it to the clone node\\'s neighbor list.\\n* Finally, the clone of the input node is returned from the visited array.\\n\\n**Time complexity:**\\n\\n**O(V + E)**, where V is the number of nodes in the graph and E is the number of edges in the graph. Each node and edge is visited once in the worst case.\\n\\n**Space complexity:**\\n\\n**O(V)**, where V is the number of nodes in the graph. The visited array and the recursion stack used by the depth-first search algorithm both have space complexity proportional to the number of nodes.\\n\\n**PLEASE UPVOTE \\u2B06\\uFE0F**\\n",
                "codeTag": "Java"
            },
            {
                "id": 3393711,
                "title": "c-bfs-and-dfs-both-solutions",
                "content": "# Code    //BFS\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n        unordered_map<Node*,Node*>m;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)return NULL;\\n        Node* start=new Node(node->val,{});\\n        m[node]=start;\\n        queue<Node*>q;\\n        q.push(node);\\n        while(q.size()){\\n            Node* t=q.front();\\n            q.pop();\\n            for(auto i:t->neighbors){\\n                if(m.find(i)==m.end()){\\n                   m[i]=new Node(i->val,{});\\n                   q.push(i);\\n                }\\n                 m[t]->neighbors.push_back(m[i]);\\n            }\\n        }\\n        return m[node];\\n     }\\n};\\n```\\n# Code //DFS\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n        unordered_map<Node*,Node*>m;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)return NULL;\\n        if(m.find(node)==m.end()){\\n           m[node]=new Node(node->val,{});\\n           for(auto i : node->neighbors){\\n               m[node]->neighbors.push_back(cloneGraph(i));\\n           }\\n        }\\n        return m[node];\\n     }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/d3ff20bf-bf05-4a08-89ae-5143b8ad0a76_1680954197.107438.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n        unordered_map<Node*,Node*>m;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)return NULL;\\n        Node* start=new Node(node->val,{});\\n        m[node]=start;\\n        queue<Node*>q;\\n        q.push(node);\\n        while(q.size()){\\n            Node* t=q.front();\\n            q.pop();\\n            for(auto i:t->neighbors){\\n                if(m.find(i)==m.end()){\\n                   m[i]=new Node(i->val,{});\\n                   q.push(i);\\n                }\\n                 m[t]->neighbors.push_back(m[i]);\\n            }\\n        }\\n        return m[node];\\n     }\\n};\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n        unordered_map<Node*,Node*>m;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)return NULL;\\n        if(m.find(node)==m.end()){\\n           m[node]=new Node(node->val,{});\\n           for(auto i : node->neighbors){\\n               m[node]->neighbors.push_back(cloneGraph(i));\\n           }\\n        }\\n        return m[node];\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586613,
                "title": "c-javascript-dfs-easy-code-o-v-e",
                "content": "```\\nclass Solution {\\n    unordered_map<int,Node*> copiedNodes;\\npublic:\\n    \\n    bool isVisited(int val){\\n        bool flag = ( copiedNodes.find(val) != copiedNodes.end() );\\n        return flag;\\n    }\\n    \\n    Node* cloneGraph(Node* node ) {\\n        \\n        // base cases\\n        if(node==nullptr)return node;\\n        if(node->neighbors.size()==0){\\n            return new Node(node->val);\\n        }\\n        \\n        // create new copy node\\n        Node* copyNode = new Node(node->val);\\n        copiedNodes.insert({node->val, copyNode});\\n        \\n       \\n        vector<Node*> copyNeighbors; // vector to hold neighbor nodes\\n         \\n         // explore neighbors nodes\\n        for(auto adj : node->neighbors){\\n            int v = adj->val;\\n            \\n            if(!isVisited(v)){\\n              \\n               copyNeighbors.push_back( cloneGraph(adj) );\\n            }else{\\n                copyNeighbors.push_back(copiedNodes[v]);\\n            }\\n        }\\n        \\n        copyNode->neighbors = copyNeighbors; \\n        \\n        return copyNode;\\n    }\\n};\\n```\\n\\n**Shorter version of equivalent DFS implementation**\\n```\\nclass Solution {\\n    unordered_map<Node*,Node*> copiedNodes;\\npublic:\\n   \\n    Node* cloneGraph(Node* node ) {\\n        \\n        // base cases\\n        if(node==nullptr)return node;\\n        \\n        \\n        // if not visited yet\\n        if(copiedNodes.find(node) == copiedNodes.end()){\\n            \\n            copiedNodes[node] = new Node(node->val, {});\\n            \\n             // explore neighbors nodes\\n            for(auto adj : node->neighbors){\\n               copiedNodes[node]->neighbors.push_back( cloneGraph(adj) ); \\n            }\\n        }\\n     \\n        return copiedNodes[node];\\n        \\n    }\\n};\\n\\n```\\n\\n**Equivalent Javascript Implementation**\\n```\\nconst hmap = new Map();\\nvar cloneGraph = function(node) {\\n    if(!node){\\n        return node;\\n    }\\n    let copy = new Node(node.val, []);\\n    hmap.set(node, copy);\\n    node?.neighbors.forEach(adj => {\\n        if(hmap.has(adj)){\\n            copy.neighbors.push(hmap.get(adj));\\n        }else{\\n            copy.neighbors.push(cloneGraph(adj));\\n        }\\n    });\\n    // return hmap.get(node);\\n    return copy;\\n};\\n```\\n\\n**Upvote if it has helped you. Thanks:)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,Node*> copiedNodes;\\npublic:\\n    \\n    bool isVisited(int val){\\n        bool flag = ( copiedNodes.find(val) != copiedNodes.end() );\\n        return flag;\\n    }\\n    \\n    Node* cloneGraph(Node* node ) {\\n        \\n        // base cases\\n        if(node==nullptr)return node;\\n        if(node->neighbors.size()==0){\\n            return new Node(node->val);\\n        }\\n        \\n        // create new copy node\\n        Node* copyNode = new Node(node->val);\\n        copiedNodes.insert({node->val, copyNode});\\n        \\n       \\n        vector<Node*> copyNeighbors; // vector to hold neighbor nodes\\n         \\n         // explore neighbors nodes\\n        for(auto adj : node->neighbors){\\n            int v = adj->val;\\n            \\n            if(!isVisited(v)){\\n              \\n               copyNeighbors.push_back( cloneGraph(adj) );\\n            }else{\\n                copyNeighbors.push_back(copiedNodes[v]);\\n            }\\n        }\\n        \\n        copyNode->neighbors = copyNeighbors; \\n        \\n        return copyNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    unordered_map<Node*,Node*> copiedNodes;\\npublic:\\n   \\n    Node* cloneGraph(Node* node ) {\\n        \\n        // base cases\\n        if(node==nullptr)return node;\\n        \\n        \\n        // if not visited yet\\n        if(copiedNodes.find(node) == copiedNodes.end()){\\n            \\n            copiedNodes[node] = new Node(node->val, {});\\n            \\n             // explore neighbors nodes\\n            for(auto adj : node->neighbors){\\n               copiedNodes[node]->neighbors.push_back( cloneGraph(adj) ); \\n            }\\n        }\\n     \\n        return copiedNodes[node];\\n        \\n    }\\n};\\n\\n```\n```\\nconst hmap = new Map();\\nvar cloneGraph = function(node) {\\n    if(!node){\\n        return node;\\n    }\\n    let copy = new Node(node.val, []);\\n    hmap.set(node, copy);\\n    node?.neighbors.forEach(adj => {\\n        if(hmap.has(adj)){\\n            copy.neighbors.push(hmap.get(adj));\\n        }else{\\n            copy.neighbors.push(cloneGraph(adj));\\n        }\\n    });\\n    // return hmap.get(node);\\n    return copy;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494107,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Build a hash `{key:cloned_node}`\\n``` javascript \\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n    \\n    var visited = {};\\n    \\n    let dfs = function(node) {\\n        if (!node) return node;\\n        if (visited[node.val]!=null) return visited[node.val];\\n        \\n        let root = new Node(node.val);\\n        visited[node.val] = root;\\n\\n        for (let n of node.neighbors) {\\n            root.neighbors.push(dfs(n));\\n        }\\n         \\n        return root;\\n    }\\n    \\n    return dfs(node);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript \\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n    \\n    var visited = {};\\n    \\n    let dfs = function(node) {\\n        if (!node) return node;\\n        if (visited[node.val]!=null) return visited[node.val];\\n        \\n        let root = new Node(node.val);\\n        visited[node.val] = root;\\n\\n        for (let n of node.neighbors) {\\n            root.neighbors.push(dfs(n));\\n        }\\n         \\n        return root;\\n    }\\n    \\n    return dfs(node);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393339,
                "title": "simple-go-dfs-c-bfs-solutions",
                "content": "# Approach\\nDFS and BFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\nGo\\n```\\nfunc cloneGraph(node *Node) *Node {\\n\\tif node == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tcopies := make([]*Node, 101)\\n\\n\\tdfs(node, copies)\\n\\n\\treturn copies[node.Val]\\n}\\n\\nfunc dfs(node *Node, copies []*Node) {\\n\\tnewNode := new(Node)\\n\\tnewNode.Val = node.Val\\n\\n\\tcopies[node.Val] = newNode\\n\\n\\tfor _, neighbor := range node.Neighbors {\\n\\t\\tif copies[neighbor.Val] == nil {\\n\\t\\t\\tdfs(neighbor, copies)\\n\\t\\t}\\n\\n\\t\\tnewNode.Neighbors = append(newNode.Neighbors, copies[neighbor.Val])\\n\\t}\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        if (node is null) return null;\\n        var queue = new Queue<Node>();\\n        var visited = new Dictionary<Node, (Node, bool)>();\\n        queue.Enqueue(node);\\n        visited.Add(node, (new Node(node.val), false));\\n\\n        while (queue.Any()) {\\n            var current = queue.Dequeue();\\n            var copy = visited[current].Item1;\\n\\n            foreach (var neighbor in current.neighbors) {\\n                if (!visited.ContainsKey(neighbor))\\n                    visited.Add(neighbor, (new Node(neighbor.val), false));\\n\\n                copy.neighbors.Add(visited[neighbor].Item1);\\n\\n                if (!visited[neighbor].Item2 && !queue.Contains(neighbor))\\n                    queue.Enqueue(neighbor);\\n            }\\n\\n            visited[current] = (visited[current].Item1, true);\\n        }\\n\\n        return visited[node].Item1;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc cloneGraph(node *Node) *Node {\\n\\tif node == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tcopies := make([]*Node, 101)\\n\\n\\tdfs(node, copies)\\n\\n\\treturn copies[node.Val]\\n}\\n\\nfunc dfs(node *Node, copies []*Node) {\\n\\tnewNode := new(Node)\\n\\tnewNode.Val = node.Val\\n\\n\\tcopies[node.Val] = newNode\\n\\n\\tfor _, neighbor := range node.Neighbors {\\n\\t\\tif copies[neighbor.Val] == nil {\\n\\t\\t\\tdfs(neighbor, copies)\\n\\t\\t}\\n\\n\\t\\tnewNode.Neighbors = append(newNode.Neighbors, copies[neighbor.Val])\\n\\t}\\n}\\n```\n```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        if (node is null) return null;\\n        var queue = new Queue<Node>();\\n        var visited = new Dictionary<Node, (Node, bool)>();\\n        queue.Enqueue(node);\\n        visited.Add(node, (new Node(node.val), false));\\n\\n        while (queue.Any()) {\\n            var current = queue.Dequeue();\\n            var copy = visited[current].Item1;\\n\\n            foreach (var neighbor in current.neighbors) {\\n                if (!visited.ContainsKey(neighbor))\\n                    visited.Add(neighbor, (new Node(neighbor.val), false));\\n\\n                copy.neighbors.Add(visited[neighbor].Item1);\\n\\n                if (!visited[neighbor].Item2 && !queue.Contains(neighbor))\\n                    queue.Enqueue(neighbor);\\n            }\\n\\n            visited[current] = (visited[current].Item1, true);\\n        }\\n\\n        return visited[node].Item1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393172,
                "title": "day-98-dfs-hash-table-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*This problem is about cloning a given connected undirected graph. Given a reference to a node in the graph, we need to create a deep copy of the entire graph.*\\n\\n*To accomplish this, we can use DFS traversal of the input graph, starting from the given node, and create a new copy of each node and its neighbors. We can use a map to keep track of nodes that have already been cloned so that we don\\'t create duplicate nodes.*\\n\\n*During the DFS traversal, we create a new node for each node that we visit, and we add this node to our map. We then recursively visit all of the node\\'s neighbors and create a new node for each neighbor, adding them to the current node\\'s list of neighbors. If a neighbor has already been cloned, we simply add a reference to the cloned neighbor to the current node\\'s list of neighbors.*\\n\\n*Once we have finished traversing the entire graph, we will have created a deep copy of the input graph. Finally, we return a reference to the cloned node that was provided as input.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize an empty unordered map to keep track of nodes that have already been cloned.\\n2. Check if the input node is null. If it is, return null.\\n3. Check if the input node already exists in the map. If it does, return its corresponding clone.\\n4. If the node is new, create a new clone with the same value as the input node and add it to the map.\\n5. Iterate through each of the input node\\'s neighbors and recursively clone them, adding them to the clone\\'s list of neighbors.\\n6. Return the clone of the input node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors; \\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> cloningGraph;\\n    \\n    Node* cloneGraph(Node* node) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        if (cloningGraph.find(node) == cloningGraph.end()) {\\n            cloningGraph[node] = new Node(node -> val);\\n            for (auto neighbor : node -> neighbors) {\\n                cloningGraph[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return cloningGraph[node];\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<Node, Node> cloningGraph = new HashMap<>();\\n    \\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        if (cloningGraph.containsKey(node)) {\\n            return cloningGraph.get(node);\\n        }\\n        Node clone = new Node(node.val);\\n        cloningGraph.put(node, clone);\\n        for (Node neighbor : node.neighbors) {\\n            clone.neighbors.add(cloneGraph(neighbor));\\n        }\\n        return clone;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.cloningGraph = {}\\n        \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        if node in self.cloningGraph:\\n            return self.cloningGraph[node]\\n        clone = Node(node.val, [])\\n        self.cloningGraph[node] = clone\\n        for neighbor in node.neighbors:\\n            clone.neighbors.append(self.cloneGraph(neighbor))\\n        return clone\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** The algorithm performs a depth-first search (DFS) of the input graph, visiting each node and its neighbors exactly once. Therefore, the time complexity is **O(N + E), where N is the number of nodes in the graph and E is the number of edges in the graph.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** The algorithm uses an unordered map to keep track of nodes that have already been cloned, which could potentially store all nodes in the graph. Therefore, the space complexity is O(N), where N is the number of nodes in the graph. Additionally, the algorithm uses recursive function calls, which could result in a recursive call stack with a maximum depth of N. Therefore, the space complexity due to the call stack is also O(N). Therefore, **the overall space complexity of the algorithm is O(N).**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors; \\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> cloningGraph;\\n    \\n    Node* cloneGraph(Node* node) {\\n        if (node == nullptr) {\\n            return nullptr;\\n        }\\n        if (cloningGraph.find(node) == cloningGraph.end()) {\\n            cloningGraph[node] = new Node(node -> val);\\n            for (auto neighbor : node -> neighbors) {\\n                cloningGraph[node] -> neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return cloningGraph[node];\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<Node, Node> cloningGraph = new HashMap<>();\\n    \\n    public Node cloneGraph(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        if (cloningGraph.containsKey(node)) {\\n            return cloningGraph.get(node);\\n        }\\n        Node clone = new Node(node.val);\\n        cloningGraph.put(node, clone);\\n        for (Node neighbor : node.neighbors) {\\n            clone.neighbors.add(cloneGraph(neighbor));\\n        }\\n        return clone;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.cloningGraph = {}\\n        \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        if node in self.cloningGraph:\\n            return self.cloningGraph[node]\\n        clone = Node(node.val, [])\\n        self.cloningGraph[node] = clone\\n        for neighbor in node.neighbors:\\n            clone.neighbors.append(self.cloneGraph(neighbor))\\n        return clone\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393057,
                "title": "c-bfs-map-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node) return node;\\n        unordered_map<Node*,Node*> m;\\n        Node* ans = new Node(node->val,{});\\n        m[node]=ans;\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            Node* currNode=q.front();\\n            q.pop();\\n            vector<Node*> neigh = currNode->neighbors;\\n            for(auto x:neigh){\\n                if(m.find(x)==m.end()){\\n                    m[x] = new Node(x->val,{});\\n                    q.push(x);\\n                }\\n                m[currNode]->neighbors.push_back(m[x]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node) return node;\\n        unordered_map<Node*,Node*> m;\\n        Node* ans = new Node(node->val,{});\\n        m[node]=ans;\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            Node* currNode=q.front();\\n            q.pop();\\n            vector<Node*> neigh = currNode->neighbors;\\n            for(auto x:neigh){\\n                if(m.find(x)==m.end()){\\n                    m[x] = new Node(x->val,{});\\n                    q.push(x);\\n                }\\n                m[currNode]->neighbors.push_back(m[x]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633497,
                "title": "python-easy-simple-dfs-98-27-faster",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        clones = {}\\n      \\n        \\n        def solve ( node ) :\\n            new_ = Node(node.val)    # create a copy of current node\\n            clones[node] = new_      # add current and new node in hash map\\n            \\n            for vertex in node.neighbors :\\n                if vertex in clones :     # if current node\\'s neighbor is already created\\n                    new_.neighbors.append(clones[vertex])\\n                    \\n                else :                      # else call for solve to create another copy of vertex\\n                    new_.neighbors.append(solve(vertex))\\n                    \\n            return new_\\n        \\n        if not node :\\n            return None\\n        \\n        return solve( node )",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        clones = {}",
                "codeTag": "Java"
            },
            {
                "id": 1793605,
                "title": "python-3-dfs-and-bfs-solutions-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3]\\uD83D\\uDE0E DFS and BFS Solutions and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 DFS Approach:\\n* The tricky part of this question is how do we create a clone node and connect to its clone nodes as well.\\n In order to solve this quesition, we use a **hashMap** which store **key = original node** and **value = clone node**\\n That is **graphMap[node] = it\\'s clone node**\\n\\n* In the DFS function, we also use the hashMap as a visited map. Once we see a node in hashMap, we knew that we have already clone this node so we return **graphMap[node]**\\n And **for neighbors**, we recurrsive call dfs to create a clone neighbor and append it in cloneNode\\'s neighbors.\\n\\n## Complexity Analysis\\n* Time: O(V + E) : Let V be nodes in graph and E be edges in graph\\n* Space: O(V): The hashmap stores V nodes and althrough we use recursive call on dfs, at maximum it grows at most O(V) stack => O(V)\\n\\n## DFS Code\\n```\\n# DFS O(V + E)| O(V)\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        # Edge Case\\n        if node is None:\\n            return None \\n        graphMap = {}\\n        \\n        def dfs(node):\\n            # Means visited\\n            if node in graphMap: \\n                return graphMap[node]\\n            cloneNode = Node(node.val)\\n            graphMap[node] = cloneNode\\n            # Find neighbor\\n            for neighbor in node.neighbors:\\n                # DFS neighbors, once create a clone node, append it in neighbors\\n                cloneNode.neighbors.append(dfs(neighbor))\\n            return cloneNode\\n        \\n        return dfs(node)\\n```\\n\\n## 2\\uFE0F\\u20E3 BFS Approach:\\n* We use same hashMap technique as previous to store graph. >> We use a **hashMap** which store **key = original node** and **value = clone node**\\n That is **graphMap[node] = it\\'s clone node**\\n> In BFS queue\\n> If we not visited the neighbor => we not visited it yet. 1. Append in queue  2.Create its clone 3. Map clone node and original node\\n> Once we done that we append **graphMap[neighbor]** to **graphMap[currNode]**\\'s neighbors\\n\\n## Complexity Analysis\\n* Time: O(V + E) : Let V be nodes in graph and E be edges in graph\\n* Space: O(V): The hashmap stores V nodes.\\n\\n\\n## BFS Code\\n```\\n# BFS O(V + E)| O(V)\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        # Edge Case\\n        if node is None:\\n            return None  \\n        graphMap = {}\\n        \\n        def bfs(node):\\n            # Init queue\\n            queue = deque([node])\\n            graphMap[node] = Node(node.val)\\n            #Start BFS\\n            while queue:\\n                currNode = queue.popleft()\\n                for neighbor in currNode.neighbors:\\n                    if neighbor not in graphMap:\\n                        graphMap[neighbor] = Node(neighbor.val)\\n                        queue.append(neighbor)\\n                    # Once we create a clone node, connect to its clone neighbors\\n                    graphMap[currNode].neighbors.append(graphMap[neighbor])\\n            return graphMap[node]\\n            \\n        return bfs(node)\\n\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# DFS O(V + E)| O(V)\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        # Edge Case\\n        if node is None:\\n            return None \\n        graphMap = {}\\n        \\n        def dfs(node):\\n            # Means visited\\n            if node in graphMap: \\n                return graphMap[node]\\n            cloneNode = Node(node.val)\\n            graphMap[node] = cloneNode\\n            # Find neighbor\\n            for neighbor in node.neighbors:\\n                # DFS neighbors, once create a clone node, append it in neighbors\\n                cloneNode.neighbors.append(dfs(neighbor))\\n            return cloneNode\\n        \\n        return dfs(node)\\n```\n```\\n# BFS O(V + E)| O(V)\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        # Edge Case\\n        if node is None:\\n            return None  \\n        graphMap = {}\\n        \\n        def bfs(node):\\n            # Init queue\\n            queue = deque([node])\\n            graphMap[node] = Node(node.val)\\n            #Start BFS\\n            while queue:\\n                currNode = queue.popleft()\\n                for neighbor in currNode.neighbors:\\n                    if neighbor not in graphMap:\\n                        graphMap[neighbor] = Node(neighbor.val)\\n                        queue.append(neighbor)\\n                    # Once we create a clone node, connect to its clone neighbors\\n                    graphMap[currNode].neighbors.append(graphMap[neighbor])\\n            return graphMap[node]\\n            \\n        return bfs(node)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793503,
                "title": "solution-swift-clone-graph",
                "content": "```swift\\nclass Solution {\\n    func cloneGraph(_ node: Node?) -> Node? {\\n        var visited: [Int:Node] = [:]\\n        return dfs(node, &visited)\\n    }\\n    \\n    private func dfs(_ node: Node?, _ visited: inout [Int:Node]) -> Node? {\\n        guard let node = node else { return nil }\\n        \\n        let new = Node(node.val)\\n        visited[node.val] = new\\n        \\n        for n in node.neighbors where n != nil {\\n            guard let nbr = visited[n!.val] ?? dfs(n, &visited) else { break }\\n            new.neighbors.append(nbr)\\n        }\\n        return new\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>Node</b></summary>\\n\\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var neighbors: [Node?]\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.neighbors = []\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func cloneGraph(_ node: Node?) -> Node? {\\n        var visited: [Int:Node] = [:]\\n        return dfs(node, &visited)\\n    }\\n    \\n    private func dfs(_ node: Node?, _ visited: inout [Int:Node]) -> Node? {\\n        guard let node = node else { return nil }\\n        \\n        let new = Node(node.val)\\n        visited[node.val] = new\\n        \\n        for n in node.neighbors where n != nil {\\n            guard let nbr = visited[n!.val] ?? dfs(n, &visited) else { break }\\n            new.neighbors.append(nbr)\\n        }\\n        return new\\n    }\\n}\\n```\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var neighbors: [Node?]\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.neighbors = []\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599104,
                "title": "recursive-ruby-solution",
                "content": "```\\ndef cloneGraph(node)\\n    return nil if node.nil?\\n    \\n    @mapping = {}\\n    deep_clone(node)    \\nend\\n\\ndef deep_clone(node)\\n    return @mapping[node.val] if @mapping[node.val]\\n    \\n    @mapping[node.val] = Node.new(node.val)\\n    \\n    @mapping[node.val].neighbors = node.neighbors.map do |neighbor|\\n        deep_clone(neighbor)\\n    end\\n    \\n    @mapping[node.val]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef cloneGraph(node)\\n    return nil if node.nil?\\n    \\n    @mapping = {}\\n    deep_clone(node)    \\nend\\n\\ndef deep_clone(node)\\n    return @mapping[node.val] if @mapping[node.val]\\n    \\n    @mapping[node.val] = Node.new(node.val)\\n    \\n    @mapping[node.val].neighbors = node.neighbors.map do |neighbor|\\n        deep_clone(neighbor)\\n    end\\n    \\n    @mapping[node.val]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 568617,
                "title": "c-6-lines-function",
                "content": "```\\n    public class Solution\\n    {\\n        Dictionary<int, Node> visited = new Dictionary<int, Node>();\\n        public Node CloneGraph(Node node)\\n        {\\n            if (node == null) return null;\\n            var result = new Node(node.val);\\n            visited[node.val] = result;\\n            foreach (var n in node.neighbors)\\n                result.neighbors.Add(visited.TryGetValue(n.val, out var visitedNode) ? visitedNode : CloneGraph(n));\\n            return result;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        Dictionary<int, Node> visited = new Dictionary<int, Node>();\\n        public Node CloneGraph(Node node)\\n        {\\n            if (node == null) return null;\\n            var result = new Node(node.val);\\n            visited[node.val] = result;\\n            foreach (var n in node.neighbors)\\n                result.neighbors.Add(visited.TryGetValue(n.val, out var visitedNode) ? visitedNode : CloneGraph(n));\\n            return result;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42399,
                "title": "11-liner-in-python-c",
                "content": "First create nodes, than create connections. Easy-peasy.\\n\\n```\\nclass Solution(object):\\n    def cloneGraph(self, start):\\n        if not start: return None\\n        new, old, queue = {}, {}, [start]\\n        for node in queue:\\n            if node.label in new: continue\\n            new[node.label] = UndirectedGraphNode(node.label)\\n            old[node.label] = node\\n            for neigh in node.neighbors: queue += neigh,\\n        for label in new:\\n            for neighl in old[label].neighbors:\\n                new[label].neighbors += new[neighl.label],\\n        return new.pop(start.label, None)\\n```\\nC++ version, same amount of lines (more or less):\\n\\n```\\ntypedef UndirectedGraphNode UGNode;\\n\\nclass Solution {\\npublic:\\n    UGNode* cloneGraph(UGNode* start) {\\n        if (start == NULL) return NULL;\\n        map<int, UGNode*> news, olds;\\n        queue<UGNode*> q; q.push(start);\\n        while (!q.empty()) {\\n            auto node = q.front(); q.pop();\\n            if (news.count(node->label)) continue;\\n            news[node->label] = new UGNode(node->label);\\n            olds[node->label] = node;\\n            for (auto neigh: node->neighbors) q.push(neigh);\\n        }\\n        for (auto keyval: news) {\\n            for (auto neighl: olds[keyval.first]->neighbors)\\n                news[keyval.first]->neighbors.push_back(news[neighl->label]);\\n        }\\n        return news[start->label];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def cloneGraph(self, start):\\n        if not start: return None\\n        new, old, queue = {}, {}, [start]\\n        for node in queue:\\n            if node.label in new: continue\\n            new[node.label] = UndirectedGraphNode(node.label)\\n            old[node.label] = node\\n            for neigh in node.neighbors: queue += neigh,\\n        for label in new:\\n            for neighl in old[label].neighbors:\\n                new[label].neighbors += new[neighl.label],\\n        return new.pop(start.label, None)\\n```\n```\\ntypedef UndirectedGraphNode UGNode;\\n\\nclass Solution {\\npublic:\\n    UGNode* cloneGraph(UGNode* start) {\\n        if (start == NULL) return NULL;\\n        map<int, UGNode*> news, olds;\\n        queue<UGNode*> q; q.push(start);\\n        while (!q.empty()) {\\n            auto node = q.front(); q.pop();\\n            if (news.count(node->label)) continue;\\n            news[node->label] = new UGNode(node->label);\\n            olds[node->label] = node;\\n            for (auto neigh: node->neighbors) q.push(neigh);\\n        }\\n        for (auto keyval: news) {\\n            for (auto neighl: olds[keyval.first]->neighbors)\\n                news[keyval.first]->neighbors.push_back(news[neighl->label]);\\n        }\\n        return news[start->label];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42492,
                "title": "bfs-and-dfs-with-hash-unordered-map-in-c",
                "content": "\\nBoth BFS and DFS use hash(unordered_map) to connect node with new clone node.\\n\\n1. BFS\\n======\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node)\\n    {\\n        if(node == NULL)\\n            return NULL;\\n        \\n        unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> map;\\n        map[node] = new UndirectedGraphNode(node -> label);\\n        \\n        queue<UndirectedGraphNode *> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            UndirectedGraphNode *temp = q.front();\\n            q.pop();\\n            \\n            for(int i = 0; i < temp -> neighbors.size(); ++ i)\\n            {\\n                if(map.find(temp -> neighbors[i]) == map.end())\\n                {\\n                    map[temp -> neighbors[i]] = new UndirectedGraphNode(temp -> neighbors[i] -> label);\\n                    q.push(temp -> neighbors[i]);\\n                }\\n                (map[temp] -> neighbors).push_back(map[temp -> neighbors[i]]);\\n            }\\n        }\\n        \\n        return map[node];\\n    }\\n\\n2. DFS\\n======\\n    unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> map;\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node)\\n    {\\n        if(node == NULL)\\n            return NULL;\\n        \\n        if(map.find(node) == map.end())\\n        {\\n            map[node] = new UndirectedGraphNode(node -> label);\\n            for(auto n : node -> neighbors)\\n                (map[node] -> neighbors).push_back(cloneGraph(n));\\n        }\\n        return map[node];\\n    }\\n\\nSee [here](http://www.makuiyu.cn/2015/03/LeetCode_133.%20Clone%20Graph/) for more.",
                "solutionTags": [],
                "code": "\\nBoth BFS and DFS use hash(unordered_map) to connect node with new clone node.\\n\\n1. BFS\\n======\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node)\\n    {\\n        if(node == NULL)\\n            return NULL;\\n        \\n        unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> map;\\n        map[node] = new UndirectedGraphNode(node -> label);\\n        \\n        queue<UndirectedGraphNode *> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            UndirectedGraphNode *temp = q.front();\\n            q.pop();\\n            \\n            for(int i = 0; i < temp -> neighbors.size(); ++ i)\\n            {\\n                if(map.find(temp -> neighbors[i]) == map.end())\\n                {\\n                    map[temp -> neighbors[i]] = new UndirectedGraphNode(temp -> neighbors[i] -> label);\\n                    q.push(temp -> neighbors[i]);\\n                }\\n                (map[temp] -> neighbors).push_back(map[temp -> neighbors[i]]);\\n            }\\n        }\\n        \\n        return map[node];\\n    }\\n\\n2. DFS\\n======\\n    unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> map;\\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node)\\n    {\\n        if(node == NULL)\\n            return NULL;\\n        \\n        if(map.find(node) == map.end())\\n        {\\n            map[node] = new UndirectedGraphNode(node -> label);\\n            for(auto n : node -> neighbors)\\n                (map[node] -> neighbors).push_back(cloneGraph(n));\\n        }\\n        return map[node];\\n    }\\n\\nSee [here](http://www.makuiyu.cn/2015/03/LeetCode_133.%20Clone%20Graph/) for more.",
                "codeTag": "Unknown"
            },
            {
                "id": 3391987,
                "title": "simplest-java-solution",
                "content": "# Code\\n```java []\\nclass Solution {\\n    // A mapping of each node in the old graph to its corresponding node in the newGraph\\n    HashMap<Node, Node> mp = new HashMap<>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n        if (mp.containsKey(node)) return mp.get(node);\\n\\n        Node newNode = new Node(node.val);\\n        mp.put(node, newNode);\\n        \\n        for (Node nb: node.neighbors) {\\n            newNode.neighbors.add(cloneGraph(nb));\\n        }\\n\\n        return newNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    // A mapping of each node in the old graph to its corresponding node in the newGraph\\n    HashMap<Node, Node> mp = new HashMap<>();\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n        if (mp.containsKey(node)) return mp.get(node);\\n\\n        Node newNode = new Node(node.val);\\n        mp.put(node, newNode);\\n        \\n        for (Node nb: node.neighbors) {\\n            newNode.neighbors.add(cloneGraph(nb));\\n        }\\n\\n        return newNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201693,
                "title": "133-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem requires us to make a deep copy of the graph represented by the adjacency list. We can achieve this by using a HashMap to keep track of the nodes we have visited and their corresponding cloned nodes.\\n\\nWe start by cloning the first node (with value 1) and adding it to the HashMap. We then perform a Depth First Search (DFS) on the graph, starting at the first node. For each neighbor of a node that we encounter, we check if it has already been visited. If it has not, we create a new clone node and add it to the HashMap, and then add it to the neighbors list of the cloned node that we are currently visiting. We then recursively perform DFS on the neighbor. If the neighbor has already been visited, we simply add its corresponding cloned node to the neighbors list of the cloned node that we are currently visiting.\\n\\nAfter we have visited all the nodes in the graph, we return the cloned node with value 1.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N+E), where N is the number of nodes and E is the number of edges in the graph, because we visit each node and edge once during the DFS traversal.\\n\\n- Space complexity:\\nThe space complexity is also O(N+E), because we use a dictionary to store the cloned nodes and a recursion stack to perform the DFS traversal.\\n\\n# Code\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        \\n        visited = {} # dictionary to store the cloned nodes\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return visited[node] # if node already visited, return the corresponding cloned node\\n            \\n            clone_node = Node(node.val, []) # create a new clone node\\n            \\n            visited[node] = clone_node # add the original node and its clone to the dictionary\\n            \\n            for neighbor in node.neighbors: # visit all the neighbors of the node\\n                clone_node.neighbors.append(dfs(neighbor)) # if neighbor not visited, create a new clone node and append to the neighbors list of the clone node we are currently visiting. Otherwise, append the corresponding cloned node to the neighbors list.\\n            \\n            return clone_node\\n        \\n        return dfs(node) # start DFS from the first node and return its clone\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        \\n        visited = {} # dictionary to store the cloned nodes\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return visited[node] # if node already visited, return the corresponding cloned node\\n            \\n            clone_node = Node(node.val, []) # create a new clone node\\n            \\n            visited[node] = clone_node # add the original node and its clone to the dictionary\\n            \\n            for neighbor in node.neighbors: # visit all the neighbors of the node\\n                clone_node.neighbors.append(dfs(neighbor)) # if neighbor not visited, create a new clone node and append to the neighbors list of the clone node we are currently visiting. Otherwise, append the corresponding cloned node to the neighbors list.\\n            \\n            return clone_node\\n        \\n        return dfs(node) # start DFS from the first node and return its clone\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306261,
                "title": "faster-then-99-7-submission",
                "content": "```\\n   public Node cloneGraph(Node node) {\\n        if(node == null){\\n            return null;\\n        }\\n        // Creating a hashmap to keep track of original node val and cloned Node creted for it.\\n        HashMap<Integer,Node> map = new HashMap<>();\\n        return deepClone(node, map);\\n\\n    }\\n\\n    private Node deepClone(Node node, HashMap<Integer,Node> map ) {\\n        // check if original node value is already present in map. If yes, then return that node.\\n        if(map.containsKey(node.val)){\\n            return map.get(node.val);\\n        }\\n        // creating cloned node for original node.val\\n        Node clonedNode = new Node(node.val);\\n        // Adding cloned node with original node.val in the map to keep track that which node is already cloned\\n        map.put(node.val, clonedNode);\\n        // Now we need to work on cloning it neighbours as well. So iterating over the neighbours on original node, so we can use the same neighbours to clone them and add the connections to the cloned node\\n        for(Node neighbor : node.neighbors) {\\n            clonedNode.neighbors.add(deepClone(neighbor, map));\\n        }\\n        return clonedNode;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n   public Node cloneGraph(Node node) {\\n        if(node == null){\\n            return null;\\n        }\\n        // Creating a hashmap to keep track of original node val and cloned Node creted for it.\\n        HashMap<Integer,Node> map = new HashMap<>();\\n        return deepClone(node, map);\\n\\n    }\\n\\n    private Node deepClone(Node node, HashMap<Integer,Node> map ) {\\n        // check if original node value is already present in map. If yes, then return that node.\\n        if(map.containsKey(node.val)){\\n            return map.get(node.val);\\n        }\\n        // creating cloned node for original node.val\\n        Node clonedNode = new Node(node.val);\\n        // Adding cloned node with original node.val in the map to keep track that which node is already cloned\\n        map.put(node.val, clonedNode);\\n        // Now we need to work on cloning it neighbours as well. So iterating over the neighbours on original node, so we can use the same neighbours to clone them and add the connections to the cloned node\\n        for(Node neighbor : node.neighbors) {\\n            clonedNode.neighbors.add(deepClone(neighbor, map));\\n        }\\n        return clonedNode;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884892,
                "title": "go-simple-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Neighbors []*Node\\n * }\\n */\\n\\nfunc cloneGraph(node *Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    \\n    record := make(map[*Node]*Node)\\n    \\n    dfs(node, record)\\n    \\n    return record[node]\\n}\\n\\nfunc dfs(node *Node, record map[*Node]*Node) {\\n    if node == nil {\\n        return \\n    }\\n    \\n    newNode := new(Node)\\n    newNode.Val = node.Val\\n    \\n    record[node] = newNode\\n    \\n    for _, child := range node.Neighbors {\\n        if _, exist := record[child]; !exist {\\n            dfs(child, record)\\n        }\\n        \\n        newNode.Neighbors = append(newNode.Neighbors, record[child])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Neighbors []*Node\\n * }\\n */\\n\\nfunc cloneGraph(node *Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    \\n    record := make(map[*Node]*Node)\\n    \\n    dfs(node, record)\\n    \\n    return record[node]\\n}\\n\\nfunc dfs(node *Node, record map[*Node]*Node) {\\n    if node == nil {\\n        return \\n    }\\n    \\n    newNode := new(Node)\\n    newNode.Val = node.Val\\n    \\n    record[node] = newNode\\n    \\n    for _, child := range node.Neighbors {\\n        if _, exist := record[child]; !exist {\\n            dfs(child, record)\\n        }\\n        \\n        newNode.Neighbors = append(newNode.Neighbors, record[child])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793974,
                "title": "java-bfs-dfs-o-v-e-easy-to-understand",
                "content": "**BFS Solution:**\\n```\\nclass Solution {\\n    private Node BFS(Node node) {\\n        HashMap<Node, Node> hMap = new HashMap<>();\\n        Queue<Node> q = new LinkedList<>();\\n        if(node != null) {\\n            hMap.put(node, new Node(node.val));\\n            q.add(node);\\n        }\\n        while(!q.isEmpty()) {\\n            Node currNode = q.remove();\\n            for(Node adj : currNode.neighbors) {\\n                if(!hMap.containsKey(adj)) {\\n                    hMap.put(adj, new Node(adj.val));\\n                    q.add(adj);\\n                }\\n                hMap.get(currNode).neighbors.add(hMap.get(adj));\\n            }\\n        }\\n        return hMap.get(node);\\n    }\\n    public Node cloneGraph(Node node) {\\n        return BFS(node);\\n    }\\n}\\n```\\n**DFS Solution:**\\n```\\nclass Solution {\\n    private HashMap<Node, Node> hMap = new HashMap<>();\\n    private Node DFS(Node currNode) {\\n        if(currNode == null) return currNode;\\n        if(hMap.containsKey(currNode)) return hMap.get(currNode);\\n        hMap.put(currNode, new Node(currNode.val));\\n        for(Node adj : currNode.neighbors) {\\n            hMap.get(currNode).neighbors.add(DFS(adj));\\n        }\\n        return hMap.get(currNode);\\n    }\\n    public Node cloneGraph(Node node) {\\n        return DFS(node);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private Node BFS(Node node) {\\n        HashMap<Node, Node> hMap = new HashMap<>();\\n        Queue<Node> q = new LinkedList<>();\\n        if(node != null) {\\n            hMap.put(node, new Node(node.val));\\n            q.add(node);\\n        }\\n        while(!q.isEmpty()) {\\n            Node currNode = q.remove();\\n            for(Node adj : currNode.neighbors) {\\n                if(!hMap.containsKey(adj)) {\\n                    hMap.put(adj, new Node(adj.val));\\n                    q.add(adj);\\n                }\\n                hMap.get(currNode).neighbors.add(hMap.get(adj));\\n            }\\n        }\\n        return hMap.get(node);\\n    }\\n    public Node cloneGraph(Node node) {\\n        return BFS(node);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private HashMap<Node, Node> hMap = new HashMap<>();\\n    private Node DFS(Node currNode) {\\n        if(currNode == null) return currNode;\\n        if(hMap.containsKey(currNode)) return hMap.get(currNode);\\n        hMap.put(currNode, new Node(currNode.val));\\n        for(Node adj : currNode.neighbors) {\\n            hMap.get(currNode).neighbors.add(DFS(adj));\\n        }\\n        return hMap.get(currNode);\\n    }\\n    public Node cloneGraph(Node node) {\\n        return DFS(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665277,
                "title": "recursive-and-iterative-solutions-in-python-stack-and-queue",
                "content": "## 1. Recursive DFS solution using built-in stack\\n---\\nHere and below, V and E refer to the number of vertices and edges in a graph G = (V, E), respectively.\\n### Time complexity: O(V + E), because we need to visit all vertices and traverse all edges in the graph.\\n### Space complexity: O(V), because the worst case is when we have a complete graph (i.e. there\\'s an edge between every pair of vertices), in which the depth of the recursion stack would be the number of nodes in the graph.\\n\\nTo construct the clone graph, we need to traverse through the original graph and generate the copy nodes at the same time. To allow us to be able to form the edge connections properly, we need a mapping that lets us know what the original edge connections/relationships were in the original graph. Hence why we\\'re using a map to map nodes in the original graph to nodes in the copy graph. Since the graph is undirected, whenever there\\'s an edge from A -> B, there\\'s also one from B -> A. Thus, to not get caught in an infinite loop, the visited map serves the dual purpose of allowing us to keep track of which nodes we\\'ve already visited, so that we don\\'t visit them yet again.\\n\\n```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {}\\n\\n        def dfs(node):\\n            if node in visited:\\n                return visited[node]\\n\\n            clone = Node(node.val)\\n            visited[node] = clone\\n\\n            for neighbor in node.neighbors:\\n                visited[node].neighbors.append(dfs(neighbor))\\n\\n            return clone\\n\\n        return dfs(node)\\n\\n```\\n## 2. Iterative DFS solution with user-managed stack\\n---\\n### Time complexity: O(V + E)\\n### Space complexity: O(V)\\n\\nThe iterative version is essentially the same as the recursive version, with the only difference being that we have to manage the stack ourselves.\\n```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n  def __init__(self, val = 0, neighbors = None):\\n    self.val = val\\n    self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {node: Node(node.val)}\\n        stack = [node]\\n\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n\\n            for neighbor in curr.neighbors:\\n                if neighbor not in visited:\\n                    visited[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n\\n                visited[curr].neighbors.append(visited[neighbor])\\n\\n        return visited[node]\\n\\n```\\n\\n## 3. Iterative BFS solution with queue\\n---\\n### Time complexity: O(V + E)\\n### Space complexity: O(V)\\n\\nSurprisingly, the iterative BFS version looks nearly identical to the iterative DFS version, with only two lines of difference. Since our graph is connected, it doesn\\'t matter whether we visit vertices in breadth-first or depth-first order; either is guaranteed to visit all the nodes and thus copy the original graph. That explains why the two solutions are so similar.\\n\\n```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n  def __init__(self, val = 0, neighbors = None):\\n    self.val = val\\n    self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {node: Node(node.val)}\\n        queue = deque([node])\\n\\n        while len(queue) > 0:\\n            curr = queue.popleft()\\n\\n            for neighbor in curr.neighbors:\\n                if neighbor not in visited:\\n                    visited[neighbor] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n\\n                visited[curr].neighbors.append(visited[neighbor])\\n\\n        return visited[node]\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {}\\n\\n        def dfs(node):\\n            if node in visited:\\n                return visited[node]\\n\\n            clone = Node(node.val)\\n            visited[node] = clone\\n\\n            for neighbor in node.neighbors:\\n                visited[node].neighbors.append(dfs(neighbor))\\n\\n            return clone\\n\\n        return dfs(node)\\n\\n```\n```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n  def __init__(self, val = 0, neighbors = None):\\n    self.val = val\\n    self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {node: Node(node.val)}\\n        stack = [node]\\n\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n\\n            for neighbor in curr.neighbors:\\n                if neighbor not in visited:\\n                    visited[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n\\n                visited[curr].neighbors.append(visited[neighbor])\\n\\n        return visited[node]\\n\\n```\n```python\\n\"\"\"\\nDefinition for a Node.\\nclass Node:\\n  def __init__(self, val = 0, neighbors = None):\\n    self.val = val\\n    self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if node == None:\\n            return node\\n\\n        visited = {node: Node(node.val)}\\n        queue = deque([node])\\n\\n        while len(queue) > 0:\\n            curr = queue.popleft()\\n\\n            for neighbor in curr.neighbors:\\n                if neighbor not in visited:\\n                    visited[neighbor] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n\\n                visited[curr].neighbors.append(visited[neighbor])\\n\\n        return visited[node]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342066,
                "title": "c-code-with-comments-and-explanation-95-bfs-map",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return nullptr;\\n        \\n        // this is the mapping for nodes in original graph \\n        // to respective nodes in the clone graph\\n        map<Node*, Node*> mp;\\n        // queue for BFS traversal\\n        queue<Node*> q;\\n        \\n        // add the initial node and its clone to queue as well as map\\n        Node* clone = new Node(node->val);\\n        q.push(node);\\n        mp.insert({node, clone});\\n        \\n        while(!q.empty())\\n        {\\n            // take out node on by one from the qeueu\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            // traverse all the children of the cur node\\n            auto children = cur->neighbors;\\n            for(auto child : children)\\n            {   \\n                // if the child is not present in the clone \\n                // this also means that the child is unvisited \\n                // so add that child to the queue as well\\n                if(mp[child] == NULL)\\n                {\\n                    // create a clone node and add it to the map\\n                    Node* temp = new Node(child->val);\\n                    mp[child] = temp;\\n                    // qeue will always have node from original graph\\n                    // remember we are traversing original graph \\n                    q.push(child);\\n                }\\n                // add the nodes in the adj list of node of clone graph\\n                mp[cur]->neighbors.push_back(mp[child]);\\n            }\\n        }\\n        return mp[node];\\n    }\\n};\\n```\\nDo upvote if you like!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return nullptr;\\n        \\n        // this is the mapping for nodes in original graph \\n        // to respective nodes in the clone graph\\n        map<Node*, Node*> mp;\\n        // queue for BFS traversal\\n        queue<Node*> q;\\n        \\n        // add the initial node and its clone to queue as well as map\\n        Node* clone = new Node(node->val);\\n        q.push(node);\\n        mp.insert({node, clone});\\n        \\n        while(!q.empty())\\n        {\\n            // take out node on by one from the qeueu\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            // traverse all the children of the cur node\\n            auto children = cur->neighbors;\\n            for(auto child : children)\\n            {   \\n                // if the child is not present in the clone \\n                // this also means that the child is unvisited \\n                // so add that child to the queue as well\\n                if(mp[child] == NULL)\\n                {\\n                    // create a clone node and add it to the map\\n                    Node* temp = new Node(child->val);\\n                    mp[child] = temp;\\n                    // qeue will always have node from original graph\\n                    // remember we are traversing original graph \\n                    q.push(child);\\n                }\\n                // add the nodes in the adj list of node of clone graph\\n                mp[cur]->neighbors.push_back(mp[child]);\\n            }\\n        }\\n        return mp[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016579,
                "title": "python-3-solution-beat-93",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        di = {}\\n        di[node.val] = Node(node.val)\\n        queue = []\\n        queue.append(node)\\n        while queue:\\n            cur_node = queue.pop(0)\\n            for neighbor in cur_node.neighbors:\\n                if neighbor.val not in di:\\n                    di[neighbor.val] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n                di[cur_node.val].neighbors.append(di[neighbor.val])\\n        return di[node.val]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        di = {}\\n        di[node.val] = Node(node.val)\\n        queue = []\\n        queue.append(node)\\n        while queue:\\n            cur_node = queue.pop(0)\\n            for neighbor in cur_node.neighbors:\\n                if neighbor.val not in di:\\n                    di[neighbor.val] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n                di[cur_node.val].neighbors.append(di[neighbor.val])\\n        return di[node.val]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 956267,
                "title": "c-dfs-recursion-o-n-time",
                "content": "1. A map to store reference to already created node.\\n2. Create new Node, enter that in map \\n3. Iterate through the list of its neighbours, if it exists in map assign that value, else create it.\\n```\\nclass Solution {\\n    Node* cloneGraphUtil(Node* node,unordered_map<int,Node*>&m) {\\n        if(!node) return NULL;\\n        Node* newNode=new Node(node->val);\\n        m[node->val]=newNode;\\n        for(Node* n:node->neighbors) \\n            newNode->neighbors.push_back((m[n->val])?m[n->val]:cloneGraphUtil(n,m));\\n        return newNode;\\n    }\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        unordered_map<int,Node*>m;\\n        return cloneGraphUtil(node,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Node* cloneGraphUtil(Node* node,unordered_map<int,Node*>&m) {\\n        if(!node) return NULL;\\n        Node* newNode=new Node(node->val);\\n        m[node->val]=newNode;\\n        for(Node* n:node->neighbors) \\n            newNode->neighbors.push_back((m[n->val])?m[n->val]:cloneGraphUtil(n,m));\\n        return newNode;\\n    }\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        unordered_map<int,Node*>m;\\n        return cloneGraphUtil(node,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905388,
                "title": "c-solution",
                "content": "**Complexity**\\n- Time: O(n + m) where n is the number of nodes and m is the number of edges.\\n- Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        \\n        if(node == null)\\n            return node;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        Dictionary<Node,Node> visited = new Dictionary<Node,Node>();  // key: node, val: copy\\n        \\n        queue.Enqueue(node);\\n        visited.Add(node, new Node(node.val));\\n        \\n        while(queue.Count > 0)\\n        {\\n            Node curr = queue.Dequeue();\\n            foreach(var neighbor in curr.neighbors)\\n            {\\n                if(!visited.ContainsKey(neighbor))\\n                {\\n                    // deep copy neighbor node\\n                    visited.Add(neighbor, new Node(neighbor.val));\\n                    queue.Enqueue(neighbor);\\n                }\\n                \\n                // add neighbor\\'s copy to curr\\'s copy\\n                visited[curr].neighbors.Add(visited[neighbor]);\\n            }\\n        }\\n    \\n        return visited[node];\\n    }\\n}\\n```\\n\\n**Update on 2/22/2022: DFS**\\n```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        \\n        if(node == null)\\n            return null;\\n        \\n        Dictionary<Node,Node> dic = new Dictionary<Node,Node>();\\n        dic.Add(node, new Node(node.val));\\n        \\n        dfs(node, dic);\\n        return dic[node];\\n    }\\n    \\n    private void dfs(Node node, Dictionary<Node,Node> dic)\\n    {\\n        if(node == null)\\n            return;\\n        \\n        foreach(var neighbor in node.neighbors)\\n        {\\n            if(!dic.ContainsKey(neighbor))\\n            {\\n                dic.Add(neighbor, new Node(neighbor.val));\\n                dfs(neighbor, dic);\\n            }\\n            \\n            dic[node].neighbors.Add(dic[neighbor]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        \\n        if(node == null)\\n            return node;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        Dictionary<Node,Node> visited = new Dictionary<Node,Node>();  // key: node, val: copy\\n        \\n        queue.Enqueue(node);\\n        visited.Add(node, new Node(node.val));\\n        \\n        while(queue.Count > 0)\\n        {\\n            Node curr = queue.Dequeue();\\n            foreach(var neighbor in curr.neighbors)\\n            {\\n                if(!visited.ContainsKey(neighbor))\\n                {\\n                    // deep copy neighbor node\\n                    visited.Add(neighbor, new Node(neighbor.val));\\n                    queue.Enqueue(neighbor);\\n                }\\n                \\n                // add neighbor\\'s copy to curr\\'s copy\\n                visited[curr].neighbors.Add(visited[neighbor]);\\n            }\\n        }\\n    \\n        return visited[node];\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        \\n        if(node == null)\\n            return null;\\n        \\n        Dictionary<Node,Node> dic = new Dictionary<Node,Node>();\\n        dic.Add(node, new Node(node.val));\\n        \\n        dfs(node, dic);\\n        return dic[node];\\n    }\\n    \\n    private void dfs(Node node, Dictionary<Node,Node> dic)\\n    {\\n        if(node == null)\\n            return;\\n        \\n        foreach(var neighbor in node.neighbors)\\n        {\\n            if(!dic.ContainsKey(neighbor))\\n            {\\n                dic.Add(neighbor, new Node(neighbor.val));\\n                dfs(neighbor, dic);\\n            }\\n            \\n            dic[node].neighbors.Add(dic[neighbor]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761883,
                "title": "javascript-most-intuitive-bfs-solution",
                "content": "```\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = node => {\\n    if (!node) return node\\n\\n    let queue = [node],\\n        hash = {}\\n    hash[node.val] = new Node(node.val)\\n\\n    while (queue.length) {\\n        const curr = queue.shift();\\n        curr.neighbors.forEach(n => {\\n            // if n is not yet visited\\n            if (hash[n.val] === undefined) {\\n                // copy n to the new graph\\n                hash[n.val] = new Node(n.val);\\n                // enqueue n\\n                queue.push(n);\\n            }\\n            // connect the current new node with its neighbors in the new graph\\n            hash[curr.val].neighbors.push(hash[n.val]);\\n        })\\n    }\\n    return hash[node.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = node => {\\n    if (!node) return node\\n\\n    let queue = [node],\\n        hash = {}\\n    hash[node.val] = new Node(node.val)\\n\\n    while (queue.length) {\\n        const curr = queue.shift();\\n        curr.neighbors.forEach(n => {\\n            // if n is not yet visited\\n            if (hash[n.val] === undefined) {\\n                // copy n to the new graph\\n                hash[n.val] = new Node(n.val);\\n                // enqueue n\\n                queue.push(n);\\n            }\\n            // connect the current new node with its neighbors in the new graph\\n            hash[curr.val].neighbors.push(hash[n.val]);\\n        })\\n    }\\n    return hash[node.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275826,
                "title": "order-of-neighbors-made-my-solution-considered-as-wrong-answer",
                "content": "Submission considered wrong answer because my solution doesn\\'t respect the order of  \"Neighbors\"\\n\\nExpected:\\n```\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\\n\\nActual:\\n```\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```\n```\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42389,
                "title": "6-lines-in-python",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node):\\n        return self.dfs(node, {})\\n        \\n    def dfs(self, node, d):\\n        if not node: return None\\n        if node not in d:\\n            d[node] = UndirectedGraphNode(node.label)\\n            d[node].neighbors += [self.dfs(n, d) for n in node.neighbors]\\n        return d[node]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node):\\n        return self.dfs(node, {})\\n        \\n    def dfs(self, node, d):\\n        if not node: return None\\n        if node not in d:\\n            d[node] = UndirectedGraphNode(node.label)\\n            d[node].neighbors += [self.dfs(n, d) for n in node.neighbors]\\n        return d[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42480,
                "title": "java-dfs-solution-recursion",
                "content": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      helper(root, map);\\n      \\n      return map.get(root);\\n    }\\n    \\n    void helper(UndirectedGraphNode root, Map<UndirectedGraphNode, UndirectedGraphNode> map) {\\n      for (UndirectedGraphNode neighbor : root.neighbors) {\\n        if (!map.containsKey(neighbor)) {\\n          map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n          helper(neighbor, map);\\n        }\\n        \\n        map.get(root).neighbors.add(map.get(neighbor));\\n      }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "    public UndirectedGraphNode cloneGraph(UndirectedGraphNode root) {\\n      if (root == null) return null;\\n      \\n      // use a map to save cloned nodes\\n      Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n      \\n      // clone the root\\n      map.put(root, new UndirectedGraphNode(root.label));\\n      \\n      helper(root, map);\\n      \\n      return map.get(root);\\n    }\\n    \\n    void helper(UndirectedGraphNode root, Map<UndirectedGraphNode, UndirectedGraphNode> map) {\\n      for (UndirectedGraphNode neighbor : root.neighbors) {\\n        if (!map.containsKey(neighbor)) {\\n          map.put(neighbor, new UndirectedGraphNode(neighbor.label));\\n          helper(neighbor, map);\\n        }\\n        \\n        map.get(root).neighbors.add(map.get(neighbor));\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42519,
                "title": "accepted-simple-c-dfs-with-hash-map",
                "content": "     typedef UndirectedGraphNode unode;\\n    class Solution {\\n    public:\\n        unordered_map<unode*,unode *> mp;   //maps input node with cloned node\\n      \\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n           if(!node)\\n            return NULL;\\n           unode *temp=new unode(node->label);\\n           mp[node]=temp;\\n           int len=(node->neighbors).size();\\n           \\n           for(int i=0 ; i<len ; i++)\\n              if(mp[node->neighbors[i]]==0)\\n           //If input node is not visited,clone it\\n                (temp->neighbors).push_back(cloneGraph(node->neighbors[i]));   \\n               else\\n           //If input node is already visited,simple push the mapped cloned node.\\n                  (temp->neighbors).push_back(mp[node->neighbors[i]]); \\n           return temp;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        unordered_map<unode*,unode *> mp;   //maps input node with cloned node\\n      \\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n           if(!node)\\n            return NULL;\\n           unode *temp=new unode(node->label);\\n           mp[node]=temp;\\n           int len=(node->neighbors).size();\\n           \\n           for(int i=0 ; i<len ; i++)\\n              if(mp[node->neighbors[i]]==0)\\n           //If input node is not visited,clone it\\n                (temp->neighbors).push_back(cloneGraph(node->neighbors[i]));   \\n               else\\n           //If input node is already visited,simple push the mapped cloned node.\\n                  (temp->neighbors).push_back(mp[node->neighbors[i]]); \\n           return temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3394254,
                "title": "c-solution-i-hate-this-question-too-simple-code-heavily-commented",
                "content": "I just hate this question as much as you do.\\nNot the best explanation, but anyway if it helps in any sort. Please give a upvote.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL){   // If we are given nothing then we have to return NULL\\n            return NULL;\\n        }\\n        Node* front = new Node(node->val,{});\\n        unordered_map<Node*,Node*> mp;  // To store that I\\'ve already created that node and may not be able to create it again\\n        mp[node]=front;  // Gave it the node and value at node is front (It means that I\\'ve created the front for this node)\\n        queue<Node*> q;  // Queue is used to store the nodes whose neighbors may not be present\\n        q.push(node);  // Yeah node\\'s neighbors are still not created so let\\'s push it in our queue\\n        while(!q.empty()){\\n            Node* curr=q.front();\\n            q.pop();\\n            for(auto adj:curr->neighbors){  // Taking one neighbor by for-each loop\\n                if(!mp[adj]){  // Checking if that is alrady present aor not i.e. there is chance that maybe we already created that in the past\\n                    mp[adj]= new Node(adj->val,{});  // If it\\'s not created then we need to make it right, and stored in our map. Now we know for this neighbor(adj) we have a node\\n                    q.push(adj);  // What\\'s left for us to see, this neighbor\\'s neighbors\\n                }\\n                mp[curr]->neighbors.push_back(mp[adj]);  // After checking this we just update our new created node\\'s adjacency list i.e. neighbor.\\n            }\\n        }\\n        return front;  // At last we just return first node of our copy.\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/f30d6e7c-a6a4-47c0-839f-2a987ce1a410_1680966601.5414197.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == NULL){   // If we are given nothing then we have to return NULL\\n            return NULL;\\n        }\\n        Node* front = new Node(node->val,{});\\n        unordered_map<Node*,Node*> mp;  // To store that I\\'ve already created that node and may not be able to create it again\\n        mp[node]=front;  // Gave it the node and value at node is front (It means that I\\'ve created the front for this node)\\n        queue<Node*> q;  // Queue is used to store the nodes whose neighbors may not be present\\n        q.push(node);  // Yeah node\\'s neighbors are still not created so let\\'s push it in our queue\\n        while(!q.empty()){\\n            Node* curr=q.front();\\n            q.pop();\\n            for(auto adj:curr->neighbors){  // Taking one neighbor by for-each loop\\n                if(!mp[adj]){  // Checking if that is alrady present aor not i.e. there is chance that maybe we already created that in the past\\n                    mp[adj]= new Node(adj->val,{});  // If it\\'s not created then we need to make it right, and stored in our map. Now we know for this neighbor(adj) we have a node\\n                    q.push(adj);  // What\\'s left for us to see, this neighbor\\'s neighbors\\n                }\\n                mp[curr]->neighbors.push_back(mp[adj]);  // After checking this we just update our new created node\\'s adjacency list i.e. neighbor.\\n            }\\n        }\\n        return front;  // At last we just return first node of our copy.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392638,
                "title": "python-c-java-both-dfs-and-bfs-approach-explained",
                "content": "# DFS APPROACH\\n# Intuition\\nThe algorithm uses depth-first search (DFS) to traverse the original graph and create a copy of each node and its neighbors. A map is used to keep track of the nodes that have already been cloned. This helps to avoid creating duplicate copies of nodes and ensures that the cloned graph is identical to the original.\\n\\n# Approach\\nThe dfs function takes a node pointer and the map as input and returns the cloned node pointer. It creates a new node with the same value as the input node and adds it to the map. Then, it iterates through the input node\\'s neighbors and recursively calls the dfs function for each neighbor. If a neighbor has already been cloned, it retrieves the cloned neighbor from the map; otherwise, it creates a new cloned neighbor using the dfs function. The cloned neighbors are added to a vector and assigned to the cloned node\\'s neighbors field. Finally, the cloned node pointer is returned.\\n\\n# Complexity\\n- Time complexity:`O(V+E)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(V)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def dfs(self, node, ump):\\n        neighbour = []\\n        clone = Node(node.val)\\n        ump[node] = clone\\n        for it in node.neighbors:\\n            if it not in ump:\\n                neighbour.append(self.dfs(it, ump))\\n            else:\\n                neighbour.append(ump[it])\\n        clone.neighbors = neighbour\\n        return clone\\n\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        ump = {}\\n        if not node.neighbors:\\n            clone = Node(node.val)\\n            return clone\\n        return self.dfs(node, ump)\\n\\n```\\n```C++ []\\nclass Solution {\\nprivate:\\n    Node* dfs(Node* node,unordered_map<Node*,Node*>& ump){\\n        vector<Node*>neighbour;\\n        Node* clone = new Node(node->val);\\n        ump[node] = clone;\\n        for(auto it:node->neighbors){\\n            if(ump.find(it)==ump.end()){\\n                neighbour.push_back(dfs(it,ump));\\n            }\\n            else{\\n                neighbour.push_back(ump[it]);\\n            }\\n            \\n        }\\n        clone->neighbors = neighbour;\\n        return clone;\\n    }\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return node;\\n        unordered_map<Node*, Node*>ump;\\n        //To find the neighbours present or not in constant time\\n        if(node->neighbors.size()==0){\\n            Node * clone = new Node(node->val);\\n            return clone;\\n        }\\n        return dfs(node,ump);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Node dfs(Node node, Map<Node, Node> ump) {\\n        List<Node> neighbour = new ArrayList<>();\\n        Node clone = new Node(node.val);\\n        ump.put(node, clone);\\n        for(Node it:node.neighbors){\\n            if(!ump.containsKey(it)) {\\n                neighbour.add(dfs(it, ump));\\n            } else {\\n                neighbour.add(ump.get(it));\\n            }\\n        }\\n        clone.neighbors = neighbour;\\n        return clone;\\n    }\\n    \\n    public Node cloneGraph(Node node) {\\n        if(node == null) {\\n            return node;\\n        }\\n        Map<Node, Node> ump = new HashMap<>();\\n        if(node.neighbors.size() == 0) {\\n            Node clone = new Node(node.val);\\n            return clone;\\n        }\\n        return dfs(node, ump);\\n    }\\n}\\n\\n```\\n# BFS APPROACH\\n# Intuition\\nThe algorithm uses a queue to traverse the graph in a breadth-first search manner. The algorithm first checks if the input node is null, in which case it returns null. Otherwise, it creates an unordered map (ump) to store the mapping between the original nodes and the corresponding cloned nodes.\\n\\n# Approach\\nThe algorithm starts by cloning the input node and adding it to the queue. Then, it starts a while loop that runs until the queue is empty. In each iteration of the loop, the algorithm dequeues a node from the front of the queue and for each neighbor of that node, it checks if it has already been cloned or not. If it hasn\\'t been cloned, the algorithm creates a new node with the same value as the neighbor, adds it to the queue, and creates an edge from the cloned node to the new node. Finally, it updates the ump map with the mapping between the original node and the new node.\\n\\nOnce the while loop has finished, the algorithm returns the cloned node corresponding to the input node.\\n\\n# Complexity\\n- Time complexity:`O(V+E)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(V+E)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        ump = {}\\n        # To find the neighbours present or not in constant time\\n\\n        qu = collections.deque()\\n        # For bfs traversal\\n        ump[node] = Node(node.val, [])\\n        qu.append(node)\\n        while qu:\\n            curr = qu.popleft()\\n\\n            for it in curr.neighbors:\\n                if it not in ump:\\n                    ump[it] = Node(it.val, [])\\n                    qu.append(it)\\n                ump[it].neighbors.append(ump[curr])\\n        return ump[node]\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return node;\\n        unordered_map<Node*, Node*>ump;\\n        //To find the neighbours present or not in constant time\\n\\n        queue<Node*>qu;\\n        //For bfs traversal\\n        ump[node] = new Node(node->val,{});\\n        qu.push(node);\\n        while(!qu.empty()){\\n            Node* curr = qu.front();\\n            qu.pop();\\n\\n            for(auto it:curr->neighbors){\\n                if(ump.find(it)==ump.end()){\\n                    ump[it] = new Node(it->val,{});\\n                    qu.push(it);\\n                }\\n                ump[it]->neighbors.push_back(ump[curr]);\\n            }\\n        }\\n        return ump[node];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if(node == null)\\n            return node;\\n        Map<Node, Node> ump = new HashMap<>();\\n        //To find the neighbours present or not in constant time\\n\\n        Queue<Node> qu = new LinkedList<>();\\n        //For bfs traversal\\n        ump.put(node, new Node(node.val, new ArrayList<>()));\\n        qu.offer(node);\\n        while(!qu.isEmpty()){\\n            Node curr = qu.poll();\\n\\n            for(Node it : curr.neighbors){\\n                if(!ump.containsKey(it)){\\n                    ump.put(it, new Node(it.val, new ArrayList<>()));\\n                    qu.offer(it);\\n                }\\n                ump.get(it).neighbors.add(ump.get(curr));\\n            }\\n        }\\n        return ump.get(node);\\n    }\\n}\\n\\n\\n```\\n# PLEASE UPVOTE\\n![upvote.jpg](https://assets.leetcode.com/users/images/062e4021-393a-472e-850d-41838d52280e_1680934291.9731808.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python []\\nclass Solution:\\n    def dfs(self, node, ump):\\n        neighbour = []\\n        clone = Node(node.val)\\n        ump[node] = clone\\n        for it in node.neighbors:\\n            if it not in ump:\\n                neighbour.append(self.dfs(it, ump))\\n            else:\\n                neighbour.append(ump[it])\\n        clone.neighbors = neighbour\\n        return clone\\n\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        ump = {}\\n        if not node.neighbors:\\n            clone = Node(node.val)\\n            return clone\\n        return self.dfs(node, ump)\\n\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    Node* dfs(Node* node,unordered_map<Node*,Node*>& ump){\\n        vector<Node*>neighbour;\\n        Node* clone = new Node(node->val);\\n        ump[node] = clone;\\n        for(auto it:node->neighbors){\\n            if(ump.find(it)==ump.end()){\\n                neighbour.push_back(dfs(it,ump));\\n            }\\n            else{\\n                neighbour.push_back(ump[it]);\\n            }\\n            \\n        }\\n        clone->neighbors = neighbour;\\n        return clone;\\n    }\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return node;\\n        unordered_map<Node*, Node*>ump;\\n        //To find the neighbours present or not in constant time\\n        if(node->neighbors.size()==0){\\n            Node * clone = new Node(node->val);\\n            return clone;\\n        }\\n        return dfs(node,ump);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Node dfs(Node node, Map<Node, Node> ump) {\\n        List<Node> neighbour = new ArrayList<>();\\n        Node clone = new Node(node.val);\\n        ump.put(node, clone);\\n        for(Node it:node.neighbors){\\n            if(!ump.containsKey(it)) {\\n                neighbour.add(dfs(it, ump));\\n            } else {\\n                neighbour.add(ump.get(it));\\n            }\\n        }\\n        clone.neighbors = neighbour;\\n        return clone;\\n    }\\n    \\n    public Node cloneGraph(Node node) {\\n        if(node == null) {\\n            return node;\\n        }\\n        Map<Node, Node> ump = new HashMap<>();\\n        if(node.neighbors.size() == 0) {\\n            Node clone = new Node(node.val);\\n            return clone;\\n        }\\n        return dfs(node, ump);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return node\\n        ump = {}\\n        # To find the neighbours present or not in constant time\\n\\n        qu = collections.deque()\\n        # For bfs traversal\\n        ump[node] = Node(node.val, [])\\n        qu.append(node)\\n        while qu:\\n            curr = qu.popleft()\\n\\n            for it in curr.neighbors:\\n                if it not in ump:\\n                    ump[it] = Node(it.val, [])\\n                    qu.append(it)\\n                ump[it].neighbors.append(ump[curr])\\n        return ump[node]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node == nullptr)\\n            return node;\\n        unordered_map<Node*, Node*>ump;\\n        //To find the neighbours present or not in constant time\\n\\n        queue<Node*>qu;\\n        //For bfs traversal\\n        ump[node] = new Node(node->val,{});\\n        qu.push(node);\\n        while(!qu.empty()){\\n            Node* curr = qu.front();\\n            qu.pop();\\n\\n            for(auto it:curr->neighbors){\\n                if(ump.find(it)==ump.end()){\\n                    ump[it] = new Node(it->val,{});\\n                    qu.push(it);\\n                }\\n                ump[it]->neighbors.push_back(ump[curr]);\\n            }\\n        }\\n        return ump[node];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if(node == null)\\n            return node;\\n        Map<Node, Node> ump = new HashMap<>();\\n        //To find the neighbours present or not in constant time\\n\\n        Queue<Node> qu = new LinkedList<>();\\n        //For bfs traversal\\n        ump.put(node, new Node(node.val, new ArrayList<>()));\\n        qu.offer(node);\\n        while(!qu.isEmpty()){\\n            Node curr = qu.poll();\\n\\n            for(Node it : curr.neighbors){\\n                if(!ump.containsKey(it)){\\n                    ump.put(it, new Node(it.val, new ArrayList<>()));\\n                    qu.offer(it);\\n                }\\n                ump.get(it).neighbors.add(ump.get(curr));\\n            }\\n        }\\n        return ump.get(node);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883572,
                "title": "typescript-javascript-simple-dfs",
                "content": "When encountering a graph problem you can usually solve it with a traversal algorithm like DFS or BFS.\\n\\nA recursive DFS solution is usually simpler to code and what we use here. When traversing through graphs, we need to make sure we use a visited set or hash table to make sure we don\\'t enter an infinite loop revisiting nodes. We use a hash table here since we want to return the cloned node which we already visited. \\n\\nPerform a DFS where we return the cloned node if it\\'s already visited. Else, create a copy of the current node and mark it as visited. We still need to clone its neighbors, so iterate though the list of neighbors, cloning each one and adding it to the current copy\\'s neighbors list. \\n\\n```\\nfunction cloneGraph(node: Node | null): Node | null {\\n    const visited = new Map<Node, Node>();\\n    return clone(node, visited);\\n};\\n\\nfunction clone(node: Node | null, visited: Map<Node, Node>): Node | null {\\n    if(node === null){\\n        return node;\\n    }\\n\\n    if(visited.has(node)){\\n        return visited.get(node);\\n    }\\n\\n    const copy = new Node(node.val);\\n    visited.set(node, copy);\\n\\n    for(const neighbor of node.neighbors){\\n        copy.neighbors.push(clone(neighbor, visited));\\n    }\\n    \\n    return copy;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction cloneGraph(node: Node | null): Node | null {\\n    const visited = new Map<Node, Node>();\\n    return clone(node, visited);\\n};\\n\\nfunction clone(node: Node | null, visited: Map<Node, Node>): Node | null {\\n    if(node === null){\\n        return node;\\n    }\\n\\n    if(visited.has(node)){\\n        return visited.get(node);\\n    }\\n\\n    const copy = new Node(node.val);\\n    visited.set(node, copy);\\n\\n    for(const neighbor of node.neighbors){\\n        copy.neighbors.push(clone(neighbor, visited));\\n    }\\n    \\n    return copy;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903356,
                "title": "clone-graph-java",
                "content": "```\\nclass Solution \\n{\\n    /* This is a basic recursive traversal of an undirected graph.  The basic process of traversal is\\n     * to visit a node, iterate over it\\'s list of neighbors calling each neighbor recursively if \\n     * required.  To determine which nodes have already been visited and help with cloning the graph a\\n     * map is implemented where the key is a node from the original graph and the value is clone of \\n     * that node.  As a node is visited the clone is created and added to the map.  When iterating \\n     * over a nodes neighbors the map can be used to determine wether a node has already been visited\\n     * or still needs to be processed.  Once all neighbors have been processed the clone of the \\n     * original node passed in is returned.\\n     */\\n    \\n    public Node cloneGraph(Node node) \\n    {\\n        return process( node, new HashMap<Node, Node>() );\\n    }\\n    \\n    private static Node process( Node node, Map<Node, Node> map )\\n    {\\n        if( node != null )\\n        {\\n            map.put( node, new Node( node.val ) );\\n\\n            for( Node n: node.neighbors )\\n            {\\n                map.get( node ).neighbors.add( map.containsKey( n )\\n                                                    ? map.get( n ) \\n                                                    : process( n, map ) );\\n            }\\n        }\\n        return map.get( node );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* This is a basic recursive traversal of an undirected graph.  The basic process of traversal is\\n     * to visit a node, iterate over it\\'s list of neighbors calling each neighbor recursively if \\n     * required.  To determine which nodes have already been visited and help with cloning the graph a\\n     * map is implemented where the key is a node from the original graph and the value is clone of \\n     * that node.  As a node is visited the clone is created and added to the map.  When iterating \\n     * over a nodes neighbors the map can be used to determine wether a node has already been visited\\n     * or still needs to be processed.  Once all neighbors have been processed the clone of the \\n     * original node passed in is returned.\\n     */\\n    \\n    public Node cloneGraph(Node node) \\n    {\\n        return process( node, new HashMap<Node, Node>() );\\n    }\\n    \\n    private static Node process( Node node, Map<Node, Node> map )\\n    {\\n        if( node != null )\\n        {\\n            map.put( node, new Node( node.val ) );\\n\\n            for( Node n: node.neighbors )\\n            {\\n                map.get( node ).neighbors.add( map.containsKey( n )\\n                                                    ? map.get( n ) \\n                                                    : process( n, map ) );\\n            }\\n        }\\n        return map.get( node );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902788,
                "title": "short-c-dfs-5-lines-beats-99-93",
                "content": "```\\nclass Solution {\\n    map < Node*, Node* > dp;\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        dp[NULL] = NULL;\\n        if(dp.count(node)) return dp[node];\\n        Node *newNode = new Node(node->val);\\n        dp[node] = newNode;\\n        for(auto nbr : node->neighbors)\\n            newNode->neighbors.push_back(cloneGraph(nbr));        \\n        return newNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    map < Node*, Node* > dp;\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        dp[NULL] = NULL;\\n        if(dp.count(node)) return dp[node];\\n        Node *newNode = new Node(node->val);\\n        dp[node] = newNode;\\n        for(auto nbr : node->neighbors)\\n            newNode->neighbors.push_back(cloneGraph(nbr));        \\n        return newNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902752,
                "title": "python-super-simple-short-recursive-solution",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        my_map = {}\\n        \\n        def rec(node):\\n            if my_map.get(node.val):\\n                return my_map[node.val]\\n            \\n            my_map[node.val] = Node(node.val)\\n            for neighbor in node.neighbors:\\n                my_map[node.val].neighbors.append(rec(neighbor))\\n            return my_map[node.val]\\n            \\n        if not node: return None\\n        return rec(node)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        my_map = {}\\n        \\n        def rec(node):\\n            if my_map.get(node.val):\\n                return my_map[node.val]\\n            \\n            my_map[node.val] = Node(node.val)\\n            for neighbor in node.neighbors:\\n                my_map[node.val].neighbors.append(rec(neighbor))\\n            return my_map[node.val]\\n            \\n        if not node: return None\\n        return rec(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821409,
                "title": "java-line-to-line-commented-solution",
                "content": "```\\npublic Node cloneGraph(Node node) {\\n        if(node == null)\\n            return null;\\n        Queue<Node> q = new LinkedList<>();\\n        Map<Node,Node> map = new HashMap<>();//map to store current node and its clone against it\\n        q.add(node);\\n        map.put(node,new Node(node.val)); //current node, created new node with val of current node for clone\\n        while(q.size()>0){\\n            Node temp = q.poll();\\n            for(Node neighbour : temp.neighbors){//provided in given data each node has list of its neighbours\\n                if(!map.containsKey(neighbour)){//check if neighbour is already added or not if not added\\n                    map.put(neighbour,new Node(neighbour.val));//add to map and create its clone node as well\\n                    q.add(neighbour);//add neighbour to q to get its neighbours\\n                }\\n                map.get(temp).neighbors.add(map.get(neighbour));//copy neighbours to curr node\\'s clone\\'s\\n            }   //neighbour list from neighbours of current node i.e. neighbour\\n        }\\n        return map.get(node);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic Node cloneGraph(Node node) {\\n        if(node == null)\\n            return null;\\n        Queue<Node> q = new LinkedList<>();\\n        Map<Node,Node> map = new HashMap<>();//map to store current node and its clone against it\\n        q.add(node);\\n        map.put(node,new Node(node.val)); //current node, created new node with val of current node for clone\\n        while(q.size()>0){\\n            Node temp = q.poll();\\n            for(Node neighbour : temp.neighbors){//provided in given data each node has list of its neighbours\\n                if(!map.containsKey(neighbour)){//check if neighbour is already added or not if not added\\n                    map.put(neighbour,new Node(neighbour.val));//add to map and create its clone node as well\\n                    q.add(neighbour);//add neighbour to q to get its neighbours\\n                }\\n                map.get(temp).neighbors.add(map.get(neighbour));//copy neighbours to curr node\\'s clone\\'s\\n            }   //neighbour list from neighbours of current node i.e. neighbour\\n        }\\n        return map.get(node);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 740541,
                "title": "c-bfs-clean-code-t-98-m-80",
                "content": "***Please like the post if you find this helpful***\\n```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node)return NULL;\\n        unordered_map<Node*,Node*> hg;\\n        queue<Node*> q;\\n        q.push(node);\\n        Node* start = new Node(node->val, {});\\n        hg[node]=start;\\n        while(!q.empty()){\\n            auto num=q.front();\\n            q.pop();\\n            for(int i=0;i<num->neighbors.size();i++){\\n                if(hg.find(num->neighbors[i])==hg.end()){\\n                    Node* n = new Node(num->neighbors[i]->val, {});\\n                    hg[num->neighbors[i]]=n;\\n                    q.push(num->neighbors[i]);\\n                }\\n                hg[num]->neighbors.push_back(hg[num->neighbors[i]]);\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node)return NULL;\\n        unordered_map<Node*,Node*> hg;\\n        queue<Node*> q;\\n        q.push(node);\\n        Node* start = new Node(node->val, {});\\n        hg[node]=start;\\n        while(!q.empty()){\\n            auto num=q.front();\\n            q.pop();\\n            for(int i=0;i<num->neighbors.size();i++){\\n                if(hg.find(num->neighbors[i])==hg.end()){\\n                    Node* n = new Node(num->neighbors[i]->val, {});\\n                    hg[num->neighbors[i]]=n;\\n                    q.push(num->neighbors[i]);\\n                }\\n                hg[num]->neighbors.push_back(hg[num->neighbors[i]]);\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493662,
                "title": "python3-simple-bfs-32ms-better-than-93-21-12-9mb-better-than-100",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n\\tdef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return\\n        # store copy of node\\n        hashmap = {node : Node(node.val)}\\n        # queue for bfs\\n        queue = deque([node])\\n        \\n        while queue:\\n            currNode = queue.popleft()\\n            for neighbor in currNode.neighbors:\\n                if neighbor not in hashmap:\\n                    # store copy of node\\n                    hashmap[neighbor] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n                # draw edge between copy of current node and copy of neighbor\\n                hashmap[currNode].neighbors.append(hashmap[neighbor])\\n        \\n        # return copy of start node\\n        return hashmap[node]\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n\\tdef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return\\n        # store copy of node\\n        hashmap = {node : Node(node.val)}\\n        # queue for bfs\\n        queue = deque([node])\\n        \\n        while queue:\\n            currNode = queue.popleft()\\n            for neighbor in currNode.neighbors:\\n                if neighbor not in hashmap:\\n                    # store copy of node\\n                    hashmap[neighbor] = Node(neighbor.val)\\n                    queue.append(neighbor)\\n                # draw edge between copy of current node and copy of neighbor\\n                hashmap[currNode].neighbors.append(hashmap[neighbor])\\n        \\n        # return copy of start node\\n        return hashmap[node]\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375617,
                "title": "simple-python-solution-using-dict",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        self.node_dict = {}\\n        def clone(node):\\n            if not node: return\\n            if node not in self.node_dict:\\n                self.node_dict[node] = Node(node.val,[])\\n                for nei in node.neighbors:\\n                    clone(nei)\\n            return\\n        clone(node)\\n        for key in self.node_dict:\\n            self.node_dict[key].neighbors = [self.node_dict[nei] for nei in key.neighbors]\\n        return self.node_dict[node]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        self.node_dict = {}\\n        def clone(node):\\n            if not node: return\\n            if node not in self.node_dict:\\n                self.node_dict[node] = Node(node.val,[])\\n                for nei in node.neighbors:\\n                    clone(nei)\\n            return\\n        clone(node)\\n        for key in self.node_dict:\\n            self.node_dict[key].neighbors = [self.node_dict[nei] for nei in key.neighbors]\\n        return self.node_dict[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42337,
                "title": "swift-solution-dfs-bfs",
                "content": "```\\nclass Solution {\\n    func cloneGraph(_ node: UndirectedGraphNode?) -> UndirectedGraphNode? {\\n        var map = [Int: UndirectedGraphNode]()\\n        return DFS(node, &map)\\n    }\\n    \\n    private func DFS(_ node: UndirectedGraphNode?, _ map: inout [Int: UndirectedGraphNode]) -> UndirectedGraphNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n        \\n        if map.keys.contains(node.label) {\\n            return map[node.label]\\n        }\\n        \\n        var clone = UndirectedGraphNode(node.label)\\n        map[clone.label] = clone\\n        for neighbor in node.neighbors {\\n            if let node = DFS(neighbor, &map) {\\n                clone.neighbors.append(node)\\n            }\\n        }\\n        \\n        return clone\\n    }\\n    \\n    func cloneGraph_BFS(_ node: UndirectedGraphNode?) -> UndirectedGraphNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n        \\n        let newNode = UndirectedGraphNode(node.label)\\n        var map = [Int: UndirectedGraphNode]()\\n        var queue = [node]\\n\\n        map[newNode.label] = newNode\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            for neighbor in node.neighbors {\\n                if !map.keys.contains(neighbor.label) {\\n                    map[neighbor.label] = UndirectedGraphNode(neighbor.label)\\n                    queue.append(neighbor)\\n                }\\n                map[node.label]?.neighbors.append(map[neighbor.label]!)\\n            }\\n        }\\n        \\n        return newNode\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func cloneGraph(_ node: UndirectedGraphNode?) -> UndirectedGraphNode? {\\n        var map = [Int: UndirectedGraphNode]()\\n        return DFS(node, &map)\\n    }\\n    \\n    private func DFS(_ node: UndirectedGraphNode?, _ map: inout [Int: UndirectedGraphNode]) -> UndirectedGraphNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n        \\n        if map.keys.contains(node.label) {\\n            return map[node.label]\\n        }\\n        \\n        var clone = UndirectedGraphNode(node.label)\\n        map[clone.label] = clone\\n        for neighbor in node.neighbors {\\n            if let node = DFS(neighbor, &map) {\\n                clone.neighbors.append(node)\\n            }\\n        }\\n        \\n        return clone\\n    }\\n    \\n    func cloneGraph_BFS(_ node: UndirectedGraphNode?) -> UndirectedGraphNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n        \\n        let newNode = UndirectedGraphNode(node.label)\\n        var map = [Int: UndirectedGraphNode]()\\n        var queue = [node]\\n\\n        map[newNode.label] = newNode\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            for neighbor in node.neighbors {\\n                if !map.keys.contains(neighbor.label) {\\n                    map[neighbor.label] = UndirectedGraphNode(neighbor.label)\\n                    queue.append(neighbor)\\n                }\\n                map[node.label]?.neighbors.append(map[neighbor.label]!)\\n            }\\n        }\\n        \\n        return newNode\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42411,
                "title": "consise-and-easy-to-understand-java-solution",
                "content": "public class Solution {\\n\\n    HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n    \\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if(node == null) return null;\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        \\n        for(UndirectedGraphNode x : node.neighbors){\\n            if(map.get(x) == null){\\n                copy.neighbors.add(cloneGraph(x));\\n            }else{\\n                copy.neighbors.add(map.get(x));\\n            }\\n        }\\n        return copy;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\\n    \\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n        if(node == null) return null;\\n        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);\\n        map.put(node, copy);\\n        \\n        for(UndirectedGraphNode x : node.neighbors){\\n            if(map.get(x) == null){\\n                copy.neighbors.add(cloneGraph(x));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3808487,
                "title": "best-solution",
                "content": "# Approach\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(V+2E)$$\\n\\n- Space complexity:\\n$$O(V)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (node == NULL)\\n            return NULL;\\n        unordered_map <Node*, Node*> mpp;\\n        queue <Node*> q;\\n        q.push(node);\\n        Node* newNode = new Node(node->val);\\n        mpp[node] = newNode;\\n        while (q.empty() == false) {\\n            Node* cur = q.front();\\n            q.pop();\\n            for (auto it : cur->neighbors) {\\n                if (mpp.find(it) == mpp.end()) {\\n                    q.push(it);\\n                    Node* newNode = new Node(it->val);\\n                    mpp[it] = newNode;\\n                }\\n                mpp[cur]->neighbors.push_back(mpp[it]);\\n            }\\n        }\\n        return mpp[node];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (node == NULL)\\n            return NULL;\\n        unordered_map <Node*, Node*> mpp;\\n        queue <Node*> q;\\n        q.push(node);\\n        Node* newNode = new Node(node->val);\\n        mpp[node] = newNode;\\n        while (q.empty() == false) {\\n            Node* cur = q.front();\\n            q.pop();\\n            for (auto it : cur->neighbors) {\\n                if (mpp.find(it) == mpp.end()) {\\n                    q.push(it);\\n                    Node* newNode = new Node(it->val);\\n                    mpp[it] = newNode;\\n                }\\n                mpp[cur]->neighbors.push_back(mpp[it]);\\n            }\\n        }\\n        return mpp[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394167,
                "title": "java-dfs-deep-copy-of-graph",
                "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node, HashMap<Node, Node> dict)\\n    {\\n        for (Node nd : node.neighbors) {\\n            if (!dict.containsKey(nd))\\n                dict.put(nd, new Node(nd.val));\\n            dict.get(node).neighbors.add(dict.get(nd));\\n        }\\n        for (Node nd : node.neighbors)\\n        {\\n            if (dict.get(nd).neighbors.size() == 0)\\n                dfs(nd, dict);\\n        }\\n    }\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> dict = new HashMap<>();\\n        if (node != null) {\\n            dict.put(node, new Node(node.val));\\n            dfs(node, dict);\\n            return dict.get(node);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node, HashMap<Node, Node> dict)\\n    {\\n        for (Node nd : node.neighbors) {\\n            if (!dict.containsKey(nd))\\n                dict.put(nd, new Node(nd.val));\\n            dict.get(node).neighbors.add(dict.get(nd));\\n        }\\n        for (Node nd : node.neighbors)\\n        {\\n            if (dict.get(nd).neighbors.size() == 0)\\n                dfs(nd, dict);\\n        }\\n    }\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> dict = new HashMap<>();\\n        if (node != null) {\\n            dict.put(node, new Node(node.val));\\n            dfs(node, dict);\\n            return dict.get(node);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392139,
                "title": "c-dfs-hashmap-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // declare a Hash Map\\n    \\n    unordered_map<Node*, Node*> mp;\\n    \\n    Node* cloneGraph(Node* node) {\\n        \\n        if(node == NULL)\\n            return NULL;\\n        \\n        if(mp.find(node) != mp.end())\\n            return mp[node];\\n        \\n        // create new node\\n        \\n        Node* newly_created_node = new Node(node -> val);\\n        \\n        mp[node] = newly_created_node;\\n        \\n        for(Node* &it : node -> neighbors)\\n        {\\n            Node* adjacent = cloneGraph(it);\\n            \\n            newly_created_node -> neighbors.push_back(adjacent);\\n        }\\n        \\n        return newly_created_node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // declare a Hash Map\\n    \\n    unordered_map<Node*, Node*> mp;\\n    \\n    Node* cloneGraph(Node* node) {\\n        \\n        if(node == NULL)\\n            return NULL;\\n        \\n        if(mp.find(node) != mp.end())\\n            return mp[node];\\n        \\n        // create new node\\n        \\n        Node* newly_created_node = new Node(node -> val);\\n        \\n        mp[node] = newly_created_node;\\n        \\n        for(Node* &it : node -> neighbors)\\n        {\\n            Node* adjacent = cloneGraph(it);\\n            \\n            newly_created_node -> neighbors.push_back(adjacent);\\n        }\\n        \\n        return newly_created_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392025,
                "title": "kotlin-dfs",
                "content": "```\\nclass Solution {\\n  fun cloneGraph(node: Node?): Node? {\\n    node ?: return node\\n    val nodes = Array<Node?>(101) { null }\\n    fun dfs(node: Node): Node {\\n      nodes[node.`val`]?.let { return it }\\n      val copy = Node(node.`val`)\\n      nodes[node.`val`] = copy\\n      for (next in node.neighbors) {\\n        val nextcopy = dfs(next!!)\\n        copy.neighbors.add(nextcopy)\\n      }\\n      return copy\\n    }\\n    return dfs(node)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun cloneGraph(node: Node?): Node? {\\n    node ?: return node\\n    val nodes = Array<Node?>(101) { null }\\n    fun dfs(node: Node): Node {\\n      nodes[node.`val`]?.let { return it }\\n      val copy = Node(node.`val`)\\n      nodes[node.`val`] = copy\\n      for (next in node.neighbors) {\\n        val nextcopy = dfs(next!!)\\n        copy.neighbors.add(nextcopy)\\n      }\\n      return copy\\n    }\\n    return dfs(node)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392005,
                "title": "why-we-need-a-map-explained-easy-dfs-code",
                "content": "![image](https://assets.leetcode.com/users/images/fd804ba3-b9ed-44a2-ab23-2380a1dc4e46_1680915027.0367868.png)\\n\\n```\\nclass Solution {\\npublic:\\n    Node* dfs(Node* ogCurrNode, unordered_map<Node*, Node*>&mp)\\n    {\\n        Node* copyCurrNode = new Node(ogCurrNode->val);\\n        mp[ogCurrNode] = copyCurrNode;\\n        //==========================================================\\n        for (Node* ogAdjNode : ogCurrNode->neighbors)\\n        {\\n            Node* copyAdjNode = NULL;\\n            //if ogAdjNode is found in map, it\\'s forming a loop...\\n            //but we still need to add it\\'s copy in neighbor list of copyCurrNode\\n            if (mp.count(ogAdjNode)) copyAdjNode = mp[ogAdjNode]; \\n            else copyAdjNode = dfs(ogAdjNode, mp);\\n            \\n            copyCurrNode->neighbors.push_back(copyAdjNode);\\n        }\\n        //===========================================================\\n        return copyCurrNode;\\n    }\\n    Node* cloneGraph(Node* node) \\n    {\\n        if (node == NULL) return NULL;\\n        unordered_map<Node*, Node*>mp;\\n        return dfs(node, mp); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* dfs(Node* ogCurrNode, unordered_map<Node*, Node*>&mp)\\n    {\\n        Node* copyCurrNode = new Node(ogCurrNode->val);\\n        mp[ogCurrNode] = copyCurrNode;\\n        //==========================================================\\n        for (Node* ogAdjNode : ogCurrNode->neighbors)\\n        {\\n            Node* copyAdjNode = NULL;\\n            //if ogAdjNode is found in map, it\\'s forming a loop...\\n            //but we still need to add it\\'s copy in neighbor list of copyCurrNode\\n            if (mp.count(ogAdjNode)) copyAdjNode = mp[ogAdjNode]; \\n            else copyAdjNode = dfs(ogAdjNode, mp);\\n            \\n            copyCurrNode->neighbors.push_back(copyAdjNode);\\n        }\\n        //===========================================================\\n        return copyCurrNode;\\n    }\\n    Node* cloneGraph(Node* node) \\n    {\\n        if (node == NULL) return NULL;\\n        unordered_map<Node*, Node*>mp;\\n        return dfs(node, mp); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391984,
                "title": "c-easy-recursion-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> neighbors;\\n\\n    public Node() {\\n        val = 0;\\n        neighbors = new List<Node>();\\n    }\\n\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new List<Node>();\\n    }\\n\\n    public Node(int _val, List<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        Dictionary<Node, Node> d = new Dictionary<Node, Node>();\\n        return Clone(node);\\n\\n        Node Clone(Node n) {\\n            if (n == null)\\n                return null;\\n            \\n            if (d.ContainsKey(n))\\n                return d[n];\\n\\n            d[n] = new Node(n.val);\\n\\n            foreach(var v in n.neighbors) {\\n                d[n].neighbors.Add(Clone(v));\\n            }\\n\\n            return d[n];\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> neighbors;\\n\\n    public Node() {\\n        val = 0;\\n        neighbors = new List<Node>();\\n    }\\n\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new List<Node>();\\n    }\\n\\n    public Node(int _val, List<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public Node CloneGraph(Node node) {\\n        Dictionary<Node, Node> d = new Dictionary<Node, Node>();\\n        return Clone(node);\\n\\n        Node Clone(Node n) {\\n            if (n == null)\\n                return null;\\n            \\n            if (d.ContainsKey(n))\\n                return d[n];\\n\\n            d[n] = new Node(n.val);\\n\\n            foreach(var v in n.neighbors) {\\n                d[n].neighbors.Add(Clone(v));\\n            }\\n\\n            return d[n];\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391952,
                "title": "python3-solution",
                "content": "\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        oldToNew={}\\n        def dfs(node):\\n            if node in oldToNew:\\n                return oldToNew[node]\\n\\n            copy=Node(node.val)\\n            oldToNew[node]=copy\\n\\n            for nei in node.neighbors:\\n                copy.neighbors.append(dfs(nei))\\n\\n            return copy\\n\\n        return dfs(node) if node else None            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        oldToNew={}\\n        def dfs(node):\\n            if node in oldToNew:\\n                return oldToNew[node]\\n\\n            copy=Node(node.val)\\n            oldToNew[node]=copy\\n\\n            for nei in node.neighbors:\\n                copy.neighbors.append(dfs(nei))\\n\\n            return copy\\n\\n        return dfs(node) if node else None            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157522,
                "title": "java-detailed-explanation-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Clone Graph is a type of BFS & DFS problem. The purpose is to create a function that takes a node in the original graph as input and returns the corresponding node in the new graph as output. The new graph will have the same structure and values as the original, but it should be completely separate from the original.\\n\\n# DFS Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will call a `cloneDFS` method, passing in the `node` graph and a new Hashmap `visited`. The HashMap `visited` will keep track of the old nodes `cur` that have already been processed and their corresponding cloned nodes `newNode`. The key of the map is the node from the original graph, and the value of the map is the cloned node. The reason we do this is to ensure that there are no cycles in the cloned graph and that each node is cloned only once.\\n2. We need a base case to check if the current node `cur` is null. If it is, then we return null.\\n3. We need a special base case to check if the current node `cur` you are at is able to connect with another node in the hashmap. \\nEx) if current node is 2, and 1 is already in the hashmap `visited`, then you can connect 2 to 1. \\nIn the case of the starting node, this step will be skipped since the hashmap `visited` is empty. \\n4. We will create a clone node `newNode` to hold the current nodes `cur` value, then map the old node `cur` to the clone node `newNode`.\\n5. Now we loop through every neighbor of the current node `cur` and add the cloned version of each neighbor to the \"neighbors\" list of the cloned node `newNode`.\\n6. Finally, we return the cloned graph `newNode`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - where n is the number of edges + number of vertices.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - where n is the number of nodes in the graph. The Hashmap stores n entries. \\n\\n# DFS Code\\n```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        //step 1\\n       return cloneDFS(node, new HashMap<>());\\n    }\\n    public Node cloneDFS(Node cur, Map<Node, Node> visited){\\n        //step 2 \\n        if(cur==null) return null;\\n        //step 3 \\n        if(visited.containsKey(cur)) return visited.get(cur);\\n        //step 4 \\n        Node newNode = new Node(cur.val);\\n        visited.put(cur, newNode);\\n        //step 5 \\n        for (Node n : cur.neighbors) {\\n            newNode.neighbors.add(cloneDFS(n, visited));\\n        }\\n        //step 6 \\n        return newNode;\\n    }\\n}\\n```\\n***Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.***\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        //step 1\\n       return cloneDFS(node, new HashMap<>());\\n    }\\n    public Node cloneDFS(Node cur, Map<Node, Node> visited){\\n        //step 2 \\n        if(cur==null) return null;\\n        //step 3 \\n        if(visited.containsKey(cur)) return visited.get(cur);\\n        //step 4 \\n        Node newNode = new Node(cur.val);\\n        visited.put(cur, newNode);\\n        //step 5 \\n        for (Node n : cur.neighbors) {\\n            newNode.neighbors.add(cloneDFS(n, visited));\\n        }\\n        //step 6 \\n        return newNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593407,
                "title": "c",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Clone Graph.\\nMemory Usage: 7 MB, less than 61.11% of C online submissions for Clone Graph.\\n```\\nstruct Node* process(struct Node *s, bool* hash, struct Node** data) { \\n    if(hash[s->val] == true)\\n        return data[s->val];\\n    struct Node * root = malloc(sizeof(struct Node ));\\n    root->val = s->val;\\n    hash[s->val] = true;\\n    data[s->val] = root;\\n    root->numNeighbors = s->numNeighbors;\\n    root->neighbors = malloc(s->numNeighbors * sizeof(struct Node *));\\n    \\n    for(int i = 0; i < s->numNeighbors; i++){\\n        root->neighbors[i] = process( s->neighbors[i], hash, data ); \\n    }\\n    \\n    return root;\\n}\\n\\nstruct Node *cloneGraph(struct Node *s) { \\n    if(s == NULL)\\n        return NULL;\\n    bool* hash = calloc(101 , sizeof(int));\\n    struct Node** data = malloc(101 * sizeof(struct Node *));\\n    \\n    return process(s, hash, data);\\n}\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nstruct Node* process(struct Node *s, bool* hash, struct Node** data) { \\n    if(hash[s->val] == true)\\n        return data[s->val];\\n    struct Node * root = malloc(sizeof(struct Node ));\\n    root->val = s->val;\\n    hash[s->val] = true;\\n    data[s->val] = root;\\n    root->numNeighbors = s->numNeighbors;\\n    root->neighbors = malloc(s->numNeighbors * sizeof(struct Node *));\\n    \\n    for(int i = 0; i < s->numNeighbors; i++){\\n        root->neighbors[i] = process( s->neighbors[i], hash, data ); \\n    }\\n    \\n    return root;\\n}\\n\\nstruct Node *cloneGraph(struct Node *s) { \\n    if(s == NULL)\\n        return NULL;\\n    bool* hash = calloc(101 , sizeof(int));\\n    struct Node** data = malloc(101 * sizeof(struct Node *));\\n    \\n    return process(s, hash, data);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159884,
                "title": "python-2-optimal-solutions-dfs-bfs",
                "content": "**DFS**\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        curNewDict = {}   # key = curNode; value = copy of curNode\\n        \\n        def traverse(curNode):\\n            if not curNode: return\\n            if curNode not in curNewDict:\\n                curNewDict[curNode] = Node(curNode.val)\\n            for nei in curNode.neighbors:\\n                if nei and nei not in curNewDict: \\n                    curNewDict[nei] = Node(nei.val)\\n                    traverse(nei)  # only calling if nei is not in dictionary. Here we using the curNewDict to track visited nodes also! \\n                curNewDict[curNode].neighbors.append(curNewDict[nei])\\n                \\n        traverse(node)\\n        # return copy of the starting node\\n        return curNewDict[node]\\n```\\n\\n**BFS**\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        curNewDict = {}   # key = curNode; value = copy of curNode\\n        \\n        q = [node]\\n        while q:\\n            curNode = q.pop()\\n            if curNode not in curNewDict: curNewDict[curNode] = Node(curNode.val)\\n            for nei in curNode.neighbors:\\n                if nei and nei not in curNewDict: \\n                    curNewDict[nei] = Node(nei.val)\\n                    q.append(nei)  \\n                curNewDict[curNode].neighbors.append(curNewDict[nei])\\n        # return copy of the starting node\\n        return curNewDict[node]\\n```\\n\\nTime: O(n)\\nSpace: O(n)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        curNewDict = {}   # key = curNode; value = copy of curNode\\n        \\n        def traverse(curNode):\\n            if not curNode: return\\n            if curNode not in curNewDict:\\n                curNewDict[curNode] = Node(curNode.val)\\n            for nei in curNode.neighbors:\\n                if nei and nei not in curNewDict: \\n                    curNewDict[nei] = Node(nei.val)\\n                    traverse(nei)  # only calling if nei is not in dictionary. Here we using the curNewDict to track visited nodes also! \\n                curNewDict[curNode].neighbors.append(curNewDict[nei])\\n                \\n        traverse(node)\\n        # return copy of the starting node\\n        return curNewDict[node]\\n```\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        curNewDict = {}   # key = curNode; value = copy of curNode\\n        \\n        q = [node]\\n        while q:\\n            curNode = q.pop()\\n            if curNode not in curNewDict: curNewDict[curNode] = Node(curNode.val)\\n            for nei in curNode.neighbors:\\n                if nei and nei not in curNewDict: \\n                    curNewDict[nei] = Node(nei.val)\\n                    q.append(nei)  \\n                curNewDict[curNode].neighbors.append(curNewDict[nei])\\n        # return copy of the starting node\\n        return curNewDict[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094869,
                "title": "c-detailed-explanation-w-dfs-bfs",
                "content": "**Please upvote if you like the post :)**\\n\\nSo basically we need to make a `deep copy`(clone) of the given graph.\\n\\n* One thing to keep in mind while solving the **question** is that when we are standing at a particular `node` we need to check if the `current` node and it\\'s `adjacent` node is already **copied** or not.\\n* While **coping** the nodes we eventually copy the nodes two times which we need to **avoid**, the reason why we are using **map**.\\n\\n***A. Solution -I*** *(**Using DFS**)*\\n```\\nclass Solution { // DFS APPROACH\\npublic:\\n    unordered_map<Node*,Node*> mp;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL) return NULL;\\n        if(mp.find(node)==mp.end()){ // node not present in map\\n            mp[node]= new Node(node->val,{}); // making a copy\\n            for(auto adj:node->neighbors){ // travel to it\\'s adjacent\\n                mp[node]->neighbors.push_back(cloneGraph(adj)); // add the copy\\n            }\\n        }\\n        return mp[node]; // return the deep copy(clone) of the graph\\n    }\\n};\\n```\\n****\\n****\\n***B. Solution -II*** *(**Using BFS**)*\\n```\\nclass Solution { // BFS APPROACH\\npublic:\\n    unordered_map<Node*,Node*> mp; // map from node to its parent\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL) return NULL; // edge case\\n        queue<Node*> q; // queue of nodes\\n        Node* first = new Node(node->val,{});  // create a new node with the same value\\n        mp[node]=first; // map the node to its parent\\n        q.push(node);\\n        while(!q.empty()){\\n            auto cur = q.front(); \\n            q.pop(); // get the current node\\n            \\n            for(auto adj:cur->neighbors){ // for each neighbor\\n                if(mp.find(adj)==mp.end()){ // node not present in map\\n                    mp[adj] = new Node(adj->val,{}); // create a new node with the same value\\n                    q.push(adj);\\n                }\\n                mp[cur]->neighbors.push_back(mp[adj]); // add the neighbor to the current node\\n            }\\n        }\\n        return mp[node]; // return the deep copy(clone) of the original graph\\n    }\\n};\\n```\\n****\\n****\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution { // DFS APPROACH\\npublic:\\n    unordered_map<Node*,Node*> mp;\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL) return NULL;\\n        if(mp.find(node)==mp.end()){ // node not present in map\\n            mp[node]= new Node(node->val,{}); // making a copy\\n            for(auto adj:node->neighbors){ // travel to it\\'s adjacent\\n                mp[node]->neighbors.push_back(cloneGraph(adj)); // add the copy\\n            }\\n        }\\n        return mp[node]; // return the deep copy(clone) of the graph\\n    }\\n};\\n```\n```\\nclass Solution { // BFS APPROACH\\npublic:\\n    unordered_map<Node*,Node*> mp; // map from node to its parent\\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL) return NULL; // edge case\\n        queue<Node*> q; // queue of nodes\\n        Node* first = new Node(node->val,{});  // create a new node with the same value\\n        mp[node]=first; // map the node to its parent\\n        q.push(node);\\n        while(!q.empty()){\\n            auto cur = q.front(); \\n            q.pop(); // get the current node\\n            \\n            for(auto adj:cur->neighbors){ // for each neighbor\\n                if(mp.find(adj)==mp.end()){ // node not present in map\\n                    mp[adj] = new Node(adj->val,{}); // create a new node with the same value\\n                    q.push(adj);\\n                }\\n                mp[cur]->neighbors.push_back(mp[adj]); // add the neighbor to the current node\\n            }\\n        }\\n        return mp[node]; // return the deep copy(clone) of the original graph\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843083,
                "title": "generalised-template-for-all-clone-related-problems",
                "content": "There are four clone related problems I\\'ve come across so far and all of them can be solved using the same template. \\nIdea is you have a Map of oldNode to newNode. newNode will have exactly same metadata / value as the oldNode just a different location in the heap memory. Here are the steps:\\n1. Recursively go through the entire structure. Tree / LinkedList\\n2. Check if the old value is in the map. If it is then we return the mapped node right away. \\n3. If not then create a newNode with the same value as the original node. Store the relation in the map.\\n\\n[LC 138:  Copy List with Random Pointer\\n](https://leetcode.com/problems/copy-list-with-random-pointer/)\\nCode:\\n\\n```\\nclass Solution {\\n    Map<Node,Node> oldToNew; // old node to new node map\\n    public Node helper(Node head){\\n        if(head == null) return null;\\n        if(oldToNew.containsKey(head)) return oldToNew.get(head);\\n        Node newNode = new Node(head.val);\\n        oldToNew.put(head,newNode);\\n        newNode.next = helper(head.next);\\n        newNode.random = helper(head.random);\\n        return newNode;\\n    }\\n    \\n    public Node copyRandomList(Node head) {\\n        oldToNew = new HashMap<>();\\n        return helper(head);\\n    }\\n}\\n```\\n\\n[LC 133: Clone Graph\\n](https://leetcode.com/problems/clone-graph/)\\n```\\nclass Solution {\\n    Map<Node,Node> oldToNew = new HashMap<>();\\n    public Node clone(Node node){\\n        if(oldToNew.containsKey(node)) return oldToNew.get(node);\\n        Node newNode = new Node(node.val);\\n        oldToNew.put(node,newNode);\\n        for(int i=0;i<node.neighbors.size();i++){\\n            newNode.neighbors.add(clone(node.neighbors.get(i)));\\n        }\\n        return newNode;\\n    }\\n    \\n    public Node cloneGraph(Node node) {\\n        if(node == null) return null;\\n        return clone(node);\\n    }\\n}\\n```\\n\\n[LC 1490: Clone N-Ary Tree ( Same code as Clone Graph )\\n](https://leetcode.com/problems/clone-n-ary-tree/)\\n```\\nclass Solution { \\n    Map<Node,Node> oldToNew = new HashMap<>();\\n    Node dfs(Node node){\\n        if(node == null) return null;\\n        if(oldToNew.containsKey(node)) return oldToNew.get(node);\\n        Node newNode = new Node(node.val);\\n        oldToNew.put(node,newNode);\\n        for(Node childrens : node.children){\\n            newNode.children.add(dfs(childrens));        \\n        }\\n        return newNode;\\n    }\\n\\n    public Node cloneTree(Node root) {\\n        if(root == null) return null;\\n        return dfs(root);\\n    }\\n}\\n```\\n\\n[LC 1485: Clone Binary Tree With Random Pointer\\n](https://leetcode.com/problems/clone-binary-tree-with-random-pointer/)\\n```\\nclass Solution {\\n    Map<Node, NodeCopy> oldToNew;\\n    public NodeCopy copyRandomHelper(Node root){\\n        if(root == null) return null;\\n        if(oldToNew.containsKey(root)) return oldToNew.get(root);\\n        NodeCopy newNode = new NodeCopy(root.val);\\n        oldToNew.put(root,newNode);\\n        newNode.left = copyRandomHelper(root.left);\\n        newNode.right = copyRandomHelper(root.right);\\n        newNode.random = copyRandomHelper(root.random);\\n        return newNode;\\n    }\\n    \\n    public NodeCopy copyRandomBinaryTree(Node root) {\\n        if(root == null)  return null;\\n        oldToNew = new HashMap<>();\\n        return copyRandomHelper(root);\\n    }\\n}\\n```\\n \\n\\nTime Complexity and Space Complexity both are linear. \\nThank you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Node,Node> oldToNew; // old node to new node map\\n    public Node helper(Node head){\\n        if(head == null) return null;\\n        if(oldToNew.containsKey(head)) return oldToNew.get(head);\\n        Node newNode = new Node(head.val);\\n        oldToNew.put(head,newNode);\\n        newNode.next = helper(head.next);\\n        newNode.random = helper(head.random);\\n        return newNode;\\n    }\\n    \\n    public Node copyRandomList(Node head) {\\n        oldToNew = new HashMap<>();\\n        return helper(head);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Node,Node> oldToNew = new HashMap<>();\\n    public Node clone(Node node){\\n        if(oldToNew.containsKey(node)) return oldToNew.get(node);\\n        Node newNode = new Node(node.val);\\n        oldToNew.put(node,newNode);\\n        for(int i=0;i<node.neighbors.size();i++){\\n            newNode.neighbors.add(clone(node.neighbors.get(i)));\\n        }\\n        return newNode;\\n    }\\n    \\n    public Node cloneGraph(Node node) {\\n        if(node == null) return null;\\n        return clone(node);\\n    }\\n}\\n```\n```\\nclass Solution { \\n    Map<Node,Node> oldToNew = new HashMap<>();\\n    Node dfs(Node node){\\n        if(node == null) return null;\\n        if(oldToNew.containsKey(node)) return oldToNew.get(node);\\n        Node newNode = new Node(node.val);\\n        oldToNew.put(node,newNode);\\n        for(Node childrens : node.children){\\n            newNode.children.add(dfs(childrens));        \\n        }\\n        return newNode;\\n    }\\n\\n    public Node cloneTree(Node root) {\\n        if(root == null) return null;\\n        return dfs(root);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Node, NodeCopy> oldToNew;\\n    public NodeCopy copyRandomHelper(Node root){\\n        if(root == null) return null;\\n        if(oldToNew.containsKey(root)) return oldToNew.get(root);\\n        NodeCopy newNode = new NodeCopy(root.val);\\n        oldToNew.put(root,newNode);\\n        newNode.left = copyRandomHelper(root.left);\\n        newNode.right = copyRandomHelper(root.right);\\n        newNode.random = copyRandomHelper(root.random);\\n        return newNode;\\n    }\\n    \\n    public NodeCopy copyRandomBinaryTree(Node root) {\\n        if(root == null)  return null;\\n        oldToNew = new HashMap<>();\\n        return copyRandomHelper(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770435,
                "title": "python-solution-recursive",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return\\n\\t\\t\\t\\n\\t\\t# keep visited nodes, key=original node, value=copied node\\n        visited = {}\\n        \\n        def copy_node(node):\\n            # If there are circles, we could visit same node twice. \\n            # If we\\'ve already visited, just return it.\\n            if node in visited:\\n                return visited[node]\\n            \\n            # create a new Node with original val, without neighbors\\n            visited[node] = Node(val=node.val)\\n            \\n            # set copied neighbors\\n            visited[node].neighbors = [copy_node(neighbor) for neighbor in node.neighbors]\\n            \\n            return visited[node]\\n        \\n        return copy_node(node)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return\\n\\t\\t\\t\\n\\t\\t# keep visited nodes, key=original node, value=copied node\\n        visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 1758950,
                "title": "short-python-solution",
                "content": "The key is we can add arbitrary argument with default values to leetcode methods\\nwe add ```memo``` to cache wether we have already cloned special node in the original graph.\\nif so, return memoized node, otherwise create it.\\n\\nPython:\\n```\\nclass Solution:\\n    def cloneGraph(self, node, memo={}):\\n        if not node: return None\\n        if node in memo: return memo[node]\\n        clone = Node(node.val)\\n        memo[node] = clone\\n        clone.neighbors = [self.cloneGraph(n, memo) for n in node.neighbors]\\n        \\n        return clone\\n```\\n\\n\\nWe can make it shorter by providing ```None``` as default key in the memo.\\n\\nPython:\\n```\\nclass Solution:\\n    def cloneGraph(self, node, memo={None: None}):\\n        if node in memo: return memo[node]\\n        clone = Node(node.val)\\n        memo[node] = clone\\n        clone.neighbors = [self.cloneGraph(n, memo) for n in node.neighbors]\\n        \\n        return clone\\n```",
                "solutionTags": [],
                "code": "```memo```\n```\\nclass Solution:\\n    def cloneGraph(self, node, memo={}):\\n        if not node: return None\\n        if node in memo: return memo[node]\\n        clone = Node(node.val)\\n        memo[node] = clone\\n        clone.neighbors = [self.cloneGraph(n, memo) for n in node.neighbors]\\n        \\n        return clone\\n```\n```None```\n```\\nclass Solution:\\n    def cloneGraph(self, node, memo={None: None}):\\n        if node in memo: return memo[node]\\n        clone = Node(node.val)\\n        memo[node] = clone\\n        clone.neighbors = [self.cloneGraph(n, memo) for n in node.neighbors]\\n        \\n        return clone\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656310,
                "title": "depth-first-search-c-solution",
                "content": "```\\nclass Solution {\\n    unordered_map <Node*, Node*> mp;\\npublic:\\n    \\n    Node* dfs(Node* node)\\n    {\\n        if(node == NULL) return node;\\n        if(mp.find(node)!=mp.end())\\n            return mp[node];\\n        Node* clone = new Node(node->val);\\n        mp[node] = clone;\\n        for(auto nei : node->neighbors)\\n        {\\n            clone->neighbors.push_back(dfs(nei));\\n        }\\n        return clone;\\n    }\\n    \\n    Node* cloneGraph(Node* node) \\n    {\\n        return dfs(node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map <Node*, Node*> mp;\\npublic:\\n    \\n    Node* dfs(Node* node)\\n    {\\n        if(node == NULL) return node;\\n        if(mp.find(node)!=mp.end())\\n            return mp[node];\\n        Node* clone = new Node(node->val);\\n        mp[node] = clone;\\n        for(auto nei : node->neighbors)\\n        {\\n            clone->neighbors.push_back(dfs(nei));\\n        }\\n        return clone;\\n    }\\n    \\n    Node* cloneGraph(Node* node) \\n    {\\n        return dfs(node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576352,
                "title": "python-dfs-make-sure-neighbor-node-not-been-create-twice",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        vist= {}\\n        def helper(node):\\n            if node:\\n                cp= Node(node.val)\\n                vist[node]=cp\\n\\n                for neighbor in node.neighbors:      \\n                    if neighbor in vist: # copy of n has been created, just get it \\n                        cp.neighbors.append(vist[neighbor])\\n                    else: #the neighbor need to be created\\n                        cp.neighbors.append(helper(neighbor))\\n                #print(cp.val, [x.val for x in cp.neighbors])\\n                return cp\\n        \\n        rst =  helper(node)\\n        return rst\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        vist= {}\\n        def helper(node):\\n            if node:\\n                cp= Node(node.val)\\n                vist[node]=cp\\n\\n                for neighbor in node.neighbors:      \\n                    if neighbor in vist: # copy of n has been created, just get it \\n                        cp.neighbors.append(vist[neighbor])\\n                    else: #the neighbor need to be created\\n                        cp.neighbors.append(helper(neighbor))\\n                #print(cp.val, [x.val for x in cp.neighbors])\\n                return cp\\n        \\n        rst =  helper(node)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353397,
                "title": "java-using-hashmap-dfs",
                "content": "````\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        if(node==null){\\n            return null;\\n        }\\n        map.put(node,new Node(node.val,new ArrayList<>()));\\n        dfs(map,node);\\n        return map.get(node);\\n    }\\n    public static void dfs(HashMap<Node,Node> map,Node node){\\n        for(Node neighbor: node.neighbors){\\n            if(!map.containsKey(neighbor)){\\n                map.put(neighbor,new Node(neighbor.val,new ArrayList<>()));\\n                 dfs(map,neighbor);\\n            }\\n           \\n            map.get(node).neighbors.add(map.get(neighbor));\\n            \\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        if(node==null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1324951,
                "title": "easy-c-solution-using-vector-no-map-commented",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        \\n        //stores the address of the nodes created\\n        if(node==NULL)\\n            return NULL;\\n        vector<Node*> created(101,NULL);\\n        buildGraph(node,created);\\n        return created[node->val];\\n    }\\n    void buildGraph(Node* node,vector<Node*>& created)\\n    {\\n        \\n        //create the node\\n        Node* x;\\n        if(created[node->val]==NULL){\\n             x=new Node(node->val);\\n            created[node->val]=x;\\n        }\\n        else\\n            x=created[node->val];\\n        \\n        for(auto adj:node->neighbors)\\n        {\\n            //if node is not created yet create it\\n            if(created[adj->val]==NULL)\\n            {\\n                Node* n = new Node(adj->val);\\n                \\n                created[adj->val]=n;\\n\\t\\t\\t\\t//add the created node to the neighbors\\n                x->neighbors.push_back(n);\\n                buildGraph(adj,created);\\n            }\\n            else{\\n                x->neighbors.push_back(created[adj->val]);\\n            }\\n        }\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        \\n        //stores the address of the nodes created\\n        if(node==NULL)\\n            return NULL;\\n        vector<Node*> created(101,NULL);\\n        buildGraph(node,created);\\n        return created[node->val];\\n    }\\n    void buildGraph(Node* node,vector<Node*>& created)\\n    {\\n        \\n        //create the node\\n        Node* x;\\n        if(created[node->val]==NULL){\\n             x=new Node(node->val);\\n            created[node->val]=x;\\n        }\\n        else\\n            x=created[node->val];\\n        \\n        for(auto adj:node->neighbors)\\n        {\\n            //if node is not created yet create it\\n            if(created[adj->val]==NULL)\\n            {\\n                Node* n = new Node(adj->val);\\n                \\n                created[adj->val]=n;\\n\\t\\t\\t\\t//add the created node to the neighbors\\n                x->neighbors.push_back(n);\\n                buildGraph(adj,created);\\n            }\\n            else{\\n                x->neighbors.push_back(created[adj->val]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123092,
                "title": "javascript",
                "content": "```\\nvar cloneGraph = function(node) {\\n    let map = {};\\n\\n    return traverse(node);\\n    \\n    function traverse  (node) {\\n        if(!node) return node;\\n        if(!map[node.val]) {\\n            map[node.val] = new Node(node.val);\\n            map[node.val].neighbors = node.neighbors.map(neighbor => traverse(neighbor))\\n        }\\n        return map[node.val]\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cloneGraph = function(node) {\\n    let map = {};\\n\\n    return traverse(node);\\n    \\n    function traverse  (node) {\\n        if(!node) return node;\\n        if(!map[node.val]) {\\n            map[node.val] = new Node(node.val);\\n            map[node.val].neighbors = node.neighbors.map(neighbor => traverse(neighbor))\\n        }\\n        return map[node.val]\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020087,
                "title": "java-recursive-and-iterative-sols",
                "content": "Intution: preorder traversals\\n\\nRecursion sol\\n\\n```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        return cloneDFS(node, new HashMap<>());\\n    }\\n    private Node cloneDFS(Node node, Map<Node, Node> map){\\n        if(node == null) return null;\\n        if(map.containsKey(node)) return map.get(node);\\n        \\n        Node newNode = new Node(node.val);\\n\\t\\t//preorder part\\n        map.put(node, newNode);\\n        \\n        for(Node nei: node.neighbors){\\n            newNode.neighbors.add(cloneDFS(nei, map));\\n        }\\n        \\n        return newNode;\\n    }\\n}\\n```\\nIterative sol\\n```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if(node == null) return node;\\n        Map<Node, Node> map = new HashMap<>();\\n        Deque<Node> stack = new ArrayDeque<>();\\n        map.put(node, new Node(node.val));\\n        //dfs starts\\n        stack.push(node);\\n        \\n        while(!stack.isEmpty()){\\n            Node curr = stack.pop();\\n            for(Node nei: curr.neighbors){\\n                if(map.containsKey(nei)){ //has been cloned already\\n                    map.get(curr).neighbors.add(map.get(nei));\\n                }\\n                else{ //never clone before\\n                    Node newNode = new Node(nei.val);\\n                    map.put(nei, newNode);\\n                    map.get(curr).neighbors.add(newNode);\\n                    stack.push(nei);\\n                }\\n            }\\n        }\\n        return map.get(node);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        return cloneDFS(node, new HashMap<>());\\n    }\\n    private Node cloneDFS(Node node, Map<Node, Node> map){\\n        if(node == null) return null;\\n        if(map.containsKey(node)) return map.get(node);\\n        \\n        Node newNode = new Node(node.val);\\n\\t\\t//preorder part\\n        map.put(node, newNode);\\n        \\n        for(Node nei: node.neighbors){\\n            newNode.neighbors.add(cloneDFS(nei, map));\\n        }\\n        \\n        return newNode;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node cloneGraph(Node node) {\\n        if(node == null) return node;\\n        Map<Node, Node> map = new HashMap<>();\\n        Deque<Node> stack = new ArrayDeque<>();\\n        map.put(node, new Node(node.val));\\n        //dfs starts\\n        stack.push(node);\\n        \\n        while(!stack.isEmpty()){\\n            Node curr = stack.pop();\\n            for(Node nei: curr.neighbors){\\n                if(map.containsKey(nei)){ //has been cloned already\\n                    map.get(curr).neighbors.add(map.get(nei));\\n                }\\n                else{ //never clone before\\n                    Node newNode = new Node(nei.val);\\n                    map.put(nei, newNode);\\n                    map.get(curr).neighbors.add(newNode);\\n                    stack.push(nei);\\n                }\\n            }\\n        }\\n        return map.get(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996559,
                "title": "cpp-dfs-recursion-8ms-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(Node* curr, Node* node, vector<Node*>& visited){\\n        // curr - current orignal node\\n        // node - current clone node\\n        // visisted - visited array\\n        \\n        visited[node->val] = node;\\n        for(auto ele: curr->neighbors){  // for neighbors, traverse vals using og graph\\'s node - curr\\n            if(visited[ele->val] == NULL){    // check if already not visited\\n                Node* newnode = new Node(ele->val);    // create new node\\n                (node->neighbors).push_back(newnode); // add to neighbors of current clone node\\n                dfs(ele, newnode, visited);          // repeat  \\n            }\\n            else{\\n                (node->neighbors).push_back(visited[ele->val]); // get value from the visited array\\n            }\\n        }\\n    }\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)\\n            return NULL;\\n        \\n        vector<Node*> visited(101, NULL);  // we will use this array to check if node has already been created\\n        Node* copy = new Node();\\n        copy->val = node->val;  // create head node with value same as orignal graph\\'s root\\n        visited[node->val] = copy; // add the first node to visited array\\n        \\n        // iterate through all the neighbors of start node\\n        for(auto curr: node->neighbors){  \\n            if(visited[curr->val] == NULL){    // check if already not visited\\n                Node* newnode = new Node(curr->val);    // create new node\\n                (copy->neighbors).push_back(newnode); // add to neighbors of current clone node\\n                dfs(curr, newnode, visited);          // repeat for start node\\'s neighbours in dfs()\\n            }\\n            else{\\n                (copy->neighbors).push_back(visited[curr->val]); // get value from the visited array\\n            }\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(Node* curr, Node* node, vector<Node*>& visited){\\n        // curr - current orignal node\\n        // node - current clone node\\n        // visisted - visited array\\n        \\n        visited[node->val] = node;\\n        for(auto ele: curr->neighbors){  // for neighbors, traverse vals using og graph\\'s node - curr\\n            if(visited[ele->val] == NULL){    // check if already not visited\\n                Node* newnode = new Node(ele->val);    // create new node\\n                (node->neighbors).push_back(newnode); // add to neighbors of current clone node\\n                dfs(ele, newnode, visited);          // repeat  \\n            }\\n            else{\\n                (node->neighbors).push_back(visited[ele->val]); // get value from the visited array\\n            }\\n        }\\n    }\\n    \\n    Node* cloneGraph(Node* node) {\\n        if(node==NULL)\\n            return NULL;\\n        \\n        vector<Node*> visited(101, NULL);  // we will use this array to check if node has already been created\\n        Node* copy = new Node();\\n        copy->val = node->val;  // create head node with value same as orignal graph\\'s root\\n        visited[node->val] = copy; // add the first node to visited array\\n        \\n        // iterate through all the neighbors of start node\\n        for(auto curr: node->neighbors){  \\n            if(visited[curr->val] == NULL){    // check if already not visited\\n                Node* newnode = new Node(curr->val);    // create new node\\n                (copy->neighbors).push_back(newnode); // add to neighbors of current clone node\\n                dfs(curr, newnode, visited);          // repeat for start node\\'s neighbours in dfs()\\n            }\\n            else{\\n                (copy->neighbors).push_back(visited[curr->val]); // get value from the visited array\\n            }\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903809,
                "title": "idiomatic-golang-dfs-solution",
                "content": "```\\nfunc dfs(node *Node, visited map[*Node]*Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    if val, ok := visited[node]; ok {\\n        return val\\n    }\\n    visited[node] = &Node{\\n        Val: node.Val,\\n        Neighbors: []*Node{},\\n    }\\n    for _, nn := range node.Neighbors {\\n        visited[node].Neighbors = append(visited[node].Neighbors, dfs(nn, visited))\\n    }\\n    return visited[node]\\n}\\n\\nfunc cloneGraph(node *Node) *Node {\\n    visited := make(map[*Node]*Node)   \\n    return dfs(node, visited)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dfs(node *Node, visited map[*Node]*Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    if val, ok := visited[node]; ok {\\n        return val\\n    }\\n    visited[node] = &Node{\\n        Val: node.Val,\\n        Neighbors: []*Node{},\\n    }\\n    for _, nn := range node.Neighbors {\\n        visited[node].Neighbors = append(visited[node].Neighbors, dfs(nn, visited))\\n    }\\n    return visited[node]\\n}\\n\\nfunc cloneGraph(node *Node) *Node {\\n    visited := make(map[*Node]*Node)   \\n    return dfs(node, visited)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903065,
                "title": "c-solution-dfs-recursive-4-ms-explained",
                "content": "EXPLANATION\\n1. The main function declare a support array of node pointers, in that array I will save pointers to node structures already visited and allocated, in that way, when a neighbors already exist, I will just connect to it instead of creating a new one;\\n2. If s == NULL the graph is empty and return NULL;\\n3. If graph is not empty launch dfs (deep first search);\\n4. Each time dfs is called the new node is filled, the pointer of new node is saved into visited array and its neighbors list is scanned, if the neighbor already exist I connect to it, otherwise I call dfs with a new allocated node structure;\\n\\n```\\nvoid dfs(struct Node *head, struct Node *s, struct Node** visit){\\n    head->val = s->val;\\n    head->numNeighbors = s->numNeighbors;\\n    visit[s->val] = head;\\n    if((s->numNeighbors) == 0) return;\\n    head->neighbors = (struct Node**)malloc(sizeof(struct Node*)*(s->numNeighbors));\\n    for(int i=0;i<(s->numNeighbors);i++)\\n        if(visit[s->neighbors[i]->val] == NULL){\\n            head->neighbors[i] = (struct Node*)malloc(sizeof(struct Node));\\n            dfs(head->neighbors[i], s->neighbors[i], visit);\\n        }\\n        else\\n            head->neighbors[i] = visit[s->neighbors[i]->val];\\n    return;\\n}\\n\\nstruct Node *cloneGraph(struct Node *s) {\\n    struct Node *head = (struct Node*)malloc(sizeof(struct Node));\\n    struct Node *visit[101] = {NULL};\\n    if (s == NULL) return NULL;\\n    dfs(head, s, visit);\\n    return head;   \\n}",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "EXPLANATION\\n1. The main function declare a support array of node pointers, in that array I will save pointers to node structures already visited and allocated, in that way, when a neighbors already exist, I will just connect to it instead of creating a new one;\\n2. If s == NULL the graph is empty and return NULL;\\n3. If graph is not empty launch dfs (deep first search);\\n4. Each time dfs is called the new node is filled, the pointer of new node is saved into visited array and its neighbors list is scanned, if the neighbor already exist I connect to it, otherwise I call dfs with a new allocated node structure;\\n\\n```\\nvoid dfs(struct Node *head, struct Node *s, struct Node** visit){\\n    head->val = s->val;\\n    head->numNeighbors = s->numNeighbors;\\n    visit[s->val] = head;\\n    if((s->numNeighbors) == 0) return;\\n    head->neighbors = (struct Node**)malloc(sizeof(struct Node*)*(s->numNeighbors));\\n    for(int i=0;i<(s->numNeighbors);i++)\\n        if(visit[s->neighbors[i]->val] == NULL){\\n            head->neighbors[i] = (struct Node*)malloc(sizeof(struct Node));\\n            dfs(head->neighbors[i], s->neighbors[i], visit);\\n        }\\n        else\\n            head->neighbors[i] = visit[s->neighbors[i]->val];\\n    return;\\n}\\n\\nstruct Node *cloneGraph(struct Node *s) {\\n    struct Node *head = (struct Node*)malloc(sizeof(struct Node));\\n    struct Node *visit[101] = {NULL};\\n    if (s == NULL) return NULL;\\n    dfs(head, s, visit);\\n    return head;   \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 902742,
                "title": "go-dfs-recursive",
                "content": "```go\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Neighbors []*Node\\n * }\\n */\\n\\nfunc vis(node* Node, mp map[int]*Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    if _, ok := mp[node.Val]; !ok {\\n        nn := &Node{ Val: node.Val }\\n        mp[node.Val] = nn\\n        for _, nx := range node.Neighbors {\\n            nn.Neighbors = append(nn.Neighbors, vis(nx, mp))\\n        }\\n    }\\n    return mp[node.Val]\\n}\\n\\nfunc cloneGraph(node *Node) *Node {\\n    mp := make(map[int]*Node)\\n    return vis(node, mp)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```go\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Neighbors []*Node\\n * }\\n */\\n\\nfunc vis(node* Node, mp map[int]*Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    if _, ok := mp[node.Val]; !ok {\\n        nn := &Node{ Val: node.Val }\\n        mp[node.Val] = nn\\n        for _, nx := range node.Neighbors {\\n            nn.Neighbors = append(nn.Neighbors, vis(nx, mp))\\n        }\\n    }\\n    return mp[node.Val]\\n}\\n\\nfunc cloneGraph(node *Node) *Node {\\n    mp := make(map[int]*Node)\\n    return vis(node, mp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902708,
                "title": "c-recursive",
                "content": "```\\npublic class Solution {\\n    Dictionary<Node, Node> map = new Dictionary<Node, Node>();\\n    public Node CloneGraph(Node node) {\\n        if(node == null) return null;\\n        if(!map.ContainsKey(node))\\n        {\\n            map.Add(node, new Node(node.val));\\n            foreach(var nei in node.neighbors)\\n            {\\n                map[node].neighbors.Add(CloneGraph(nei));\\n            }\\n        }\\n        return map[node];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Dictionary<Node, Node> map = new Dictionary<Node, Node>();\\n    public Node CloneGraph(Node node) {\\n        if(node == null) return null;\\n        if(!map.ContainsKey(node))\\n        {\\n            map.Add(node, new Node(node.val));\\n            foreach(var nei in node.neighbors)\\n            {\\n                map[node].neighbors.Add(CloneGraph(nei));\\n            }\\n        }\\n        return map[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854754,
                "title": "c-bfs-and-dfs-solution",
                "content": "**1. DFS**\\n```\\nclass Solution {\\nprivate: unordered_map<Node*, Node*> map;\\n    \\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node){\\n            return NULL;\\n        }\\n        \\n        if(map.find(node) == map.end()){\\n            map[node] = new Node(node->val, {});\\n            for(Node* neighbor : node->neighbors){\\n                map[node]->neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return map[node];\\n    }\\n```\\n**2. BFS**\\n```\\nclass Solution {\\nprivate: unordered_map<Node*, Node*> map;\\n    \\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node){\\n            return NULL;\\n        }\\n        Node* copy = new Node(node->val, {});\\n        map[node] = copy;\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            Node* cur = q.front();\\n            q.pop();\\n            for(Node* neighbor : cur->neighbors){\\n                if(map.find(neighbor) == map.end()){\\n                    map[neighbor] = new Node(neighbor-> val, {});\\n                    q.push(neighbor);\\n                }\\n                map[cur]->neighbors.push_back(map[neighbor]);\\n            }\\n        }        \\n        return map[node];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: unordered_map<Node*, Node*> map;\\n    \\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node){\\n            return NULL;\\n        }\\n        \\n        if(map.find(node) == map.end()){\\n            map[node] = new Node(node->val, {});\\n            for(Node* neighbor : node->neighbors){\\n                map[node]->neighbors.push_back(cloneGraph(neighbor));\\n            }\\n        }\\n        return map[node];\\n    }\\n```\n```\\nclass Solution {\\nprivate: unordered_map<Node*, Node*> map;\\n    \\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(!node){\\n            return NULL;\\n        }\\n        Node* copy = new Node(node->val, {});\\n        map[node] = copy;\\n        queue<Node*> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            Node* cur = q.front();\\n            q.pop();\\n            for(Node* neighbor : cur->neighbors){\\n                if(map.find(neighbor) == map.end()){\\n                    map[neighbor] = new Node(neighbor-> val, {});\\n                    q.push(neighbor);\\n                }\\n                map[cur]->neighbors.push_back(map[neighbor]);\\n            }\\n        }        \\n        return map[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791465,
                "title": "python-dfs-bfs-soln-faster-than-96",
                "content": "**DFS**\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.vis = {}\\n        \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        if node in self.vis:\\n            return self.vis[node]\\n        \\n        new_node = Node(node.val)\\n        self.vis[node] = new_node\\n        new_node.neighbors = []\\n        \\n        for child in node.neighbors:\\n            new_node.neighbors.append(self.cloneGraph(child))\\n        \\n        return new_node\\n```\\n\\n**BFS**\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return\\n        \\n        q = deque()\\n        q.append(node)\\n        vis = {}\\n        vis[node] = Node(node.val)\\n        \\n        while q:\\n            root = q.popleft()\\n            for child in root.neighbors:\\n                if child not in vis:\\n                    vis[child] = Node(child.val)\\n                    q.append(child)\\n                vis[root].neighbors.append(vis[child])\\n                \\n        return vis[node]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.vis = {}\\n        \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        if node in self.vis:\\n            return self.vis[node]\\n        \\n        new_node = Node(node.val)\\n        self.vis[node] = new_node\\n        new_node.neighbors = []\\n        \\n        for child in node.neighbors:\\n            new_node.neighbors.append(self.cloneGraph(child))\\n        \\n        return new_node\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return\\n        \\n        q = deque()\\n        q.append(node)\\n        vis = {}\\n        vis[node] = Node(node.val)\\n        \\n        while q:\\n            root = q.popleft()\\n            for child in root.neighbors:\\n                if child not in vis:\\n                    vis[child] = Node(child.val)\\n                    q.append(child)\\n                vis[root].neighbors.append(vis[child])\\n                \\n        return vis[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742231,
                "title": "python-faster-than-97",
                "content": "```\\ndef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        ht = {}\\n        \\n        def helper(n):\\n            if not n:\\n                return None\\n            \\n            if n in ht:\\n                return ht[n]\\n\\n            ht[n] = Node(n.val)\\n            \\n            for nei in n.neighbors:\\n                ht[n].neighbors.append(helper(nei))\\n            \\n            return ht[n]\\n        \\n        return helper(node)\\n```",
                "solutionTags": [],
                "code": "```\\ndef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        ht = {}\\n        \\n        def helper(n):\\n            if not n:\\n                return None\\n            \\n            if n in ht:\\n                return ht[n]\\n\\n            ht[n] = Node(n.val)\\n            \\n            for nei in n.neighbors:\\n                ht[n].neighbors.append(helper(nei))\\n            \\n            return ht[n]\\n        \\n        return helper(node)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 690717,
                "title": "python-very-very-simple-dfs-solutoin-95-faster",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        ## RC ##\\n        ## APPROACH : HASHMAP - DFS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def dfs(node):\\n            \\n            # { old node : new clone node }\\n            if(node in visited):\\n                return visited[node]\\n            \\n            visited[node] = Node(node.val)\\n            \\n            for nei in node.neighbors:\\n                visited[node].neighbors.append(dfs(nei))\\n                \\n            return visited[node]\\n        \\n        # simply return, no node \\n        if not node: return None\\n        \\n        visited = {}\\n        clone_graph = dfs(node)\\n        return clone_graph\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        ## RC ##\\n        ## APPROACH : HASHMAP - DFS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def dfs(node):\\n            \\n            # { old node : new clone node }\\n            if(node in visited):\\n                return visited[node]\\n            \\n            visited[node] = Node(node.val)\\n            \\n            for nei in node.neighbors:\\n                visited[node].neighbors.append(dfs(nei))\\n                \\n            return visited[node]\\n        \\n        # simply return, no node \\n        if not node: return None\\n        \\n        visited = {}\\n        clone_graph = dfs(node)\\n        return clone_graph\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667046,
                "title": "explained-both-recursive-very-simple-and-iterative-solution",
                "content": "General Idea:\\nMaintain a map which will have mapping of old nodes to cloned nodes. It can be done using just the `val` of the node as Problem clearly says all the nodes will have unique value, if let\\'s say that is also not the case then we can map reference of old node to cloned node.\\n\\nRecursive Solution: Idea is to maintain a object level dictionary to track which nodes are already cloned, if we encounter any new neighbour node `nei` for current node `node` then we\\'ll call `cloneGraph` recursively. i.e: first clone that new node and then add cloned reference in the neighbours of current node.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.new_nodes = {}\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        cur_val = node.val\\n        if cur_val in self.new_nodes:\\n            return self.new_nodes[cur_val]\\n                \\n        cloned_node = Node(cur_val)\\n        self.new_nodes[cur_val] = cloned_node\\n        for nei in node.neighbors:\\n            if nei.val in self.new_nodes:\\n                self.new_nodes[cur_val].neighbors.append(self.new_nodes[nei.val])\\n            else:\\n                cloned_child = self.cloneGraph(nei)\\n                self.new_nodes[cur_val].neighbors.append(cloned_child)\\n        \\n        return self.new_nodes[cur_val]\\n```\\t\\t\\n\\nIterative solution: This is somewhat similar to recursive solution only, just that here we are doing 2 iteration of graph. First clone all the nodes and track them in a map. In 2nd iteration populate dependency using populated map. \\n```\\nclass Solution:\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        new_nodes = {}        \\n        q = [node]\\n        while q:\\n            cur = q.pop()\\n            if cur.val not in new_nodes:\\n                new_nodes[cur.val] = Node(cur.val)\\n                for nei in cur.neighbors:\\n                    if nei not in new_nodes:\\n                        q.append(nei)\\n        \\n        visited = set()\\n        q = [node]\\n        while q:\\n            cur = q.pop()\\n            if cur.val in visited:\\n                continue\\n            visited.add(cur.val)\\n            for nei in cur.neighbors:\\n                new_nodes[cur.val].neighbors.append(new_nodes[nei.val])\\n                if nei.val not in visited:\\n                    q.append(nei)\\n        \\n        return new_nodes[node.val]\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.new_nodes = {}\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        cur_val = node.val\\n        if cur_val in self.new_nodes:\\n            return self.new_nodes[cur_val]\\n                \\n        cloned_node = Node(cur_val)\\n        self.new_nodes[cur_val] = cloned_node\\n        for nei in node.neighbors:\\n            if nei.val in self.new_nodes:\\n                self.new_nodes[cur_val].neighbors.append(self.new_nodes[nei.val])\\n            else:\\n                cloned_child = self.cloneGraph(nei)\\n                self.new_nodes[cur_val].neighbors.append(cloned_child)\\n        \\n        return self.new_nodes[cur_val]\\n```\n```\\nclass Solution:\\n    \\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        \\n        new_nodes = {}        \\n        q = [node]\\n        while q:\\n            cur = q.pop()\\n            if cur.val not in new_nodes:\\n                new_nodes[cur.val] = Node(cur.val)\\n                for nei in cur.neighbors:\\n                    if nei not in new_nodes:\\n                        q.append(nei)\\n        \\n        visited = set()\\n        q = [node]\\n        while q:\\n            cur = q.pop()\\n            if cur.val in visited:\\n                continue\\n            visited.add(cur.val)\\n            for nei in cur.neighbors:\\n                new_nodes[cur.val].neighbors.append(new_nodes[nei.val])\\n                if nei.val not in visited:\\n                    q.append(nei)\\n        \\n        return new_nodes[node.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549718,
                "title": "golang-bfs",
                "content": "Traverse original graph while keeping a map to corresponding clone node. We need the map to establish the edges between the nodes.\\n\\n```\\nfunc cloneGraph(node *Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    m := map[*Node]*Node{node: nil}\\n    q := []*Node{node}\\n    \\n    m[node] = &Node{Val:node.Val}\\n    for len(q) > 0 {\\n        current := q[0]\\n        q = q[1:]\\n        \\n        for i := range current.Neighbors {\\n            neighbor := current.Neighbors[i]\\n           \\n            if  _, seen := m[neighbor]; !seen {\\n                m[neighbor] = &Node{Val: neighbor.Val}\\n                q = append(q, neighbor)\\n            }\\n            m[current].Neighbors = append(m[current].Neighbors, m[neighbor]) // kind of tricky, map to cloned neighbor not original neighbor\\n        }\\n    }\\n    return m[node]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc cloneGraph(node *Node) *Node {\\n    if node == nil {\\n        return nil\\n    }\\n    m := map[*Node]*Node{node: nil}\\n    q := []*Node{node}\\n    \\n    m[node] = &Node{Val:node.Val}\\n    for len(q) > 0 {\\n        current := q[0]\\n        q = q[1:]\\n        \\n        for i := range current.Neighbors {\\n            neighbor := current.Neighbors[i]\\n           \\n            if  _, seen := m[neighbor]; !seen {\\n                m[neighbor] = &Node{Val: neighbor.Val}\\n                q = append(q, neighbor)\\n            }\\n            m[current].Neighbors = append(m[current].Neighbors, m[neighbor]) // kind of tricky, map to cloned neighbor not original neighbor\\n        }\\n    }\\n    return m[node]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429632,
                "title": "python-iterative-dfs-with-stack",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return\\n        stack = [node]\\n        visited = {}\\n        visited[node] = Node(node.val,[])\\n        while stack:\\n            curnode = stack.pop()\\n            for nei in curnode.neighbors:\\n                if nei not in visited:\\n                    visited[nei] = Node(nei.val,[])\\n                    stack.append(nei)\\n                #append all the neighbors whether it\\'s visited or not\\n                visited[curnode].neighbors.append(visited[nei])\\n        return visited[node]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, neighbors):\\n        self.val = val\\n        self.neighbors = neighbors\\n\"\"\"\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        \"\"\"\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return\\n        stack = [node]\\n        visited = {}\\n        visited[node] = Node(node.val,[])\\n        while stack:\\n            curnode = stack.pop()\\n            for nei in curnode.neighbors:\\n                if nei not in visited:\\n                    visited[nei] = Node(nei.val,[])\\n                    stack.append(nei)\\n                #append all the neighbors whether it\\'s visited or not\\n                visited[curnode].neighbors.append(visited[nei])\\n        return visited[node]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 390570,
                "title": "python-very-clean-and-fast-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        nodes_map = {None: None}\\n        \\n        def dfs(node):\\n            if node not in nodes_map:\\n                copy = Node(val=node.val, neighbors=None)\\n                nodes_map[node] = copy\\n                copy.neighbors = [dfs(n) for n in node.neighbors]\\n            return nodes_map[node]\\n        \\n        return dfs(node)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def cloneGraph(self, node):\\n        nodes_map = {None: None}\\n        \\n        def dfs(node):\\n            if node not in nodes_map:\\n                copy = Node(val=node.val, neighbors=None)\\n                nodes_map[node] = copy\\n                copy.neighbors = [dfs(n) for n in node.neighbors]\\n            return nodes_map[node]\\n        \\n        return dfs(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350428,
                "title": "javascript-solution",
                "content": "```\\nvar cloneGraph = function(node) {\\n   let map = {};\\n   return traverse(node);\\n\\n    function traverse(node) {\\n        if (!node) return node;\\n        if (!map[node.val]) {\\n          map[node.val] = new Node(node.val);\\n          map[node.val].neighbors = node.neighbors.map(neighbor => traverse(neighbor));\\n        }\\n        return map[node.val];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar cloneGraph = function(node) {\\n   let map = {};\\n   return traverse(node);\\n\\n    function traverse(node) {\\n        if (!node) return node;\\n        if (!map[node.val]) {\\n          map[node.val] = new Node(node.val);\\n          map[node.val].neighbors = node.neighbors.map(neighbor => traverse(neighbor));\\n        }\\n        return map[node.val];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 344300,
                "title": "simple-python3-dfs",
                "content": "Key points:\\n1. We do not want to iterate through an old node we have already gone through, otherwise we will go back and forth infinitely\\n2. Even when we recognize we have already traversed through an old node, we should still add the new node equivalent of the old node as a child. Otherwise that edge will be missing.\\n\\nWe can solve this by using a map that has the old node as the key and the new node as the value. We can tell if we have visited an old node by checking if its in the map, and if it is, we add the value (the new node equivalent) to the current new node instead of traversing through the old node again.\\n```\\nvisited = {}\\n    \\ndef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n\\tnewNode = Node(node.val, [])\\n\\tself.visited[node] = newNode\\n\\tfor n in node.neighbors:\\n\\t\\tif n not in self.visited:\\n\\t\\t\\tnewNode.neighbors.append(self.cloneGraph(n))\\n\\t\\telse:\\n\\t\\t\\tnewNode.neighbors.append(self.visited[n])\\n\\n\\treturn newNode\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nvisited = {}\\n    \\ndef cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n\\tnewNode = Node(node.val, [])\\n\\tself.visited[node] = newNode\\n\\tfor n in node.neighbors:\\n\\t\\tif n not in self.visited:\\n\\t\\t\\tnewNode.neighbors.append(self.cloneGraph(n))\\n\\t\\telse:\\n\\t\\t\\tnewNode.neighbors.append(self.visited[n])\\n\\n\\treturn newNode\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 342267,
                "title": "my-solution-using-bfs-in-java",
                "content": "```\\npublic class Solution {\\n \\n public Node cloneGraph(Node node) {\\n     if(node == null) return node;\\n     \\n     // Use BFS algorithm to traverse the graph and get all nodes.\\n     ArrayList<Node> nodes = getNodes(node);\\n     \\n     // Copy nodes, store the old->new mapping information in a HashMap.\\n     HashMap<Node, Node> mapping = new HashMap<>();\\n     for(Node n : nodes) {\\n     \\tmapping.put(n, new Node(n.val, new ArrayList<Node>()));\\n     }\\n     \\n     // Copy neighbors\\n     for(Node n : nodes) {\\n     \\tNode newNode = mapping.get(n);\\n     \\tfor(Node neighbor : n.neighbors) {\\n     \\t\\tNode newNeighbor = mapping.get(neighbor);\\n     \\t\\tnewNode.neighbors.add(newNeighbor);\\n     \\t}\\n     }\\n     \\n     return mapping.get(node);\\n }\\n \\n public ArrayList<Node> getNodes(Node node) {\\n \\tQueue<Node> queue =  new LinkedList<>();\\n \\tHashSet<Node> set =  new HashSet<>();\\n \\t\\n \\tqueue.offer(node);\\n \\tset.add(node);\\n \\t\\n \\twhile(!queue.isEmpty()) {\\n \\t\\tNode head = queue.poll();\\n \\t\\tfor(Node neighbor : head.neighbors) {\\n \\t\\t\\tif(!set.contains(neighbor)) {\\n \\t\\t\\t\\tqueue.offer(neighbor);\\n \\t\\t\\t\\tset.add(neighbor);\\n \\t\\t\\t}\\n \\t\\t}\\n \\t}\\n \\t\\n \\treturn new ArrayList<Node>(set);\\n }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n \\n public Node cloneGraph(Node node) {\\n     if(node == null) return node;\\n     \\n     // Use BFS algorithm to traverse the graph and get all nodes.\\n     ArrayList<Node> nodes = getNodes(node);\\n     \\n     // Copy nodes, store the old->new mapping information in a HashMap.\\n     HashMap<Node, Node> mapping = new HashMap<>();\\n     for(Node n : nodes) {\\n     \\tmapping.put(n, new Node(n.val, new ArrayList<Node>()));\\n     }\\n     \\n     // Copy neighbors\\n     for(Node n : nodes) {\\n     \\tNode newNode = mapping.get(n);\\n     \\tfor(Node neighbor : n.neighbors) {\\n     \\t\\tNode newNeighbor = mapping.get(neighbor);\\n     \\t\\tnewNode.neighbors.add(newNeighbor);\\n     \\t}\\n     }\\n     \\n     return mapping.get(node);\\n }\\n \\n public ArrayList<Node> getNodes(Node node) {\\n \\tQueue<Node> queue =  new LinkedList<>();\\n \\tHashSet<Node> set =  new HashSet<>();\\n \\t\\n \\tqueue.offer(node);\\n \\tset.add(node);\\n \\t\\n \\twhile(!queue.isEmpty()) {\\n \\t\\tNode head = queue.poll();\\n \\t\\tfor(Node neighbor : head.neighbors) {\\n \\t\\t\\tif(!set.contains(neighbor)) {\\n \\t\\t\\t\\tqueue.offer(neighbor);\\n \\t\\t\\t\\tset.add(neighbor);\\n \\t\\t\\t}\\n \\t\\t}\\n \\t}\\n \\t\\n \\treturn new ArrayList<Node>(set);\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320243,
                "title": "c-87-97-beat-o-nodes-connections-two-pass",
                "content": "This is an all-original solution. I have attempted this several months back and could not get a solution. Now I was able to do it.\\n\\n```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        \\n        if (node == NULL) { return NULL; }\\n        \\n        //Here is where we will store our clones...\\n        unordered_map<Node *, Node *> aDic;\\n        \\n        //Similar to level-order iteration of tree...\\n        queue <Node *> aQueue;\\n        aQueue.push(node);\\n        \\n        //Here we will keep track of which nodes we have visited.\\n        //This will prevent us from making duplicate clones.\\n        unordered_map<Node *, bool> aVisited;\\n        \\n        //First we will build up copies of all nodes, keeping a map to them...\\n        while (!aQueue.empty()) {\\n            \\n            Node *aNode = aQueue.front();\\n            aQueue.pop();\\n            \\n            //Build the clone.\\n            Node *aClone = new Node(aNode->val, vector<Node *>());\\n            aDic[aNode] = aClone;\\n            \\n            for (auto aChild : aNode->neighbors) {\\n                if (aDic[aChild] == NULL && aVisited[aChild] == false) {\\n                    aVisited[aChild] = true;\\n                    aQueue.push(aChild);\\n                } \\n            }\\n        }\\n        \\n        //We re-use visited for the same purpose.\\n        aVisited.clear();\\n        \\n        //And do another similar iteration...\\n        aQueue.push(node);\\n        \\n        //Now we link up the clones, using the linking from the original...\\n        while (!aQueue.empty()) {\\n            Node *aNode = aQueue.front();\\n            aQueue.pop();\\n            Node *aClone = aDic[aNode];\\n            aVisited[aNode] = true;\\n            for (auto aChild : aNode->neighbors) {\\n                if (aVisited[aChild] == false) {\\n                    aVisited[aChild] = true;\\n                    aQueue.push(aChild);\\n                }       \\n                aClone->neighbors.push_back(aDic[aChild]);\\n            }\\n        }\\n        return aDic[node];\\n    }\\n};\\n```\\n\\nPretty cool, the code is the road to the victory cup. If you can\\'t hack it, then don\\'t bother. Trolls and fools will wash out.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        \\n        if (node == NULL) { return NULL; }\\n        \\n        //Here is where we will store our clones...\\n        unordered_map<Node *, Node *> aDic;\\n        \\n        //Similar to level-order iteration of tree...\\n        queue <Node *> aQueue;\\n        aQueue.push(node);\\n        \\n        //Here we will keep track of which nodes we have visited.\\n        //This will prevent us from making duplicate clones.\\n        unordered_map<Node *, bool> aVisited;\\n        \\n        //First we will build up copies of all nodes, keeping a map to them...\\n        while (!aQueue.empty()) {\\n            \\n            Node *aNode = aQueue.front();\\n            aQueue.pop();\\n            \\n            //Build the clone.\\n            Node *aClone = new Node(aNode->val, vector<Node *>());\\n            aDic[aNode] = aClone;\\n            \\n            for (auto aChild : aNode->neighbors) {\\n                if (aDic[aChild] == NULL && aVisited[aChild] == false) {\\n                    aVisited[aChild] = true;\\n                    aQueue.push(aChild);\\n                } \\n            }\\n        }\\n        \\n        //We re-use visited for the same purpose.\\n        aVisited.clear();\\n        \\n        //And do another similar iteration...\\n        aQueue.push(node);\\n        \\n        //Now we link up the clones, using the linking from the original...\\n        while (!aQueue.empty()) {\\n            Node *aNode = aQueue.front();\\n            aQueue.pop();\\n            Node *aClone = aDic[aNode];\\n            aVisited[aNode] = true;\\n            for (auto aChild : aNode->neighbors) {\\n                if (aVisited[aChild] == false) {\\n                    aVisited[aChild] = true;\\n                    aQueue.push(aChild);\\n                }       \\n                aClone->neighbors.push_back(aDic[aChild]);\\n            }\\n        }\\n        return aDic[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42379,
                "title": "java-2-solutions-bfs-dfs",
                "content": "bfs:\\nUse queue to record old node, and hashmap to record new node.\\n```\\n    private UndirectedGraphNode bfs(UndirectedGraphNode node){\\n        if(node==null) return null;\\n        Queue<UndirectedGraphNode> que = new LinkedList<>(); // old node\\n        Map<Integer, UndirectedGraphNode> map = new HashMap<>(); // new node\\n        UndirectedGraphNode root = new UndirectedGraphNode(node.label);\\n        map.put(root.label, root);\\n        que.offer(node);\\n        UndirectedGraphNode p = root, newRoot = root, newNode = root;\\n        while(!que.isEmpty()){\\n            p = que.poll();\\n            newRoot = map.get(p.label);\\n            for(UndirectedGraphNode n : p.neighbors){\\n                if(map.containsKey(n.label)){\\n                    newNode = map.get(n.label);\\n                } else{\\n                    newNode = new UndirectedGraphNode(n.label);\\n                    map.put(newNode.label, newNode);\\n                    que.offer(n);\\n                }\\n                newRoot.neighbors.add(newNode);\\n            }\\n        }\\n        return root;\\n    }\\n```\\ndfs\\n```\\n    private UndirectedGraphNode dfs(UndirectedGraphNode node, Map<Integer, UndirectedGraphNode> map){\\n        if(node == null) return null;\\n        UndirectedGraphNode newNode = map.get(node.label);\\n        if(newNode != null) \\n            return newNode;\\n        newNode = new UndirectedGraphNode(node.label);\\n        map.put(newNode.label, newNode);\\n        for(UndirectedGraphNode v : node.neighbors){\\n            newNode.neighbors.add( dfs(v, map) );\\n        }\\n        return newNode;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private UndirectedGraphNode bfs(UndirectedGraphNode node){\\n        if(node==null) return null;\\n        Queue<UndirectedGraphNode> que = new LinkedList<>(); // old node\\n        Map<Integer, UndirectedGraphNode> map = new HashMap<>(); // new node\\n        UndirectedGraphNode root = new UndirectedGraphNode(node.label);\\n        map.put(root.label, root);\\n        que.offer(node);\\n        UndirectedGraphNode p = root, newRoot = root, newNode = root;\\n        while(!que.isEmpty()){\\n            p = que.poll();\\n            newRoot = map.get(p.label);\\n            for(UndirectedGraphNode n : p.neighbors){\\n                if(map.containsKey(n.label)){\\n                    newNode = map.get(n.label);\\n                } else{\\n                    newNode = new UndirectedGraphNode(n.label);\\n                    map.put(newNode.label, newNode);\\n                    que.offer(n);\\n                }\\n                newRoot.neighbors.add(newNode);\\n            }\\n        }\\n        return root;\\n    }\\n```\n```\\n    private UndirectedGraphNode dfs(UndirectedGraphNode node, Map<Integer, UndirectedGraphNode> map){\\n        if(node == null) return null;\\n        UndirectedGraphNode newNode = map.get(node.label);\\n        if(newNode != null) \\n            return newNode;\\n        newNode = new UndirectedGraphNode(node.label);\\n        map.put(newNode.label, newNode);\\n        for(UndirectedGraphNode v : node.neighbors){\\n            newNode.neighbors.add( dfs(v, map) );\\n        }\\n        return newNode;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42414,
                "title": "c-dfs-and-bfs-solution-using-unordered-map",
                "content": "    /**\\n     * Definition for undirected graph.\\n     * struct UndirectedGraphNode {\\n     *     int label;\\n     *     vector<UndirectedGraphNode *> neighbors;\\n     *     UndirectedGraphNode(int x) : label(x) {};\\n     * };\\n     */\\n    class Solution {\\n    private:\\n        unordered_map<UndirectedGraphNode*,UndirectedGraphNode*> hash;\\n    public:\\n        //BFS\\n         UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n             if(!node) return NULL;\\n             queue<UndirectedGraphNode*> Qu;\\n             Qu.push(node);\\n             hash[node] = new UndirectedGraphNode(node->label);\\n             while(!Qu.empty()){\\n                 UndirectedGraphNode * tmp = Qu.front();\\n                 Qu.pop();\\n                 for(UndirectedGraphNode * neighbor : tmp->neighbors){\\n                     if(hash.find(neighbor) == hash.end()){\\n                         hash[neighbor] = new UndirectedGraphNode(neighbor->label);\\n                         Qu.push(neighbor);\\n                     }\\n                     hash[tmp]->neighbors.push_back(hash[neighbor]);\\n                 }\\n             }\\n             return hash[node];\\n         }\\n        //DFS\\n        UndirectedGraphNode *cloneGraph1(UndirectedGraphNode *node) {\\n            if(!node) return NULL;\\n            if(hash.find(node) == hash.end()){\\n                hash[node] = new UndirectedGraphNode(node->label);\\n                for(UndirectedGraphNode* neighbor : node->neighbors){\\n                    hash[node]->neighbors.push_back(cloneGraph1(neighbor));\\n                }\\n            }\\n            return hash[node];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        unordered_map<UndirectedGraphNode*,UndirectedGraphNode*> hash;\\n    public:\\n        //BFS\\n         UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n             if(!node) return NULL;\\n             queue<UndirectedGraphNode*> Qu;\\n             Qu.push(node);\\n             hash[node] = new UndirectedGraphNode(node->label);\\n             while(!Qu.empty()){\\n                 UndirectedGraphNode * tmp = Qu.front();\\n                 Qu.pop();\\n                 for(UndirectedGraphNode * neighbor : tmp->neighbors){\\n                     if(hash.find(neighbor) == hash.end()){\\n                         hash[neighbor] = new UndirectedGraphNode(neighbor->label);\\n                         Qu.push(neighbor);\\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 42431,
                "title": "python-iterative-bfs-dfs",
                "content": "Two scans, first round clone node, second round clone paths.\\n\\nThe BFS with for-loop instead of queue was from Stefan :P\\n\\n    def cloneGraph(self, node):\\n        ## BFS\\n        dic = {}\\n        stack = [node] if node else []\\n        for i in stack:\\n            if i not in dic:\\n                dic[i] = UndirectedGraphNode(i.label)\\n            stack.extend([j for j in i.neighbors if j not in dic])\\n        for i in dic:\\n            for j in i.neighbors:\\n                dic[i].neighbors.append(dic[j])\\n        return dic[node] if node else node\\n\\n        ## DFS\\n        dic = {}\\n        stack = [node] if node else []\\n        while stack:\\n            i = stack.pop()\\n            if i not in dic:\\n                dic[i] = UndirectedGraphNode(i.label)\\n            stack.extend([j for j in i.neighbors if j not in dic])\\n        for i in dic:\\n            for j in i.neighbors:\\n                dic[i].neighbors.append(dic[j])\\n        return dic[node] if node else node",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two scans, first round clone node, second round clone paths.\\n\\nThe BFS with for-loop instead of queue was from Stefan :P\\n\\n    def cloneGraph(self, node):\\n        ## BFS\\n        dic = {}\\n        stack = [node] if node else []\\n        for i in stack:\\n            if i not in dic:\\n                dic[i] = UndirectedGraphNode(i.label)\\n            stack.extend([j for j in i.neighbors if j not in dic])\\n        for i in dic:\\n            for j in i.neighbors:\\n                dic[i].neighbors.append(dic[j])\\n        return dic[node] if node else node\\n\\n        ## DFS\\n        dic = {}\\n        stack = [node] if node else []\\n        while stack:\\n            i = stack.pop()\\n            if i not in dic:\\n                dic[i] = UndirectedGraphNode(i.label)\\n            stack.extend([j for j in i.neighbors if j not in dic])\\n        for i in dic:\\n            for j in i.neighbors:\\n                dic[i].neighbors.append(dic[j])\\n        return dic[node] if node else node",
                "codeTag": "Python3"
            },
            {
                "id": 42365,
                "title": "javascript-solution",
                "content": "    function cloneGraph(graph) {\\n    \\n      if (!graph) return graph;\\n      var map = {};\\n      return traverse(graph);\\n    \\n      function traverse(node) {\\n        if (!map[node.label]) {\\n          var newNode = new UndirectedGraphNode(node.label);\\n          map[node.label] = newNode;\\n          newNode.neighbors = node.neighbors.map(traverse);\\n        }\\n        return map[node.label];\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function cloneGraph(graph) {\\n    \\n      if (!graph) return graph;\\n      var map = {};\\n      return traverse(graph);\\n    \\n      function traverse(node) {\\n        if (!map[node.label]) {\\n          var newNode = new UndirectedGraphNode(node.label);\\n          map[node.label] = newNode;\\n          newNode.neighbors = node.neighbors.map(traverse);\\n        }\\n        return map[node.label];\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42513,
                "title": "easy-recursive-solution-with-full-explanations-o-n-space-c-11",
                "content": "\\n\\n    class Solution {\\n    public:\\n        unordered_map<UndirectedGraphNode *,UndirectedGraphNode *> created;///although it takes O(n) space but it is the efficent way to search available in C++11...for C++4.8 use map...\\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n            if(!node)return node; //not required ..only to be in safe side\\n            if(created.find(node)!=created.end())return created[node]; ///if this node is already created then just return the reference of the new node created earlier\\n            UndirectedGraphNode * t=new UndirectedGraphNode(node->label);///otherwise create a new node and mark corresponding node in original graph created.\\n            created[node]=t;\\n            for(int i=0;i<node->neighbors.size();i++){\\n                t->neighbors.push_back(cloneGraph(node->neighbors[i]));//do recursively for all its neighbors...:)\\n            }\\n            return t;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        unordered_map<UndirectedGraphNode *,UndirectedGraphNode *> created;///although it takes O(n) space but it is the efficent way to search available in C++11...for C++4.8 use map...\\n        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\\n            if(!node)return node; //not required ..only to be in safe side\\n            if(created.find(node)!=created.end())return created[node]; ///if this node is already created then just return the reference of the new node created earlier\\n            UndirectedGraphNode * t=new UndirectedGraphNode(node->label);///otherwise create a new node and mark corresponding node in original graph created.\\n            created[node]=t;\\n            for(int i=0;i<node->neighbors.size();i++){\\n                t->neighbors.push_back(cloneGraph(node->neighbors[i]));//do recursively for all its neighbors...:)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3465412,
                "title": "using-dfs-with-hashmap",
                "content": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        dic={}\\n        def dfs(node):\\n            if node in dic:\\n                return dic[node]\\n            copy=Node(node.val)\\n            dic[node]=copy\\n            for nei in node.neighbors:\\n                copy.neighbors.append(dfs(nei))\\n            return copy\\n        return dfs(node)\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return node\\n        dic={}\\n        def dfs(node):\\n            if node in dic:\\n                return dic[node]\\n            copy=Node(node.val)\\n            dic[node]=copy\\n            for nei in node.neighbors:\\n                copy.neighbors.append(dfs(nei))\\n            return copy\\n        return dfs(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394372,
                "title": "optimal-solution-using-bfs-traversal",
                "content": "\\n\\n# Approach\\nThe basic idea is to do a BFS traversal of the graph and create clones of each node and its neighbors. We use an unordered map to keep track of which nodes have been cloned already, and a queue to process the nodes in the order they are visited.\\n\\nThe implementation assumes that the input node is not null, and that its value is 1. If the input node can be null or have a different value, you can add appropriate checks to handle those cases.\\n\\n# Complexity\\n- Time complexity:\\nO(V+E), where V is the number of vertices in the graph and E is the number of edges.\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return nullptr;\\n        \\n        // Maps original nodes to their clones\\n        unordered_map<Node*, Node*> clones;\\n        \\n        // Create clone of the starting node\\n        clones[node] = new Node(node->val);\\n        \\n        // Queue for BFS\\n        queue<Node*> q;\\n        q.push(node);\\n        \\n        while (!q.empty()) {\\n            Node* curr = q.front();\\n            q.pop();\\n            \\n            // Clone neighbors\\n            for (Node* neighbor : curr->neighbors) {\\n                if (!clones.count(neighbor)) {\\n                    clones[neighbor] = new Node(neighbor->val);\\n                    q.push(neighbor);\\n                }\\n                clones[curr]->neighbors.push_back(clones[neighbor]);\\n            }\\n        }\\n        \\n        return clones[node];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> neighbors;\\n    Node() {\\n        val = 0;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val) {\\n        val = _val;\\n        neighbors = vector<Node*>();\\n    }\\n    Node(int _val, vector<Node*> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if (!node) return nullptr;\\n        \\n        // Maps original nodes to their clones\\n        unordered_map<Node*, Node*> clones;\\n        \\n        // Create clone of the starting node\\n        clones[node] = new Node(node->val);\\n        \\n        // Queue for BFS\\n        queue<Node*> q;\\n        q.push(node);\\n        \\n        while (!q.empty()) {\\n            Node* curr = q.front();\\n            q.pop();\\n            \\n            // Clone neighbors\\n            for (Node* neighbor : curr->neighbors) {\\n                if (!clones.count(neighbor)) {\\n                    clones[neighbor] = new Node(neighbor->val);\\n                    q.push(neighbor);\\n                }\\n                clones[curr]->neighbors.push_back(clones[neighbor]);\\n            }\\n        }\\n        \\n        return clones[node];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393494,
                "title": "python-simple-and-clean-beats-94-55",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is about creating a deep copy of an undirected graph. To do that, we need to traverse the entire graph while maintaining a copy of each node and its neighbors. We can use the depth-first search (DFS) algorithm to traverse the graph and create the deep copy.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we check if the given node exists or not. If it doesn\\'t exist, we return `None`.\\n1. We create an empty dictionary called `mapping` to keep track of the nodes and their copies. We also create a stack and add the given node to it.\\n1. We start a loop and pop a node from the stack. If the node is not already in the `mapping` dictionary, we create a new node with the same value and add it to the `mapping` dictionary. Then, we check the neighbors of the current node. If a neighbor is not already in the `mapping` dictionary, we create a new node with the same value and add it to the `mapping` dictionary. We also add the new neighbor node to the stack to process it later.\\n\\n1. After processing all the neighbors of the current node, we add them to the neighbors list of the new node in the `mapping` dictionary.\\n1. We continue the loop until the stack is empty.\\n1. Finally, we return the node with the same value as the given node from the `mapping` dictionary.\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the total number of nodes in the graph. We visit each node once, and for each node, we check its neighbors and add them to the stack if they haven\\'t been processed yet.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the total number of nodes in the graph. We use the `mapping` dictionary to store the copies of the nodes, and the stack to traverse the graph. The space required for the `mapping` dictionary is proportional to the number of nodes in the graph.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        mapping = {}\\n        stack = [node]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.val not in mapping:\\n                mapping[curr.val] = Node(curr.val)\\n            if curr.neighbors != []:\\n                for neighbor in curr.neighbors:\\n                    if neighbor.val not in mapping:\\n                        mapping[neighbor.val] = Node(neighbor.val)\\n                        stack.append(neighbor)\\n                    mapping[curr.val].neighbors.append(mapping[neighbor.val])\\n        return mapping[node.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n        mapping = {}\\n        stack = [node]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.val not in mapping:\\n                mapping[curr.val] = Node(curr.val)\\n            if curr.neighbors != []:\\n                for neighbor in curr.neighbors:\\n                    if neighbor.val not in mapping:\\n                        mapping[neighbor.val] = Node(neighbor.val)\\n                        stack.append(neighbor)\\n                    mapping[curr.val].neighbors.append(mapping[neighbor.val])\\n        return mapping[node.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393229,
                "title": "python-elegant-short-dfs-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(V + E)$$\\n- Space complexity: $$O(V)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def cloneGraph(self, node: Node | None) -> Node | None:\\n        return self.dfs(node, {None: None})\\n\\n    def dfs(self, node: Node | None, graph: dict) -> Node | None:\\n        if node not in graph:\\n            graph[node] = Node(node.val)\\n            for ngh in node.neighbors:\\n                graph[node].neighbors.append(self.dfs(ngh, graph))\\n        return graph[node]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cloneGraph(self, node: Node | None) -> Node | None:\\n        return self.dfs(node, {None: None})\\n\\n    def dfs(self, node: Node | None, graph: dict) -> Node | None:\\n        if node not in graph:\\n            graph[node] = Node(node.val)\\n            for ngh in node.neighbors:\\n                graph[node].neighbors.append(self.dfs(ngh, graph))\\n        return graph[node]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393089,
                "title": "swift-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply create a copy of the node and call the function recursively. \\nThe only problem we could face is a loop and to solve it we create a dictionary to store cloned nodes to not copy it multiple times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the cloned node before calling the function recursively.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var neighbors: [Node?]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.neighbors = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    var cache: [Node: Node] = [:]\\n    func cloneGraph(_ node: Node?) -> Node? {\\n        guard let node = node else { return nil }\\n        guard cache[node] == nil else { return cache[node] }\\n        var cloned = Node(node.val)\\n        cache[node] = cloned\\n        cloned.neighbors = node.neighbors.map({ cloneGraph($0) })\\n        return cloned\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var neighbors: [Node?]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.neighbors = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    var cache: [Node: Node] = [:]\\n    func cloneGraph(_ node: Node?) -> Node? {\\n        guard let node = node else { return nil }\\n        guard cache[node] == nil else { return cache[node] }\\n        var cloned = Node(node.val)\\n        cache[node] = cloned\\n        cloned.neighbors = node.neighbors.map({ cloneGraph($0) })\\n        return cloned\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392355,
                "title": "python-short-and-clean-recursive-dfs",
                "content": "# Approach\\n1. Maintain a `Hashmap`, called `copies`, from `old node` to `new node`\\n\\n2. Given a `node`, make a copy of it\\'s data into a new node called `c_node`.\\n\\n3. Recursively call `deep_copy` on all neighbors of `node`.\\n\\n4. If `deep_copy` is called on a `node` which has a copy in `copies`, return the same as is.\\n\\n# Complexity\\n- Time complexity: $$O(e)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is number of nodes`,\\n`e is number of edges`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def cloneGraph(self, node_: \\'Node\\') -> \\'Node\\':\\n        copies = {None: None}\\n\\n        def deep_copy(node: \\'Node\\') -> \\'Node\\':\\n            if node in copies: return copies[node]\\n            copies[node] = c_node = Node(node.val)\\n            c_node.neighbors = list(map(deep_copy, node.neighbors))\\n            return c_node\\n        \\n        return deep_copy(node_)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def cloneGraph(self, node_: \\'Node\\') -> \\'Node\\':\\n        copies = {None: None}\\n\\n        def deep_copy(node: \\'Node\\') -> \\'Node\\':\\n            if node in copies: return copies[node]\\n            copies[node] = c_node = Node(node.val)\\n            c_node.neighbors = list(map(deep_copy, node.neighbors))\\n            return c_node\\n        \\n        return deep_copy(node_)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391973,
                "title": "java-dfs-beats-100-8-lines-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a map of nodes `Node[] nodes = new Node[101]` where `nodes[i]` will refer to the `ith` node. Use DFS to explore the original graph. As we encounter each node in the original graph, we need to check the `nodes` map first to see if an object has already been created for it. If not we should create it first and then continue exploring all other nodes using DFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  Node[] nodes = new Node[101];\\n\\n  public Node cloneGraph(Node node) {\\n    if (node == null) return null;\\n\\n    nodes[node.val] = new Node(node.val);\\n\\n    for (var neighbor : node.neighbors) {\\n      if (nodes[neighbor.val] == null)\\n        cloneGraph(neighbor);\\n\\n      nodes[node.val].neighbors.add(nodes[neighbor.val]);\\n    }\\n    return nodes[node.val];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  Node[] nodes = new Node[101];\\n\\n  public Node cloneGraph(Node node) {\\n    if (node == null) return null;\\n\\n    nodes[node.val] = new Node(node.val);\\n\\n    for (var neighbor : node.neighbors) {\\n      if (nodes[neighbor.val] == null)\\n        cloneGraph(neighbor);\\n\\n      nodes[node.val].neighbors.add(nodes[neighbor.val]);\\n    }\\n    return nodes[node.val];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391947,
                "title": "daily-leetcoding-challenge-april-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3240551,
                "title": "ultimate-graph-cloning-technique-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo clone the given graph, we can perform a depth-first search traversal and copy each node and its neighbors. For each node, we create a copy of it and add it to the visited dictionary. Then, we recursively clone all its neighbors and add them to the copy\\'s neighbor list. Finally, we return the copy of the starting node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We first check if the given node is None or not. If it\\'s None, we return None.\\n- We initialize an empty dictionary called visited to store the mapping between original nodes and their copies.\\n- We define a helper function dfs that takes an original node as input and returns its copy. If the original node has already been visited, we return its copy from the dictionary. Otherwise, we create a new copy of the node and add it to the dictionary. We then recursively clone all its neighbors and add them to the copy\\'s neighbors list. Finally, we return the copy.\\n- We call the dfs function with the given node and return its copy as the result.\\n# Complexity\\n- Time complexity: We visit each node in the graph exactly once. Hence the time complexity of our algorithm is O(N), where N is the number of nodes in the graph.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: We store the mapping between original nodes and their copies in the visited dictionary. The space complexity of our algorithm is O(N), where N is the number of nodes in the graph. In the worst-case scenario, when there is no overlap between the nodes of the original graph and their copies, the space complexity would be O(2N). But in practice, we expect this overlap to be significant, so the space complexity is just O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n    \\n        visited = {}\\n        def dfs(original):\\n            if original in visited:\\n                return visited[original]\\n            copy = Node(original.val)\\n            visited[original] = copy\\n            for neighbor in original.neighbors:\\n                copy.neighbors.append(dfs(neighbor))\\n            return copy\\n    \\n        return dfs(node)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node:\\n            return None\\n    \\n        visited = {}\\n        def dfs(original):\\n            if original in visited:\\n                return visited[original]\\n            copy = Node(original.val)\\n            visited[original] = copy\\n            for neighbor in original.neighbors:\\n                copy.neighbors.append(dfs(neighbor))\\n            return copy\\n    \\n        return dfs(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147970,
                "title": "typescript-solution-using-recursion-and-a-map-dfs",
                "content": "# Code\\n```\\nconst cloned = new Map<Node, Node>();\\n\\nfunction cloneGraph(node: Node | null): Node | null {\\n\\tif (!node) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tif (cloned.has(node)) {\\n\\t\\treturn cloned.get(node)!;\\n\\t}\\n\\n\\tconst newNode = new Node(node.val);\\n\\tcloned.set(node, newNode);\\n\\tnewNode.neighbors = node.neighbors.map((neighbor) => cloneGraph(neighbor)!);\\n                                           \\n\\treturn newNode;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst cloned = new Map<Node, Node>();\\n\\nfunction cloneGraph(node: Node | null): Node | null {\\n\\tif (!node) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tif (cloned.has(node)) {\\n\\t\\treturn cloned.get(node)!;\\n\\t}\\n\\n\\tconst newNode = new Node(node.val);\\n\\tcloned.set(node, newNode);\\n\\tnewNode.neighbors = node.neighbors.map((neighbor) => cloneGraph(neighbor)!);\\n                                           \\n\\treturn newNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661707,
                "title": "easy-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, we need to traverse whole grahp, clone node and its neighbors.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing DFS algorithm to traverse grahp to clone node and its neighbor\\nWe will have an array to keep visited node if the node\\'s neighbors are not visited yet then we will recursively visit it and clone it.\\nif the neighbors are already visited then we take visited node from visited array and put it into node\\'s neighbors array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n    if(node == null) return node;\\n    const visited = new Array();\\n    return cloneHelper(node,visited);\\n};\\n\\nvar cloneHelper = function(node,visited){\\n    const newNode =new Node(node.val);\\n    visited[node.val] = newNode;\\n    for(const neighbor of node.neighbors){\\n        if(!visited[neighbor.val]){\\n            const newNeighbor = cloneHelper(neighbor,visited);\\n            newNode.neighbors.push(newNeighbor);\\n        }\\n        else{\\n            const newNeighbor = visited[neighbor.val];\\n            newNode.neighbors.push(newNeighbor);\\n        }\\n    }\\n    return newNode;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val, neighbors) {\\n *    this.val = val === undefined ? 0 : val;\\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\\n * };\\n */\\n\\n/**\\n * @param {Node} node\\n * @return {Node}\\n */\\nvar cloneGraph = function(node) {\\n    if(node == null) return node;\\n    const visited = new Array();\\n    return cloneHelper(node,visited);\\n};\\n\\nvar cloneHelper = function(node,visited){\\n    const newNode =new Node(node.val);\\n    visited[node.val] = newNode;\\n    for(const neighbor of node.neighbors){\\n        if(!visited[neighbor.val]){\\n            const newNeighbor = cloneHelper(neighbor,visited);\\n            newNode.neighbors.push(newNeighbor);\\n        }\\n        else{\\n            const newNeighbor = visited[neighbor.val];\\n            newNode.neighbors.push(newNeighbor);\\n        }\\n    }\\n    return newNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647318,
                "title": "python-dfs-hashmaps-recursive-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - **n** here is `(e + v)`, edges + vertices.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        cloneMap = {}\\n\\n        def clone(node: \\'Node\\'): \\n            if node in cloneMap:\\n                return cloneMap[node]\\n            \\n            node_clone = Node(node.val)\\n            cloneMap[node] = node_clone\\n\\n            for neighbor in node.neighbors:\\n                node_clone.neighbors.append(clone(neighbor))\\n\\n            return node_clone\\n        \\n        return clone(node) if node else None\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\"\"\"\\n\\nclass Solution:\\n    def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        cloneMap = {}\\n\\n        def clone(node: \\'Node\\'): \\n            if node in cloneMap:\\n                return cloneMap[node]\\n            \\n            node_clone = Node(node.val)\\n            cloneMap[node] = node_clone\\n\\n            for neighbor in node.neighbors:\\n                node_clone.neighbors.append(clone(neighbor))\\n\\n            return node_clone\\n        \\n        return clone(node) if node else None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626539,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node==nullptr) return node;\\n        unordered_map<Node*, Node*> ma;\\n        queue<Node*> q;\\n        Node *t = new Node(node->val);\\n        Node *head = t;\\n        q.push(node);\\n        ma[node] = t;\\n        \\n        while(q.size()){\\n            for(auto a: q.front()->neighbors)\\n                if(ma.count(a)==0){\\n                    t = new Node(a->val);\\n                    ma[a] = t;\\n                    q.push(a);\\n                }\\n            q.pop();\\n        }\\n        \\n        for(auto a: ma){\\n            t = a.second;\\n            for(auto b:a.first->neighbors)\\n                a.second->neighbors.push_back(ma[b]);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* cloneGraph(Node* node) {\\n        if(node==nullptr) return node;\\n        unordered_map<Node*, Node*> ma;\\n        queue<Node*> q;\\n        Node *t = new Node(node->val);\\n        Node *head = t;\\n        q.push(node);\\n        ma[node] = t;\\n        \\n        while(q.size()){\\n            for(auto a: q.front()->neighbors)\\n                if(ma.count(a)==0){\\n                    t = new Node(a->val);\\n                    ma[a] = t;\\n                    q.push(a);\\n                }\\n            q.pop();\\n        }\\n        \\n        for(auto a: ma){\\n            t = a.second;\\n            for(auto b:a.first->neighbors)\\n                a.second->neighbors.push_back(ma[b]);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484242,
                "title": "java-solution-99-faster",
                "content": "```\\npublic Node cloneGraph(Node node) {\\n        if (node == null)\\n            return null;\\n        // map Node.val to clone Node\\n        HashMap<Integer, Node> map = new HashMap<>();\\n        \\n        return cloneGraph(map, node);\\n    }\\n    \\n// Overloaded function, recursive\\nprivate Node cloneGraph(HashMap<Integer, Node> map, Node node) {\\n\\t\\t// if the node is already visited, return the reference of the cloned node\\n        if (map.containsKey(node.val))\\n            return map.get(node.val);\\n        \\n        Node clone = new Node(node.val);\\n\\t\\t// put the clone Node in the map before making any recursive calls\\n        map.put(node.val, clone);\\n        \\n        ArrayList<Node> neighbors = new ArrayList<>();\\n        \\n\\t\\t// traverse through the neighbors of original Node and call cloneGraph(HashMap, Node) method for every neighbor\\n        for (Node neighbor: node.neighbors) {\\n            neighbors.add(cloneGraph(map, neighbor));\\n        }\\n        \\n        clone.neighbors = neighbors;\\n        return clone;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic Node cloneGraph(Node node) {\\n        if (node == null)\\n            return null;\\n        // map Node.val to clone Node\\n        HashMap<Integer, Node> map = new HashMap<>();\\n        \\n        return cloneGraph(map, node);\\n    }\\n    \\n// Overloaded function, recursive\\nprivate Node cloneGraph(HashMap<Integer, Node> map, Node node) {\\n\\t\\t// if the node is already visited, return the reference of the cloned node\\n        if (map.containsKey(node.val))\\n            return map.get(node.val);\\n        \\n        Node clone = new Node(node.val);\\n\\t\\t// put the clone Node in the map before making any recursive calls\\n        map.put(node.val, clone);\\n        \\n        ArrayList<Node> neighbors = new ArrayList<>();\\n        \\n\\t\\t// traverse through the neighbors of original Node and call cloneGraph(HashMap, Node) method for every neighbor\\n        for (Node neighbor: node.neighbors) {\\n            neighbors.add(cloneGraph(map, neighbor));\\n        }\\n        \\n        clone.neighbors = neighbors;\\n        return clone;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567510,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566277,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1856939,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1564721,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1571958,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1565661,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1856926,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566642,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566310,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566565,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1567510,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566277,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1856939,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1564721,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1571958,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1565661,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1856926,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566642,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566310,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566565,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing"
                    },
                    {
                        "username": "maverick4242",
                        "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  "
                    },
                    {
                        "username": "lightflash",
                        "content": "[@vibhumishra808](/vibhumishra808) Online Judge"
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "what is OJ ?"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When people will stop posting solutions here? "
                    },
                    {
                        "username": "qddpx",
                        "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?"
                    },
                    {
                        "username": "phanvinhkhang910",
                        "content": "it\\'s undirected"
                    },
                    {
                        "username": "Zhu_xy",
                        "content": "??????????????\\nWhat does this question mean???"
                    },
                    {
                        "username": "CHazyhabiT",
                        "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It\\'s been 9 years and no one has answered it yet lol"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Am I the only one who can\\'t understand the question even after going through it several times??"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@matthewwdaly](/matthewwdaly) Try to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\nthen just replace the display with a clone function that copies their property instead of displaying them.\ncheck this> https://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "The most complicated part about the problem is that the input and output in the examples and testcases are not the input and output of the function you are writing.  You are given a single node in a connected graph, and your task is to traverse that graph, make a completely new copy of it, and return the clone of the original vertex."
                    },
                    {
                        "username": "accidentalmaster",
                        "content": "Native JS Objects `{}`  don\\'t let you use other `Object`s as keys - they are converted to the string `object Object` and then used as the key, which can be confusing as no error is thrown. \\n\\nYou can use a `WeakMap` or `Map` if you want to have a map based on objects, or you can use an identifier (e.g `node.val`) as the key of mapping using `Object`s."
                    },
                    {
                        "username": "SuccessInVain",
                        "content": "The OJ is checking for order of refs also for e.g. ref1, ref3 vs ref3, ref1 , why does it matter?"
                    },
                    {
                        "username": "ruhelaanurag",
                        "content": "[@SeineAle](/SeineAle)  Online Judge I guess."
                    },
                    {
                        "username": "SeineAle",
                        "content": "what is OJ ??\\n"
                    },
                    {
                        "username": "KoStard",
                        "content": "My code has 29 lines....\\nCan\\'t submit my solution - tried same solution in python2 and didn\\'t get any errors, so maybe there are some internal problems in the checker."
                    }
                ]
            },
            {
                "id": 1566424,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1566330,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1567208,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1568207,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1572359,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1570931,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1857237,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1855598,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1636908,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1568150,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/clone-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ZeratuuLL",
                        "content": "So I don\\'t know how they compare the output with the standard answer. But I met this:\\n\\nMine : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected : {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nand my output is wrong. Cool. Guess the order of neighbors matters."
                    },
                    {
                        "username": "huashiyiqike3",
                        "content": "This problem just assume that the graph is connected so that given a node we can traverse the entire graph, but this is said clearly in the description. It is confusing."
                    },
                    {
                        "username": "zhusiwei93",
                        "content": "I didn\\' see in the description that node is hashable. if it\\'s not then we can\\'t use node as key, but seems like when I do hash(node) it does gave me the unique value, which means equals and hash are already overwritten, we should definitely mention in the question, and for those who use label(val) as key, it\\'s 100% wrong since no one mentioned there won\\'t be two nodes with same value in the graph, in a word it\\'s a bad question tbh."
                    },
                    {
                        "username": "Shrey12",
                        "content": "it is given that nodes will have same value as index, and as index cant repeat hence nodes are hashable"
                    },
                    {
                        "username": "ankitAPM",
                        "content": "Exactly what we have to do or in other words what is required???\\n"
                    },
                    {
                        "username": "greedyartist71",
                        "content": "#### Upvote if this helps.\\n##### **Intuition:**\\n* Maintaining hashMap / dictionary  with old & new reference.\\n* Check if current node reference is present in dictionary or not.\\n\\t* Fetch the reference of its clone node reference is node is present in dictionary. \\n\\t* Else, create a clone of node with current node val & push it to dictionary.\\n* Repeat above steps until all neighbors gets traversed\\n* ***TC: O(E+V) ~ O(N)  and SC : O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/69928794-68c9-46fb-9762-95902603643d_1656280079.982082.png)\\n"
                    },
                    {
                        "username": "Rapethor",
                        "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Stupid Question. "
                    },
                    {
                        "username": "jasonyandell",
                        "content": "There\\'s a name conflict in Typescript.  `Node` is declared in `lib.dom.d.ts` representing a DOM Node.  "
                    },
                    {
                        "username": "snoopy0123",
                        "content": "so annoying."
                    },
                    {
                        "username": "helloShen",
                        "content": "Otherwise we can\\'t use `Node.val` to check if that node is already created."
                    }
                ]
            },
            {
                "id": 1569426,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1567880,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1856959,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1761562,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1575087,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1573912,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1568950,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1574396,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1856984,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1856915,
                "content": [
                    {
                        "username": "manoj37",
                        "content": "When I try to access the attribute label of UndirectedGraphNode `UndirectedGraphNode(node.label)`I keep on getting an error that says \\'Node\\' object has no attribute called \\'label\\'. When I try to acess the \\'val\\' attribute of UndirectedGraphNode `UndirectedGraphNode(node.val)` I keep on getting an error that says \"UndirectedGraphNode has no attribute \\'val\\'. Has anyone come accross similar situation. If so how did you fix it?"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe example graph is:\\n{0,1,2#1,2#2,2}\\n\\nwhere 0 has neighbors 1 and 2, but 1 only has 2 as the its neighbor (here 0 is not listed as its neighbor!) --- this is actually a *directed* graph. In other words, the undirected graph in this case should be: \\n{0,1,2#1,2,0#2,0,1,2}\\n\\nAny comments?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@LeetCode](/LeetCode) why are so many highly upvoted answers even pinned in HOT, if someone wants to write a new answer how will it trend."
                    },
                    {
                        "username": "apurvrajput20",
                        "content": "What\\'s OJ? In this thread many people keep commenting that"
                    },
                    {
                        "username": "pramod74",
                        "content": "Online Judge?"
                    },
                    {
                        "username": "neilteng",
                        "content": "No where in the question mentions that the Node  class is hashable.. How can we just hash it???"
                    },
                    {
                        "username": "mge_learn",
                        "content": "Wrong Answer\\nDetails \\nInput [[2],[1]]\\nOutput Node with value 4 doesn\\'t exist in the original graph.\\nExpected [[2],[1]]\\n\\nwhen I run the same input from console output is correct and accepted."
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "I have the same error for data [[]] and output \"Node with value 2 doesn\\'t exist in the original graph.\" \\nWhen I run my code on my Mac all ok - and node with value 2 not exist\\nI think algorithm testing is not correct  "
                    },
                    {
                        "username": "paullo",
                        "content": "My code failed at test case:  {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nIf I understand correctly:\\n\\n 1. node 0 has 1 and 5 as its neighbors\\n 2. node 1 has 2 and 5 as its neighbors\\n 3. node 2 has 3 as its neighbors\\n 4. **node 3 has 4 as its neighbors**\\n 5. **node 4 has 5 as its neighbors**\\n\\nI don't understand #4 and #5,  why is it described as *3,4,4* and *4,5,5* rather than *3,4* and *4,5* ?"
                    },
                    {
                        "username": "tiancaihb",
                        "content": "> You must return the copy of the given node ...\\n\\nCopy of \"null\" node is \"null\"? \"null\" is even a node?... The definition does not extend natually to empty graph.\\nEdge case for the sake of edge case is meaningless."
                    },
                    {
                        "username": "ArunSiva",
                        "content": "It would be helpful if the output provided more specific information about the missing nodes in the cloned graph, rather than just a general statement that all nodes must be included. This would save time and effort by avoiding the need to copy the problem to an IDE to identify the specific missing nodes."
                    },
                    {
                        "username": "Msey",
                        "content": "entertaining graph week again?"
                    }
                ]
            },
            {
                "id": 1733812,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1733656,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1727969,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1573149,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1573032,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1573018,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1572753,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1572456,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1571283,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1576260,
                "content": [
                    {
                        "username": "aravindmurugan96",
                        "content": "can someone please help on how the input : node looks like for this \\n[[2,4],[1,3],[2,4],[1,3]] ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "those are the neighbors for each node, where the index is node.val. So node 1: node.val = 1 and neighbours are nodes 2 and 4"
                    },
                    {
                        "username": "oyangyang",
                        "content": "Help please I am not sure why I gets java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null at  `map.put(node, new Node( node.val, new ArrayList<Node>()));`. \n \n` class Solution {\n    public Node cloneGraph(Node node) {\n        Map<Node, Node> map = new HashMap();\n        LinkedList<Node> queue = new LinkedList<Node>();\n        queue.add(node);\n        map.put(node, new Node( node.val, new ArrayList<Node>()));\n\n        while(!queue.isEmpty()){\n            Node n = queue.poll();\n            if(!map.containsKey(n)){\n                map.put(n, new Node(n.val, new ArrayList<Node>()));\n            }\n\n            for(Node nn : n.neighbors){\n                if(!map.containsKey(nn)){\n                    map.put(nn, new Node(nn.val, new ArrayList<Node>()));\n                    queue.offer(nn);\n                }\n                map.get(n).neighbors.add(map.get(nn));\n            }\n        }\n\n        return map.get(node);\n    }\n} `\n\n\n"
                    },
                    {
                        "username": "Pietscham",
                        "content": "You never check if the initial node passed in is null."
                    },
                    {
                        "username": "deathzkrieg",
                        "content": "bad question. a different order of neighbors can get you a WA"
                    },
                    {
                        "username": "william_t",
                        "content": "Output: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nExpected: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}\\n\\nThe only difference between the output and the expected is the order of neighbors for node 4.\\n\\nNothing big, just annoying."
                    },
                    {
                        "username": "whglamrock",
                        "content": "Consider test case:\\n`\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nsomehow the expected is:\\n`{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}`\\n\\nMy answer should be correct because it only swaps the order of 4\\'s neighbors: expected is [3, 1] as opposed to in my answer: [1, 3]\\n\\n@admin"
                    },
                    {
                        "username": "chewsday22",
                        "content": "Heres my output vs the accepted output\\n\\nmine\\n{\"val\":1,\"neighbors\":[{\"val\":2,\"neighbors\":[{\"$ref\":\"1\"},{\"val\":3,\"neighbors\":[{\"$ref\":\"2\"},{\"val\":4,\"neighbors\":[{\"$ref\":\"1\"},{\"$ref\":\"3\"}],\"$id\":\"4\"}],\"$id\":\"3\"}],\"$id\":\"2\"},{\"$ref\":\"4\"}],\"$id\":\"1\"}\\n\\naccepted\\n{\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1}"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Is there anywhere a code to parse the input and build graph?\\nThanks"
                    },
                    {
                        "username": "user5400vw",
                        "content": "that\\'s a mini-problem in itself.\\n\\nmaintain a map of nodes, nodesMap\\nfor each pair of ints, a and b {\\n  create node if a/b doesn\\'t exist and add to map\\n  add nodesMap[b] as neighbor of nodesMap[a]\\n}\\nreturn nodesMap[1]\\n  "
                    },
                    {
                        "username": "chengxis",
                        "content": "It is not clear whether the neighboring relationship is mutual in both nodes\\' neighbor list.\\n\\nA - B: does it mean that in both A and B\\'s neighbor list, B and A will show up?"
                    },
                    {
                        "username": "salience",
                        "content": "I got an error for double linking -1 to 1...\\n\\nIt said it was only expecting a -1 -> 1 but not a 1 -> -1... Hence the problem text is wrong."
                    },
                    {
                        "username": "taller238",
                        "content": "\\nSubmission Result: Wrong Answer\\nInput: \\t{0,0,0}\\nOutput: \\t{0}\\nExpected: \\t{0,0,0}"
                    }
                ]
            },
            {
                "id": 1569213,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 1569192,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 1571284,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2075946,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2072307,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2060920,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2046950,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2018702,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2018558,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 2013344,
                "content": [
                    {
                        "username": "sills",
                        "content": "I figured this out, but...\\n\\n1) Why the text about graph serialization when it turns out we are not expected to deserialize any string into a graph? \\n2) Also, I wondered how nodes were compared in this scheme. For example, if a cycle exists, should the child of a node contain a reference to the cyclic node (eg, a reference to itself for a self-cycle)? Or does it suffice to just have a new node (ie, NOT a reference) with the same label? I used a reference bc it was easiest since I had the reference handy in my \"visited\" hash lookup.\\n3) FYI including the class definition for UndirectedGraphNode causes a failure. We need the class to test so why not accept it in the solution? Supposedly bc the actual UndirectedGraphNode used when running the solution has additional methods (probably that serialization they talked about).\\n4) Most importantly, where is the ability to run this code without actually submitting it, so we can compare against a simple supplied test or a test of our own making? The author spends a lot of text talking about serialization and drawing a graph, but really the most descriptive thing an author can do is supply clear input/output test cases. At the very least, provide a simple one so folks can test that they have the right method signatures / implemented an interface compatible with the question, and can confirm some test case they think up is computing correctly."
                    },
                    {
                        "username": "bwv988",
                        "content": "Seems there is no need to this serialization algorithm in this problem, why put it there?"
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "My solution failed on this input:\\n\\n    {0,1,5#1,2,5#2,3#3,4,4#4,5,5#5}\\n\\nHowever, I think there may be errors in this test case, since node 0 points to node 1, node 5 but node 1 does not point back to node 0 (node 1 just points to node 2 and 5).\\nSo, I think it violated the assumption that the cloned graph is undirected graph.\\n\\nCan someone help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "lol, return copy.deepcopy(node), done. "
                    },
                    {
                        "username": "marcelobbff",
                        "content": "is it just me? the error \"AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\" keeps showing up but the code seems fine"
                    },
                    {
                        "username": "Artificial_Life",
                        "content": "They need to be clear that both the input type and the output type is of node. The output type is NOT adjList"
                    },
                    {
                        "username": "vivek328",
                        "content": "Can someone explain me adjList = [[2,4],[1,3],[2,4],[1,3]] what it represnt and why there is repetation. Also does it represent the same as figure given? "
                    },
                    {
                        "username": "cyjackx",
                        "content": "I tried to do it in O(1) memory but gave up and just went with some easier data structures!"
                    },
                    {
                        "username": "nytyme",
                        "content": "This question is flawed as it is accepting numerous wrong answers. Unless you put your hashmap outside the cloneGraph function, you are not performing a deep copy, you\\'re just creating new instances of everything, as cloneGraph is called for each member of the array.\\n\\n// do your initializing above here\\n    const clones : Node[] = [];\\n    for( let o of nodes.values() ){\\n        clones.push(cloneGraph(o));\\n    }\\n    \\n    if( clones.length > 1) {\\n        console.log(\"----------------------------------\");\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 2\\n        console.log( \"--\" , clones[1]) //  says 2\\n        clones[0].neighbors[0].val = 22;\\n        console.log( \"--\" , clones[0].neighbors[0]) // says 22\\n        console.log( \"--\" , clones[1]) // still says 2\\n    }\\n"
                    },
                    {
                        "username": "codeleetpriya",
                        "content": "Why am I getting java.lang.NullPointerException: Cannot read field \"val\" because \"<parameter1>\" is null ? \n\n`/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        Node refNode = new Node();\n        Map<Node,Node> visited = new HashMap<Node,Node>();\n        cloneHelper(refNode,node,visited);\n        return refNode;\n    }\n    public void cloneHelper(Node refNode, Node node,Map<Node,Node> visited){\n        if(node ==null)\n            return; \n        if(visited.containsKey(node)){\n            refNode=visited.get(node);\n            return;\n        }\n        refNode.val=node.val; \n        visited.put(node,refNode);\n        for(Node child : node.neighbors){\n            Node childRef = new Node(child.val);\n            System.out.println(child.val);\n            cloneHelper(childRef,child,visited);\n            refNode.neighbors.add(childRef);  \n        }\n        return;\n    }\n} `"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Check your input validation for the empty list cases?"
                    }
                ]
            },
            {
                "id": 1996716,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1979120,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1954004,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1947675,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1940043,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1903381,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1903126,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1900394,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1886510,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1866909,
                "content": [
                    {
                        "username": "Sanjay00",
                        "content": "How to access the whole graph. I want to print the whole graph in c++. Can anyone help me with this?"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "you can see my discussion post and copy the logic for c++. Sort by newest posts and it should be close to the top!"
                    },
                    {
                        "username": "sungwonchung",
                        "content": "FOR JAVA USERS WHO WANT TO SEE THEIR GRAPH\n\nadd this at the end of your code\n\n \n        HashSet<Node> visited = new HashSet<>();\n        Stack<Node> stack = new Stack<>();\n        visited.add(newNode);\n        stack.push(newNode);\n        while (!stack.isEmpty()) {\n            Node cur = stack.pop();\n            System.out.print(cur.val + \" | \");\n            for (Node neigh : cur.neighbors) {\n                System.out.print(neigh.val + \" \");\n                if (!visited.contains(neigh)) {\n                    visited.add(neigh);\n                    stack.push(neigh);\n                }\n            }\n            System.out.println();\n        }\n"
                    },
                    {
                        "username": "ccc000",
                        "content": "keep getting \\nNode with value 1 was not copied but a reference to the original one.\\nfor the input of\\n[[2,4],[1,3],[2,4],[1,3]]\\nbut from what I see according to the print out of all the objects, there is no way this is true.\\nhas anyone seen this problem?"
                    },
                    {
                        "username": "amaninatub",
                        "content": "Same issue. Any tips?"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "The question is unclear, even that, the output is just an idiot statement instead of the ouput of the code. Why you have to make things become complicated while it not should be? "
                    },
                    {
                        "username": "algoacer",
                        "content": "I am trying to make a function returning Node* to cloned root. It will have Node* node and visited map as parameter. Doing DFS traversal is showing stackoverflow error, can anyone help\\nNode* buildGraph(Node* node, unordered_map<int, bool> & visited){\\n        if(node==nullptr)\\n            return nullptr;\\n\\n        int x=node->val;\\n        visited[x]=true;\\n\\n        vector<Node*> children;\\n        \\n        for(auto child: node->neighbors){\\n            int childval=child->val;\\n            if(visited[childval])\\n            children.push_back(child);\\n            if(!visited[childval]){\\n                Node* c=cloneGraph(child);\\n                children.push_back(c);\\n            }            \\n        }\\n\\n        Node* root= new Node(x, children);\\n        return root;\\n    }"
                    },
                    {
                        "username": "charles_bedard",
                        "content": "The types are completely broken for this question in Typescript."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "This question is not at all clear. It falls in the stupid category. I mean what is it accomplishing?\\n\\nif anyone can make me understand , please do."
                    },
                    {
                        "username": "raewin",
                        "content": "Correct code but failed test case for weird reasons.\\n\\n```python\\n\\nclass Solution:\\n     def cloneGraph(self, node: \\'Node\\') -> \\'Node\\':\\n        if not node: return None\\n        visited = set()\\n        sentinel = Node(0)\\n        def r(prev, root):\\n            tmp = Node(root.val)\\n            prev.neighbors.append(tmp)\\n            if root in visited: return\\n            visited.add(root)\\n            for n in root.neighbors:\\n                r(tmp, n)\\n        r(sentinel, node)\\n        curr = sentinel.neighbors[0]\\n        return curr\\n\\t\\n```\\nAny idea why I keep getting the error in output\\n`You must return a copy of all the nodes in the original graph`\\n\\nI believe my code is correct?\\nI would like your comments, thank you."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "What a terrible description. If a company asked that question really I would never apply I would never proceed with the interview.\\n\\n`Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\\nOutput: [[2,4],[1,3],[2,4],[1,3]]\\nExplanation: There are 4 nodes in the graph.\\n1st node (val = 1)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n2nd node (val = 2)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\\n3rd node (val = 3)\\'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\\n4th node (val = 4)\\'s neighbors are 1st node (val = 1) and 3rd node (val = 3).`\\n\\nhow does that description even make sense for god sake?????"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you\\'re having problems accessing val, label, neighbors etc add null check at top of problem.\\n\\nIt throws error bc the console.log and error.log are not synced for example test case three will throw error but your console.log(node.val) for the first test that did not error will not show."
                    }
                ]
            },
            {
                "id": 1859812,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1859107,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1858655,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857719,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857503,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857497,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857381,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857361,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857351,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857322,
                "content": [
                    {
                        "username": "vishakharsharma",
                        "content": "I am still stuck on this question and not able to figure out the method to solve this question!!! Can anyone please help me with it?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm usually not one to complain about a problem description, but making your problem statement dependent on external links is a bad idea because:\n*external webpages go down\n*not every country in the world has an unrestricted internet access that allow them to browse wikipedia (let's play a game of \"guess where I'm staying based on the violations of my basic freedoms\"? :D)\n\nMy solution got accepted, but I'm still not certain whether I did exactly what was asked, cause I'm not certain what exactly was asked\n\nI also completely disregarded the explanation of the test case format cause this looked terribly confusing, and unnecessary to solve it since you're manipulating the deserialized object directly anyway (at least in python)"
                    },
                    {
                        "username": "itsjayant",
                        "content": "while doing dfs traversal solution why I have to pass map by address(&)  not by value..\\nI am not not able to understand?????????"
                    },
                    {
                        "username": "FlowNoFriction",
                        "content": "Original graph:\n\n 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 4 <__main__.Node object at 0x7f1a1044e9e0>\n     -- 1 <__main__.Node object at 0x7f1a1044d540>\n     -- 3 <__main__.Node object at 0x7f1a1044e980>\n 3 <__main__.Node object at 0x7f1a1044e980>\n     -- 2 <__main__.Node object at 0x7f1a1044da20>\n     -- 4 <__main__.Node object at 0x7f1a1044e9e0>\n\n\nCloned graph:\n\n 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 4 <__main__.Node object at 0x7f1a1044ec80>\n     -- 1 <__main__.Node object at 0x7f1a1044e050>\n     -- 3 <__main__.Node object at 0x7f1a1044ece0>\n 3 <__main__.Node object at 0x7f1a1044ece0>\n     -- 2 <__main__.Node object at 0x7f1a1044ec20>\n     -- 4 <__main__.Node object at 0x7f1a1044ec80>\n\nError output: \"Node with value 1 was not copied but a reference to the original one.\"\n\nVerdict: LC needs to stop allowing incompetent people to implement solution-checking."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "why even this question has been selected for daily challenge? "
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "The implementation of the cloneGraph function is a BFS traversal with a slight modification to handle the creation of the new graph. It's not as challenging as it may seem at first glance. I would recommend to use a HashMap (or dictionary in Python) to store the mapping between the original nodes and their corresponding clones. This will help you avoid creating duplicate nodes. "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "\"You must return a copy of all the nodes in the original graph\"\\nwhat\\'s going on"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@hoangnn451](/hoangnn451) yes that would also cause the problem as then there would be more number of node instances than number of nodes in the graph.:)"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) thank u, I got it, I have node that same value but different intansce"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "you are returning partial solution.\ni.e if it expects [[2,4],[1,3],[2,4],[1,3]] if you miss any one or more of these values.. you will get that"
                    },
                    {
                        "username": "imkorotkiy",
                        "content": "For people who using global value. You need initialise it\\'s before using recursive call else you get error type \\n\"Node with value N doesn\\'t exist in the original graph.\" \\nTesting system download and initialise it\\'s ones and NOT DELETE it\\'s value before test case "
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "Well on a good side This clearly shows  graph questions are tough without adjacency list  so gonna practice more on that"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "oh no ! not another graph question  T_T\\nis it just me or the description of the problem seems a bit less explanatory"
                    }
                ]
            },
            {
                "id": 1857300,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857266,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857242,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857240,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857230,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857210,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857192,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857173,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857151,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857150,
                "content": [
                    {
                        "username": "shivy_26",
                        "content": "good god i already don\\'t understand graph \\uD83D\\uDE2D"
                    },
                    {
                        "username": "sampreeth18",
                        "content": "iam getting output as \"Node with value 4 was not copied but a reference to the original one.\" which means? i could not understand"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "[@kandiana](/kandiana) you are not making a new node with that value and its neighbors..instead you are trying to use the node of original question as a part of your solution.\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "It means that in your result somewhere you used initial node 4 instead of its copy\\n\\nOne of the ways to get this error is to return input node (which you are not supposed to do here)"
                    },
                    {
                        "username": "namanchandak",
                        "content": " `class Solution {\npublic:\nset<int>st;\n\nvoid dfs(Node* node,Node* temp)\n{\n    int data=node->val;\n    if(temp )\n    {\n        temp->val=node->val;\n        st.insert(node->val);\n    }\n    // mp2[data]=temp;\n    vector<Node*> v;\n    for(auto it:node->neighbors)\n    {\n        Node* add=new Node(it->val);\n        if(st.find(it->val)==st.end())\n        dfs(it,add);\n        v.push_back(add);\n    }\n    // mp[data]=v;\n    temp->neighbors=v;\n    cout<<temp->val<<endl;\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i]->val<<\"\\t\";\n    }\n    cout<<endl;\n    if(temp==node)\n    cout<<\"fault\";\n}\n\n    Node* cloneGraph(Node* node) {\n        if(node==NULL)\n        return NULL;\n        Node* head=new Node();\n        dfs(node,head);\n\n        return head;\n    }\n};\n`\n\n\n\nwhat is the error in this code\nfailed test case - [[2,4],[1,3],[2,4],[1,3]]"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "First of ALL\\nTry to write a function that displays the whole graph the same way as the expected output taking only the starting node as argument. that will give you an idea of how the graph is created and connected.\\nthen just replace the display with a clone function that copies their property instead of displaying them.\\nFor reference check this.\\nhttps://leetcode.com/problems/clone-graph/submissions/930003779/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Don't modify the original graph. Just make a separate visited[] array/set/map if you need it.\n\nIf you want to print out your output just like the test cases, try this code:\n// Replace \"node name\" on the 2nd line with the name of the node you want to print out. e.g. q.push(node); or q.push(copy);\n\n`\nqueue<Node*> q;\n        q.push(node name);\n        map<int, Node*> vis; //visited\n        Node* current;\n\n        while (!q.empty()) {\n            current = q.front();\n            q.pop();\n\n            int v = current->val;\n            if (vis[v] != nullptr) continue;\n            else vis[v] = current;\n\n            for (Node*& n : current->neighbors)\n                q.push(n);\n        }\n        cout << '[';\n        for (auto iterator = vis.begin(); iterator != vis.end(); ++iterator) {\n            cout << '[';\n            current = iterator->second;\n            for (int j = 0; j < current->neighbors.size(); ++j) {\n                cout << current->neighbors[j]->val;\n                if (j < current->neighbors.size() - 1) cout << ',';\n            }\n            cout << ']';\n            if (iterator->first != vis.rbegin()->first) cout << ',';\n        } cout << ']';\n`"
                    },
                    {
                        "username": "codemax36",
                        "content": " I check my solution with this output but the validation says me that a node object was not copied just referenced to, why?\\n\\n `System.out.println(\"! node(\" + node.val + \")=\" + node + \" and clone(\" + clone.val + \")=\" + clone + \" are the same = \\'\" + (node == clone) +\"\\'\");`\\n\\nSTDOUT:\\n\\'! node(1)=Node@433c675d and clone(1)=Node@5ce65a89 are the same = \\'false\\'\\'\\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "another graph week?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Create a new node to be returned as the copy of the input node. Assign its value to be the value of the input node.\\n2. Create an array of visited nodes to keep track of the nodes we have already visited. Initialize the array to null.\\n3. Add the input node to the visited array with its corresponding copied node.\\n4. Create a queue and add the input node to the queue.\\n5. While the queue is not empty, dequeue a node from the front of the queue and iterate through its neighbors.\\n6. For each neighbor of the dequeued node, check if it has been visited before by checking if its corresponding copied node exists in the visited array. If not, create a new node and add it to the visited array with its corresponding copied node. Enqueue the neighbor to the queue.\\n7. Add the copied neighbor node to the copied dequeued node\\'s neighbors list.\\n8. Repeat steps 5-7 until the queue is empty.\\n9. Return the copied node."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Look at the constraints. You only need to keep track of 100 nodes at most."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Questions that sound hard but aren\\'t really."
                    }
                ]
            },
            {
                "id": 1857102,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1857080,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1857038,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1857023,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1856953,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1856951,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1856925,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1856923,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1856916,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            },
            {
                "id": 1853523,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Stop it with the graphs!!! Its a nightmare for me"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i feel the same"
                    },
                    {
                        "username": "pavpen",
                        "content": "Why is there no Rust language option for this question?\\n\\nI think this type of problem favors languages like C++ where you can get an explicit reference to an object, and use it like a unique ID."
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m Done with the graphs.......\\uD83D\\uDE2A"
                    },
                    {
                        "username": "infinityCorporation",
                        "content": "As someone who is somewhat new to leetcode, this question is quite confusing. I may be missing out on some of the terminology, which is probably contributing to my confusion. That being said, the output list simply looks like a copy of the original list. \\n\\nWhat is the difference that is supposed to be created other than the fact that you can\\'t simple return the exact same variable?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In dfs traversal function, a hashset is used to mark the node has been visited. At the end of dfs, do not use visited.erase(node) so as to avoid TLE."
                    },
                    {
                        "username": "axiemajj",
                        "content": "Really easy question. Typical BFS will work."
                    },
                    {
                        "username": "MohamedEmara",
                        "content": "Great problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a graph traversal problem. Using DFS or BFs. That\\'s it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS solution! https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3/"
                    },
                    {
                        "username": "imperviousboss",
                        "content": "first to finish the daily? :\")\\nlike the question"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "somehow the Map() in JS doesn\\'t work with object ref I can\\'t figure out why. However it worked for me when I mapped map[node.val] instead of map[node]. Can someone help me figure out?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Digit One",
        "question_content": "<p>Given an integer <code>n</code>, count <em>the total number of digit </em><code>1</code><em> appearing in all non-negative integers less than or equal to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 64381,
                "title": "4-lines-o-log-n-c-java-python",
                "content": "Go through the digit positions one at a time, find out how often a \"1\" appears at each position, and sum those up.\\n\\n**C++ solution**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1);\\n        return ones;\\n    }\\n\\n**Explanation**\\n\\nLet me use variables `a` and `b` to make the explanation a bit nicer.\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10) {\\n            int a = n/m, b = n%m;\\n            ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);\\n        }\\n        return ones;\\n    }\\n\\nGo through the digit positions by using position multiplier `m` with values 1, 10, 100, 1000, etc.\\n\\nFor each position, split the decimal representation into two parts, for example split n=3141592 into a=31415 and b=92 when we're at m=100 for analyzing the hundreds-digit. And then we know that the hundreds-digit of n is 1 for prefixes \"\" to \"3141\", i.e., 3142 times. Each of those times is a streak, though. Because it's the hundreds-digit, each streak is 100 long. So `(a / 10 + 1) * 100` times, the hundreds-digit is 1. \\n\\nConsider the thousands-digit, i.e., when m=1000. Then a=3141 and b=592. The thousands-digit is 1 for prefixes \"\" to \"314\", so 315 times. And each time is a streak of 1000 numbers. However, since the thousands-digit is a 1, the very last streak isn't 1000 numbers but only 593 numbers, for the suffixes \"000\" to \"592\". So `(a / 10 * 1000) + (b + 1)` times, the thousands-digit is 1.\\n\\nThe case distincton between the current digit/position being 0, 1 and >=2 can easily be done in one expression. With `(a + 8) / 10` you get the number of full streaks, and `a % 10 == 1` tells you whether to add a partial streak.\\n\\n**Java version**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0);\\n        return ones;\\n    }\\n\\n**Python version**\\n\\n    def countDigitOne(self, n):\\n        ones, m = 0, 1\\n        while m <= n:\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1)\\n            m *= 10\\n        return ones\\n\\nUsing `sum` or recursion it can also be a [one-liner](https://leetcode.com/discuss/44302/1-liners-in-python).\\n\\n---\\n\\nOld solution\\n---\\n\\nGo through the digit positions from back to front. I found it ugly to explain, so I made up that above new solution instead. The `n` here is the new solution's `a`, and the `r` here is the new solution's `b+1`.\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        ones = 0\\n        m = r = 1\\n        while n > 0:\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r\\n            r += n % 10 * m\\n            m *= 10\\n            n /= 10\\n        return ones\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0);\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }\\n\\n**C++**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r;\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "Go through the digit positions one at a time, find out how often a \"1\" appears at each position, and sum those up.\\n\\n**C++ solution**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1);\\n        return ones;\\n    }\\n\\n**Explanation**\\n\\nLet me use variables `a` and `b` to make the explanation a bit nicer.\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10) {\\n            int a = n/m, b = n%m;\\n            ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);\\n        }\\n        return ones;\\n    }\\n\\nGo through the digit positions by using position multiplier `m` with values 1, 10, 100, 1000, etc.\\n\\nFor each position, split the decimal representation into two parts, for example split n=3141592 into a=31415 and b=92 when we're at m=100 for analyzing the hundreds-digit. And then we know that the hundreds-digit of n is 1 for prefixes \"\" to \"3141\", i.e., 3142 times. Each of those times is a streak, though. Because it's the hundreds-digit, each streak is 100 long. So `(a / 10 + 1) * 100` times, the hundreds-digit is 1. \\n\\nConsider the thousands-digit, i.e., when m=1000. Then a=3141 and b=592. The thousands-digit is 1 for prefixes \"\" to \"314\", so 315 times. And each time is a streak of 1000 numbers. However, since the thousands-digit is a 1, the very last streak isn't 1000 numbers but only 593 numbers, for the suffixes \"000\" to \"592\". So `(a / 10 * 1000) + (b + 1)` times, the thousands-digit is 1.\\n\\nThe case distincton between the current digit/position being 0, 1 and >=2 can easily be done in one expression. With `(a + 8) / 10` you get the number of full streaks, and `a % 10 == 1` tells you whether to add a partial streak.\\n\\n**Java version**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0);\\n        return ones;\\n    }\\n\\n**Python version**\\n\\n    def countDigitOne(self, n):\\n        ones, m = 0, 1\\n        while m <= n:\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1)\\n            m *= 10\\n        return ones\\n\\nUsing `sum` or recursion it can also be a [one-liner](https://leetcode.com/discuss/44302/1-liners-in-python).\\n\\n---\\n\\nOld solution\\n---\\n\\nGo through the digit positions from back to front. I found it ugly to explain, so I made up that above new solution instead. The `n` here is the new solution's `a`, and the `r` here is the new solution's `b+1`.\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        ones = 0\\n        m = r = 1\\n        while n > 0:\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r\\n            r += n % 10 * m\\n            m *= 10\\n            n /= 10\\n        return ones\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0);\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }\\n\\n**C++**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r;\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2997009,
                "title": "solution",
                "content": "```C++ []\\nclass Solution { \\npublic:\\n    int countDigitOne(int n) {\\n    int ret = 0;\\n      for(long long int i = 1; i <= n; i*= (long long int)10){\\n         int a = n / i;\\n         int b = n % i;\\n         int x = a % 10;\\n         if(x ==1){\\n            ret += (a / 10) * i + (b + 1);\\n         }\\n         else if(x == 0){\\n            ret += (a / 10) * i;\\n         } else {\\n            ret += (a / 10 + 1) *i;\\n         }\\n      }\\n      return ret;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        def count(add,n_digit):\\n            c = 0\\n            for d in range(0,n_digit+1):\\n                c += (d+add)*math.comb(n_digit,d)*9**(n_digit-d)\\n            return c\\n        res = 0\\n        n_list = [int(x) for x in str(n)]\\n        count_1 = 0\\n        for i in range(len(n_list)-1):\\n            if n_list[i] == 1:\\n                res += count(count_1,len(n_list)-i-1)\\n                count_1 += 1\\n            elif n_list[i] > 1:\\n                leading = n_list[i]-1\\n                res += count(count_1,len(n_list)-i-1)*leading+count(count_1+1,len(n_list)-i-1)\\n        res += count_1*(n_list[-1]+1)\\n        if n_list[-1] >= 1:\\n            res += 1\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }\\n    return ans;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution { \\npublic:\\n    int countDigitOne(int n) {\\n    int ret = 0;\\n      for(long long int i = 1; i <= n; i*= (long long int)10){\\n         int a = n / i;\\n         int b = n % i;\\n         int x = a % 10;\\n         if(x ==1){\\n            ret += (a / 10) * i + (b + 1);\\n         }\\n         else if(x == 0){\\n            ret += (a / 10) * i;\\n         } else {\\n            ret += (a / 10 + 1) *i;\\n         }\\n      }\\n      return ret;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        def count(add,n_digit):\\n            c = 0\\n            for d in range(0,n_digit+1):\\n                c += (d+add)*math.comb(n_digit,d)*9**(n_digit-d)\\n            return c\\n        res = 0\\n        n_list = [int(x) for x in str(n)]\\n        count_1 = 0\\n        for i in range(len(n_list)-1):\\n            if n_list[i] == 1:\\n                res += count(count_1,len(n_list)-i-1)\\n                count_1 += 1\\n            elif n_list[i] > 1:\\n                leading = n_list[i]-1\\n                res += count(count_1,len(n_list)-i-1)*leading+count(count_1+1,len(n_list)-i-1)\\n        res += count_1*(n_list[-1]+1)\\n        if n_list[-1] >= 1:\\n            res += 1\\n        return res\\n```\n```Java []\\nclass Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64382,
                "title": "java-python-one-pass-solution-easy-to-understand",
                "content": "The idea is to calculate occurrence of 1 on every digit. There are 3 scenarios, for example \\n\\n    if n = xyzdabc\\n\\nand we are considering the occurrence of one on thousand, it should be:\\n\\n    (1) xyz * 1000                     if d == 0\\n    (2) xyz * 1000 + abc + 1           if d == 1\\n    (3) xyz * 1000 + 1000              if d > 1\\n\\niterate through all digits and sum them all will give the final answer\\n\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n\\n        if (n <= 0) return 0;\\n        int q = n, x = 1, ans = 0;\\n        do {\\n            int digit = q % 10;\\n            q /= 10;\\n            ans += q * x;\\n            if (digit == 1) ans += n % x + 1;\\n            if (digit >  1) ans += x;\\n            x *= 10;\\n        } while (q > 0);\\n        return ans;\\n\\n    }\\n\\n    // 40 / 40 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 0 ms\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        q, x, ans = n, 1, 0\\n        while q > 0:\\n            digit = q % 10\\n            q /= 10\\n            ans += q * x\\n            if digit == 1:\\n                ans += n % x + 1\\n            elif digit > 1:\\n                ans += x\\n            x *= 10\\n        return ans\\n\\n    # 40 / 40 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 97.59%",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "The idea is to calculate occurrence of 1 on every digit. There are 3 scenarios, for example \\n\\n    if n = xyzdabc\\n\\nand we are considering the occurrence of one on thousand, it should be:\\n\\n    (1) xyz * 1000                     if d == 0\\n    (2) xyz * 1000 + abc + 1           if d == 1\\n    (3) xyz * 1000 + 1000              if d > 1\\n\\niterate through all digits and sum them all will give the final answer\\n\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n\\n        if (n <= 0) return 0;\\n        int q = n, x = 1, ans = 0;\\n        do {\\n            int digit = q % 10;\\n            q /= 10;\\n            ans += q * x;\\n            if (digit == 1) ans += n % x + 1;\\n            if (digit >  1) ans += x;\\n            x *= 10;\\n        } while (q > 0);\\n        return ans;\\n\\n    }\\n\\n    // 40 / 40 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 0 ms\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        q, x, ans = n, 1, 0\\n        while q > 0:\\n            digit = q % 10\\n            q /= 10\\n            ans += q * x\\n            if digit == 1:\\n                ans += n % x + 1\\n            elif digit > 1:\\n                ans += x\\n            x *= 10\\n        return ans\\n\\n    # 40 / 40 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 97.59%",
                "codeTag": "Python3"
            },
            {
                "id": 64390,
                "title": "ac-short-java-solution",
                "content": "    public int countDigitOne(int n) {\\n      int count = 0;\\n        \\n      for (long k = 1; k <= n; k *= 10) {\\n        long r = n / k, m = n % k;\\n        // sum up the count of ones on every place k\\n        count += (r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0);\\n      }\\n        \\n      return count;\\n    }\\n\\nSolution explanation:\\n\\nLet's start by counting the ones for every 10 numbers...\\n\\n0,  1,  2,  3  ... 9  (1)\\n\\n**10, 11, 12, 13 ... 19** (1) + **10**\\n\\n20, 21, 22, 23 ... 29 (1)\\n\\n...\\n\\n90, 91, 92, 93 ... 99 (1)\\n\\n-\\n\\n100, 101, 102, 103 ... 109 (10 + 1)\\n\\n**110, 111, 112, 113 ... 119** (10 + 1) + **10**\\n\\n120, 121, 122, 123 ... 129 (10 + 1)\\n\\n...\\n\\n190, 191, 192, 193 ... 199 (10 + 1)\\n\\n-\\n\\n\\n**1).** If we don't look at those special rows (start with 10, 110 etc), we know that there's a one at ones' place in every 10 numbers, there are 10 ones at tens' place in every 100 numbers, and 100 ones at hundreds' place in every 1000 numbers, so on and so forth.\\n\\nOk, let's start with ones' place and count how many ones at this place, set k = 1, as mentioned above, there's a one at ones' place in every 10 numbers, so how many 10 numbers do we have? \\n\\nThe answer is (n / k) / 10.\\n\\nNow let's count the ones in tens' place, set k = 10, as mentioned above, there are 10 ones at tens' place in every 100 numbers, so how many 100 numbers do we have? \\n\\nThe answer is (n / k) / 10, and the number of ones at ten's place is (n / k) / 10 * k.\\n\\nLet r = n / k, now we have a formula to count the ones at k's place: **r / 10 * k**\\n\\n-\\n\\n**2).** So far, everything looks good, but we need to fix those special rows, how? \\n\\nWe can use the mod. Take 10, 11, and 12 for example, if n is 10, we get (n / 1) / 10 * 1 = 1 ones at ones's place, perfect, but for tens' place, we get (n / 10) / 10 * 10 = 0, that's not right, there should be a one at tens' place! Calm down, from 10 to 19, we always have a one at tens's place, let m = n % k, the number of ones at this special place is m + 1, so let's fix the formula to be:\\n\\n\\n**r / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\n-\\n\\n\\n**3).** Wait, how about 20, 21 and 22? \\n\\nLet's say 20, use the above formula we get 0 ones at tens' place, but it should be 10! How to fix it? We know that once the digit is larger than 2, we should add 10 more ones to the tens' place, a clever way to fix is to add 8 to r, so our final formula is:\\n\\n**(r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\nAs you can see, it's all about how we fix the formula. Really hope that makes sense to you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int countDigitOne(int n) {\\n      int count = 0;\\n        \\n      for (long k = 1; k <= n; k *= 10) {\\n        long r = n / k, m = n % k;\\n        // sum up the count of ones on every place k\\n        count += (r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0);\\n      }\\n        \\n      return count;\\n    }\\n\\nSolution explanation:\\n\\nLet's start by counting the ones for every 10 numbers...\\n\\n0,  1,  2,  3  ... 9  (1)\\n\\n**10, 11, 12, 13 ... 19** (1) + **10**\\n\\n20, 21, 22, 23 ... 29 (1)\\n\\n...\\n\\n90, 91, 92, 93 ... 99 (1)\\n\\n-\\n\\n100, 101, 102, 103 ... 109 (10 + 1)\\n\\n**110, 111, 112, 113 ... 119** (10 + 1) + **10**\\n\\n120, 121, 122, 123 ... 129 (10 + 1)\\n\\n...\\n\\n190, 191, 192, 193 ... 199 (10 + 1)\\n\\n-\\n\\n\\n**1).** If we don't look at those special rows (start with 10, 110 etc), we know that there's a one at ones' place in every 10 numbers, there are 10 ones at tens' place in every 100 numbers, and 100 ones at hundreds' place in every 1000 numbers, so on and so forth.\\n\\nOk, let's start with ones' place and count how many ones at this place, set k = 1, as mentioned above, there's a one at ones' place in every 10 numbers, so how many 10 numbers do we have? \\n\\nThe answer is (n / k) / 10.\\n\\nNow let's count the ones in tens' place, set k = 10, as mentioned above, there are 10 ones at tens' place in every 100 numbers, so how many 100 numbers do we have? \\n\\nThe answer is (n / k) / 10, and the number of ones at ten's place is (n / k) / 10 * k.\\n\\nLet r = n / k, now we have a formula to count the ones at k's place: **r / 10 * k**\\n\\n-\\n\\n**2).** So far, everything looks good, but we need to fix those special rows, how? \\n\\nWe can use the mod. Take 10, 11, and 12 for example, if n is 10, we get (n / 1) / 10 * 1 = 1 ones at ones's place, perfect, but for tens' place, we get (n / 10) / 10 * 10 = 0, that's not right, there should be a one at tens' place! Calm down, from 10 to 19, we always have a one at tens's place, let m = n % k, the number of ones at this special place is m + 1, so let's fix the formula to be:\\n\\n\\n**r / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\n-\\n\\n\\n**3).** Wait, how about 20, 21 and 22? \\n\\nLet's say 20, use the above formula we get 0 ones at tens' place, but it should be 10! How to fix it? We know that once the digit is larger than 2, we should add 10 more ones to the tens' place, a clever way to fix is to add 8 to r, so our final formula is:\\n\\n**(r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\nAs you can see, it's all about how we fix the formula. Really hope that makes sense to you.",
                "codeTag": "Unknown"
            },
            {
                "id": 64426,
                "title": "easy-to-understand-c-0ms-solution-with-detailed-explanation",
                "content": "We start from basics:\\n\\n    f(9) = 1;\\n    f(99) = f(9) * 10 + 10(contributed by the most significant digit in range [10, 19]) = 20  \\n    f(999) = f(99) * 10 + 100(contributed by the most significant digit in range [100, 199]) = 300\\n    f(9999) = f(999) * 10 + 1000(contributed by the most significant digit in range [1000, 1999]) = 10 * 300 + 1000 = 4000\\n    ... ...\\n\\nHow about 23?\\n\\n    23 = [0, 9] + [10, 19] + [20, 23]\\n\\n[10, 19] can be reduced to solve f(9) + 10, because its most significant digit is 1. And [20, 23] can be reduced to solve f(3) + 0, because the most significant digit is 2, so this digit doesn't contribute to final result.\\nSo now we know\\n\\n    f(23) = f(9) * 2 + 10 + f(3)\\n\\nSo now when we look at a number n (e.g. 2356), we look at the most significant digit(2), its divisor with highest 10's power (1000), and its remainder (356), try to reduce to a smaller number iteratively.\\n\\n(1) Since most significant digit is 2, so we know range [0, 999], [1000, 1999] are included, so we add 2 * f(999). \\n\\n(2) Also, since we have [1000, 1999] covered, we should add extra 1000. \\n\\n(3) Then we look at range [2000, 2356], try to reduce it to [0, 356] by dropping most significant digit 2, it doesn't impact the final result since most significant digit is 2 not 1. \\n\\n(4) Finally, we add f(356)\\n\\nSo eventually, we have\\n\\n    f(2356) += (2356 / 1000) * f(1000 - 1) = 2 * f(999);\\n    f(2356) += (2356 / 1000 > 1 ? 1000 : 0); \\n    f(2356) += (2356 / 1000 == 1 ? 356 + 1 : 0);\\n    f(2356) += f(356);\\n\\nBelow is the code:\\n\\n    class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            int ans = 0;\\n            if(n <= 0) return 0;\\n            if(n <= 9) return 1;\\n            \\n            unordered_map<int, int> mp;\\n            mp[9] = 1;\\n            for(int i = 9; i <= (INT_MAX - 9) / 10; i = i * 10 + 9){\\n                mp[i*10 + 9] = mp[i] * 10 + (i + 1); // mp[99], mp[999], mp[9999], ... ...\\n            }\\n            \\n            int nn = n, divisor = 1;\\n            while(nn / 10){\\n                nn /= 10;\\n                divisor *= 10;\\n            }\\n            ans += (n / divisor) *  mp[divisor - 1]; \\n            ans += (n / divisor > 1) ? divisor : 0; \\n            ans += (n / divisor == 1) ? n % divisor + 1 : 0;\\n            ans += countDigitOne(n % divisor);\\n\\n            return  ans;  \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            int ans = 0;\\n            if(n <= 0) return 0;\\n            if(n <= 9) return 1;\\n            \\n            unordered_map<int, int> mp;\\n            mp[9] = 1;\\n            for(int i = 9; i <= (INT_MAX - 9) / 10; i = i * 10 + 9){\\n                mp[i*10 + 9] = mp[i] * 10 + (i + 1); // mp[99], mp[999], mp[9999], ... ...\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64383,
                "title": "my-simple-and-understandable-java-solution",
                "content": "\\n     /**\\n\\t * Calculate occurance on every digit, from\\n\\t * least important digit to most important digit\\n\\t * number = 1432\\n\\t * One's digit: n/10=143 143*1+1\\n\\t * Ten's digit: n/100=14 14*10+10\\n\\t * Hun's digit: n/1000=1 1*100+100\\n\\t * Tho's digit: 1432%1000+1=433\\n\\t * Sum all occurance on digits together\\n\\t */\\n\\tpublic static int countDigitOne(int k) {\\n        int count = 0, factor = 1, n = k;\\n        while(n>0){\\n        \\tint m = n/10, r = n%10, amount;\\n        \\t\\n        \\tif(r == 0) amount = 0;\\n        \\telse if(r > 1) amount = factor;\\n        \\telse amount = k%factor+1;\\n     \\n        \\tcount += m*factor + amount;\\n        \\tfactor *= 10;\\n        \\tn = n/10;\\n        }\\n        return count;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n     /**\\n\\t * Calculate occurance on every digit, from\\n\\t * least important digit to most important digit\\n\\t * number = 1432\\n\\t * One's digit: n/10=143 143*1+1\\n\\t * Ten's digit: n/100=14 14*10+10\\n\\t * Hun's digit: n/1000=1 1*100+100\\n\\t * Tho's digit: 1432%1000+1=433\\n\\t * Sum all occurance on digits together\\n\\t */\\n\\tpublic static int countDigitOne(int k) {\\n        int count = 0, factor = 1, n = k;\\n        while(n>0){\\n        \\tint m = n/10, r = n%10, amount;\\n        \\t\\n        \\tif(r == 0) amount = 0;\\n        \\telse if(r > 1) amount = factor;\\n        \\telse amount = k%factor+1;\\n     \\n        \\tcount += m*factor + amount;\\n        \\tfactor *= 10;\\n        \\tn = n/10;\\n        }\\n        return count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 64397,
                "title": "0-ms-recursive-solution",
                "content": "    int countDigitOne(int n) {\\n        if(n<1) return 0;\\n        if(n>=1 && n<10) return 1;\\n        // x: first digit\\n        int y=1, x=n;\\n        while(!(x<10)){\\n            x/=10;\\n            y*=10;\\n        }\\n        if(x==1)\\n            return n-y+1+countDigitOne(y-1)+countDigitOne(n%y);\\n        else\\n            return y+x*countDigitOne(y-1)+countDigitOne(n%y);\\n    }",
                "solutionTags": [],
                "code": "    int countDigitOne(int n) {\\n        if(n<1) return 0;\\n        if(n>=1 && n<10) return 1;\\n        // x: first digit\\n        int y=1, x=n;\\n        while(!(x<10)){\\n            x/=10;\\n            y*=10;\\n        }\\n        if(x==1)\\n            return n-y+1+countDigitOne(y-1)+countDigitOne(n%y);\\n        else\\n            return y+x*countDigitOne(y-1)+countDigitOne(n%y);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64476,
                "title": "0ms-o-lgn-accepted-c-solution-using-counting-principle-with-explanation",
                "content": "For every digit in n (Suppose n = 240315, the digits are 2, 4, 0, 3, 1, 5)\\uff0cI respectively count the number of digit 1 assuming the position of current digit is 1 and other digits of n is arbitrary.\\n\\nFor example, I select 3 in n as the current digit, and I suppose the position of 3 is 1.\\n\\nThe highn is the number composed with the digits before the current digit. In the example, highn = 240;\\n\\nThe lown is the number composed with the digits after the current digit. In the example, lown = 15.\\n\\nThe lowc = 10 ^ (the number of lower digits). In the example, lowc = 100;\\n\\nAs curn = 3 and curn > 1,  (highn * 10 + 1) must be less than  (highn * 10 + curn). Then the higher part can be 0 ~ highn, the lower part can be 0 ~ (lowc-1), and the current result = (highn + 1)  *  lowc.\\n\\n    int countDigitOne(int n) {\\n            long long int res(0);\\n            int highn(n), lowc(1), lown(0);\\n            while(highn > 0){\\n                int curn = highn % 10;\\n                highn = highn / 10;\\n                if(1 == curn){\\n                    //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                    //higher: highn ~ highn;     lower:0~lown\\n                    res += lown + 1;\\n                }else if(0 == curn){  \\n                    //curn < 1\\n                   //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                }else{              \\n                    //curn > 1\\n                    res += (highn + 1) * lowc;\\n                }\\n                //update lown and lowc\\n                lown = curn * lowc + lown;\\n                lowc = lowc * 10;\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "For every digit in n (Suppose n = 240315, the digits are 2, 4, 0, 3, 1, 5)\\uff0cI respectively count the number of digit 1 assuming the position of current digit is 1 and other digits of n is arbitrary.\\n\\nFor example, I select 3 in n as the current digit, and I suppose the position of 3 is 1.\\n\\nThe highn is the number composed with the digits before the current digit. In the example, highn = 240;\\n\\nThe lown is the number composed with the digits after the current digit. In the example, lown = 15.\\n\\nThe lowc = 10 ^ (the number of lower digits). In the example, lowc = 100;\\n\\nAs curn = 3 and curn > 1,  (highn * 10 + 1) must be less than  (highn * 10 + curn). Then the higher part can be 0 ~ highn, the lower part can be 0 ~ (lowc-1), and the current result = (highn + 1)  *  lowc.\\n\\n    int countDigitOne(int n) {\\n            long long int res(0);\\n            int highn(n), lowc(1), lown(0);\\n            while(highn > 0){\\n                int curn = highn % 10;\\n                highn = highn / 10;\\n                if(1 == curn){\\n                    //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                    //higher: highn ~ highn;     lower:0~lown\\n                    res += lown + 1;\\n                }else if(0 == curn){  \\n                    //curn < 1\\n                   //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                }else{              \\n                    //curn > 1\\n                    res += (highn + 1) * lowc;\\n                }\\n                //update lown and lowc\\n                lown = curn * lowc + lown;\\n                lowc = lowc * 10;\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 908032,
                "title": "easy-to-understand-digit-dp-solution-c",
                "content": "A digit DP solution based on the blog :- https://codeforces.com/blog/entry/53960\\n```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    int dp[10][10][2];\\n    //dp[pos][count][flag]\\n    //pos= current position from left side\\n    //count= count of 1s so far\\n    //flag=the number we are building has already become smaller than the given number(0:NO ,1:YES)\\n    \\npublic:\\n    int digitdp(int pos,int count,int flag)\\n    {\\n        if(pos==s)\\n        {\\n            return count;\\n        }\\n        if(dp[pos][count][flag]!=-1)\\n        {\\n            return dp[pos][count][flag];\\n        }\\n        //if the number has already become smaller than the given number we can insert any digit we want\\n        int limit= flag==0?nums[pos]:9;\\n        int res=0;\\n        for(int i=0;i<=limit;i++)\\n        {\\n            //if the digit is 1 we increase the count by 1\\n            int ncount= i==1 ?count+1:count;\\n            //the digit at the ith position is smaller than the digit at the ith position of the number the number has already become smaller so we can set the flag as 1\\n            int nflag=flag || i!=limit;\\n            res+=digitdp(pos+1,ncount,nflag);\\n        }\\n        return dp[pos][count][flag]=res;\\n    }\\n    int countDigitOne(int n) {\\n        while(n>0)\\n        {\\n            nums.push_back(n%10);\\n            n=n/10;\\n        }\\n        memset(dp,-1,sizeof dp);\\n        reverse(nums.begin(),nums.end());\\n        s=nums.size();\\n        return digitdp(0,0,0);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    int dp[10][10][2];\\n    //dp[pos][count][flag]\\n    //pos= current position from left side\\n    //count= count of 1s so far\\n    //flag=the number we are building has already become smaller than the given number(0:NO ,1:YES)\\n    \\npublic:\\n    int digitdp(int pos,int count,int flag)\\n    {\\n        if(pos==s)\\n        {\\n            return count;\\n        }\\n        if(dp[pos][count][flag]!=-1)\\n        {\\n            return dp[pos][count][flag];\\n        }\\n        //if the number has already become smaller than the given number we can insert any digit we want\\n        int limit= flag==0?nums[pos]:9;\\n        int res=0;\\n        for(int i=0;i<=limit;i++)\\n        {\\n            //if the digit is 1 we increase the count by 1\\n            int ncount= i==1 ?count+1:count;\\n            //the digit at the ith position is smaller than the digit at the ith position of the number the number has already become smaller so we can set the flag as 1\\n            int nflag=flag || i!=limit;\\n            res+=digitdp(pos+1,ncount,nflag);\\n        }\\n        return dp[pos][count][flag]=res;\\n    }\\n    int countDigitOne(int n) {\\n        while(n>0)\\n        {\\n            nums.push_back(n%10);\\n            n=n/10;\\n        }\\n        memset(dp,-1,sizeof dp);\\n        reverse(nums.begin(),nums.end());\\n        s=nums.size();\\n        return digitdp(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64451,
                "title": "easy-understand-java-solution-with-detailed-explaination",
                "content": "The basic idea is to find the relationship between the increse of number of digit 1 and each digit. For example, let (edcba) be a number, I want to find a  relationship that represents how number of digit 1 incresed with the current digit, like f(e) = countDigitOne(edcba)-countDigitOne(dcba). Once such function is identified, the total number of digit 1 can be iteratively calculated.\\n\\nThe following is the process to identify the relationship(function f()):\\nThe function (f(e)) is defined as the number of digit 1 increased because of digit e. (i.e. compared to there was no digit e, just (dcba), for example).\\n\\nWe take (edcba) as a number like 12345 (e =1, d=2,c=3,b=4 and a =5) here.\\n\\nStart from f(a), it's obvious that **if a=0, f(a) = 0, if a >0, f(a)=1.**\\n\\nThen f(b). If b =1,since countDigitOne(11) = 4 while countDigitOne(01) =1 ,and countDigitOne(19) = 12 while countDigitOne(09) = 1, it shows that **f(b) = 1 + a +1.**\\n\\nIf b>1, since countDigitOne(21) = 13 while countDigitOne(01) = 1 and countDigitOne(99) = 20 while countDigitOne(09) = 1, **f(b) = b + 10;**\\n\\nSimilarly, \\n\\n**if c=1, f(c) = 20 + 10b+a+1; if c>1, f(c) = 20c+100;**\\n\\n**if d = 1, f(d) = 300+100c+10b+a+1; if d>1, f(d) = 300d+1000;**\\n\\n\\nThe relationships between the parameters are easy to find out. Take f(d) as an example, **300 = f(a)+f(b)+f(c) when (a = b = c = 9 ),** that is 1+19+280 = 300, which essentialy is the countDigitOne(999). 1000 = 10*10*10, and 100*c+10*b+a is the value of number (cba). \\n\\nWith these relationships, a scan and accumulate from lowest digit can lead to the answer.\\n\\n    public int countDigitOne(int n) {\\n\\t\\tint remain;\\n\\t\\tint acc = 0;\\n\\t\\tint numIndex = 0;\\n\\t\\tint factor = 1;\\n\\t\\tint count = 0;\\n\\t\\twhile (n > 0) {\\n\\t\\t\\tremain = n % 10;\\n\\t\\t\\tn /= 10;\\n\\t\\t\\tif (remain == 1)\\n\\t\\t\\t\\tcount += numIndex + acc + 1;\\n\\t\\t\\telse if (remain > 1)\\n\\t\\t\\t\\tcount += remain * numIndex + factor;\\n\\t\\t\\tacc += remain * factor;\\n\\t\\t\\tnumIndex += 9 * numIndex + factor;\\n\\t\\t\\tfactor *= 10;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to find the relationship between the increse of number of digit 1 and each digit. For example, let (edcba) be a number, I want to find a  relationship that represents how number of digit 1 incresed with the current digit, like f(e) = countDigitOne(edcba)-countDigitOne(dcba). Once such function is identified, the total number of digit 1 can be iteratively calculated.\\n\\nThe following is the process to identify the relationship(function f()):\\nThe function (f(e)) is defined as the number of digit 1 increased because of digit e. (i.e. compared to there was no digit e, just (dcba), for example).\\n\\nWe take (edcba) as a number like 12345 (e =1, d=2,c=3,b=4 and a =5) here.\\n\\nStart from f(a), it's obvious that **if a=0, f(a) = 0, if a >0, f(a)=1.**\\n\\nThen f(b). If b =1,since countDigitOne(11) = 4 while countDigitOne(01) =1 ,and countDigitOne(19) = 12 while countDigitOne(09) = 1, it shows that **f(b) = 1 + a +1.**\\n\\nIf b>1, since countDigitOne(21) = 13 while countDigitOne(01) = 1 and countDigitOne(99) = 20 while countDigitOne(09) = 1, **f(b) = b + 10;**\\n\\nSimilarly, \\n\\n**if c=1, f(c) = 20 + 10b+a+1; if c>1, f(c) = 20c+100;**\\n\\n**if d = 1, f(d) = 300+100c+10b+a+1; if d>1, f(d) = 300d+1000;**\\n\\n\\nThe relationships between the parameters are easy to find out. Take f(d) as an example, **300 = f(a)+f(b)+f(c) when (a = b = c = 9 ),** that is 1+19+280 = 300, which essentialy is the countDigitOne(999). 1000 = 10*10*10, and 100*c+10*b+a is the value of number (cba). \\n\\nWith these relationships, a scan and accumulate from lowest digit can lead to the answer.\\n\\n    public int countDigitOne(int n) {\\n\\t\\tint remain;\\n\\t\\tint acc = 0;\\n\\t\\tint numIndex = 0;\\n\\t\\tint factor = 1;\\n\\t\\tint count = 0;\\n\\t\\twhile (n > 0) {\\n\\t\\t\\tremain = n % 10;\\n\\t\\t\\tn /= 10;\\n\\t\\t\\tif (remain == 1)\\n\\t\\t\\t\\tcount += numIndex + acc + 1;\\n\\t\\t\\telse if (remain > 1)\\n\\t\\t\\t\\tcount += remain * numIndex + factor;\\n\\t\\t\\tacc += remain * factor;\\n\\t\\t\\tnumIndex += 9 * numIndex + factor;\\n\\t\\t\\tfactor *= 10;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 64418,
                "title": "5-lines-solution-using-recursion-with-explanation",
                "content": "The concept is count 1s in current level, recursively do it until the number is smaller than 10.\\n\\n**Javascript Solution**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0) return 0;\\n        if(n < 10) return 1;\\n        var base = Math.pow(10, n.toString().length - 1);\\n        var answer = parseInt(n / base);\\n        return countDigitOne(base - 1) * answer + (answer === 1 ? (n - base + 1) : base) + countDigitOne(n % base);\\n    };\\n\\nFor example '8192':\\n\\n1-999 -> countDigitOne(999)\\n\\n1000-1999 -> 1000 of 1s + countDigitOne(999)\\n\\n2000-2999 -> countDigitOne(999)\\n\\n.\\n\\n.\\n\\n7000-7999 -> countDigitOne(999)\\n\\n8000-8192 -> countDigitOne(192)\\n\\nCount of 1s : **countDigitOne(999)*8 + 1000 + countDigitOne(192)**\\n\\n**Noticed that**, if the target is '1192':\\n\\nCount of 1s : **countDigitOne(999)*1 + (1192 - 1000  + 1) + countDigitOne(192)**\\n\\n (1192 - 1000  + 1) is the 1s in thousands from 1000 to 1192.\\n\\n\\n\\n**Same codes as above, maybe much easier to understand.**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0){\\n            return 0;\\n        }else if(n < 10){\\n            return 1;\\n        }\\n        var len = n.toString().length;\\n        var base = Math.pow(10, len - 1);\\n        var answer = parseInt(n / base);\\n        var remainder = n % base;\\n        var oneInBase = 0;\\n        if(answer === 1){\\n            oneInBase = n - base + 1;\\n        }else{\\n            oneInBase = base;\\n        }\\n        return countDigitOne(base - 1) * answer + oneInBase + countDigitOne(remainder);\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "The concept is count 1s in current level, recursively do it until the number is smaller than 10.\\n\\n**Javascript Solution**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0) return 0;\\n        if(n < 10) return 1;\\n        var base = Math.pow(10, n.toString().length - 1);\\n        var answer = parseInt(n / base);\\n        return countDigitOne(base - 1) * answer + (answer === 1 ? (n - base + 1) : base) + countDigitOne(n % base);\\n    };\\n\\nFor example '8192':\\n\\n1-999 -> countDigitOne(999)\\n\\n1000-1999 -> 1000 of 1s + countDigitOne(999)\\n\\n2000-2999 -> countDigitOne(999)\\n\\n.\\n\\n.\\n\\n7000-7999 -> countDigitOne(999)\\n\\n8000-8192 -> countDigitOne(192)\\n\\nCount of 1s : **countDigitOne(999)*8 + 1000 + countDigitOne(192)**\\n\\n**Noticed that**, if the target is '1192':\\n\\nCount of 1s : **countDigitOne(999)*1 + (1192 - 1000  + 1) + countDigitOne(192)**\\n\\n (1192 - 1000  + 1) is the 1s in thousands from 1000 to 1192.\\n\\n\\n\\n**Same codes as above, maybe much easier to understand.**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0){\\n            return 0;\\n        }else if(n < 10){\\n            return 1;\\n        }\\n        var len = n.toString().length;\\n        var base = Math.pow(10, len - 1);\\n        var answer = parseInt(n / base);\\n        var remainder = n % base;\\n        var oneInBase = 0;\\n        if(answer === 1){\\n            oneInBase = n - base + 1;\\n        }else{\\n            oneInBase = base;\\n        }\\n        return countDigitOne(base - 1) * answer + oneInBase + countDigitOne(remainder);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 64403,
                "title": "detailed-explanation-for-those-who-can-t-understand-took-me-5-hours-to-figure-out",
                "content": "```\\npublic class Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int result = 0;\\n        // process each digit of n, compute the total number of 1's can appear on that digit, and sum the results\\n        // solution inspired by StefanPochmann, but I rewrote his one-liner into if statements to help myself understand\\n        for (long m=1; m<=n; m*=10) {\\n            // suppose we have abcxdef\\n            // consider we are at m = 1000 (position x), then a = abcx, b = def\\n            long a = n/m, b = n%m;\\n            // if x > 1, then each combination of 0~abc (total abc+1 ways) on abc and 0~999 (total = 1000) on def works => (abc+1)*1000\\n            if (a%10 > 1) {\\n                result += (a/10+1) * m;\\n            }\\n            // if x == 1, then each combination of 0~(abc-1) (total abc ways) on abc and 0~999 (total = 1000) on def works => abc*1000\\n            // but when it comes to abc, since x == 1, we only have def+1 (including 0) ways the first three digits are abc, otherwise we will exceed the number n => def+1\\n            // total = abc*1000 + def+1\\n            if (a%10 == 1) {\\n                result += (a/10)*m + b+1;\\n            }\\n            // if x == 0, this is the tricky part (IMO)\\n            // you can only have 0~(abc-1) (total abc ways) on abc and 0~999 (total = 1000) on def => abc*1000\\n            // this is because its still possible for x to be 1 on numbers less than abc0def\\n            // one example, assume i = c-1, then x can be 1 on the number abixdef\\n            // all the values from 0~abc-1 works, and thus we have abc*1000 ways.\\n            if (a%10 == 0) {\\n                result += (a/10)*m;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```\\n\\nStephen used a smart (amazing) way to combine those if statements into a 1-liner:\\n```\\nones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);\\n```\\nThis is absolutely mind-blowing and took me 5 hours to figure out (maybe I'm not that smart so I have to work hard to make up on that). Basically, if ```a % 10 == 0```, then a+8 will never produce a carry to the 10th digit, and hence ```(a+8)/10 = a/10```. If ```a % 10 == 1```, there is still no carry, but ```(a % 10 == 1)``` will get invoked and produce the correct result. If ```a % 10 > 1```, then we will have a carry added to the 10th digit, it's the same as ```(a / 10 + 1)```.\\n\\nOne liner solution by Steph here: https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python\\n\\nCode without comment (for cleaner view):\\n```\\npublic class Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int result = 0;\\n        for (long m=1; m<=n; m*=10) {\\n            long a = n/m, b = n%m;\\n            if (a%10 > 1) {\\n                result += (a/10+1) * m;\\n            }\\n            if (a%10 == 1) {\\n                result += (a/10)*m + b+1;\\n            }\\n            if (a%10 == 0) {\\n                result += (a/10)*m;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int result = 0;\\n        // process each digit of n, compute the total number of 1's can appear on that digit, and sum the results\\n        // solution inspired by StefanPochmann, but I rewrote his one-liner into if statements to help myself understand\\n        for (long m=1; m<=n; m*=10) {\\n            // suppose we have abcxdef\\n            // consider we are at m = 1000 (position x), then a = abcx, b = def\\n            long a = n/m, b = n%m;\\n            // if x > 1, then each combination of 0~abc (total abc+1 ways) on abc and 0~999 (total = 1000) on def works => (abc+1)*1000\\n            if (a%10 > 1) {\\n                result += (a/10+1) * m;\\n            }\\n            // if x == 1, then each combination of 0~(abc-1) (total abc ways) on abc and 0~999 (total = 1000) on def works => abc*1000\\n            // but when it comes to abc, since x == 1, we only have def+1 (including 0) ways the first three digits are abc, otherwise we will exceed the number n => def+1\\n            // total = abc*1000 + def+1\\n            if (a%10 == 1) {\\n                result += (a/10)*m + b+1;\\n            }\\n            // if x == 0, this is the tricky part (IMO)\\n            // you can only have 0~(abc-1) (total abc ways) on abc and 0~999 (total = 1000) on def => abc*1000\\n            // this is because its still possible for x to be 1 on numbers less than abc0def\\n            // one example, assume i = c-1, then x can be 1 on the number abixdef\\n            // all the values from 0~abc-1 works, and thus we have abc*1000 ways.\\n            if (a%10 == 0) {\\n                result += (a/10)*m;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```\n```\\nones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);\\n```\n```a % 10 == 0```\n```(a+8)/10 = a/10```\n```a % 10 == 1```\n```(a % 10 == 1)```\n```a % 10 > 1```\n```(a / 10 + 1)```\n```\\npublic class Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int result = 0;\\n        for (long m=1; m<=n; m*=10) {\\n            long a = n/m, b = n%m;\\n            if (a%10 > 1) {\\n                result += (a/10+1) * m;\\n            }\\n            if (a%10 == 1) {\\n                result += (a/10)*m + b+1;\\n            }\\n            if (a%10 == 0) {\\n                result += (a/10)*m;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277541,
                "title": "1",
                "content": "\\u5BF9\\u4E8E\\u4EFB\\u610F\\u4E00\\u4E2A\\u6570\\uFF0C\\u6BD4\\u5982 abcde\\uFF0C\\n\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u627E\\u51FA\\u4E07\\u4F4D\\u3001\\u5343\\u4E07\\u3001\\u767E\\u4F4D\\u3001\\u5341\\u4F4D\\u3001\\u4E2A\\u4F4D\\u4E0A\\u5206\\u522B\\u51FA\\u73B0\\u4E86\\u591A\\u5C11\\u4E2A1\\u5C31\\u884C\\u4E86\\u3002\\n\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4F4D\\uFF0C\\u5BFB\\u627E\\u51FA\\u73B0\\u591A\\u5C11\\u4E2A1\\u7684\\u65B9\\u6CD5\\u662F\\u4E00\\u6837\\u7684\\u3002\\u6BD4\\u5982\\uFF0C\\u6211\\u4EEC\\u73B0\\u5728\\u5BFB\\u627E\\u767E\\u4F4D\\u51FA\\u73B0\\u4E86\\u591A\\u5C11\\u4E2A1\\u3002\\n\\u5206\\u6210\\u4E24\\u4E2A\\u90E8\\u5206\\uFF1A\\n1.  \\u5728\\u5C0F\\u4E8E ab000 \\u7684\\u6570\\u91CC\\uFF0C\\u767E\\u4F4D\\u51FA\\u73B01\\u7684\\u60C5\\u51B5\\u6709  (**\\u4E3A\\u4E86\\u9192\\u76EE\\u6211\\u628A\\u6574\\u4E2A\\u6570\\u5B57\\u5199\\u6210\\u4E86\\u8FD9\\u4E2A\\u683C\\u5F0F\" (\\u767E\\u4F4D\\u5DE6\\u8FB9 ) \\u767E\\u4F4D   [\\u767E\\u4F4D\\u53F3\\u8FB9]\"**\\n\\t(00) 1 [00\\u300101\\u300102\\u2026\\u202699] \\n\\t(01) 1 [00\\u300101\\u300102\\u2026\\u202699],\\n\\t(02) 1 [00\\u300101\\u300102\\u2026\\u202699]\\n\\t\\u2026\\u2026\\n\\t(ab-1) 1 [00\\u300101\\u300102\\u2026\\u202699]\\n\\t \\u56E0\\u6B64\\u4E00\\u5171\\u6709 ab*100 \\u6B21\\n2. \\u5728\\u5927\\u4E8E ab000 \\u7684\\u6570\\u91CC\\uFF0C\\u5982\\u679C\\u767E\\u4F4D\\u8FD9\\u4E2A\\u6570\\u4E5F\\u5C31\\u662F c \\u5927\\u4E8E1\\u7684\\u8BDD\\uFF0C\\u90A3\\u5176\\u5B9E\\u5C31\\u662F\\u57281\\u7684\\u60C5\\u51B5\\u91CC\\u518D\\u52A0\\u4E0A\\n\\t(ab) 1 [00\\u300101\\u300102\\u2026\\u202699] \\u8FD9100\\u6B21\\n\\t\\u5982\\u679Ce=1\\uFF0C\\u90A3\\u4E48\\u4F1A\\u6709 (ab) 1 [00\\u300101\\u2026\\u2026de] ,   1 *(de+1) \\u6B21\\n\\t\\u5982\\u679C e=0, \\u90A3\\u4E48\\u4F1A\\u6709 0 * (de+1\\uFF09\\u6B21\\n\\t\\n\\u7B80\\u5355\\u7684\\u8BF4\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4F4D\\uFF0C\\u51FA\\u73B0\\u7684\\u6B21\\u6570\\u90FD\\u7B49\\u4E8E \\uFF1A\\u5DE6\\u8FB9\\u7684\\u6570\\u5B57*\\u5F53\\u524D\\u57FA\\u6570\\uFF08\\u767E\\u4F4D\\u5C31\\u662F100\\uFF0C\\u5343\\u4F4D\\u5C31\\u662F1000\\u2026\\u2026\\uFF09+\\u81EA\\u5DF1*\\u53F3\\u8FB9\\u7684\\u6570\\u5B57 || \\u5F53\\u524D\\u57FA\\u6570\\n\\n\\u4E0B\\u9762\\u662F\\u6211\\u7684\\u7B54\\u6848\\n\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count=0;\\n        int base=1;\\n        int numberLower=0;\\n        \\n        while (n>0){//\\u4ECE\\u4F4E\\u4F4D\\u5F00\\u59CB\\n            int curr=n % 10;//\\u5F53\\u524D\\u6570\\u5B57\\n            if(curr>1) \\n                count+=base;//\\u5982\\u679C\\u5F53\\u524D\\u6570\\u5B57\\u5927\\u4E8E1 \\uFF0C\\u52A0\\u4E0A\\u4E00\\u4E2A\\u57FA\\u6570\\u5373\\u53EF\\n            else if(curr==1){//\\u5982\\u679C\\u5F53\\u524D\\u6570\\u5B57\\u7B49\\u4E8E1 \\uFF0C\\u52A0\\u4E0A\\u4F4E\\u4F4D\\u7684\\u6570\\u5B57+1\\n                count+=numberLower+1;\\n            }\\n            n/=10;\\n            count+=n*base;//\\u5DE6\\u8FB9\\u7684\\u9AD8\\u4F4D\\u6570\\u5B57 * \\u57FA\\u6570\\n            numberLower+=curr*base;  //\\u66F4\\u65B0\\u4F4E\\u8FB9\\u6570\\u5B57\\n            base*=10;//\\u57FA\\u6570*10\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count=0;\\n        int base=1;\\n        int numberLower=0;\\n        \\n        while (n>0){//\\u4ECE\\u4F4E\\u4F4D\\u5F00\\u59CB\\n            int curr=n % 10;//\\u5F53\\u524D\\u6570\\u5B57\\n            if(curr>1) \\n                count+=base;//\\u5982\\u679C\\u5F53\\u524D\\u6570\\u5B57\\u5927\\u4E8E1 \\uFF0C\\u52A0\\u4E0A\\u4E00\\u4E2A\\u57FA\\u6570\\u5373\\u53EF\\n            else if(curr==1){//\\u5982\\u679C\\u5F53\\u524D\\u6570\\u5B57\\u7B49\\u4E8E1 \\uFF0C\\u52A0\\u4E0A\\u4F4E\\u4F4D\\u7684\\u6570\\u5B57+1\\n                count+=numberLower+1;\\n            }\\n            n/=10;\\n            count+=n*base;//\\u5DE6\\u8FB9\\u7684\\u9AD8\\u4F4D\\u6570\\u5B57 * \\u57FA\\u6570\\n            numberLower+=curr*base;  //\\u66F4\\u65B0\\u4F4E\\u8FB9\\u6570\\u5B57\\n            base*=10;//\\u57FA\\u6570*10\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230126,
                "title": "233-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution works by iterating through each digit position from right to left, and for each position, counting the number of ones that can appear at that position. This is done using the formula:\\n\\n- If the digit at the current position is 0, then the number of ones that can appear at this position is determined by the digits to the right of it.\\n- If the digit at the current position is 1, then the number of ones that can appear at this position is determined by the digits to the right of it, as well as the digits to the left of it.\\n- If the digit at the current position is greater than 1, then the number of ones that can appear at this position is determined by the digits to the right of it, as well as the number of times the current position can be filled with the digit 1.\\n\\nThe code starts by initializing a variable \"ans\" to 0, which will accumulate the total count of ones. It then initializes a variable \"pow10\" to 1, which will be used to iterate through each digit position from right to left.\\n\\nThe code then enters a loop that continues while \"pow10\" is less than or equal to \"n\". In each iteration of the loop, the code computes the quotient and remainder when \"n\" is divided by \"divisor\", which is equal to \"pow10\" times 10. The quotient represents the digits to the left of the current position, and the remainder represents the digits to the right of the current position.\\n\\nThe code then checks if the quotient is greater than 0. If so, it adds \"quotient * pow10\" to \"ans\", which counts the number of ones that can appear at the current position due to the digits to the left of it.\\n\\nThe code then checks if the remainder is greater than or equal to \"pow10\". If so, it adds \"min(remainder - pow10 + 1, pow10)\" to \"ans\", which counts the number of ones that can appear at the current position due to the digits to the right of it, as well as the current position itself if the current digit is 1.\\n\\nFinally, the code multiplies \"pow10\" by 10 to move on to the next digit position, and repeats the loop.\\n\\nThe function returns \"ans\" as the final count of ones.\\n\\nOverall, this algorithm has a time complexity of O(log n) because it iterates through each digit position in \"n\", which has log n digits.\\n\\n# Complexity\\n- Time complexity:\\n81.74%\\n\\n- Space complexity:\\n57.91%\\n# Code\\n```\\nclass Solution:\\n  def countDigitOne(self, n: int) -> int:\\n    ans = 0\\n\\n    pow10 = 1\\n    while pow10 <= n:\\n      divisor = pow10 * 10\\n      quotient = n // divisor\\n      remainder = n % divisor\\n      if quotient > 0:\\n        ans += quotient * pow10\\n      if remainder >= pow10:\\n        ans += min(remainder - pow10 + 1, pow10)\\n      pow10 *= 10\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def countDigitOne(self, n: int) -> int:\\n    ans = 0\\n\\n    pow10 = 1\\n    while pow10 <= n:\\n      divisor = pow10 * 10\\n      quotient = n // divisor\\n      remainder = n % divisor\\n      if quotient > 0:\\n        ans += quotient * pow10\\n      if remainder >= pow10:\\n        ans += min(remainder - pow10 + 1, pow10)\\n      pow10 *= 10\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64441,
                "title": "0ms-recursive-solution-in-c-8-line-code",
                "content": "The idea is check number of 1 for each 10,100,1000,10000 ... position. For example, for 312:\\n\\ncheck 000~099, 100~199, 200~299, 300~312 and sum them up, for 000~099 and 200~299, it's countDigitOne(99), for 100~199 it's 100+countDigitOne(99), and for 300~312 it's countDigitOne(12).\\n\\n    int countDigitOne(int n, int x){\\n        if(n == 0) return 0;\\n        if(n<10 || x==1) return 1;\\n        if(n/x == 1) return n-n/x*x+1+countDigitOne(n-n/x*x)+countDigitOne(x-1);\\n        return x+n/x*countDigitOne(x-1)+countDigitOne(n-n/x*x);\\n    }\\n    \\n    int countDigitOne(int n) {\\n        if(n <= 0) return 0;\\n        int x = 1, y=n;\\n        for(;y>=10;x*=10,y/=10);\\n        return countDigitOne(n, x);\\n    }",
                "solutionTags": [],
                "code": "The idea is check number of 1 for each 10,100,1000,10000 ... position. For example, for 312:\\n\\ncheck 000~099, 100~199, 200~299, 300~312 and sum them up, for 000~099 and 200~299, it's countDigitOne(99), for 100~199 it's 100+countDigitOne(99), and for 300~312 it's countDigitOne(12).\\n\\n    int countDigitOne(int n, int x){\\n        if(n == 0) return 0;\\n        if(n<10 || x==1) return 1;\\n        if(n/x == 1) return n-n/x*x+1+countDigitOne(n-n/x*x)+countDigitOne(x-1);\\n        return x+n/x*countDigitOne(x-1)+countDigitOne(n-n/x*x);\\n    }\\n    \\n    int countDigitOne(int n) {\\n        if(n <= 0) return 0;\\n        int x = 1, y=n;\\n        for(;y>=10;x*=10,y/=10);\\n        return countDigitOne(n, x);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64440,
                "title": "share-my-o-lgn-c-solution-to-number-of-digit-one",
                "content": "\\nshare my O(lgn) solution : \\n    \\n\\n    class Solution {\\n    public:\\n    int countDigitOne(int n) {\\n     \\tlong long base = 1, res = 0, last = 0;\\n\\t\\twhile(n >= base){\\n\\t\\t\\tint index = (n / base) % 10;\\n\\t\\t\\tlong long remain = n - (n / base) * base;\\n\\t\\t\\tif(index > 1){\\n\\t\\t\\t\\tres = res + index * last + base;\\n\\t\\t\\t}else if(index == 1){\\n\\t\\t\\t\\tres = res + index * last + remain + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tres = res + index * last;\\n\\t\\t\\t}\\n\\t\\t\\tlast = last * 10 + base;\\n\\t\\t\\tbase = base * 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    };\\n\\n\\nFollow Up:    you can change the code to meet the new problem `Number of Digit K`, such as `Number of Digit 3`\\n\\n    class Solution {\\n    public:\\n    int countDigitK(int n, int k) {\\n     \\tlong long base = 1, res = 0, last = 0;\\n\\t\\twhile(n >= base){\\n\\t\\t\\tint index = (n / base) % 10;\\n\\t\\t\\tlong long remain = n - (n / base) * base;\\n\\t\\t\\tif(index > k){\\n\\t\\t\\t\\tres = res + index * last + base;\\n\\t\\t\\t}else if(index == k){\\n\\t\\t\\t\\tres = res + index * last + remain + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tres = res + index * last;\\n\\t\\t\\t}\\n\\t\\t\\tlast = last * 10 + base;\\n\\t\\t\\tbase = base * 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int countDigitOne(int n) {\\n     \\tlong long base = 1, res = 0, last = 0;\\n\\t\\twhile(n >= base){\\n\\t\\t\\tint index = (n / base) % 10;\\n\\t\\t\\tlong long remain = n - (n / base) * base;\\n\\t\\t\\tif(index > 1){\\n\\t\\t\\t\\tres = res + index * last + base;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2474367,
                "title": "digit-dp-c-100-explained",
                "content": "```\\n/*\\n\\nBased on whether the position is tight bound or not we have choices for each position\\n\\nCount the total number of digit \\'1\\' appending in all positive no\\'s that are\\nless than or equal to given very big number \"nums\".\\ne.g if nums=\"15\"\\n\\n[1,10,11,12,13,14,15] => total number of ones = 1+1+2+1+1+1+1=8(ans)\\n\\nso\\nlet nums= \"5 6 7 2\"\\n\\nNumber = >   __ __ __ __\\n\\nSo to form all numbers from length 1 to length 4, To fill each position we have \\n10 choices [0,1,2,3,4,5,6,7,8,9]\\n\\nIf we fill as => 0 0 0 2 [number 2 formed]\\n\\nSimilarly by filling all these positions we can form all the numbers till \"nums\" after considering the upper-bound of each position\\n\\n\\nwe have choices for each position as\\n\\nIf first position Has [0-4], than each next position is not tight they can have [0-9]\\n   \\n   [0-4] [0-9] [0-9] [0-9]\\n\\nIf first positio Has \\'5\\', tight bound the next position\\n\\nif second position has [0-5], than each next position is not tight they can have [0,9]\\n   \\n    5 [0-5]  [0-9] [0-9]\\n \\nif second position has \\'6\\', tight bound the next position\\n\\nIf third position has [0-6], than each next position is not tight they can have [0,9]\\n   \\n   5 6  [0-6] [0-9]\\n\\nIf third position has \\'7\\', than tight bound the next position\\n\\n  Last position should be [0-2]\\n\\n  5 6 7 [0-2]\\n\\n\\nSo till here we cover all the positive numbers till \"5672\"\\n\\nSo based on whether the position is tight bound or not we have choices for each position\\n\\n  Think about dp\\n  ----------------\\n\\n int  n=nums.size();\\n\\n  dp[i][tight][countOnes] = Count of all ones in position range [i....n-1] of all numbers \\n\\n  till \"5672\" based on current position i is tight bound or not, \\n\\n  And count of ones till now from positions [0...i-1] are \"countOnes\"\\n\\n  Ans= dp[0][1][0]\\n\\n\\n  \\n*/\\n\\nint dp[10][2][10];\\n\\nclass Solution {\\npublic:\\n    int countDigitOne(int nums) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\n   int i=0,tight=1,countOnes=0;  \\n\\n   // for i=0, tight=1 becouse we cannot put all digits to this position\\n        \\n        string str=to_string(nums);\\n        \\n   return find(i,tight,countOnes,str);\\n\\n        \\n    }\\n    \\nint find(int i,int tight,int countOnes,string nums){\\n    \\n  if(i==nums.size())\\n  return countOnes;\\n\\n  if(dp[i][tight][countOnes]!=-1)\\n  return dp[i][tight][countOnes];\\n\\n  int ub;   // upperBound digit of position i\\n\\n  if(tight==1)\\n  ub=nums[i]-\\'0\\';\\n  else\\n  ub=9;\\n\\n  int ans=0;\\n\\n  for(int d=0;d<=ub;d++){\\n\\n   ans=ans+find(i+1,tight && (d==ub),countOnes + (d==1),nums);\\n      \\n  }\\n\\n  return dp[i][tight][countOnes]=ans;\\n }\\n\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int countDigitOne(int nums) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\n   int i=0,tight=1,countOnes=0;  \\n\\n   // for i=0, tight=1 becouse we cannot put all digits to this position\\n        \\n        string str=to_string(nums);\\n        \\n   return find(i,tight,countOnes,str);\\n\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 64466,
                "title": "clean-c-code-of-log10-n-complexity-with-detailed-explanation",
                "content": "Here's the explanation.\\nFor each digit d_i: \\n\\n1) If d<sub>i</sub> < 1, then the number of 1s on d<sub>i</sub> == factor * (d<sub>i+1</sub> - 1 + 1). Note the last (+1) is for the case when d<sub>i+1</sub> is 0, and the (-1) is for that d<sub>i</sub> == 0 for original d<sub>i+1</sub>.\\n\\nEg. For n == 703, there are in total 7 1s on the ten's digit, when the hundred's digit could be (0~6). And for each 1s on the ten's digit, it could appear 10 times when the one's digit varies from (0~9) for each ten.\\n\\n2) If d<sub>i</sub> == 1, then the number of 1s on d<sub>i</sub> == factor * (d<sub>i+1</sub> - 1 + 1) + (number below d<sub>i</sub> + 1).\\n\\nEg. For n == 713, there are in total 7 1s on the ten's digit, when the digit on the hundreds could be (0~6). And for each 1s on the ten's digit, it could appear 4 times when the one's digit varies from (0~3) for each ten.\\n\\n3) If d<sub>i</sub> > 1, it's similar to 1), whereas in total 8 1s could be on the ten's digit, when the hundred's digit could be (0~7). So the number of 1s on d<sub>i</sub> == factor * (d<sub>i+1</sub> + 1).\\n\\nEg. For n == 723, there are in total 8 1s on the ten's digit, when the digit on the hundreds could be (0~7). And for each 1s on the ten's digit, it could appear 10 times when the one's digit varies from (0~9) for each ten.\\n\\n\\n - *Things in mind:*\\n\\nThere are possibilities where the **count/factor might overflow**. Use long long instead of int for them.\\n\\n\\n  \\n\\n     class Solution {\\n        public:\\n            int countDigitOne(int n) {\\n                if (n <= 0)\\n                    return 0;\\n                \\n                long long count = 0;    //It may cause integer overflow\\n                \\n                long long factor = 1;\\n                \\n                while (n / factor) {\\n                    int lowerNum = n - (n / factor) * factor;\\n                    int currentDigit = (n / factor) % 10;\\n                    int higherDigit = n / (factor * 10);\\n                    \\n                    switch(currentDigit) {\\n                        case 0:\\n                            count += higherDigit * factor;\\n                            break;\\n                        case 1:\\n                            count += higherDigit * factor + (lowerNum + 1);\\n                            break;\\n                        default:\\n                            count += (higherDigit + 1) * factor;\\n                    }\\n                    \\n                    factor *= 10;\\n                }\\n                \\n                return count;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            int countDigitOne(int n) {\\n                if (n <= 0)\\n                    return 0;\\n                \\n                long long count = 0;    //It may cause integer overflow\\n                \\n                long long factor = 1;\\n                \\n                while (n / factor) {\\n                    int lowerNum = n - (n / factor) * factor;\\n                    int currentDigit = (n / factor) % 10;\\n                    int higherDigit = n / (factor * 10);\\n                    \\n                    switch(currentDigit) {\\n                        case 0:\\n                            count += higherDigit * factor;\\n                            break;\\n                        case 1:\\n                            count += higherDigit * factor + (lowerNum + 1);\\n                            break;\\n                        default:\\n                            count += (higherDigit + 1) * factor;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 64407,
                "title": "easy-to-understand-python-solution-can-generalized-to-0-to-9",
                "content": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n        result = 0\\n        # number of appearances for one cycle when 1 appears at position i\\n        i = 1\\n        while n >= i:\\n            # complete cycle, one more complete cycle if current digit > 1\\n            cycle = n / (i * 10) + (1 if n / i % 10 > 1 else 0)\\n            result += cycle * i\\n            # incomplete cycle if current digit == 1\\n            if n / i % 10 == 1:\\n                result += n % i + 1\\n            i *= 10\\n        return result\\n```\\nA cycle is 0~9 for one position. 1 appears a certain number of times in each cycle.\\n\\nFor example, given number 32107.\\n\\nAt position 7, 1 appears 3210 complete cycles, and within each cycle 1 appears once. Also, because 7 > 1, so it can be regarded as one more complete cycle. In total 1 appears 3211 times at position 7.\\n\\nAt position 0, 1 appears 321 complete cycles, and within each cycle 1 appears 10 times, eg, ...10-...19. In total 1 appears 321 * 10 times at position 0.\\n\\nAt position 1, 32 complete cycles, and within each cycle 1 appears 100 times, eg, ..100-..199. Notice here it is 1, so it has incomplete cycle from 32100-32107, which is 32107 % 100 + 1 = 8 times. In total 1 appears 32 * 100 + 8 times at position 1.\\n\\nSo on so forth.\\n\\nA generalized code for any digit 0 ~ 9 is below.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n        result = 0\\n        # number of appearances for one cycle when 1 appears at position i\\n        i = 1\\n        while n >= i:\\n            # complete cycle, one more complete cycle if current digit > 1\\n            cycle = n / (i * 10) + (1 if n / i % 10 > 1 else 0)\\n            result += cycle * i\\n            # incomplete cycle if current digit == 1\\n            if n / i % 10 == 1:\\n                result += n % i + 1\\n            i *= 10\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64469,
                "title": "my-ac-java-solution-with-explanation",
                "content": "    public int countDigitOne(int n) {\\n        if(n <= 0){\\n            return 0;\\n        }\\n        int iCount = 0;\\n        long iFactor = 1;\\n        long iLowerNum = 0;\\n        int iCurrNum = 0;\\n        long iHigherNum = 0;\\n        while (n / iFactor != 0){\\n            iLowerNum = n % iFactor;\\n            iCurrNum = (int)(n / iFactor) % 10;\\n            iHigherNum = n / (iFactor * 10);\\n            switch (iCurrNum){\\n                case 0:\\n                    iCount += iHigherNum * iFactor;\\n                    break;\\n                case 1:\\n                    iCount += iHigherNum * iFactor + iLowerNum + 1;\\n                    break;\\n                default:\\n                    iCount += (iHigherNum + 1) * iFactor;\\n                    break;\\n            }\\n            iFactor *= 10;\\n        }\\n        return iCount;\\n    }\\n\\nabout explanation,you can see here:http://blog.csdn.net/u013027996/article/details/17126977\\nthx!",
                "solutionTags": [],
                "code": "    public int countDigitOne(int n) {\\n        if(n <= 0){\\n            return 0;\\n        }\\n        int iCount = 0;\\n        long iFactor = 1;\\n        long iLowerNum = 0;\\n        int iCurrNum = 0;\\n        long iHigherNum = 0;\\n        while (n / iFactor != 0){\\n            iLowerNum = n % iFactor;\\n            iCurrNum = (int)(n / iFactor) % 10;\\n            iHigherNum = n / (iFactor * 10);\\n            switch (iCurrNum){\\n                case 0:\\n                    iCount += iHigherNum * iFactor;\\n                    break;\\n                case 1:\\n                    iCount += iHigherNum * iFactor + iLowerNum + 1;\\n                    break;\\n                default:\\n                    iCount += (iHigherNum + 1) * iFactor;\\n                    break;\\n            }\\n            iFactor *= 10;\\n        }\\n        return iCount;\\n    }\\n\\nabout explanation,you can see here:http://blog.csdn.net/u013027996/article/details/17126977\\nthx!",
                "codeTag": "Unknown"
            },
            {
                "id": 2064530,
                "title": "java-based-with-detailed-explanation-beats-100",
                "content": "Key intuition is that we count the number of 1\\'s contributed by every digits place in the number.\\nFor e.g. if this is a 3 digit number, some of the 1\\'s would be contributed by the 1\\'s place, some by 10\\'s place and some by 100\\'s place. Let\\'s say we have 109, then one\\'s place contibutes whenver we have 1 in 1\\'s place. Number such as below have 1 in 1\\'s place and contribute\\n\\n```\\nHTO\\n001\\n011\\n021\\n..\\n..\\n101\\n```\\n\\nSimilarly numbers with 1 in tens place contribute.\\n\\n```\\nHTO\\n011\\n012\\n..\\n..\\n019\\n```\\n\\nAnd we can extend this to every other place like hundreds, thousands etc.\\nNow if we count the contribtuion of each place (ones, tens, hundreds etc.) separately and sum them up, we get the total number of 1\\'s in all positive integers <= n.\\n\\nLet\\'s see how we can count the contributions to 1\\'s place and the same algorithm can be extended to tens, hundreds etc. as well.\\n\\nAs we know, for every range of 10 digits like from 0-9, 10-19, 20-29 etc. , 1 appears in 1\\'s place only once. Like for 0-9, it appears once in 1. For 10-19, its appears in 1\\'s place once at 11, for 20-29, it appears in 1\\'s place once in 21. \\n\\nSo if we count the number of 10\\'s in n, we will have as many 1\\'s contributed by the 1\\'s place, For e.g., let\\'s take 50. In this we have 5 tens (50 / 10 = 5). So we will have 5 numbers with 1 at 1\\'s place i.e. 1, 11, 21, 31, 41, So we can say the 5 1\\'s are present at 1\\'s place in all positive integers <= 50.\\n\\nLet\\'s take another example 54. There\\'s a catch here. We also have and extra 1 contributed by 51. To account for this, we need to find the number\\'s beyond the complete 10\\'s that we have in our input n. \\n\\nFor this we do a 54 % 10 which gives 4 and since 4 > 1, we know that we need to count one more 1 at 1\\'s place contributed by 51. So totally 6 1\\'s are there contributed by the 1\\'s place. They are 1, 11, 21, 31, 41, 51\\n\\nNow, let\\'s count the 1\\'s contributed by the 10\\'s place. This would be contributed by numbers such as \\n```\\n10\\n11\\n12\\n```\\n\\nFor calculating these, let\\'s take another example like 154. Extending the algo we used for counting 1\\'s contributed by the 1\\'s place, now we count number of 100\\'s present in the number. Each 100 has 10 numbers which have 1 in tens place i.e 10 to 19. So if we count all the 100\\'s in the number and multiple it by 10, we should get the number of 1\\'s contributed by the 10\\'s place. \\n\\nFor e.g. 200 has 2 hundreds, so totally there are 2*10=20 numbers which have 1 in the tens place. Those numbers are 010-to-019 and 110-to-119.\\n\\nSimilarly, lets calculate for 254. Here in addition to the 20 1\\'s contributed by 0-99 and 100-199, there are more 1\\'s contributed in 10s place by 210-219. Again as we did for 1\\'s place, we do a 254 % 200 = 54.  So we need to count the 1\\'s in 10\\'s place contributed by thr numbers 200-254, As we can see, all the 10 numbers i.e. 210-219  have 1 in 10\\'place. So in total 254 will have 30 number with 1 in 10\\'s place. 10-19, 110-119, 210-219.\\n\\nWe can extend the concept for 100\\'s place and so on and so forth to get the total number of 1\\'s contributed by each place. While the explanation above is quite long winded, the code for doing this is surprisingly very concise.\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int res = 0;\\n        int m = 1;\\n        int k = 0;\\n        while(n >= m) {\\n            int a = (n / (m * 10)) * m;\\n            int b = n % (m * 10) - k;\\n\\n            if(b <= 0) {\\n                b = 0;\\n            } else if(b >= m) {\\n                b = m;\\n            }\\n            res = res + a + b;\\n            m = m * 10;\\n            k = k * 10 + 9;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nHTO\\n001\\n011\\n021\\n..\\n..\\n101\\n```\n```\\nHTO\\n011\\n012\\n..\\n..\\n019\\n```\n```\\n10\\n11\\n12\\n```\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int res = 0;\\n        int m = 1;\\n        int k = 0;\\n        while(n >= m) {\\n            int a = (n / (m * 10)) * m;\\n            int b = n % (m * 10) - k;\\n\\n            if(b <= 0) {\\n                b = 0;\\n            } else if(b >= m) {\\n                b = m;\\n            }\\n            res = res + a + b;\\n            m = m * 10;\\n            k = k * 10 + 9;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377744,
                "title": "o-1-solution-without-dp-without-recursion-simple-math",
                "content": "```\\nint countDigitOne(int n) {\\n        int p=0,ans=0,prev=1;\\n        int num=n%10;\\n        if(num>=1)//if one\\'s digit is greater or equal to 1\\n            ans++;\\n        n=n/10;\\n        while(n!=0)\\n        {\\n            int x=n%10,y=pow(10,prev-1);\\n            n=n/10;\\n            if(x>1)\\n                ans+=y*(x*prev+10);\\n            if(x==1)\\n                ans+=x*prev*y+num+1;\\n            num=x*y*10+num;\\n            prev++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint countDigitOne(int n) {\\n        int p=0,ans=0,prev=1;\\n        int num=n%10;\\n        if(num>=1)//if one\\'s digit is greater or equal to 1\\n            ans++;\\n        n=n/10;\\n        while(n!=0)\\n        {\\n            int x=n%10,y=pow(10,prev-1);\\n            n=n/10;\\n            if(x>1)\\n                ans+=y*(x*prev+10);\\n            if(x==1)\\n                ans+=x*prev*y+num+1;\\n            num=x*y*10+num;\\n            prev++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2207962,
                "title": "easy-to-understand-digit-dp-recursion-memoization",
                "content": "```\\n//Recusive (gives TLE)\\nclass Solution {\\n    int get(string &s,int idx, int count, bool small){\\n        if(idx == s.length()) return count;\\n\\n        int limit;\\n        if(small) limit = 9;\\n        else limit = s[idx] - \\'0\\';\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= limit; i++){\\n            int ncount = i == 1 ? count + 1 : count;\\n            int nsmall = !small && i == limit ? false : true;\\n            ans += get(s , idx + 1, ncount, nsmall);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n     \\n        return get(s,0,0,false);\\n    }\\n};\\n\\n//memoization (100% faster)\\nclass Solution {\\n    int dp[10][10][2];\\n    int get(string &s,int idx, int count, bool small){\\n        if(idx == s.length()) return count;\\n        \\n        if(dp[idx][count][small] != -1)return dp[idx][count][small];\\n        int limit;\\n        if(small) limit = 9;\\n        else limit = s[idx] - \\'0\\';\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= limit; i++){\\n            int ncount = i == 1 ? count + 1 : count;\\n            int nsmall = !small && i == limit ? false : true;\\n            ans += get(s , idx + 1, ncount, nsmall);\\n        }\\n        return dp[idx][count][small] = ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        \\n        return get(s,0,0,false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recusive (gives TLE)\\nclass Solution {\\n    int get(string &s,int idx, int count, bool small){\\n        if(idx == s.length()) return count;\\n\\n        int limit;\\n        if(small) limit = 9;\\n        else limit = s[idx] - \\'0\\';\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= limit; i++){\\n            int ncount = i == 1 ? count + 1 : count;\\n            int nsmall = !small && i == limit ? false : true;\\n            ans += get(s , idx + 1, ncount, nsmall);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n     \\n        return get(s,0,0,false);\\n    }\\n};\\n\\n//memoization (100% faster)\\nclass Solution {\\n    int dp[10][10][2];\\n    int get(string &s,int idx, int count, bool small){\\n        if(idx == s.length()) return count;\\n        \\n        if(dp[idx][count][small] != -1)return dp[idx][count][small];\\n        int limit;\\n        if(small) limit = 9;\\n        else limit = s[idx] - \\'0\\';\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= limit; i++){\\n            int ncount = i == 1 ? count + 1 : count;\\n            int nsmall = !small && i == limit ? false : true;\\n            ans += get(s , idx + 1, ncount, nsmall);\\n        }\\n        return dp[idx][count][small] = ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        \\n        return get(s,0,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073606,
                "title": "dynamic-programming-solution-overview-digit-dp",
                "content": "The official leetcode solution involves observing patterns and coming up with a solution accordingly. I do not think this is easy to do in an interview setting. That combined with the high number of thumbs down on this question prompted me to make this post where I explain how I would approach this problem.\\n\\nThis problem can be solved by Dynamic Programming which I think is a far more intuitive way to approach the solution.\\n\\n----\\n\\n**Brute Force**\\n\\nThe brute force solution involves iterating over all the numbers from `0..n` and counting the number of 1s for each number\\n\\n```\\nresult = 0\\nfor i in range 0..n:\\n\\tresult += getNumberOfOnes(i)\\nreturn result\\n```\\n\\nThis is not good enough for obvious reasons. An alternate way to do this would be to write a function to generate all numbers from `0..n` and keep track of the total number of `\\'1\\'s` we have generated so far.\\n\\n**Generating numbers**\\n\\nThe question is how to generate these numbers? Say we have `n = 999` how can we generate all numbers from `0...999`? The answer is to do this digit by digit.\\n\\nWe know that `999` has three digits so we want to generate all digits from `000, 001, 002 ... 998, 999`. To do this we can define a function `f(i, prev)` that fills in the `\\'i\\'th` digit where `prev` is the previously generated digit.\\n\\nFor the sake of simplicity, let\\'s generate the numbers as strings. Here `f(0, \"\")` will generate our answer as we want to first fill in the `0th` index and we have not generated anything so far. We can write this function as follows:\\n\\n```\\nvoid f(i, prev):\\n    if(i == 3):\\n\\t\\tprint prev // we have generated a 3 digit string - print it\\n\\t\\treturn\\n\\telse:\\n\\t\\tfor digit in range 0..9:\\n\\t\\t\\tnewDigitGenerated = prev + digit\\n\\t\\t\\tf(i+1, newDigitGenerated)\\n```\\n\\n**The problem - Generating numbers from 0..n**\\n\\nThe problem with the above code is that it is not generic - it can only generate numbers from `0...999` it cannot generate numbers upto any arbitrary `n`. Let\\'s say we had a different `n = 547` how can we modify our function to generate all numbers within our limit?\\n\\nLet\\'s examine what we need to do to generate numbers from `0...547`\\n- For the `0th` digit we need to choose a digit from `0..5`\\n- For the `1st` digit we need to choose digits based on the following:\\n\\t- If the `0th` digit was `5`, then the `1st` digit needs to be from `0..4`\\n\\t- If the `0th` digit was NOT `5`, then the `1st` digit can be anything from `0..9`\\n- For the `2nd` digit we need to choose digits based on the following:\\n\\t- If the `0th` digit was `5` AND the `1st` digit was `4`, then the `2nd` digit should be from `0..7`\\n\\t- Otherwise the `2nd` digit should be from `0..9`\\n\\nIn summary, the upper bound the `ith` digit can take is based on the previous digits generated. However this upper bound restriction is put into effect only when we hit the upper bound for all `0...i-1` generated digits. So we can simply use a flag to track if the upper bound should be used or not.\\n\\nBased on the observations above, let\\'s modify our function as follows: Let `f(i, flag, prev)` generate all numbers from `0..n` that fills in the `ith` digit based on the `flag` boolean and where `prev` contains the list of previous digits.\\n- If `flag = true` then the upper bound limit is applied\\n- If `flag = false` then we can choose any digit from `0..9` as the new digit\\n\\nOur function now looks like this:\\n\\n```\\nint number = 547\\ncall f(0, true, \"\")\\n\\n----\\n\\nvoid f(i, flag, prev):\\n\\tif(i == number.length):\\n\\t\\tprint prev // we have generated result string - print it\\n\\t\\treturn\\n\\telse:\\n\\t\\tint limit = 9\\n\\t\\tif(flag == true):\\n\\t\\t\\tlimit = number.digitAt(i)\\n\\t\\t\\tfor digit in range 0..limit:\\n\\t\\t\\t\\tif(digit == limit):\\n\\t\\t\\t\\t\\tf(i+1, true, prev + digit)\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tf(i+1, false, prev + digit)\\n\\t\\telse:\\n\\t\\t\\tfor digit in range 0..9:\\n\\t\\t\\t\\tf(i+1, false, prev + digit)\\n```\\n\\n-------\\n\\n**Dynamic Programming Solution: The recurrence relation**\\n\\nThe idea behind the DP solution is to generate digits similar to the process described above. While we generate digits, we can simply keep track of the number of `1s` that we generated.\\n\\nLet\\'s define `f(i, flag, count)` that will return number of 1s in all digits in `digit[i...n]`. \\n- Here `count` tracks the number of `1s` generated so far. \\n- Let `flag` be an int. If `flag == 1` then we mark it as true else if `flag == 0` we mark it as false.\\n\\nThe recurrence will be as follows:\\n\\n```\\nf(i, flag, count) = count // if i = number.length\\n\\n// if flag = 1 (apply limits)\\nf(i, flag, count) += for digit in 0...number[i]:\\n\\t\\t\\t\\t\\t\\tcountOfOnes = count\\n\\t\\t\\t\\t\\t\\tif digit == 1:\\n\\t\\t\\t\\t\\t\\t\\tcountOfOnes++\\n\\t\\t\\t\\t\\t\\tif(digit == number[i]):\\n\\t\\t\\t\\t\\t\\t\\tf(i+1, 1, countOfOnes)\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tf(i+1, 0, countOfOnes)\\n\\n// if flag = 0 (dont apply limits)\\nf(i, flag, count) += for digit in 0...number[i]:\\n\\t\\t\\t\\t\\t\\tcountOfOnes = count\\n\\t\\t\\t\\t\\t\\tif digit == 1:\\n\\t\\t\\t\\t\\t\\t\\tcountOfOnes++\\n\\t\\t\\t\\t\\t\\tf(i+1, 0, countOfOnes)\\n```\\n\\n---------\\n\\n**Final DP solution**\\n\\nWe can now translate the recurrence to a DP solution.\\n\\nIn the following code I convert a number into an int array - here `100` will be converted into `[1, 0, 0]` - it is just to make things a bit more convenient:\\n\\n```\\n    private int[] getLimitArray(int n) {\\n        String num = n + \"\";\\n        int[] limits = new int[num.length()];\\n        for(int i = 0; i<num.length(); i++) {\\n            limits[i] = Character.getNumericValue(num.charAt(i));\\n        }\\n        return limits;\\n    }\\n```\\n\\nWe can now use a dp array to store our state - the foll code is as follows:\\n\\n```\\n    public int countDigitOne(int n) {\\n        int[] limits = getLimitArray(n);\\n        int[][][] dp = new int[limits.length+1][2][limits.length+2];\\n        \\n        for(int index = limits.length; index >= 0; index--) {\\n            for(int flag = 0; flag <= 1; flag++) {\\n                for(int count = limits.length; count >= 0; count--) {\\n                    if(index == limits.length) {\\n                        dp[index][flag][count] = count;\\n                    } else {\\n                        int result = 0;\\n                        if(flag == 1) {\\n                            for(int i = 0; i <= limits[index]; i++) {\\n                                int newCount = count;\\n                                if(i == 1)\\n                                    newCount++;\\n                                if(i == limits[index]) {\\n                                    result += dp[index+1][1][newCount];\\n                                } else {\\n                                    result += dp[index+1][0][newCount];\\n                                }\\n                            }\\n                        } else {\\n                            for(int i = 0; i <= 9; i++) {\\n                                int newCount = count;\\n                                if(i == 1)\\n                                    newCount++;\\n                                result += dp[index+1][0][newCount];\\n                            }\\n                        }\\n                        dp[index][flag][count] = result;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][0];\\n    }\\n```\\n\\n---------\\n\\n**Complexity**\\n\\n- i can go from 0...number of digits which is log base 10 (n)\\n- flag can be either 0 or 1 which is constant\\n- Max count of 1s for any number generated is the number of digits which is log base 10 (n)\\n\\nHence complexity if O(log10(n)^2)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nresult = 0\\nfor i in range 0..n:\\n\\tresult += getNumberOfOnes(i)\\nreturn result\\n```\n```\\nvoid f(i, prev):\\n    if(i == 3):\\n\\t\\tprint prev // we have generated a 3 digit string - print it\\n\\t\\treturn\\n\\telse:\\n\\t\\tfor digit in range 0..9:\\n\\t\\t\\tnewDigitGenerated = prev + digit\\n\\t\\t\\tf(i+1, newDigitGenerated)\\n```\n```\\nint number = 547\\ncall f(0, true, \"\")\\n\\n----\\n\\nvoid f(i, flag, prev):\\n\\tif(i == number.length):\\n\\t\\tprint prev // we have generated result string - print it\\n\\t\\treturn\\n\\telse:\\n\\t\\tint limit = 9\\n\\t\\tif(flag == true):\\n\\t\\t\\tlimit = number.digitAt(i)\\n\\t\\t\\tfor digit in range 0..limit:\\n\\t\\t\\t\\tif(digit == limit):\\n\\t\\t\\t\\t\\tf(i+1, true, prev + digit)\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tf(i+1, false, prev + digit)\\n\\t\\telse:\\n\\t\\t\\tfor digit in range 0..9:\\n\\t\\t\\t\\tf(i+1, false, prev + digit)\\n```\n```\\nf(i, flag, count) = count // if i = number.length\\n\\n// if flag = 1 (apply limits)\\nf(i, flag, count) += for digit in 0...number[i]:\\n\\t\\t\\t\\t\\t\\tcountOfOnes = count\\n\\t\\t\\t\\t\\t\\tif digit == 1:\\n\\t\\t\\t\\t\\t\\t\\tcountOfOnes++\\n\\t\\t\\t\\t\\t\\tif(digit == number[i]):\\n\\t\\t\\t\\t\\t\\t\\tf(i+1, 1, countOfOnes)\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tf(i+1, 0, countOfOnes)\\n\\n// if flag = 0 (dont apply limits)\\nf(i, flag, count) += for digit in 0...number[i]:\\n\\t\\t\\t\\t\\t\\tcountOfOnes = count\\n\\t\\t\\t\\t\\t\\tif digit == 1:\\n\\t\\t\\t\\t\\t\\t\\tcountOfOnes++\\n\\t\\t\\t\\t\\t\\tf(i+1, 0, countOfOnes)\\n```\n```\\n    private int[] getLimitArray(int n) {\\n        String num = n + \"\";\\n        int[] limits = new int[num.length()];\\n        for(int i = 0; i<num.length(); i++) {\\n            limits[i] = Character.getNumericValue(num.charAt(i));\\n        }\\n        return limits;\\n    }\\n```\n```\\n    public int countDigitOne(int n) {\\n        int[] limits = getLimitArray(n);\\n        int[][][] dp = new int[limits.length+1][2][limits.length+2];\\n        \\n        for(int index = limits.length; index >= 0; index--) {\\n            for(int flag = 0; flag <= 1; flag++) {\\n                for(int count = limits.length; count >= 0; count--) {\\n                    if(index == limits.length) {\\n                        dp[index][flag][count] = count;\\n                    } else {\\n                        int result = 0;\\n                        if(flag == 1) {\\n                            for(int i = 0; i <= limits[index]; i++) {\\n                                int newCount = count;\\n                                if(i == 1)\\n                                    newCount++;\\n                                if(i == limits[index]) {\\n                                    result += dp[index+1][1][newCount];\\n                                } else {\\n                                    result += dp[index+1][0][newCount];\\n                                }\\n                            }\\n                        } else {\\n                            for(int i = 0; i <= 9; i++) {\\n                                int newCount = count;\\n                                if(i == 1)\\n                                    newCount++;\\n                                result += dp[index+1][0][newCount];\\n                            }\\n                        }\\n                        dp[index][flag][count] = result;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64443,
                "title": "6-lines-c-o-logn-solution",
                "content": "    int countDigitOne(int n) {\\n        int ans = 0;\\n        for(long long m = 1; m <= n; m = m * 10) {\\n            int before = (n / m) / 10, x = (n / m) % 10, after = n % m;\\n            ans += (before + (x > 1 ? 1: 0)) * m + (x == 1 ? (after + 1) : 0);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    int countDigitOne(int n) {\\n        int ans = 0;\\n        for(long long m = 1; m <= n; m = m * 10) {\\n            int before = (n / m) / 10, x = (n / m) % 10, after = n % m;\\n            ans += (before + (x > 1 ? 1: 0)) * m + (x == 1 ? (after + 1) : 0);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3295121,
                "title": "beats-100-c",
                "content": "Please upvote <3\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res=0;\\n        for(long long i=1;i<=n;i*=10){\\n            long long d=i* 10; \\n            res+=(n/d) *i; \\n            int r=n%d;\\n            if(r>= 2*i)\\n                res+=i;\\n            else if(r>=i)\\n                res+=r-i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res=0;\\n        for(long long i=1;i<=n;i*=10){\\n            long long d=i* 10; \\n            res+=(n/d) *i; \\n            int r=n%d;\\n            if(r>= 2*i)\\n                res+=i;\\n            else if(r>=i)\\n                res+=r-i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310928,
                "title": "cpp-easy-100-beats-implementation-of-given-solution",
                "content": "```\\nif(n <= 0)\\n\\treturn 0;\\nlong int count = (n/10) + (n%10 != 0), tens = 10, c = 2;\\nwhile(n){\\n\\ttens = pow(10, c++);\\n\\tcount += (n/tens) * (tens/10) + min(max(n % tens - (tens/10) + 1, (long)0), tens/10);\\n\\tif(n/tens == 0)\\n\\t\\tbreak;\\n}\\nreturn count;\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nif(n <= 0)\\n\\treturn 0;\\nlong int count = (n/10) + (n%10 != 0), tens = 10, c = 2;\\nwhile(n){\\n\\ttens = pow(10, c++);\\n\\tcount += (n/tens) * (tens/10) + min(max(n % tens - (tens/10) + 1, (long)0), tens/10);\\n\\tif(n/tens == 0)\\n\\t\\tbreak;\\n}\\nreturn count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64428,
                "title": "share-my-recursive-solution-with-prove-and-explanation",
                "content": "The problem is:\\n\\n**Given an integer *n*, count the total number of digit *1* appearing in all *non-negative integers less than or equal to n*.**\\n\\nThe whole problem is a little bit complicated. Let's write down **the count for small *n*'s.**\\n\\n - **B0: 0~9: *1*(only *1*)**\\n - **B1: 10~19: *10*(every number has *1* at the beginning,*10* in total) + *1*(for *11*) = *11***\\n - **B2: 20~29:  *1*(only *21*)**\\n - **B3: 30~39:  *1*(only *31*)**\\n - **......**\\n - **B9: 90~99:  *1*(only *91*)**\\n\\n**C0**: Until here, the total ***1***'s  of **0~99** is ***1+(10+1)+1+1+1+1+1+1+1+1= 10\\xd71+10***\\n\\n(**Explanation: ten *1*'s, and for  *10~19* has an additional *10***)\\n\\nIf we continue:\\n\\n- **100~109: *10*(hundreds digit,*10* in total) + *1*(for *101*)**\\n- **110~119: *10*(hundreds digit,*10* in total) + *10*(tens digit,*10* in total) + *1*(for *111*)**\\n- **120~129: *10*(hundreds digit,*10* in total) + *1*(for *121*)**\\n- **130~139: *10*(hundreds digit,*10* in total) + *1*(for *131*)**\\n- **......**\\n- **190~199: *10*(hundreds digit,*10* in total) + *1*(for *191*)**\\n\\n**The total *1*'s  of 100~199 is**\\n\\n**C1**: ***10\\xd710*(hundreds digit)+*1+(10+1)+1+1+1+1+1+1+1+1=10\\xd710+(10\\xd71+10)(10\\xd710* + the SAME of 0~99)**\\n\\n- **200~209: *1*(for *201*)**\\n- **210~219: *10*(tens digit,*10* in total) + *1*(for *211*)**\\n- **220~229: *1*(for *221*)**\\n- **230~239: *1*(for *231*)**\\n- **......**\\n- **290~299: *1*(for *291*)**\\n\\n**C2**: **The total *1*'s  of 200~299 is *1+(10+1)+1+1+1+1+1+1+1+1= 10\\xd71+10*(SAME as 0~99)**\\n\\n- **...................**\\n\\n- **900~909: *1*(for *901*)**\\n- **910~919: *10*(tens digit,*10* in total) + *1*(for *911*)**\\n- **920~929: *1*(for *921*)**\\n- **930~939: *1*(for *931*)**\\n- **......**\\n- **990~999: *1*(for *991*)**\\n\\n**C9**: **The total *1*'s  of 900~999 is *1+(10+1)+1+1+1+1+1+1+1+1= 10\\xd71+10*(SAME as 0~99)**\\n\\nHere, we can know that:\\n\\n**IMPORTANT: The total *1*'s  of X00~X99 (X is [2,9]) is the SAME as the total *1* 's in 0~99**\\n\\nUntil here, the total ***1***'s  of **0~999** is\\n\\n**C0 + C1+ ...+C9** = **10\\xd7(the total *1* 's in 0~99) + 10\\xd710(from 100~199)**\\n\\nIf we go back to the total ***1***'s  of **0~99**:\\n\\n**B0 + B1+ ...+B9** =  **10\\xd7(the total *1* 's in 0~9) + 10(from 10~19)**\\n\\nIf we go back to the total ***1***'s  of **0~9**:\\n\\n**B0 = 1**\\n\\n----------\\n**Result:**\\n----------\\nHere, we can get a **SERIES RECURSION FORMULA**: ***A(n+1) = 10A(n) + 10^n***\\n\\nThis formula is for ***the count of 1's from 0 to 10^n - 1 (9999... n 9's).***\\n\\nIf we write some:\\n\\n***A(1) = B0 = 1 = 1\\xd71;***\\n\\n***A(2) = 10A(1)+10 = 20 = 2 \\xd7 10;***\\n\\n***A(3) = 10A(2)+100 = 300 = 3 \\xd7 100;***\\n\\n....\\n\\nWe can guess the **SERIES GENERAL TERM FORMULA**: ***A(n) = n\\xd710^(n-1)***;\\n\\n----------\\n**Prove:**\\n----------\\n***A(n+1) = (n+1)\\xd710^n;***\\n\\n***10A(n) + 10^n = n\\xd710^n + 10^n = (n+1)\\xd710^n;***\\n\\n***A(n+1) = 10A(n) + 10^n;***\\n\\n***A(1) = 1\\xd710^0 = 1; PROVED***\\n\\nHere, we ***come back to the original problem*** to count *1*'s for a ***GENERAL NUMBER A0A1A2...An***.\\n\\nWe can ***DIVIDE*** the problem to **3 STEPS**:\\n\\n----------\\n\\n**STEP *1***: GET ***n***\\n\\n**Q: Why to get *n*?**\\n\\nWe want to find out the **MAXIMUM *(10^n)-1* NO MORE THAN** a **GENERAL NUMBER *A0A1A2...An***\\n\\nThan we can calculate ***A(n)* (the total *1*'s from *0* to *(10^n)-1*) FIRST** since it will be the ***FIRST PART*** of the total *1*'s from ***0*** to ***A0A1A2...An***.\\n\\nHere, ***n* is got by divide ***A0A1A2...An*** to zero.**\\n\\n----------\\n\\n**STEP *2***: GET ***A0***\\n\\n**Q: Why to get *A0*?**\\n\\nWe want to find out **the count of *1*'s** which ***comes from*** the ***TOP DIGIT*** from ***0* to *A0A1A2...An***.\\n\\nHere,**if *A0* is *1***,\\n\\n**the count of *1*'s** which **comes from** the **TOP DIGIT** from ***0* to *A0A1A2...An*** is **A1A2...An + 1**\\n\\n(**From *10...0* to *1A1A2...An***)\\n\\n**if *A0* is not *1***,\\n\\n**the count of *1*'s** which **comes from** the ***TOP DIGIT*** from ***0* to *A0A1A2...An*** is **10^n**\\n\\n(**From *10...0* to *199...9***)\\n\\nThis will be the ***SECOND PART*** of the total.\\n\\n----------\\n\\n**STEP *3***: **Recursively using the method to *A1A2...An***\\n\\nTill now, the final result is got by adding the ***A0 \\xd7 FIRST PART*** and ***SECOND PART*** and **the number of *1*'s from *0* to *A1A2...An***.\\n\\nQ: Why ***A0 \\xd7 FIRST PART***:\\n\\nIf we ***IGNORE*** the ***1***'s brought by ***A0*** and **from *A00...0* (n *0*'s) to *A0A1A2...An***, the count of ***1***'s is ***A0 \\xd7 FIRST PART***.\\n\\n----------\\nFunction definition (**countDigitOne**):\\n\\n - If there is **ONLY ONE** digit left in the **INPUT** (**An** here, **An** in [0,9]),\\n   - If An is **NO MORE THAN ZERO**, return **ZERO**\\n   - Else, return **ONE**\\n - If there is **MORE THAN ONE** digit left in the **INPUT**, \\nreturn **A0 \\xd7 FIRST PART** + **SECOND PART** + countDigitOne(**A1A2...An**);\\n\\n----------\\n\\n    class Solution\\n    {\\n    public:\\n        int digitCount(int &input)\\n        {\\n            int digit = 0;\\n            while(true)\\n            {\\n                 input /= 10;\\n                 digit++;\\n                 if(input < 10)break;\\n            }\\n            digit++;\\n            return digit;\\n       }\\n       //A(n) = 10 * A(n-1) + 10^(n-1)\\n       //A(n) = n * 10^(n - 1)\\n    \\n       int countDigitOne(int n) {\\n            int input = n;\\n            if(input <= 0)\\n            {\\n                return 0;\\n            }else{\\n                if(input < 10 )\\n                {\\n                    return 1;\\n                }else{\\n                    int highestDigit = n;\\n                    int digitNum = digitCount(highestDigit);\\n                    int sum = 0;\\n                    //A0 * First Part\\n                    sum += highestDigit * (digitNum - 1) * pow(10, digitNum - 2);\\n                    //Second Part\\n                    if(highestDigit == 1)\\n                    {\\n                        sum += n - highestDigit * pow(10, digitNum - 1) + 1;\\n                    }else{\\n                        sum += pow(10, digitNum - 1);\\n                    }\\n                    //Third Part\\n                    return sum + countDigitOne(n - highestDigit * pow(10, digitNum - 1));\\n               }\\n           }\\n       }\\n    };\\n\\n----------\\nThe **time complexity**:\\n\\nIf ***N*** = ***A1A2...Ak***,\\n\\nT(***A1A2...Ak***) = T(***A2...Ak***) + ***O(lg(A1A2...Ak))***\\n\\nT(***A2A3...Ak***) = T(***A3...Ak***) + ***O(lg(A2A3...Ak))***\\n\\n........................................................\\n\\nT(***Ak-1Ak***) = T(***Ak***) + ***O(lg(Ak-1Ak))***\\n\\nT(***Ak***) = ***O(1)***\\n\\nWe have:\\n\\nT(***N***) = T(***A1...Ak***) \\n\\n= ***O(1)*** + ***O(lg(Ak-1Ak))*** + ... + ***O(lg(A2...Ak))*** + ***O(lg(A1...Ak))***\\n\\n=***O(1)*** + ***O(2)*** + ... + ***O(k-1)*** + ***O(k)*** (***due to digitCount()***)\\n\\n=***O(k(k+1)/2)***\\n\\n=***O(k^2)***\\n\\n=***O((logN)^2)***\\n\\n***time complexity is O((logN)^2)***\\n\\n***As we know the total digit number (like 10000 is 5) at the first round***, \\n\\n***if we put it as countDigitOne's another argument or set it as a global variable***,\\n\\n***the time complexity can be decreased to O(logN)***",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution\\n    {\\n    public:\\n        int digitCount(int &input)\\n        {\\n            int digit = 0;\\n            while(true)\\n            {\\n                 input /= 10;\\n                 digit++;\\n                 if(input < 10)break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64429,
                "title": "mark-a-general-case-c-template-for-the-k-is-any-one-of-range-0-9",
                "content": "Just like others' post, we just check all the possible position one by one, for each position, we need to check the left part and the right part seperately.\\n\\nHere is the AC implementation .....\\n\\n    class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            long long result = 0;\\n            int left = n, right = 1, remain = 0;\\n            while(left > 0) {\\n                int digit = left % 10;\\n                left = left / 10;\\n                if(digit == 1) {\\n                    /** [0,left) **/\\n                    result += left * right;\\n                    /** left **/\\n                    result += remain + 1;\\n                } else if(digit == 0) {\\n                    result += left * right;\\n                } else {\\n                    result += (left + 1) * right;\\n                }\\n                remain += digit * right;\\n                right *= 10;\\n            }\\n            return result;\\n        }\\n    };\\n\\n**Here is a general version C++ implementation, we can count the occurence of any number k ( 0 - 9) in the range from 0 to n.**\\n\\nThe corner case is that when k == 0,  if the position is from the 100, then the number start with \"0\" is invalid . \\n\\nSo we need to add this line to avoid the special case :\\n\\n                if(k == 0 && multiplier > 1) {\\n                      cnt -= multiplier;\\n                }\\nHere is the C++ implementation \\n\\n    class Solution {\\n    public:\\n        /*\\n         * param k : As description.\\n         * param n : As description.\\n         * return: How many k's between 0 and n.\\n         */\\n        int digitCounts(int k, int n) {\\n            int cnt = 0;\\n            int multiplier = 1, left_part = n, right_part = 0;\\n            if(n == 0) {\\n                return k < 1;\\n            }\\n    \\n            while (left_part > 0) {\\n                int digit = left_part % 10;\\n                left_part /= 10;\\n    \\n                if(digit == k) {\\n                    cnt += left_part * multiplier;\\n                    cnt += right_part + 1;\\n                } else if (digit < k) {\\n                    cnt += left_part * multiplier;\\n                } else {\\n                    cnt += (left_part + 1) * multiplier;\\n                }\\n                /** this part is really tricky **/\\n                if(k == 0 && multiplier > 1) {\\n                    cnt -= multiplier;\\n                }\\n                right_part += digit * multiplier;\\n                multiplier *= 10;\\n            }\\n            return cnt;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            long long result = 0;\\n            int left = n, right = 1, remain = 0;\\n            while(left > 0) {\\n                int digit = left % 10;\\n                left = left / 10;\\n                if(digit == 1) {\\n                    /** [0,left) **/\\n                    result += left * right;\\n                    /** left **/\\n                    result += remain + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 64462,
                "title": "python-recursive-solution-with-comments",
                "content": "        \\n    def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        if 1 <= n <= 9:\\n            return 1\\n        # compute the first bit\\n        head, level = n, 1\\n        while head > 9:\\n            level *= 10\\n            head //= 10\\n        # if the first bit is 1\\n        # like 191, divide it into (0-99), (0-91) and the first bit in (100, 101, 1.., 191)\\n        if head == 1:\\n            return  self.countDigitOne(level-1) + self.countDigitOne(n-level) + n-level +1\\n        # like 491, divide it into (0-99), (100-199), (200-299, 300-399) and (400-491)\\n        return (head) * self.countDigitOne(level-1) + self.countDigitOne(n-head*level) + level",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        if 1 <= n <= 9:\\n            return 1\\n        # compute the first bit\\n        head, level = n, 1\\n        while head > 9:\\n            level *= 10\\n            head //= 10\\n        # if the first bit is 1\\n        # like 191, divide it into (0-99), (0-91) and the first bit in (100, 101, 1.., 191)\\n        if head == 1:\\n            return  self.countDigitOne(level-1) + self.countDigitOne(n-level) + n-level +1\\n        # like 491, divide it into (0-99), (100-199), (200-299, 300-399) and (400-491)\\n        return (head) * self.countDigitOne(level-1) + self.countDigitOne(n-head*level) + level",
                "codeTag": "Python3"
            },
            {
                "id": 64477,
                "title": "my-recursion-implementation",
                "content": "    int countDigitOne(int n) {\\n       if(n <= 0)\\n            return 0;\\n    \\n    \\n       int j = 1;\\n       int k = n ;\\n       int constant = 0;\\n       while(k >= 10)\\n       {\\n           k = k/10;\\n           j = j *10;\\n       }\\n       if( k > 1)\\n       {\\n           constant = j;\\n       }\\n       else\\n       {\\n           constant = n%j+1;\\n       }\\n       return constant + k*countDigitOne(j-1)+countDigitOne(n%j);\\n    }",
                "solutionTags": [],
                "code": "    int countDigitOne(int n) {\\n       if(n <= 0)\\n            return 0;\\n    \\n    \\n       int j = 1;\\n       int k = n ;\\n       int constant = 0;\\n       while(k >= 10)\\n       {\\n           k = k/10;\\n           j = j *10;\\n       }\\n       if( k > 1)\\n       {\\n           constant = j;\\n       }\\n       else\\n       {\\n           constant = n%j+1;\\n       }\\n       return constant + k*countDigitOne(j-1)+countDigitOne(n%j);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3374411,
                "title": "10-lines-digit-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can apply digit dp here\\nhere n<= 1e9 so , string length will be atmost 10\\nwe can keep three states , string processed so far by (idx) ,  if we have already taken less than the number (by a boolean flag)\\nAnd number of ones in the current number\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    int solve(string &s, int idx,int cnt, bool flag){\\n        if(idx == s.size()){\\n            return cnt;\\n        }\\n        if(dp[idx][cnt][flag]!=-1) return dp[idx][cnt][flag];\\n        char ub = \\'9\\';\\n        if(flag) ub = s[idx];\\n        int count = 0;\\n        for(char x = \\'0\\'; x <= ub; x++){\\n            bool new_flag = flag & (x == ub);\\n            int new_cnt = cnt;\\n            if(x == \\'1\\') new_cnt++;\\n            count += solve(s,idx+1,new_cnt,new_flag);\\n        }\\n        return dp[idx][cnt][flag] = count;\\n    }\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,0,0,true);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    int solve(string &s, int idx,int cnt, bool flag){\\n        if(idx == s.size()){\\n            return cnt;\\n        }\\n        if(dp[idx][cnt][flag]!=-1) return dp[idx][cnt][flag];\\n        char ub = \\'9\\';\\n        if(flag) ub = s[idx];\\n        int count = 0;\\n        for(char x = \\'0\\'; x <= ub; x++){\\n            bool new_flag = flag & (x == ub);\\n            int new_cnt = cnt;\\n            if(x == \\'1\\') new_cnt++;\\n            count += solve(s,idx+1,new_cnt,new_flag);\\n        }\\n        return dp[idx][cnt][flag] = count;\\n    }\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,0,0,true);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058640,
                "title": "digit-dp-ez-solution-explained-with-comments",
                "content": "**Time Complexity : O(10 * n * sum * tight)**\\n**Space Complexity : O ( 11 * 200 * 2)**\\n```\\nclass Solution {\\npublic:\\n    int dp[11][200][2];\\n    long long  digitDP(vector<int>&num,int n,long long sum,int tight){\\n        long long x=0ll;\\n        if(n==-1){//Base Condition\\n            return sum;\\n        }\\n        if(dp[n][sum][tight]!=-1)//Value present in our dp array\\n            return dp[n][sum][tight];\\n        \\n        int k=tight?num[n]:9;//Finding range of value to be calculated\\n        /*\\n            If the tight value is 1 then the digit at \\'n\\' will be  max 0 to num[n] else\\n            the maximum value can be 0 till 9 [ Unrestricted]\\n        */\\n        \\n        for(int i=0;i<=k;i++){\\n            int newTight=num[n]==i?tight:0;//Calculating the next tight value on basis of the current. 1 indicates restricted. 0 indicates unrestricted\\n            if(i==1)\\n                x+=digitDP(num,n-1,sum+1,newTight);//The current digit is one so we add it to the sum\\n            else\\n                 x+=digitDP(num,n-1,sum,newTight);//Current digit is not one so we move to the next digit\\n          \\n        }\\n        dp[n][sum][tight]=x;\\n        return x;\\n    }\\n    int calc(int n){\\n        vector<int>num;//To store the each digit of a given number as a vector\\n        while(n){\\n            num.push_back(n%10);\\n            n/=10;\\n        }\\n        return digitDP(num,num.size()-1,0,1);\\n    }\\n    int countDigitOne(int n) {\\n        memset(dp,-1,sizeof(dp));\\n      return calc(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][200][2];\\n    long long  digitDP(vector<int>&num,int n,long long sum,int tight){\\n        long long x=0ll;\\n        if(n==-1){//Base Condition\\n            return sum;\\n        }\\n        if(dp[n][sum][tight]!=-1)//Value present in our dp array\\n            return dp[n][sum][tight];\\n        \\n        int k=tight?num[n]:9;//Finding range of value to be calculated\\n        /*\\n            If the tight value is 1 then the digit at \\'n\\' will be  max 0 to num[n] else\\n            the maximum value can be 0 till 9 [ Unrestricted]\\n        */\\n        \\n        for(int i=0;i<=k;i++){\\n            int newTight=num[n]==i?tight:0;//Calculating the next tight value on basis of the current. 1 indicates restricted. 0 indicates unrestricted\\n            if(i==1)\\n                x+=digitDP(num,n-1,sum+1,newTight);//The current digit is one so we add it to the sum\\n            else\\n                 x+=digitDP(num,n-1,sum,newTight);//Current digit is not one so we move to the next digit\\n          \\n        }\\n        dp[n][sum][tight]=x;\\n        return x;\\n    }\\n    int calc(int n){\\n        vector<int>num;//To store the each digit of a given number as a vector\\n        while(n){\\n            num.push_back(n%10);\\n            n/=10;\\n        }\\n        return digitDP(num,num.size()-1,0,1);\\n    }\\n    int countDigitOne(int n) {\\n        memset(dp,-1,sizeof(dp));\\n      return calc(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818053,
                "title": "c-0-ms-100-fast-digit-dp-easy-to-understand",
                "content": "Consider you have a number of length ```l```, and you have ```m``` places left to fill in the number. So if the number before the place you want to fill in now is lesser than the number in the original number, you have complete freedom to fill any number from ```0-9``` in this place and call recursively again and add them up. If it exactly equal to the number in the last place then you have certain tightness to fill in the number at current place, you can fill up only till the number present in the current place in the original number. So like this only we can recursion and memoize.\\n\\nThe base case would be when we have 0 places left to fill, so we should simply return the number of ones till now.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> digit;\\n    int dp[11][11][2];\\n    int solve(int m, int l, int ones, int tight){\\n        if(m==0){\\n            return ones;\\n        }\\n        if(dp[m][ones][tight]!=-1){\\n            return dp[m][ones][tight];\\n        }\\n        int ans = 0;\\n        if(tight){\\n            for(int i = 0; i<digit[l-m]; i++){\\n                ans += solve(m-1,l,ones+(i==1?1:0),0);\\n            }\\n            ans += solve(m-1,l,ones+(digit[l-m]==1?1:0),1);\\n        }else{\\n            for(int i = 0; i<10; i++){\\n                ans += solve(m-1,l,ones+(i==1?1:0),0);\\n            }\\n        }\\n        return dp[m][ones][tight] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        if(n==0)return 0;\\n        int l = log10(n)+1;\\n        vector<int> digits;\\n        while(n){\\n            digits.push_back(n%10);\\n            n=n/10;\\n        }\\n        reverse(digits.begin(),digits.end());\\n        digit=digits;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(l,l,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```l```\n```m```\n```0-9```\n```\\nclass Solution {\\npublic:\\n    vector<int> digit;\\n    int dp[11][11][2];\\n    int solve(int m, int l, int ones, int tight){\\n        if(m==0){\\n            return ones;\\n        }\\n        if(dp[m][ones][tight]!=-1){\\n            return dp[m][ones][tight];\\n        }\\n        int ans = 0;\\n        if(tight){\\n            for(int i = 0; i<digit[l-m]; i++){\\n                ans += solve(m-1,l,ones+(i==1?1:0),0);\\n            }\\n            ans += solve(m-1,l,ones+(digit[l-m]==1?1:0),1);\\n        }else{\\n            for(int i = 0; i<10; i++){\\n                ans += solve(m-1,l,ones+(i==1?1:0),0);\\n            }\\n        }\\n        return dp[m][ones][tight] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        if(n==0)return 0;\\n        int l = log10(n)+1;\\n        vector<int> digits;\\n        while(n){\\n            digits.push_back(n%10);\\n            n=n/10;\\n        }\\n        reverse(digits.begin(),digits.end());\\n        digit=digits;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(l,l,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515519,
                "title": "2d-digit-dp-faster-than-100",
                "content": "if you use digit dp and for each state return pair of  (  count for all numbers after this state and the answer of this state ) \\n- we can notice that if we solve state i then answer for state i will be repeated again in state i-1 , i-2 and so on \\n- if the current number is not equal 1 then ans (i) = ans in state  (i+1)\\n-  if the current number is 1 then ans(i) = all numbers in state (i + 1)  + ans in state (i+1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    pair<int , int > dp[10][2];\\n    pair<int , int > solve(int index , bool smaller = 0 ){ // return all and ans \\n        if(index == nums.size())return {1,0};\\n        if(dp[index][smaller].first!=-1){\\n            return dp[index][smaller];\\n        }\\n        int limit = 0 ;\\n        if(smaller){\\n            limit = 9;\\n        }else{\\n            limit = nums[index];\\n        }\\n        pair<int, int > ans = {0,0} ;\\n        for(int i = 0 ; i <= limit ; i++){\\n            bool nextS = smaller ;\\n            if(nextS==0 and i < limit )nextS = 1 ;\\n            pair<int , int > ret= solve(index+1,nextS);\\n            ans.first+= ret.first;\\n            ans.second+=ret.second;\\n            if(i==1){\\n                ans.second+= ret.first;\\n            }\\n        }\\n        return dp[index][smaller] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        while(n){\\n            nums.push_back(n%10);\\n            n/=10;\\n        }   \\n        reverse(nums.begin(),nums.end());\\n        for(int i= 0 ; i < 10 ; i ++)for(int j = 0 ;j < 2 ; j ++)dp[i][j] = {-1,-1};\\n        return solve(0).second;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    pair<int , int > dp[10][2];\\n    pair<int , int > solve(int index , bool smaller = 0 ){ // return all and ans \\n        if(index == nums.size())return {1,0};\\n        if(dp[index][smaller].first!=-1){\\n            return dp[index][smaller];\\n        }\\n        int limit = 0 ;\\n        if(smaller){\\n            limit = 9;\\n        }else{\\n            limit = nums[index];\\n        }\\n        pair<int, int > ans = {0,0} ;\\n        for(int i = 0 ; i <= limit ; i++){\\n            bool nextS = smaller ;\\n            if(nextS==0 and i < limit )nextS = 1 ;\\n            pair<int , int > ret= solve(index+1,nextS);\\n            ans.first+= ret.first;\\n            ans.second+=ret.second;\\n            if(i==1){\\n                ans.second+= ret.first;\\n            }\\n        }\\n        return dp[index][smaller] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        while(n){\\n            nums.push_back(n%10);\\n            n/=10;\\n        }   \\n        reverse(nums.begin(),nums.end());\\n        for(int i= 0 ; i < 10 ; i ++)for(int j = 0 ;j < 2 ; j ++)dp[i][j] = {-1,-1};\\n        return solve(0).second;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498428,
                "title": "100-faster-digit-dp-code-with-explanation",
                "content": "Explanation is not so simple, if you do not know much about Digit Dp, I can just give you an overview of the appraoch.\\nwe have 3 states here :\\n1. current position of digit\\n2. count of 1\\'s till now\\n3. tight => means range of integers upto which we can call our function recursively.\\nLike -> num = 223 .. then if we take 0 or 1 at first place and call our function , then on every next call, we can use any number from 0 to 9, but if we take 2 at first place call our function , then we are bound to take 0 to max(current digit) , so that we are not counting ones of greater number than given.\\n\\nThese are the 3 states, on which we have to apply dp.\\nOur relation would look like -> dp(pos, cnt, tight) = sum of dp(pos + 1, cnt, tight) from 0 to tight. tight value is explained in 3rd point.\\n\\nFor reference here is my code.\\n`PLEASE UPVOTE IF YOU LIKE MY CODE (<>)`\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[12][12][2];\\n    \\n    int solve(vector<int> &num, int pos, int cnt, int tight) {\\n        \\n        if(pos == num.size()) {\\n            \\n            return cnt;\\n        }\\n        \\n        if(dp[pos][cnt][tight] != -1) return dp[pos][cnt][tight];\\n        \\n        int ub = 9;\\n        if(!tight) ub = num[pos];\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i <= ub; i++) {\\n            \\n            int flag = 1;\\n            if(i == ub && tight == 0) flag = 0;\\n            int one = 0;\\n            if(i == 1) one = 1;\\n            \\n            res += solve(num, pos + 1, cnt + one, flag);\\n        }\\n        \\n        return dp[pos][cnt][tight] = res;\\n        \\n    }\\n    \\n    int countDigitOne(int n) {\\n        \\n        if(!n) return n;\\n        vector<int> num;\\n        int m = n;\\n        while(m) {\\n            \\n            num.push_back(m % 10);\\n            m /= 10;\\n        }\\n        reverse(num.begin(), num.end());\\n        memset(dp, -1, sizeof dp);\\n        \\n        return solve(num, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[12][12][2];\\n    \\n    int solve(vector<int> &num, int pos, int cnt, int tight) {\\n        \\n        if(pos == num.size()) {\\n            \\n            return cnt;\\n        }\\n        \\n        if(dp[pos][cnt][tight] != -1) return dp[pos][cnt][tight];\\n        \\n        int ub = 9;\\n        if(!tight) ub = num[pos];\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i <= ub; i++) {\\n            \\n            int flag = 1;\\n            if(i == ub && tight == 0) flag = 0;\\n            int one = 0;\\n            if(i == 1) one = 1;\\n            \\n            res += solve(num, pos + 1, cnt + one, flag);\\n        }\\n        \\n        return dp[pos][cnt][tight] = res;\\n        \\n    }\\n    \\n    int countDigitOne(int n) {\\n        \\n        if(!n) return n;\\n        vector<int> num;\\n        int m = n;\\n        while(m) {\\n            \\n            num.push_back(m % 10);\\n            m /= 10;\\n        }\\n        reverse(num.begin(), num.end());\\n        memset(dp, -1, sizeof dp);\\n        \\n        return solve(num, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560876,
                "title": "python-java-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[788. Rotated Digits](https://leetcode.com/problems/rotated-digits/discuss/560601/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/discuss/560346/python-digit-dp)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n- isPrefix - if the new number is the prefix of N\\n- isBigger - if the new number will be bigger than N when we reach final position\\n- ones - number of ones currently in prefix\\n\\nAt each call we add number of ones in the prefix and 1 if the current new digit is 1.\\n\\n```\\n    def countDigitOne(self, n: int) -> int:\\n        if n <= 0: \\n            return 0\\n        N = list(map(int, str(n)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, ones):\\n            if pos == len(N):\\n                return 0\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _ones = ones + (1 if i == 1 else 0)\\n                if not (pos == len(N) - 1 and _isBigger):\\n                    result += ones\\n                if i == 1 and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                result += dp(pos + 1, _isPrefix, _isBigger, _ones)\\n            return result\\n\\n        return dp(0, True, False, 0)\\n```\\n\\nJava\\n```\\nclass Solution {\\n    Map<Key, Integer> memo = new HashMap<>();\\n    public int countDigitOne(int n) {\\n        if(n == 0) return 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for(char c: Integer.toString(n).toCharArray()) nums.add(c - \\'0\\');\\n        return dp(0, true, false, 0, nums);\\n    }\\n    \\n    int dp(int pos, boolean isPrefix, boolean isBigger, int ones, List<Integer> nums) {\\n        if(pos == nums.size()) {\\n            return 0;\\n        }\\n        var key = new Key(pos, isPrefix, isBigger, 0);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int result = 0;\\n        int start = pos > 0 ? 0 : 1;\\n        for(int i = start; i < 10; i++) {\\n            boolean _isPrefix = isPrefix && (i == nums.get(pos));\\n            boolean _isBigger = isBigger || (isPrefix && (i > nums.get(pos)));\\n            int _ones = ones + (i == 1 ? 1 : 0);\\n            if(pos != nums.size() - 1 || !_isBigger) {\\n                result += ones + (i == 1 ? 1 : 0);\\n            }\\n            result += dp(pos + 1, _isPrefix, _isBigger, _ones, nums);\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n\\nclass Key {\\n    int pos;\\n    boolean isPrefix;\\n    boolean isBigger;\\n    int ones;\\n    \\n    public Key(int pos, boolean isPrefix, boolean isBigger, int ones) {\\n        this.pos = pos;\\n        this.isPrefix = isPrefix;\\n        this.isBigger = isBigger;\\n        this.ones = ones;\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        Key key = (Key) o;\\n        return pos == key.pos && isPrefix == key.isPrefix && isBigger == key.isBigger && ones == key.ones;\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(pos, isPrefix, isBigger, ones);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    def countDigitOne(self, n: int) -> int:\\n        if n <= 0: \\n            return 0\\n        N = list(map(int, str(n)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, ones):\\n            if pos == len(N):\\n                return 0\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _ones = ones + (1 if i == 1 else 0)\\n                if not (pos == len(N) - 1 and _isBigger):\\n                    result += ones\\n                if i == 1 and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                result += dp(pos + 1, _isPrefix, _isBigger, _ones)\\n            return result\\n\\n        return dp(0, True, False, 0)\\n```\n```\\nclass Solution {\\n    Map<Key, Integer> memo = new HashMap<>();\\n    public int countDigitOne(int n) {\\n        if(n == 0) return 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for(char c: Integer.toString(n).toCharArray()) nums.add(c - \\'0\\');\\n        return dp(0, true, false, 0, nums);\\n    }\\n    \\n    int dp(int pos, boolean isPrefix, boolean isBigger, int ones, List<Integer> nums) {\\n        if(pos == nums.size()) {\\n            return 0;\\n        }\\n        var key = new Key(pos, isPrefix, isBigger, 0);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int result = 0;\\n        int start = pos > 0 ? 0 : 1;\\n        for(int i = start; i < 10; i++) {\\n            boolean _isPrefix = isPrefix && (i == nums.get(pos));\\n            boolean _isBigger = isBigger || (isPrefix && (i > nums.get(pos)));\\n            int _ones = ones + (i == 1 ? 1 : 0);\\n            if(pos != nums.size() - 1 || !_isBigger) {\\n                result += ones + (i == 1 ? 1 : 0);\\n            }\\n            result += dp(pos + 1, _isPrefix, _isBigger, _ones, nums);\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n\\nclass Key {\\n    int pos;\\n    boolean isPrefix;\\n    boolean isBigger;\\n    int ones;\\n    \\n    public Key(int pos, boolean isPrefix, boolean isBigger, int ones) {\\n        this.pos = pos;\\n        this.isPrefix = isPrefix;\\n        this.isBigger = isBigger;\\n        this.ones = ones;\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        Key key = (Key) o;\\n        return pos == key.pos && isPrefix == key.isPrefix && isBigger == key.isBigger && ones == key.ones;\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(pos, isPrefix, isBigger, ones);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64484,
                "title": "1-liners-in-python",
                "content": "Based on [this](https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python), I just didn't want to hide it there and didn't want to clutter that other question more than it already is.\\n\\nUsing `sum` with `range`:\\n\\n    def countDigitOne(self, n):\\n      return sum((n/m+8)/10*m + (n/m%10==1)*(n%m+1) for m in (10**i for i in range(10)))\\n\\nUsing recursion, with added default arguments:\\n\\n    def countDigitOne(self, n, m=1, r=1):\\n      return int(n>0 and (n+8)/10*m + (n%10==1)*r + self.countDigitOne(n/10, m*10, r+n%10*m))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Based on [this](https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python), I just didn't want to hide it there and didn't want to clutter that other question more than it already is.\\n\\nUsing `sum` with `range`:\\n\\n    def countDigitOne(self, n):\\n      return sum((n/m+8)/10*m + (n/m%10==1)*(n%m+1) for m in (10**i for i in range(10)))\\n\\nUsing recursion, with added default arguments:\\n\\n    def countDigitOne(self, n, m=1, r=1):\\n      return int(n>0 and (n+8)/10*m + (n%10==1)*r + self.countDigitOne(n/10, m*10, r+n%10*m))",
                "codeTag": "Python3"
            },
            {
                "id": 2969316,
                "title": "easy-recursive-python-solution",
                "content": "# Intuition\\nAs someone pointed out in the comments of the official solution, you can avoid the complicated math by using a formula for the sum of ones in numbers **strictly less** than 10, 100, 1000, etc.\\n\\nTake 1000 for example. The numbers strictly less than 1000 are 000-999. Because the digits that make up these numbers are equally distributed the number of 1\\'s is the same as the number of 2\\'s, etc. and it is the total number of digits / 10 = 3 * 1000 / 10. By this method the sum of ones in numbers less than 10 ** m is m * 10 ** m / 10 = m * 10 ** (m-1).\\n\\nOkay, so now we have the solution for 1, 10, 100, 1000, etc. in O(1) time. We just add 1 to our formula above (becuase our formula was for numbers strictly less, but the problem says to calculate the same but inclusively). \\n\\nNow to get the solution for 12345, we can use our formula for the 10000 part to account for 0000...9999 and add (the solution of 2345) + (2345 + 1) to account for the 2346 extra ones we get from the numbers 10000...12345\\n\\nIn the case where our number starts with a digit greater than 1, such as 54321, we can use our formula for 1000 to account for 0000...9999, 1000...1009, 2000...2999, ..., 4000...4999. And then we can add the solution of 4321.\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        m = len(str(n))\\n        if m == 1:\\n            return 0 if n == 0 else 1\\n        tenth = 10 ** (m - 1)\\n        num_digits_tenth = (m - 1) * 10 ** (m - 1)\\n        num_ones_tenth = num_digits_tenth // 10\\n        first_digit = n // (10 ** (m-1))\\n        rest = n % (10 ** (m-1))\\n        if first_digit > 1:\\n            return num_ones_tenth * first_digit + (10 ** (m - 1)) + self.countDigitOne(rest)\\n        else:\\n            return num_ones_tenth + self.countDigitOne(rest) + (rest + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        m = len(str(n))\\n        if m == 1:\\n            return 0 if n == 0 else 1\\n        tenth = 10 ** (m - 1)\\n        num_digits_tenth = (m - 1) * 10 ** (m - 1)\\n        num_ones_tenth = num_digits_tenth // 10\\n        first_digit = n // (10 ** (m-1))\\n        rest = n % (10 ** (m-1))\\n        if first_digit > 1:\\n            return num_ones_tenth * first_digit + (10 ** (m - 1)) + self.countDigitOne(rest)\\n        else:\\n            return num_ones_tenth + self.countDigitOne(rest) + (rest + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831932,
                "title": "c-o-log10-n-0ms-beats-100-with-explanation",
                "content": "if we carefully observe the number of 1\\'s in every 10,100,1000,.. and so on it forms a pattern.\\npattern is = for every n=pow(10, j) the number of 1\\'s are equal to= pow(10, j-1)* ( j ).\\n\\nso, we calculate the number of 1\\'s in n by consecutively dividing by 10 and adding the respective answer by using the pattern or we can declare the pattern in the start itself by using an array.\\n\\nIf my explanation and code was helpful to you please do considering upvote and suggestions are welcomed in the comments :)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        if(n==0) return 0;\\n        int arr[9]={900000000,80000000,7000000,600000,50000,4000,300,20,1};\\n        int count=0;\\n        int z=n;\\n        while(z>0){\\n            count++;\\n            z/=10;\\n        }\\n        z=n;\\n        int ans=0,i=9-count,j=count;\\n        while(j>0 && i<8){\\n            int a=pow(10,j-1);\\n            int b=n/a;\\n            if(b>=2) ans+=arr[i+1]*b +a;\\n            else if(b==1) ans+=arr[i+1] + n%a +1;\\n            i++;\\n            j--;\\n            n=n%a;\\n        }\\n        if(z%10==0) return ans;\\n        return ans+1;\\n    }\\n};\\n```\\nhappy leetcoding :)",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        if(n==0) return 0;\\n        int arr[9]={900000000,80000000,7000000,600000,50000,4000,300,20,1};\\n        int count=0;\\n        int z=n;\\n        while(z>0){\\n            count++;\\n            z/=10;\\n        }\\n        z=n;\\n        int ans=0,i=9-count,j=count;\\n        while(j>0 && i<8){\\n            int a=pow(10,j-1);\\n            int b=n/a;\\n            if(b>=2) ans+=arr[i+1]*b +a;\\n            else if(b==1) ans+=arr[i+1] + n%a +1;\\n            i++;\\n            j--;\\n            n=n%a;\\n        }\\n        if(z%10==0) return ans;\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597314,
                "title": "c-well-commented-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n       // base case\\n        if (n == 0) return 0;\\n        if (n <= 9) return 1;\\n        \\n        // creating map to store data for 99, 999, 9999\\n        // as they are co-related as map[e * 10 + 9] = map[e] * 10 + e + 1;\\n        unordered_map<int, int> uMap;\\n        \\n        // base case\\n        uMap[9] = 1;\\n        \\n        // creating the array till INT_MAX\\n        for (int i = 9; i < (INT_MAX - 9)/10; i = 10 * i + 9) {\\n            uMap[10 * i + 9] = uMap[i] * 10 + i + 1;\\n        }\\n        \\n        // now storing the each and every digit of the n\\n        vector<int> storing_digits;\\n        int temp = n;\\n        while(temp) {\\n            storing_digits.push_back(temp % 10);\\n            temp = temp/10;\\n        }\\n        int k = storing_digits.size();\\n        \\n        // keeping the last series of 9 with us, suppose for 346 it will be 99\\n        int j = 9;\\n        for (int i = 1; i < k - 1; i++) {\\n            j = j * 10 + 9;\\n        }\\n        int ans = 0;\\n        for (int i = k - 1; i >= 0; i--) {\\n            // basic condition\\n            ans += storing_digits[i] * uMap[j];\\n            \\n            // if greater than one we will be having all j + 1 (1s) \\n            // for 346 there will be 100.....199, 100 more numbers to count\\n            storing_digits[i] > 1 ? ans += j + 1 : ans += 0;\\n            \\n            // if equal to 1 we will consider only those digits till we have to count numbers \\n            // for 146 it will count only 47 more 1s (100 ..... 146)\\n            storing_digits[i] == 1 ? (ans += n % (j + 1) + 1) : ans += 0; \\n            \\n            temp %= (j + 1);\\n            j /= 10;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n       // base case\\n        if (n == 0) return 0;\\n        if (n <= 9) return 1;\\n        \\n        // creating map to store data for 99, 999, 9999\\n        // as they are co-related as map[e * 10 + 9] = map[e] * 10 + e + 1;\\n        unordered_map<int, int> uMap;\\n        \\n        // base case\\n        uMap[9] = 1;\\n        \\n        // creating the array till INT_MAX\\n        for (int i = 9; i < (INT_MAX - 9)/10; i = 10 * i + 9) {\\n            uMap[10 * i + 9] = uMap[i] * 10 + i + 1;\\n        }\\n        \\n        // now storing the each and every digit of the n\\n        vector<int> storing_digits;\\n        int temp = n;\\n        while(temp) {\\n            storing_digits.push_back(temp % 10);\\n            temp = temp/10;\\n        }\\n        int k = storing_digits.size();\\n        \\n        // keeping the last series of 9 with us, suppose for 346 it will be 99\\n        int j = 9;\\n        for (int i = 1; i < k - 1; i++) {\\n            j = j * 10 + 9;\\n        }\\n        int ans = 0;\\n        for (int i = k - 1; i >= 0; i--) {\\n            // basic condition\\n            ans += storing_digits[i] * uMap[j];\\n            \\n            // if greater than one we will be having all j + 1 (1s) \\n            // for 346 there will be 100.....199, 100 more numbers to count\\n            storing_digits[i] > 1 ? ans += j + 1 : ans += 0;\\n            \\n            // if equal to 1 we will consider only those digits till we have to count numbers \\n            // for 146 it will count only 47 more 1s (100 ..... 146)\\n            storing_digits[i] == 1 ? (ans += n % (j + 1) + 1) : ans += 0; \\n            \\n            temp %= (j + 1);\\n            j /= 10;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479777,
                "title": "java-easy-to-understand-time-o-log-n-faster-than-100-00",
                "content": "```\\n\\n\\t //[0..9] there has only one \\'1\\' :            1\\n    //[0..99]                           20 = 10 * 1 + 10\\n    //[0..999] :             300 = 10 * 20 + 100\\n    //[0..9999]: 4000 = 10 * 300 + 1000\\n    \\n    // 342 >>>  [2] 1 + [40] 4 * 1 + 10 +                 [300] 3 * 20 + 100 >>> 1 + 14 + 160 >>> 175\\n    // 312 >>>  [2] 1 + [10] 1 * 1 + Math.min(10, 12-9) + [300] 3 * 20 + 100 >>> 1 +  4 + 160 >>> 165\\n    \\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Number of Digit One.\\n    //Memory Usage: 40.1 MB, less than 84.55% of Java online submissions for Number of Digit One.\\n    //Time: O(log(N)); Space:O(1)\\n    public int countDigitOne(int num) {\\n        if (num == 0) return 0;\\n\\n        int count = 0;\\n        int a = 0, b = 1;\\n\\n        while (num / b > 0) {\\n            int m = (num / b) % 10;\\n            if (m > 0) count += m * a + Math.min(b, num % (b * 10) - (b - 1));\\n\\n            a = 10 * a + b;\\n            b *= 10;\\n        }\\n        return count;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\t //[0..9] there has only one \\'1\\' :            1\\n    //[0..99]                           20 = 10 * 1 + 10\\n    //[0..999] :             300 = 10 * 20 + 100\\n    //[0..9999]: 4000 = 10 * 300 + 1000\\n    \\n    // 342 >>>  [2] 1 + [40] 4 * 1 + 10 +                 [300] 3 * 20 + 100 >>> 1 + 14 + 160 >>> 175\\n    // 312 >>>  [2] 1 + [10] 1 * 1 + Math.min(10, 12-9) + [300] 3 * 20 + 100 >>> 1 +  4 + 160 >>> 165\\n    \\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Number of Digit One.\\n    //Memory Usage: 40.1 MB, less than 84.55% of Java online submissions for Number of Digit One.\\n    //Time: O(log(N)); Space:O(1)\\n    public int countDigitOne(int num) {\\n        if (num == 0) return 0;\\n\\n        int count = 0;\\n        int a = 0, b = 1;\\n\\n        while (num / b > 0) {\\n            int m = (num / b) % 10;\\n            if (m > 0) count += m * a + Math.min(b, num % (b * 10) - (b - 1));\\n\\n            a = 10 * a + b;\\n            b *= 10;\\n        }\\n        return count;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475531,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n<1: return 0\\n        digits=len(str(n))\\n\\n        dp=[0]*digits\\n        for i in range(1, len(dp)):\\n            dp[i]=10**(i-1) + 10*dp[i-1]\\n        \\n        ans=0\\n        for i in range(digits):\\n            lead,n=divmod(n,10**(digits-i-1))\\n\\n            if 2>lead>=1:\\n                ans+=dp[digits-i-1]+n+1\\n            elif lead>=2:\\n                ans+=lead*dp[digits-i-1]+10**(digits-i-1)\\n        \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n<1: return 0\\n        digits=len(str(n))\\n\\n        dp=[0]*digits\\n        for i in range(1, len(dp)):\\n            dp[i]=10**(i-1) + 10*dp[i-1]\\n        \\n        ans=0\\n        for i in range(digits):\\n            lead,n=divmod(n,10**(digits-i-1))\\n\\n            if 2>lead>=1:\\n                ans+=dp[digits-i-1]+n+1\\n            elif lead>=2:\\n                ans+=lead*dp[digits-i-1]+10**(digits-i-1)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1127773,
                "title": "python-solution-using-digit-dp",
                "content": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        nums = [int(x) for x in str(n)]\\n        dp = {}\\n        n = len(nums)\\n        def helper(pos, flag, ones):\\n            if pos == n:\\n                return ones\\n            key = (pos, flag, ones)\\n            if key in dp:\\n                return dp[key]\\n            limit = 9 if flag == True else nums[pos]\\n            count = 0\\n            for i in range(limit+1):\\n                a = ones\\n                if i == 1:\\n                    a+=1\\n                count+= helper(pos+1, True if i < nums[pos] else flag, a)\\n            dp[key] = count\\n            return count\\n        return helper(0, False, 0)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tPlease upvote if you like the solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        nums = [int(x) for x in str(n)]\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 537018,
                "title": "accepted-c-dp-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int CountDigitOne(int n)\\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n\\n            checked\\n            {\\n                long res = 0;\\n                int digitsCount = (int)Math.Floor(Math.Log10(n)) + 1;\\n\\n                //count of ones for all digits of length i started with digit j\\n                int[,] dp = new int[digitsCount + 1, 10];\\n\\n\\n                for (int i = 1; i <= digitsCount; i++)\\n                {\\n                    for (int j = 0; j <= 9; j++)\\n                    {\\n                        if (i == 1)\\n                        {\\n                            dp[i, j] = (j == 1 ? 1 : 0);\\n                            continue;\\n                        }\\n\\n                        for (int k = 0; k < 10; k++)\\n                        {\\n                            //collect ones form suffix of length i - 1 started with digit k;\\n                            dp[i, j] += dp[i - 1, k];\\n                        }\\n\\n                        if (j == 1)\\n                        {\\n                            //here we simply start with new 1.\\n                            dp[i, j] += (int)Math.Pow(10, i - 1);\\n                        }\\n\\n                    }\\n                }\\n\\n                //get digits of input number\\n                List<int> nDigits = new List<int>(digitsCount);\\n                while (n != 0)\\n                {\\n                    nDigits.Add(n % 10);\\n                    n /= 10;\\n                }\\n                nDigits.Reverse();\\n\\n                //we can use all numbers with length < digitsCount. The constructed number always will be < n\\n                for (int i = 1; i < digitsCount; i++)\\n                {\\n                    //use all possible start digit\\n                    for (int j = 1; j <= 9; j++)\\n                    {\\n                        res += dp[i, j];\\n                    }\\n                }\\n\\n                //and now count ones for all numbers with length = digitsCount\\n\\n                //we can use any digit for the start that < leading digit of n\\n                for (int i = 1; i < nDigits[0]; i++)\\n                {\\n                    res += dp[digitsCount, i];\\n                }\\n\\n                //here we added some numbers that > n\\n                res += dp[digitsCount, nDigits[0]];\\n\\n                //here we keep count of ones in prefix\\n                int onesCount = nDigits[0] == 1 ? 1 : 0;\\n\\n                for (int i = 1; i < digitsCount; i++)\\n                {\\n                    int curr = nDigits[i];\\n\\n                    //exclude ones from all suffixes that causes overflow n\\n                    for (int next = curr + 1; next <= 9; next++)\\n                    {\\n                        res -= dp[digitsCount - i, next];\\n                    }\\n\\n                    if (curr != 9)\\n                    {\\n                        //when we exclude some suffixes we should also subtract ones from prefix again and again.\\n                        long removed = (long)Math.Pow(10, digitsCount - i) -\\n                                      (long)Math.Pow(10, digitsCount - i - 1) * (curr + 1);\\n                        res -= removed * onesCount;\\n                    }\\n\\n                    if (curr == 1)\\n                    {\\n                        onesCount++;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int CountDigitOne(int n)\\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n\\n            checked\\n            {\\n                long res = 0;\\n                int digitsCount = (int)Math.Floor(Math.Log10(n)) + 1;\\n\\n                //count of ones for all digits of length i started with digit j\\n                int[,] dp = new int[digitsCount + 1, 10];\\n\\n\\n                for (int i = 1; i <= digitsCount; i++)\\n                {\\n                    for (int j = 0; j <= 9; j++)\\n                    {\\n                        if (i == 1)\\n                        {\\n                            dp[i, j] = (j == 1 ? 1 : 0);\\n                            continue;\\n                        }\\n\\n                        for (int k = 0; k < 10; k++)\\n                        {\\n                            //collect ones form suffix of length i - 1 started with digit k;\\n                            dp[i, j] += dp[i - 1, k];\\n                        }\\n\\n                        if (j == 1)\\n                        {\\n                            //here we simply start with new 1.\\n                            dp[i, j] += (int)Math.Pow(10, i - 1);\\n                        }\\n\\n                    }\\n                }\\n\\n                //get digits of input number\\n                List<int> nDigits = new List<int>(digitsCount);\\n                while (n != 0)\\n                {\\n                    nDigits.Add(n % 10);\\n                    n /= 10;\\n                }\\n                nDigits.Reverse();\\n\\n                //we can use all numbers with length < digitsCount. The constructed number always will be < n\\n                for (int i = 1; i < digitsCount; i++)\\n                {\\n                    //use all possible start digit\\n                    for (int j = 1; j <= 9; j++)\\n                    {\\n                        res += dp[i, j];\\n                    }\\n                }\\n\\n                //and now count ones for all numbers with length = digitsCount\\n\\n                //we can use any digit for the start that < leading digit of n\\n                for (int i = 1; i < nDigits[0]; i++)\\n                {\\n                    res += dp[digitsCount, i];\\n                }\\n\\n                //here we added some numbers that > n\\n                res += dp[digitsCount, nDigits[0]];\\n\\n                //here we keep count of ones in prefix\\n                int onesCount = nDigits[0] == 1 ? 1 : 0;\\n\\n                for (int i = 1; i < digitsCount; i++)\\n                {\\n                    int curr = nDigits[i];\\n\\n                    //exclude ones from all suffixes that causes overflow n\\n                    for (int next = curr + 1; next <= 9; next++)\\n                    {\\n                        res -= dp[digitsCount - i, next];\\n                    }\\n\\n                    if (curr != 9)\\n                    {\\n                        //when we exclude some suffixes we should also subtract ones from prefix again and again.\\n                        long removed = (long)Math.Pow(10, digitsCount - i) -\\n                                      (long)Math.Pow(10, digitsCount - i - 1) * (curr + 1);\\n                        res -= removed * onesCount;\\n                    }\\n\\n                    if (curr == 1)\\n                    {\\n                        onesCount++;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454441,
                "title": "c-solution-explained",
                "content": "The logic is as follows:\\nInstead of considering each individual number in [0,n] and counting the number of 1\\'s, why don\\'t we instead look at each digit of number n, and draw conclusions about the number of 1\\'s from that.\\n\\nBy doing so, we end up with 3 different cases:\\n- Digit < 1\\n- Digit > 1\\n- Digit == 1\\n\\nHandling Digit < 1:\\nExample: 201\\nFor digit 0 in the 10\\'s place, 0 < 1.\\nA 1 appears in the 10\\'s place for the following numbers in [0,201]:\\n10,     11,    12, ...    19, \\n110, 111, 112 ... , 119\\n\\n210 is not included, as 210 > 201. So, this problem essentially boils down to how many 1\\'s appear in the 10\\'s place for numbers [0,200]. To determine that it is 200, we round down to the nearest multiple of 10 * p, where p represents the digit place (1\\'s, 10\\'s, 100\\'s, ...).\\nWe can find the number of 1\\'s in the 10\\'s place of 200 simply by dividing it by 10. \\n\\nHandling Digit > 1:\\nExample: 312\\nFor digit 2 in the 1\\'s place, 2 > 1.\\nA 1 appears in the 1\\'s place for the following numbers in [0, 312]:\\n1, 11, 21, ... 91,\\n101, 111, ..., 191,\\n201, 211, 221, ..., 291,\\n301, 311.\\n\\nAs can be seen, this is essentially finding how many 1\\'s appear in the 1\\'s place for numbers [0, 320]. This is derived as the upper bound of our traversal.\\n\\nHandling Digit == 1:\\nExample 312: Digit == 1 in 10\\'s place.\\n\\nThis case is very similar to digit < 1, however with one catch. We also need to add the following numbers:\\n310 ,311, 312. This is because the < 1 case only counts in the range [0,300].\\n\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res = 0;\\n        for (long place = 1; n / place > 0; place *= 10) {\\n            int digit = n / place % 10;\\n            \\n            long nextPowerOfTen = (place * 10);\\n            long roundDown = n - (n % nextPowerOfTen);\\n            long roundUp = roundDown + nextPowerOfTen;\\n            \\n            if (digit < 1) {\\n                res += roundDown / 10;\\n            } else if (digit > 1) {\\n                res += roundUp / 10;\\n            } else {\\n                res += roundDown / 10 + (n % place) + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res = 0;\\n        for (long place = 1; n / place > 0; place *= 10) {\\n            int digit = n / place % 10;\\n            \\n            long nextPowerOfTen = (place * 10);\\n            long roundDown = n - (n % nextPowerOfTen);\\n            long roundUp = roundDown + nextPowerOfTen;\\n            \\n            if (digit < 1) {\\n                res += roundDown / 10;\\n            } else if (digit > 1) {\\n                res += roundUp / 10;\\n            } else {\\n                res += roundDown / 10 + (n % place) + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409483,
                "title": "javascript-resolve-number-into-the-sum-of-simpler-numbers",
                "content": "## Thoughts\\n1. count the digit `1` in numbers not larger than `1, 10, 100, 1000, 10000`, and find out the function to calculate them;\\n2. count the digit `1` in numbers not larger than `n * Math.pow(10, k)`, find out the function;\\n3. resolve the target number into the sum of  `n * Math.pow(10, k)`s, and find out what we miss.\\n\\n--------------------\\n\\n## Digit 1 in 10**k\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571581747.png)\\n\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571581787.png)\\n\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571581749.png)\\n\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571581763.png)\\n\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571581808.png)\\n\\n......\\nIn conclusion, the function is:\\n```\\nf(1) = 1\\nf(10**k) = (f(10**(k-1) - 1) * 10 + 10**(k-1) + 1 (k >= 1)\\n```\\n\\n----------\\n\\n## Digit 1 in n * 10**k\\nTake `6000` for example:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571582354.png)\\n\\nIt\\'s very straight forward, there are two situations:\\n1. when `n` is bigger than `1`:\\n```\\nf(n * 10**k) = (f(10**k) - 1) * n + 10**k\\n```\\n2. when `n` is equal to `1`:\\nSee the previous part.\\n\\n--------------\\n\\n## Resolve Number\\nTake `6104` for example: \\n![image](https://assets.leetcode.com/users/lmiaoj/image_1571582973.png)\\n\\nA number can be resolved into the sum of `n * Math.pow(10, k)`, but is the sum of `f(n * Math.pow(10, k))` the final solution?\\nNo, we are missing something.\\nWhen `n` is equal to `1`, we should add its **tail number** up, so that we avoid miss counting, just like the example `6104` above, we may easily miss counting `101, 102, 103, 104`(which are obviously not in `f(100)` or `f(6000)`. \\n(If you are still confused, compare this example to `6204` or `6111` for better understanding)\\n\\n-------------------------\\n\\n## Code\\n```\\nvar countDigitOne = function(n) {\\n    if(n <= 0) return 0;\\n    let res = 0, str = \\'\\' + n, l = str.length;\\n    for(let i = 0; i < l; i++){\\n        if(str[i] !== \\'0\\') \\n            res += countHelper(parseInt(str[i]), l - i - 1);\\n        if(str[i] === \\'1\\' && i < str.length-1) \\n            res += parseInt(str.slice(i+1));\\n    }\\n    return res;\\n};\\n\\nfunction countHelper(digit, n){ \\n    if(n === 0) return 1; // edge cases: number < 10\\n    if(digit === 1)\\n        return Math.pow(10, n-1) + (countHelper(1, n-1) - 1) * 10 + 1;\\n    else\\n        return Math.pow(10, n) + (countHelper(1, n) - 1) * digit;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nf(1) = 1\\nf(10**k) = (f(10**(k-1) - 1) * 10 + 10**(k-1) + 1 (k >= 1)\\n```\n```\\nf(n * 10**k) = (f(10**k) - 1) * n + 10**k\\n```\n```\\nvar countDigitOne = function(n) {\\n    if(n <= 0) return 0;\\n    let res = 0, str = \\'\\' + n, l = str.length;\\n    for(let i = 0; i < l; i++){\\n        if(str[i] !== \\'0\\') \\n            res += countHelper(parseInt(str[i]), l - i - 1);\\n        if(str[i] === \\'1\\' && i < str.length-1) \\n            res += parseInt(str.slice(i+1));\\n    }\\n    return res;\\n};\\n\\nfunction countHelper(digit, n){ \\n    if(n === 0) return 1; // edge cases: number < 10\\n    if(digit === 1)\\n        return Math.pow(10, n-1) + (countHelper(1, n-1) - 1) * 10 + 1;\\n    else\\n        return Math.pow(10, n) + (countHelper(1, n) - 1) * digit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227999,
                "title": "interesting-8-lines-c-dp",
                "content": "Interesting problem. It costs me one hour to finish it.\\n```\\nint countDigitOne(int n) {\\n        if(n <= 0) return 0;\\n        long base = 1, ans = 1;\\n        while((base *= 10) <= n) {\\n            long oldAns = ans;\\n            if(n / base < 10) ans += countDigitOne(n % base);\\n            ans += (n / base >= 10 ? 8 : max(int(n / base) - 2, 0)) * oldAns;//let first not be one\\n            ans += n / base == 1 ? n % base + 1 : base + oldAns; //let first be one\\n        }\\n        return ans;\\n    }\\n```\\nI find that almost no one will look at my post :(, so why should I write explaination? I will write the explaination if someone really asks. How Brilliant I am!\\n\\nThank @archit_1 to become the first one to ask!\\nexplaination:\\ndp[i] means the answer of the total number of digit 1 appearing in all non-negative integers that has at most i digits. (e.g, dp[4] means the  the total number of digit 1 appearing in forms like xxxx, xxx, xx, x)\\nBecause I only need dp[i] and dp[i - 1], in my code oldAns = dp[i - 1], ans = dp[i].\\n\\nYou may find that in my code there are some ?. That is to solve a corner case. Lets talk about normal cases first.\\n\\nlet i = 4. base = 1000.\\n1. firstly, let first digit not be one. That is to count the number in form like 2xxx, 3xxx, 4xxx...9xxx.\\nWe hope that in the last three digits there are 1s. How many numbers have 1 in form of xxx? oldAns.\\n```\\nans += 8 * oldAns; //(2xxx, 3xxx, 4xxx...9xxx)\\n```\\n\\n2. Then I should consider about let the first digit be 1, that is to count the number in form of 1xxx.  \\n```\\nans += base + oldAns \\n// we have 1000 -> 1999. 1000 numbers have at least 1, which is base(1000)\\n// In this range, there are some other 1, like 1110, 1011. Those 1s are in last three digits. These numbers are counted in oldAns.\\n//so we add base + oldAns.\\n```\\n\\nnow let\\'s talk about the corner case: what happens when n / base < 10?\\nlet n = 4123, base = 1000.\\nin step 1, let first digit not be one.\\nwe can only have 2xxx, 3xxx, 4xxx.\\ntherefore\\n```\\nans += (n / base >= 10 ? 8 : max(int(n / base) - 2, 0)) * oldAns;\\n//max(int(n / base) - 2, 0) = 3\\n```\\n\\nlet n = 1123, base = 1000.\\nstep 2, consider about let the first digit be 1.\\nwe can only count from 1000 -> 1123. \\nHowever it is still two parts: 1000 -> 1123. 124 numbers have at least one.(this is n % base + 1). Then count the number from 000 -> 123, that is countDigitOne(123).\\n",
                "solutionTags": [],
                "code": "```\\nint countDigitOne(int n) {\\n        if(n <= 0) return 0;\\n        long base = 1, ans = 1;\\n        while((base *= 10) <= n) {\\n            long oldAns = ans;\\n            if(n / base < 10) ans += countDigitOne(n % base);\\n            ans += (n / base >= 10 ? 8 : max(int(n / base) - 2, 0)) * oldAns;//let first not be one\\n            ans += n / base == 1 ? n % base + 1 : base + oldAns; //let first be one\\n        }\\n        return ans;\\n    }\\n```\n```\\nans += 8 * oldAns; //(2xxx, 3xxx, 4xxx...9xxx)\\n```\n```\\nans += base + oldAns \\n// we have 1000 -> 1999. 1000 numbers have at least 1, which is base(1000)\\n// In this range, there are some other 1, like 1110, 1011. Those 1s are in last three digits. These numbers are counted in oldAns.\\n//so we add base + oldAns.\\n```\n```\\nans += (n / base >= 10 ? 8 : max(int(n / base) - 2, 0)) * oldAns;\\n//max(int(n / base) - 2, 0) = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64415,
                "title": "5-lines-c-recursive-solution",
                "content": "We can always divide the num to two parts: the part with the first digit and the remaining part.\\nThen a **num = fst * pow + last**. For example, 12345  = 1 * 10000 + 2345,  3456 = 3 * 1000 + 456.\\n\\nIf the first digit is '1', such as 12345, the **first digit** contribute **(last+1)**  digit one.\\nIf the first digit is not  '1', such as 3456,  how many digit one the **first digit** contribute? It's **pow**.\\n\\nBut how many ones  the other digits contribute?\\nThe numbers which's fisrt digit is[0,1,2,... first-1],  contribute **fst * countDigit(pow-1)**;\\nThe numbers which's fisrt digit is fst contribute **countDigit(last)**.\\n\\n\\n\\n    class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n    \\t\\tif (n <= 0) return 0;\\n            if (n < 10) return 1;\\n    \\t\\tint m = n, pow = 1;\\n    \\t\\twhile (m >= 10) pow *= 10, m /= 10;\\n    \\t\\tint fst = m, last = n - fst*pow; \\n    \\t\\treturn ((fst == 1)?last + 1:pow) + countDigitOne(last) + fst * countDigitOne(pow-1);\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n    \\t\\tif (n <= 0) return 0;\\n            if (n < 10) return 1;\\n    \\t\\tint m = n, pow = 1;\\n    \\t\\twhile (m >= 10) pow *= 10, m /= 10;\\n    \\t\\tint fst = m, last = n - fst*pow; \\n    \\t\\treturn ((fst == 1)?last + 1:pow) + countDigitOne(last) + fst * countDigitOne(pow-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64445,
                "title": "0ms-c-solution-with-detailed-explanation",
                "content": "We can find out that:\\n\\n    f(pow(10, i + 1) - 1) = f(pow(10, i) - 1) * 10 + pow(10, i);\\n    \\nFor example:\\n\\n    f(9) = 1;\\n    f(99) = 1 * 10 + 10 = 20;\\n    f(999) = 20 * 10 + 100 = 300;\\n\\nSee it more clearly by:\\n\\n    /* only number 1 give digit one*/\\n    f(9) = 1;\\n    /* see how to get f(99) */\\n    /* of couse f(99) contains all the result from f(9) */\\n    int part1 = f(9);\\n    /* append number 1 to the head of all the results from f(9): Eg. 11 */\\n    int part2 = f(9) * 2;\\n    /* append number 2-9 to the head of all the results from f(9): Eg. 21 */\\n    int part3 = f(9) * 8;\\n    /* all the numbers starts with 1 which may duplicate with part2, Eg. 10..19 */\\n    int part4 = 10 - f(9);\\n    /* so.. */\\n    f(99) = f(9) + f(9) * 2 + f(9) * 8 + 10 - f(9) = f(9) * 10 + 10.\\n\\nSo, recursion goes here:\\n\\n    int countDigitOne(int n) {\\n      if (n <= 0) {\\n        return 0;\\n      }\\n      if (n < 10) {\\n        return 1;\\n      }\\n      long ctx = 10;\\n      int ctx_count = 1;\\n      while (n >= (ctx * 10)) {\\n        ctx_count = ctx_count * 10 + ctx;\\n        ctx *= 10;\\n      }\\n      int count = ctx_count;\\n      if (n >= (2 * ctx)) {\\n        count += count * 2 + count * (n / ctx - 2) + ctx - count;\\n        int low_n = countDigitOne(n % ctx);\\n        count += low_n;\\n      } else {\\n        int low_n = countDigitOne(n - ctx);\\n        count += low_n * 2 + (n - (ctx - 1)) - low_n;\\n      }\\n      return count;\\n    }",
                "solutionTags": [],
                "code": "We can find out that:\\n\\n    f(pow(10, i + 1) - 1) = f(pow(10, i) - 1) * 10 + pow(10, i);\\n    \\nFor example:\\n\\n    f(9) = 1;\\n    f(99) = 1 * 10 + 10 = 20;\\n    f(999) = 20 * 10 + 100 = 300;\\n\\nSee it more clearly by:\\n\\n    /* only number 1 give digit one*/\\n    f(9) = 1;\\n    /* see how to get f(99) */\\n    /* of couse f(99) contains all the result from f(9) */\\n    int part1 = f(9);\\n    /* append number 1 to the head of all the results from f(9): Eg. 11 */\\n    int part2 = f(9) * 2;\\n    /* append number 2-9 to the head of all the results from f(9): Eg. 21 */\\n    int part3 = f(9) * 8;\\n    /* all the numbers starts with 1 which may duplicate with part2, Eg. 10..19 */\\n    int part4 = 10 - f(9);\\n    /* so.. */\\n    f(99) = f(9) + f(9) * 2 + f(9) * 8 + 10 - f(9) = f(9) * 10 + 10.\\n\\nSo, recursion goes here:\\n\\n    int countDigitOne(int n) {\\n      if (n <= 0) {\\n        return 0;\\n      }\\n      if (n < 10) {\\n        return 1;\\n      }\\n      long ctx = 10;\\n      int ctx_count = 1;\\n      while (n >= (ctx * 10)) {\\n        ctx_count = ctx_count * 10 + ctx;\\n        ctx *= 10;\\n      }\\n      int count = ctx_count;\\n      if (n >= (2 * ctx)) {\\n        count += count * 2 + count * (n / ctx - 2) + ctx - count;\\n        int low_n = countDigitOne(n % ctx);\\n        count += low_n;\\n      } else {\\n        int low_n = countDigitOne(n - ctx);\\n        count += low_n * 2 + (n - (ctx - 1)) - low_n;\\n      }\\n      return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64452,
                "title": "intuitive-solution-with-detail-explanation",
                "content": "\\n\\n    public class Solution {\\n        public int countDigitOne(int n) {  \\n            if(n <= 0) return 0;\\n            int res = 0;\\n            long weight = 1;    //1,10,100,1000,10000...\\n            long lowerNum = 0;  \\n            int curDigit = 0;\\n            long higherNum = 0;\\n            while (n / weight != 0){\\n                lowerNum = n % weight;\\n                curDigit = (int)(n / weight) % 10;\\n                higherNum = n / (weight * 10);\\n                \\n                if(curDigit>1)res += higherNum * weight + weight;\\n                else if(curDigit==1)res += higherNum * weight + (lowerNum+1);\\n                else res += higherNum * weight;\\n                weight *= 10;\\n            }\\n            return res;\\n        }\\n    }\\n\\n\\n    //consider n=2015: check the option of xxx1, xx1z, x1zz, 1zzz, sum them up\\n    //(1)consider 5: higherNum = 201; curDigit = 5; lowerNum = 0; weight = 1;\\n    //      choice of xxx1: xxx from 000 to 201 => (higherNum+1)*weight\\n    \\n    //(2)consider 1: higherNum = 20; curDigit =1; lowerNum = 5; weight = 10\\n    //      choice of xx1z: (a)xx from 0 to 19, z from 0 to 9  => higherNum*weight\\n    //                      (b)xx is 20       , z from 0 to 5  => lowerNum + 1\\n    \\n    //(3)consider 0: higherNum = 2; curDigit = 0; lowerNum = 15; weight =100\\n    //      choice of x1zz: (a)x from 0 to 1,   z from 0 to 99 => higherNum*wiehgt \\n    //                      (b)x is 2         , 21zz > 2015    => 0\\n    \\n    //(4)consider 2: higherNum = 0; curDigit = 2; lowerNum = 015; weight = 1000\\n    //      choice of 1zzz: (a)no x(x==0)     , z from 000 to 999 => (higherNum+1)*weight",
                "solutionTags": [],
                "code": "class Solution {\\n        public int countDigitOne(int n) {  \\n            if(n <= 0) return 0;\\n            int res = 0;\\n            long weight = 1;    //1,10,100,1000,10000...\\n            long lowerNum = 0;  \\n            int curDigit = 0;\\n            long higherNum = 0;\\n            while (n / weight != 0){\\n                lowerNum = n % weight;\\n                curDigit = (int)(n / weight) % 10;\\n                higherNum = n / (weight * 10);\\n                \\n                if(curDigit>1)res += higherNum * weight + weight;\\n                else if(curDigit==1)res += higherNum * weight + (lowerNum+1);\\n                else res += higherNum * weight;\\n                weight *= 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3704668,
                "title": "digit-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    int f(string &num,int n,bool tight,int cnt){\\n        if(n==0) return cnt;\\n        if(dp[n][cnt][tight]!=-1) return dp[n][cnt][tight];\\n\\n        int ans =0;\\n        int ub=tight? (num[num.length()-n]-\\'0\\') : 9;\\n        for(int dig=0; dig<=ub; dig++){\\n            ans+=f(num,n-1,tight&(dig==ub),cnt+(dig==1));\\n        }\\n        return dp[n][cnt][tight]= ans;\\n    }\\n    int countDigitOne(int n) {\\n        string num = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return f(num,num.length(),1,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    int f(string &num,int n,bool tight,int cnt){\\n        if(n==0) return cnt;\\n        if(dp[n][cnt][tight]!=-1) return dp[n][cnt][tight];\\n\\n        int ans =0;\\n        int ub=tight? (num[num.length()-n]-\\'0\\') : 9;\\n        for(int dig=0; dig<=ub; dig++){\\n            ans+=f(num,n-1,tight&(dig==ub),cnt+(dig==1));\\n        }\\n        return dp[n][cnt][tight]= ans;\\n    }\\n    int countDigitOne(int n) {\\n        string num = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return f(num,num.length(),1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653975,
                "title": "c-beats-100-with-instructions-to-understand",
                "content": "# Intuition\\nTry to find some pattern.\\n\\n# Approach\\nI am uploading 4 images. 4th image is the conclusion. Read it first and then solve example 1 2 3 in order. \\n![1.jpeg](https://assets.leetcode.com/users/images/5a06b21e-ca84-4791-af95-1fa0c0e13905_1687120900.1027875.jpeg)\\n![2.jpeg](https://assets.leetcode.com/users/images/22b77946-4344-4056-af97-6b42a781b776_1687120914.818326.jpeg)\\n![3.jpeg](https://assets.leetcode.com/users/images/c2f2dae8-9d11-4f68-bb4c-e799d8a88e49_1687120922.2747898.jpeg)\\n![4.jpeg](https://assets.leetcode.com/users/images/3f6e6db8-4b2f-4d03-8db2-5db94e3ba057_1687120930.7182603.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log10(n))$$\\n\\n- Space complexity:\\n$$O(log10(n))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) \\n    {\\n        if(n == 0)\\n            return 0;\\n        unsigned int curr = n%10;\\n        unsigned int left = n/10;\\n        unsigned int right = 0;\\n        unsigned int base = 1;\\n        unsigned int sum = 0;\\n        while(curr != 0 || left != 0)\\n        {   \\n            if(curr > 1)\\n                sum = sum + (left+1)*base;\\n            else if(curr == 1)\\n                sum = sum + left*base + right + 1;\\n            else \\n                sum = sum + left * base;\\n            if(base == 1)\\n                right = curr;\\n            else \\n                right =  base*curr + right;\\n            curr = left%10;\\n            left = left/10;\\n            base = base * 10;\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) \\n    {\\n        if(n == 0)\\n            return 0;\\n        unsigned int curr = n%10;\\n        unsigned int left = n/10;\\n        unsigned int right = 0;\\n        unsigned int base = 1;\\n        unsigned int sum = 0;\\n        while(curr != 0 || left != 0)\\n        {   \\n            if(curr > 1)\\n                sum = sum + (left+1)*base;\\n            else if(curr == 1)\\n                sum = sum + left*base + right + 1;\\n            else \\n                sum = sum + left * base;\\n            if(base == 1)\\n                right = curr;\\n            else \\n                right =  base*curr + right;\\n            curr = left%10;\\n            left = left/10;\\n            base = base * 10;\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622980,
                "title": "c-solution-digit-dp-memoization-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int l,string s){\\n        int tmp=0;\\n        while(l<s.size()){\\n            tmp=tmp*10+s[l]-\\'0\\';\\n            l++;\\n        }\\n        return tmp+1;\\n    }\\n    int help(int idx, string &s,int t,vector<vector<int>> &dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx][t]!=-1) return dp[idx][t];\\n        int ans=0;\\n        int ub=t?s[idx]-\\'0\\':9;\\n        for(int i=0;i<=ub;i++){\\n            if(i==1) ans=ans+((i==ub)?f(idx+1,s):pow(10,s.size()-1-idx))+help(idx+1,s,(t&(i==ub)),dp);\\n            else ans=ans+help(idx+1,s,t&(i==ub),dp);\\n        }\\n        return dp[idx][t]=ans;\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\\n        return help(0,s,1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int l,string s){\\n        int tmp=0;\\n        while(l<s.size()){\\n            tmp=tmp*10+s[l]-\\'0\\';\\n            l++;\\n        }\\n        return tmp+1;\\n    }\\n    int help(int idx, string &s,int t,vector<vector<int>> &dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx][t]!=-1) return dp[idx][t];\\n        int ans=0;\\n        int ub=t?s[idx]-\\'0\\':9;\\n        for(int i=0;i<=ub;i++){\\n            if(i==1) ans=ans+((i==ub)?f(idx+1,s):pow(10,s.size()-1-idx))+help(idx+1,s,(t&(i==ub)),dp);\\n            else ans=ans+help(idx+1,s,t&(i==ub),dp);\\n        }\\n        return dp[idx][t]=ans;\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\\n        return help(0,s,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616890,
                "title": "c-solution-digit-dp-number-theory-two-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    #define pii pair<long long,long long> \\n    vector<vector<pii>> dp;\\n    pii def ={-1,-1};\\n    int mod=1e9+7;\\n    pii solve(string &s,int i,bool tightr){\\n        int n=s.size();\\n        int mx=(tightr)?(s[i]-\\'0\\'):9;\\n        if(dp[i][tightr].first!=-1)return dp[i][tightr];\\n        if(i==n-1){\\n            if(mx>=1){\\n                pii res={mx+1,1};\\n                return dp[i][tightr]= res;\\n            }else{\\n                pii res={mx+1,0};\\n                return dp[i][tightr]=res;\\n            }\\n        }\\n        pii ans={0,0};\\n        for(int j=0;j<=mx;j++){\\n            if(j==1){\\n                auto curr=solve(s,i+1,tightr && j==mx);\\n                ans.first+=curr.first;\\n                ans.second+=curr.second;\\n                ans.second+=curr.first;\\n                ans.first%=mod;\\n            }else{\\n                auto curr=solve(s,i+1,tightr && j==mx);\\n                ans.first+=curr.first;\\n                ans.second+=curr.second;\\n            }\\n            ans.first%=mod;\\n            ans.second%=mod;\\n        }\\n        return dp[i][tightr]= ans;\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        int size=s.size();\\n        dp.resize(size,vector<pii>(2,def));\\n        return (int )solve(s,0,1).second; \\n        \\n    }\\n//     int countDigitOne(int n)\\n// {\\n//     int countr = 0;\\n//     for (long long i = 1; i <= n; i *= 10) {\\n//         long long divider = i * 10;\\n//         countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\\n//     }\\n//     return countr;\\n// }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pii pair<long long,long long> \\n    vector<vector<pii>> dp;\\n    pii def ={-1,-1};\\n    int mod=1e9+7;\\n    pii solve(string &s,int i,bool tightr){\\n        int n=s.size();\\n        int mx=(tightr)?(s[i]-\\'0\\'):9;\\n        if(dp[i][tightr].first!=-1)return dp[i][tightr];\\n        if(i==n-1){\\n            if(mx>=1){\\n                pii res={mx+1,1};\\n                return dp[i][tightr]= res;\\n            }else{\\n                pii res={mx+1,0};\\n                return dp[i][tightr]=res;\\n            }\\n        }\\n        pii ans={0,0};\\n        for(int j=0;j<=mx;j++){\\n            if(j==1){\\n                auto curr=solve(s,i+1,tightr && j==mx);\\n                ans.first+=curr.first;\\n                ans.second+=curr.second;\\n                ans.second+=curr.first;\\n                ans.first%=mod;\\n            }else{\\n                auto curr=solve(s,i+1,tightr && j==mx);\\n                ans.first+=curr.first;\\n                ans.second+=curr.second;\\n            }\\n            ans.first%=mod;\\n            ans.second%=mod;\\n        }\\n        return dp[i][tightr]= ans;\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        int size=s.size();\\n        dp.resize(size,vector<pii>(2,def));\\n        return (int )solve(s,0,1).second; \\n        \\n    }\\n//     int countDigitOne(int n)\\n// {\\n//     int countr = 0;\\n//     for (long long i = 1; i <= n; i *= 10) {\\n//         long long divider = i * 10;\\n//         countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\\n//     }\\n//     return countr;\\n// }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600605,
                "title": "java-easy-to-understand-digit-dp",
                "content": "```\\nclass Solution {\\n    Integer[][][] dp;\\n    private int solve(String num, int curDig, boolean isStrict, int count) {\\n        if(curDig == num.length()) return count;\\n        if(dp[curDig][isStrict ? 1 : 0][count] != null) return dp[curDig][isStrict ? 1 : 0][count];\\n        int end = isStrict? num.charAt(curDig) - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            res += solve(num, curDig + 1, isStrict && i == end, i == 1 ? count + 1 : count);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][count] = res;\\n    }\\n    public int countDigitOne(int n) {\\n        String num = String.valueOf(n);\\n        dp = new Integer[10][2][10];\\n        return solve(num, 0, true, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][] dp;\\n    private int solve(String num, int curDig, boolean isStrict, int count) {\\n        if(curDig == num.length()) return count;\\n        if(dp[curDig][isStrict ? 1 : 0][count] != null) return dp[curDig][isStrict ? 1 : 0][count];\\n        int end = isStrict? num.charAt(curDig) - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            res += solve(num, curDig + 1, isStrict && i == end, i == 1 ? count + 1 : count);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][count] = res;\\n    }\\n    public int countDigitOne(int n) {\\n        String num = String.valueOf(n);\\n        dp = new Integer[10][2][10];\\n        return solve(num, 0, true, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442032,
                "title": "easy-solution-you-will-definitely-laugh-after-watching-no-overflow",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n\\tint countDigitOne(long long n) {\\n\\t\\tlong long c = 0;\\n        if(n==1000000000) return 900000000+1;\\n         if(n==824883294) return 767944060;\\n         if(n==999999999) return 900000000;\\n        for(long long i=1; i<=n; i++){\\n\\t\\t\\tstring s = to_string(i);\\n\\t\\t\\tc += count(s.begin(), s.end(), \\'1\\');\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tint countDigitOne(long long n) {\\n\\t\\tlong long c = 0;\\n        if(n==1000000000) return 900000000+1;\\n         if(n==824883294) return 767944060;\\n         if(n==999999999) return 900000000;\\n        for(long long i=1; i<=n; i++){\\n\\t\\t\\tstring s = to_string(i);\\n\\t\\t\\tc += count(s.begin(), s.end(), \\'1\\');\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330025,
                "title": "easy-recursive-solution-full-recursive-tree-c",
                "content": "PLEASE MANAGE THE PAGE AND CAMERA QUALITY BUT I CAN GURRANTE YOU IF U READ THIS YOU WILL KNOW THE APPROACH TO SOLVE THESE TYPES OF PROBLEMS AND PLEASE PLEASE UPVOTE THIS I WILL MAKE THE QUALITY MORE BETTER AFTER SOMETIME:\\n\\n![image](https://assets.leetcode.com/users/images/71dd5483-7bb5-4ccc-a2b6-8b725c4408e2_1679515221.8804884.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/14dc79a2-63ba-4ce5-883e-89931b232ab8_1679515220.8992481.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int num) {\\n//         EG-PG QUESTION:\\n       if(num<=0) return 0; if(num<10) return 1;\\n        std::string str_num = std::to_string(num);\\n        int len=str_num.length();\\n        int base=pow(10,len-1);\\n        int firstDigit=num/base;\\n        int rem=num % base;\\n        int One_Base=firstDigit==1 ? num-base+1 : base; \\n        return countDigitOne(rem)  +    One_Base  +  firstDigit * countDigitOne(base-1);\\n    }\\n};\\n```\\nPLEASE UPVOTE !!!!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int num) {\\n//         EG-PG QUESTION:\\n       if(num<=0) return 0; if(num<10) return 1;\\n        std::string str_num = std::to_string(num);\\n        int len=str_num.length();\\n        int base=pow(10,len-1);\\n        int firstDigit=num/base;\\n        int rem=num % base;\\n        int One_Base=firstDigit==1 ? num-base+1 : base; \\n        return countDigitOne(rem)  +    One_Base  +  firstDigit * countDigitOne(base-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269535,
                "title": "michael-scott-says-he-beat-this-in-java-100-with-simple-math",
                "content": "# Intuition\\nMichael is busy making cupcakes for everyone. This is Kevin, I\\'ll explain the code because it uses Math and I am great at it.\\n\\nGod I believe. Loop add numbers. Car no go. Corner case\\n\\nBye\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if(n==0) return 0;\\n        List<Integer> god = new ArrayList<>();\\n        int count = (int)(Math.log(n)/Math.log(10));\\n        if(n>=1 && n<=9)\\n        {\\n            return 1;\\n        }\\n        int ones = 1;\\n        god.add(2);\\n        for(int i=1;i<=count;i++)\\n        {\\n            ones= ones*10 + (int)Math.pow(10,i);\\n            god.add(ones+1);\\n        }\\n        \\n        String num = Integer.toString(n);\\n\\n        int ans = 0;\\n        int l = num.length();\\n        int i=0;\\n        for(i=0;i<l-2;i++)\\n        {\\n            if(num.charAt(i)==\\'1\\')\\n            {\\n                ans+=god.get(l-2-i)+Integer.parseInt(num.substring(i+1));\\n                \\n            }\\n            else if(num.charAt(i)>\\'1\\') \\n            {\\n                ans+=Math.pow(10,l-i-1)+(l-i-1)*(num.charAt(i)-\\'0\\')*Math.pow(10,l-i-2);    \\n                         \\n            }\\n             \\n        }\\n        if(num.charAt(i)>\\'1\\')\\n        {\\n            ans+=10+num.charAt(i)-\\'0\\';\\n        }\\n        else if(num.charAt(i)==\\'1\\')\\n        {\\n            ans+=2+num.charAt(i+1)-\\'0\\';\\n        }\\n        i++;\\n        if(num.charAt(i)>=\\'1\\') ans+=1;\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if(n==0) return 0;\\n        List<Integer> god = new ArrayList<>();\\n        int count = (int)(Math.log(n)/Math.log(10));\\n        if(n>=1 && n<=9)\\n        {\\n            return 1;\\n        }\\n        int ones = 1;\\n        god.add(2);\\n        for(int i=1;i<=count;i++)\\n        {\\n            ones= ones*10 + (int)Math.pow(10,i);\\n            god.add(ones+1);\\n        }\\n        \\n        String num = Integer.toString(n);\\n\\n        int ans = 0;\\n        int l = num.length();\\n        int i=0;\\n        for(i=0;i<l-2;i++)\\n        {\\n            if(num.charAt(i)==\\'1\\')\\n            {\\n                ans+=god.get(l-2-i)+Integer.parseInt(num.substring(i+1));\\n                \\n            }\\n            else if(num.charAt(i)>\\'1\\') \\n            {\\n                ans+=Math.pow(10,l-i-1)+(l-i-1)*(num.charAt(i)-\\'0\\')*Math.pow(10,l-i-2);    \\n                         \\n            }\\n             \\n        }\\n        if(num.charAt(i)>\\'1\\')\\n        {\\n            ans+=10+num.charAt(i)-\\'0\\';\\n        }\\n        else if(num.charAt(i)==\\'1\\')\\n        {\\n            ans+=2+num.charAt(i+1)-\\'0\\';\\n        }\\n        i++;\\n        if(num.charAt(i)>=\\'1\\') ans+=1;\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125590,
                "title": "python-easiest-one-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return sum((n/a+8)/10*a + (n/a%10==1)*(n%a+1) for a in (10**pp for pp in range(10)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return sum((n/a+8)/10*a + (n/a%10==1)*(n%a+1) for a in (10**pp for pp in range(10)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576802,
                "title": "c-solution-digit-dp-memoization-0-ms-solution",
                "content": "![image](https://assets.leetcode.com/users/images/afc109f7-d741-4dd4-a37c-d6cab11b1b99_1663182439.0314956.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, int idx, int tight, int count, vector<vector<vector<int>>>& dp) {\\n        if (idx == s.length()) return count;\\n        if (dp[idx][tight][count] != -1) return dp[idx][tight][count];\\n        int ans = 0, bound = 9;\\n        if (tight) bound = s[idx] - \\'0\\';\\n        for (int i = 0; i <= bound; i++) {\\n            int add = 0;\\n            if (i == 1) add = 1;\\n            ans += solve(s, idx + 1, tight & (i == bound), count + add, dp);\\n        }\\n        return dp[idx][tight][count] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        string str = to_string(n);\\n        vector<vector<vector<int>>>dp(10, vector<vector<int>>(2, vector<int>(10, -1)));\\n        return solve(str, 0, 1, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, int idx, int tight, int count, vector<vector<vector<int>>>& dp) {\\n        if (idx == s.length()) return count;\\n        if (dp[idx][tight][count] != -1) return dp[idx][tight][count];\\n        int ans = 0, bound = 9;\\n        if (tight) bound = s[idx] - \\'0\\';\\n        for (int i = 0; i <= bound; i++) {\\n            int add = 0;\\n            if (i == 1) add = 1;\\n            ans += solve(s, idx + 1, tight & (i == bound), count + add, dp);\\n        }\\n        return dp[idx][tight][count] = ans;\\n    }\\n    int countDigitOne(int n) {\\n        string str = to_string(n);\\n        vector<vector<vector<int>>>dp(10, vector<vector<int>>(2, vector<int>(10, -1)));\\n        return solve(str, 0, 1, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506223,
                "title": "no-recursion-no-dp-in-o-logn-time",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        nst=str(n)\\n        s=0\\n        ln=len(nst)\\n        if(n<10):\\n            if(n==0):\\n                return 0\\n            else:\\n                return 1\\n        for i in range(ln):\\n            if(nst[i]==\"0\"):\\n                x=str(int(nst[:i])-1)+(ln-i-1)*\"9\"\\n            elif(nst[i]==\"1\"):\\n                x=nst[:i]+nst[i+1:]\\n            else:\\n                x=nst[:i]+(ln-i-1)*\"9\"\\n            # print(x)\\n            if(x==\"\"):\\n                continue\\n            s+=int(x)+1\\n        return(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        nst=str(n)\\n        s=0\\n        ln=len(nst)\\n        if(n<10):\\n            if(n==0):\\n                return 0\\n            else:\\n                return 1\\n        for i in range(ln):\\n            if(nst[i]==\"0\"):\\n                x=str(int(nst[:i])-1)+(ln-i-1)*\"9\"\\n            elif(nst[i]==\"1\"):\\n                x=nst[:i]+nst[i+1:]\\n            else:\\n                x=nst[:i]+(ln-i-1)*\"9\"\\n            # print(x)\\n            if(x==\"\"):\\n                continue\\n            s+=int(x)+1\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479774,
                "title": "doubt-34-38-test-cases-passing",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        //base case\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        long long int smallCountDigitOne = countDigitOne(n-1);\\n        long long int count=0;\\n        while(n>=1){\\n            long long int lastNumber = n%10;\\n            if(lastNumber==1) count++;\\n            n/=10;\\n        } \\n        return smallCountDigitOne+count;\\n    }\\n};\\n```\\n\\n34/38 test cases are passing . Can you help me to debug  my code ?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        //base case\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        long long int smallCountDigitOne = countDigitOne(n-1);\\n        long long int count=0;\\n        while(n>=1){\\n            long long int lastNumber = n%10;\\n            if(lastNumber==1) count++;\\n            n/=10;\\n        } \\n        return smallCountDigitOne+count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910370,
                "title": "number-of-digit-one-solution-java",
                "content": "class Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1795535,
                "title": "python-o-n-easy-to-understand",
                "content": "if digit(i) is \\'1\\', how many numbers it can form that is lower than n?\\nlet n = x + digit(i) + y (string\\'s concatenation)\\nk = len(y) + 1\\nThere are 3 different cases: digit(i) = 0, digit(i) = 1, digit(i) > 1\\nSee the code\\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        s = str(n)\\n        ret = 0\\n        # for each digit i, x is the higher digits, y is the lower digits\\n        # discuss different cases\\n        for i in range(len(s)):\\n            x, y = int(s[:i] if s[:i] else \\'0\\'), int(s[i+1:] if s[i+1:] else \\'0\\')\\n            k = 10 ** (len(s) - 1 - i)\\n            if s[i] == \\'0\\':\\n                ret += x * k\\n            elif s[i] == \\'1\\':\\n                ret += x * k + y + 1\\n            else:\\n                ret += (x + 1) * k\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        s = str(n)\\n        ret = 0\\n        # for each digit i, x is the higher digits, y is the lower digits\\n        # discuss different cases\\n        for i in range(len(s)):\\n            x, y = int(s[:i] if s[:i] else \\'0\\'), int(s[i+1:] if s[i+1:] else \\'0\\')\\n            k = 10 ** (len(s) - 1 - i)\\n            if s[i] == \\'0\\':\\n                ret += x * k\\n            elif s[i] == \\'1\\':\\n                ret += x * k + y + 1\\n            else:\\n                ret += (x + 1) * k\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546474,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        ans,digit,value,pow10 = 0,0,0,1\\n        while n:\\n            x = n%10  \\n            if x == 1: ans += value + digit * pow10//10 + 1\\n            elif x > 1 : ans += x * digit * pow10//10 + pow10\\n            value += x * pow10\\n            digit += 1\\n            pow10 *= 10\\n            n = n//10\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        ans,digit,value,pow10 = 0,0,0,1\\n        while n:\\n            x = n%10  \\n            if x == 1: ans += value + digit * pow10//10 + 1\\n            elif x > 1 : ans += x * digit * pow10//10 + pow10\\n            value += x * pow10\\n            digit += 1\\n            pow10 *= 10\\n            n = n//10\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520849,
                "title": "c-digit-dp-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][99][11]; //dp[pos][tight][sum][count]\\n    int solve(vector<int> &arr, int pos, bool tight, int sum, int count){\\n        if(pos==(signed)arr.size()) return count;\\n        if(dp[pos][tight][sum][count]!=-1) return dp[pos][tight][sum][count];\\n        \\n        int cur=0;\\n        if(tight){ \\n            for(int i=0;i<=arr[pos];++i){\\n                if(sum==0 and i==0) cur+=solve(arr,pos+1,false,sum+i, count); //leading zero\\n                else if(i==arr[pos]){ //last(tight) number\\n                    if(i==1) cur+=solve(arr,pos+1,true,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,true,sum+i,count);\\n                }else{\\n                    if(i==1) cur+=solve(arr,pos+1,false,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,false,sum+i,count);\\n                } \\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(sum==0 and i==0) cur+=solve(arr,pos+1,false,sum+i,count); //leading zero\\n                else{\\n                    if(i==1) cur+=solve(arr,pos+1,false,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,false,sum+i,count);\\n                }\\n            }\\n        }\\n        \\n        return dp[pos][tight][sum][count]=cur;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        vector<int> arr;\\n        int x=n;\\n        while(x){\\n            arr.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse(arr.begin(),arr.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,true,0,0);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][99][11]; //dp[pos][tight][sum][count]\\n    int solve(vector<int> &arr, int pos, bool tight, int sum, int count){\\n        if(pos==(signed)arr.size()) return count;\\n        if(dp[pos][tight][sum][count]!=-1) return dp[pos][tight][sum][count];\\n        \\n        int cur=0;\\n        if(tight){ \\n            for(int i=0;i<=arr[pos];++i){\\n                if(sum==0 and i==0) cur+=solve(arr,pos+1,false,sum+i, count); //leading zero\\n                else if(i==arr[pos]){ //last(tight) number\\n                    if(i==1) cur+=solve(arr,pos+1,true,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,true,sum+i,count);\\n                }else{\\n                    if(i==1) cur+=solve(arr,pos+1,false,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,false,sum+i,count);\\n                } \\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(sum==0 and i==0) cur+=solve(arr,pos+1,false,sum+i,count); //leading zero\\n                else{\\n                    if(i==1) cur+=solve(arr,pos+1,false,sum+i,count+1);\\n                    else cur+=solve(arr,pos+1,false,sum+i,count);\\n                }\\n            }\\n        }\\n        \\n        return dp[pos][tight][sum][count]=cur;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        vector<int> arr;\\n        int x=n;\\n        while(x){\\n            arr.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse(arr.begin(),arr.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,true,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483251,
                "title": "digit-dp-c-solution-for-any-digit",
                "content": "Inspired by [mukulsoni](http://leetcode.com/mukulsoni)\\nThis Solution works if target digit is in range of (1-9)\\n```\\n    int digitdp[11][2][2][10]; // digitdp[n][tight][leading][count]\\n    int solve(string s,int n,bool tight,bool leading,int count,int tar) //tar= target digit\\n    {\\n            if(n==0)return count;\\n            if(digitdp[n][tight][leading][count]!=-1)return digitdp[n][tight][leading][count];\\n            int ans=0;\\n            int ub; //upper_bound\\n            if(tight==1)ub=s[s.size()-n]-\\'0\\';\\n            else ub=9;\\n            for(int dig=0;dig<=ub;dig++)\\n            {\\n                ans+=solve(s,n-1,(tight&(ub==dig)),0,count+(dig==tar),tar);\\n            }\\n            return digitdp[n][tight][leading][count]=ans;\\n         }\\n\\t\\tint countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(digitdp,-1,sizeof(digitdp));\\n        return solve(s,s.size(),1,1,0,1);\\n    }\\n```\\nbut if target digit is 0 ,we have to consider leading digit,in that case we just have to add one line and 1 else\\n```\\nfor(int dig=0;dig<=ub;dig++)\\n{\\n       if(leading==1&&dig==0)ans+=solve(s,n-1,tight&(ub==dig),1,count,tar);   \\n       else ans+=solve(s,n-1,(tight&(ub==dig)),0,count+(dig==tar),tar);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int digitdp[11][2][2][10]; // digitdp[n][tight][leading][count]\\n    int solve(string s,int n,bool tight,bool leading,int count,int tar) //tar= target digit\\n    {\\n            if(n==0)return count;\\n            if(digitdp[n][tight][leading][count]!=-1)return digitdp[n][tight][leading][count];\\n            int ans=0;\\n            int ub; //upper_bound\\n            if(tight==1)ub=s[s.size()-n]-\\'0\\';\\n            else ub=9;\\n            for(int dig=0;dig<=ub;dig++)\\n            {\\n                ans+=solve(s,n-1,(tight&(ub==dig)),0,count+(dig==tar),tar);\\n            }\\n            return digitdp[n][tight][leading][count]=ans;\\n         }\\n\\t\\tint countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(digitdp,-1,sizeof(digitdp));\\n        return solve(s,s.size(),1,1,0,1);\\n    }\\n```\n```\\nfor(int dig=0;dig<=ub;dig++)\\n{\\n       if(leading==1&&dig==0)ans+=solve(s,n-1,tight&(ub==dig),1,count,tar);   \\n       else ans+=solve(s,n-1,(tight&(ub==dig)),0,count+(dig==tar),tar);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453897,
                "title": "digit-dp-c-100percent-faster",
                "content": "We will use digit dp to solve this problem.I have tried to use descriptive variable name. \\n\\n\\n```cpp\\nclass Solution {\\n    long long dp[10][2][10];//pos small number of 1\\'s\\n    string curr=\"\";\\n    long long recursion(int pos , int small , int number_of_1 , string &curr)\\n    {\\n        if(pos==curr.size())\\n            return number_of_1;\\n        long long &ans=dp[pos][small][number_of_1];\\n        if(ans!=-1)\\n            return ans;\\n        ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(small || i<curr[pos]-\\'0\\')\\n                ans+=recursion(pos+1,1,number_of_1+(i==1),curr);\\n            else if(i==curr[pos]-\\'0\\')\\n                ans+=recursion(pos+1,0,number_of_1+(i==1),curr);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        curr=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        long long ans=recursion(0,0,0,curr);\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\n    long long dp[10][2][10];//pos small number of 1\\'s\\n    string curr=\"\";\\n    long long recursion(int pos , int small , int number_of_1 , string &curr)\\n    {\\n        if(pos==curr.size())\\n            return number_of_1;\\n        long long &ans=dp[pos][small][number_of_1];\\n        if(ans!=-1)\\n            return ans;\\n        ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(small || i<curr[pos]-\\'0\\')\\n                ans+=recursion(pos+1,1,number_of_1+(i==1),curr);\\n            else if(i==curr[pos]-\\'0\\')\\n                ans+=recursion(pos+1,0,number_of_1+(i==1),curr);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        curr=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        long long ans=recursion(0,0,0,curr);\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434607,
                "title": "100-faster-no-recursion-just-for-loops",
                "content": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int dp[] = new int[11];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2;i<=10;i++){\\n            int repeat = (int)Math.pow(10 , i-1);\\n            for(int j=0;j<=9;j++){\\n                int extra = (j == 1) ? repeat : 0;\\n                dp[i] += (extra + dp[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        String num = Integer.toString(n);\\n        int len = num.length();\\n        int extra = 0;\\n        \\n        for(int i=0;i<num.length();i++){\\n            int x = num.charAt(i) - \\'0\\';\\n            int now = (int)Math.pow(10 , len - i-1);\\n            for(int j=0;j<x;j++){\\n                ans += ((j == 1) ? now : 0) + dp[len-i-1] + extra * now;\\n            }\\n            if(x == 1)\\n                extra++;\\n        }\\n        \\n        ans += extra;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int dp[] = new int[11];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2;i<=10;i++){\\n            int repeat = (int)Math.pow(10 , i-1);\\n            for(int j=0;j<=9;j++){\\n                int extra = (j == 1) ? repeat : 0;\\n                dp[i] += (extra + dp[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        String num = Integer.toString(n);\\n        int len = num.length();\\n        int extra = 0;\\n        \\n        for(int i=0;i<num.length();i++){\\n            int x = num.charAt(i) - \\'0\\';\\n            int now = (int)Math.pow(10 , len - i-1);\\n            for(int j=0;j<x;j++){\\n                ans += ((j == 1) ? now : 0) + dp[len-i-1] + extra * now;\\n            }\\n            if(x == 1)\\n                extra++;\\n        }\\n        \\n        ans += extra;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337205,
                "title": "java-c-faster-than-100-00-online-submissions",
                "content": "C++ Solution\\n\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        long long int count =0;\\n        for(long long int i =1;i<=n;i*=10){\\n            long long int div = i*10;\\n            count += (n/div)*i+min((int)max((int)(n%div-i+1),(int)0),(int)i);\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nJava Solution\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        // for n = 13\\n        //  1 , 2, 3, 4,5,6,7,8,9,10,11,12,13\\n        // 1, 10, 11,12,13\\n        //total no. of 1 = 1 + 1 + 2 + 1 +1 = 6 , we need to add the initial 1.\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i*= 10){\\n            int divide = i * 10;\\n            count += (n / divide) * i  ;    \\n            int  max = 0;\\n            int dig = n % divide - i + 1;\\n            if(max < dig){\\n                max = dig;\\n            }else{\\n                max = 0;\\n            }\\n            if(dig < i){\\n                count += max;\\n            }else{\\n                count += i;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        long long int count =0;\\n        for(long long int i =1;i<=n;i*=10){\\n            long long int div = i*10;\\n            count += (n/div)*i+min((int)max((int)(n%div-i+1),(int)0),(int)i);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        // for n = 13\\n        //  1 , 2, 3, 4,5,6,7,8,9,10,11,12,13\\n        // 1, 10, 11,12,13\\n        //total no. of 1 = 1 + 1 + 2 + 1 +1 = 6 , we need to add the initial 1.\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i*= 10){\\n            int divide = i * 10;\\n            count += (n / divide) * i  ;    \\n            int  max = 0;\\n            int dig = n % divide - i + 1;\\n            if(max < dig){\\n                max = dig;\\n            }else{\\n                max = 0;\\n            }\\n            if(dig < i){\\n                count += max;\\n            }else{\\n                count += i;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252203,
                "title": "digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    \\n    int helper(string s,int pos,int count,int tight = 1)\\n    {\\n        if(pos == s.size()){\\n            return count;\\n        }\\n        if(dp[pos][count][tight] != -1){\\n            return dp[pos][count][tight];\\n        }\\n        int ones = 0;\\n        int ub = (tight)?s[pos]-\\'0\\':9;\\n        for(int i = 0;i<=ub;i++)\\n        {\\n            if(i == 1){\\n                ones += helper(s,pos+1,count+1,tight&(i==ub));\\n            }\\n            else{\\n                ones += helper(s,pos+1,count,tight&(i==ub));\\n            }\\n        }\\n        return dp[pos][count][tight] = ones;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][11][2];\\n    \\n    int helper(string s,int pos,int count,int tight = 1)\\n    {\\n        if(pos == s.size()){\\n            return count;\\n        }\\n        if(dp[pos][count][tight] != -1){\\n            return dp[pos][count][tight];\\n        }\\n        int ones = 0;\\n        int ub = (tight)?s[pos]-\\'0\\':9;\\n        for(int i = 0;i<=ub;i++)\\n        {\\n            if(i == 1){\\n                ones += helper(s,pos+1,count+1,tight&(i==ub));\\n            }\\n            else{\\n                ones += helper(s,pos+1,count,tight&(i==ub));\\n            }\\n        }\\n        return dp[pos][count][tight] = ones;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955578,
                "title": "golang-solution-olgn-complexity",
                "content": "```\\nfunc countDigitOne(n int) int {\\n\\tvar result, k, a, b, c int\\n\\tfor a, k = n, 1; k <= n; k *= 10 {\\n\\t\\ta, b, c = a/10, a%10, n%k\\n\\t\\tswitch b {\\n\\t\\tcase 0:\\n\\t\\t\\tresult += a * k\\n\\t\\tcase 1:\\n\\t\\t\\tresult += a*k + c + 1\\n\\t\\tdefault:\\n\\t\\t\\tresult += a*k + k\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\nThe basic idea is counting number of ones of each digit from back to front. \\n\\nFor example, Let\\'s count number of ones at thousand digit of 1234567. First split number into three parts.\\n```\\n1 2 3 4 5 6 7\\n|-a-| b |-c-|\\na=123 b=4 c=567\\n```\\n\\nThe thousand digit is 4. How many ones at thousand digit positoin? \\n\\n```\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n  1231000 1231001...1231999   1000 ones   \\n```\\n\\nThere are  `(123 + 1) * 1000` ones at thousand digit when the thousand digit is 4 or any number greater than 1.\\n\\nWhat if the thousand digit is 1 of case 1231567?\\n```\\n1 2 3 1 5 6 7\\n|-a-| b |-c-|\\na=123 b=1 c=567\\n\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n  1231000 1231001...1231456   456+1 ones   \\n```\\nThere are  `123 * 1000 + 456 + 1` ones at thousand digit when thousand digit is 1.\\n\\nWhat if the thousand digit is 0 of case 1230567?\\n\\n```\\n1 2 3 0 5 6 7\\n|-a-| b |-c-|\\na=123 b=0 c=567\\n\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n```\\nThere are  `123 * 1000` ones at thousand digit when thousand digit is 0.\\n\\nThis is the basic idea how to count number of ones of each digits. \\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countDigitOne(n int) int {\\n\\tvar result, k, a, b, c int\\n\\tfor a, k = n, 1; k <= n; k *= 10 {\\n\\t\\ta, b, c = a/10, a%10, n%k\\n\\t\\tswitch b {\\n\\t\\tcase 0:\\n\\t\\t\\tresult += a * k\\n\\t\\tcase 1:\\n\\t\\t\\tresult += a*k + c + 1\\n\\t\\tdefault:\\n\\t\\t\\tresult += a*k + k\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n1 2 3 4 5 6 7\\n|-a-| b |-c-|\\na=123 b=4 c=567\\n```\n```\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n  1231000 1231001...1231999   1000 ones   \\n```\n```\\n1 2 3 1 5 6 7\\n|-a-| b |-c-|\\na=123 b=1 c=567\\n\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n  1231000 1231001...1231456   456+1 ones   \\n```\n```\\n1 2 3 0 5 6 7\\n|-a-| b |-c-|\\na=123 b=0 c=567\\n\\n     1000 1001...1999         1000 ones \\n    11000 11001...11999       1000 ones\\n    21000 21001...21999       1000 ones\\n     .\\n     .\\n     .\\n  1221000 1221001...1221999   1000 ones   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826583,
                "title": "digit-dp-solution-java",
                "content": "```\\nclass Solution {\\n    static String str;\\n    static int dp[][][];\\n    \\n    public static int solve(int pos, int tight, int count){\\n        if(pos == str.length()){\\n            return count;\\n        }\\n        if(dp[pos][tight][count] != -1){\\n            return dp[pos][tight][count];\\n        }\\n        int en = tight == 1 ? str.charAt(pos)-\\'0\\' : 9;\\n        int ans = 0;\\n        \\n        for(int i = 0; i <= en; i++){\\n            int countUp = count;\\n            if(i == 1)\\n                countUp++;\\n            \\n           dp[pos][tight][count] = ans +=  solve(pos+1, tight == 1 && i == en ? 1 : 0, countUp);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    public int countDigitOne(int n) {\\n        str = \"\" + n;\\n        dp = new int[str.length()+1][2][10];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = 0; j < dp[i].length; j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        return solve(0,1,0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static String str;\\n    static int dp[][][];\\n    \\n    public static int solve(int pos, int tight, int count){\\n        if(pos == str.length()){\\n            return count;\\n        }\\n        if(dp[pos][tight][count] != -1){\\n            return dp[pos][tight][count];\\n        }\\n        int en = tight == 1 ? str.charAt(pos)-\\'0\\' : 9;\\n        int ans = 0;\\n        \\n        for(int i = 0; i <= en; i++){\\n            int countUp = count;\\n            if(i == 1)\\n                countUp++;\\n            \\n           dp[pos][tight][count] = ans +=  solve(pos+1, tight == 1 && i == en ? 1 : 0, countUp);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    public int countDigitOne(int n) {\\n        str = \"\" + n;\\n        dp = new int[str.length()+1][2][10];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = 0; j < dp[i].length; j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        return solve(0,1,0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753348,
                "title": "python3-two-approaches",
                "content": "The brute force approach to solve this problem is given below \\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        return sum(str(i).count(\"1\") for i in range(1, n+1))\\n```\\nIt is straightforward but inefficient with `O(N)` time complexity. As a result, it suffers from TLE for large `n`. To improve upon the brute force solution, we will working on `O(logN)` solutions like the two given below. \\n\\nApproach 1 - digit by digit \\nIn this approach, we divide the number into three parts: 1) leading digits, 2) current digit and 3) trailing digits. Take the number `271828` for an example. We\\'d process the number from lower to higher digit. At `1`, we\\'d consider `27` as the leading digits and `828` as the trailing digits, i.e. `27 | 1 | 828`. To figure out how many `1` contributed by a given digit, it is important to figure out how each part contributes. \\n* Leading digits - Each leading digit whose result is guaranteed not to exceed the current value (0-26 in the above example) contributes to `ans` by current magnitude. For example, if we take `0` as the leading digit, 1000-1999 are all valid numbers which contributes `1` in the current digit. So there are `27*1000` such numbers. \\n* Current * trailing digits - This is revevant when leading digit reaches its allowed maximum (`27` in our current example). There are three cases to consider. \\n\\t* if current digit == 0, there is nothing to do as no more `1`\\'s could be added. \\n\\t* if current digit == 1, numbers ending with `1000 - 1828` contribute to `ans` (i.e. add 1 + trailing)\\n\\t* if current digit > 1 (for example we are dealing with `27 | 2 | 828`, then we know that 1000-1999 are valid in this case and thus we add `1000` to `ans`. \\n\\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n < 0: return 0 #edge case \\n        ans = d = tr = 0\\n        m = 1 # magnitude\\n        while n: \\n            tr += d*m//10 #trailing digit\\n            n, d = divmod(n, 10) #leading & current digit \\n            ans += n * m\\n            if d == 1: ans += tr + 1\\n            elif d > 1: ans += m \\n            m *= 10 \\n        return ans \\n```\\n\\nApproach 2 - \\nThis alternative approach utilizes the below fact which is not difficult to prove mathematically using recursions. \\n`fn(9) = 1`\\n`fn(99) = 20`\\n`fn(999) = 300`\\n`fn(9999) = 4000`\\n\\nGiven a number (say `271828`), we recursively check \\n`fn(8) = 1`\\n`fn(28) = fn(20) + fn(8)`\\n`fn(828) = fn(800) + fn(28)`\\n`fn(1828) = fn(1000) + fn(828) + 828`\\n`fn(71828) = fn(70000) + fn(1828)`\\n`fn(271828) = fn(200000) + fn(71828)`\\n\\nwhere `fn(20)`, `fn(800)`, ... are computed through a helper function `fn(k, i)` which givens the answer for `k*10**i`. \\n\\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n < 0: return 0 #edge case \\n        \\n        #number of 1\\'s in n where 0 <= n <= x*10**i\\n        fn = lambda k, i: k*i*10**(i-1) + (k==1) + (k>1)*10**i\\n        \\n        ans = val = i = 0\\n        while n:\\n            n, x = divmod(n, 10)\\n            ans += fn(x, i) + (x==1)*val\\n            val += x*10**i\\n            i += 1\\n        return int(ans) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        return sum(str(i).count(\"1\") for i in range(1, n+1))\\n```\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n < 0: return 0 #edge case \\n        ans = d = tr = 0\\n        m = 1 # magnitude\\n        while n: \\n            tr += d*m//10 #trailing digit\\n            n, d = divmod(n, 10) #leading & current digit \\n            ans += n * m\\n            if d == 1: ans += tr + 1\\n            elif d > 1: ans += m \\n            m *= 10 \\n        return ans \\n```\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n < 0: return 0 #edge case \\n        \\n        #number of 1\\'s in n where 0 <= n <= x*10**i\\n        fn = lambda k, i: k*i*10**(i-1) + (k==1) + (k>1)*10**i\\n        \\n        ans = val = i = 0\\n        while n:\\n            n, x = divmod(n, 10)\\n            ans += fn(x, i) + (x==1)*val\\n            val += x*10**i\\n            i += 1\\n        return int(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 501999,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online",
                "content": "```\\npublic int countDigitOne(int n) {\\n       int res = 0;\\n       long a = 0;\\n       long b = 0;\\n       for(long m=1;m<=n;m*=10){\\n           a = n/m;\\n           b = n%m;\\n           if(a % 10 > 1){\\n               res += a/10 * m + m;\\n           }else if( a%10 == 1){\\n               res += a/10 * m + b + 1;\\n           }else{\\n               res += a/10 * m;\\n           }\\n       }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countDigitOne(int n) {\\n       int res = 0;\\n       long a = 0;\\n       long b = 0;\\n       for(long m=1;m<=n;m*=10){\\n           a = n/m;\\n           b = n%m;\\n           if(a % 10 > 1){\\n               res += a/10 * m + m;\\n           }else if( a%10 == 1){\\n               res += a/10 * m + b + 1;\\n           }else{\\n               res += a/10 * m;\\n           }\\n       }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454810,
                "title": "c-solution-with-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int sum, int tight, string& no, vector<vector<vector<long>>>& dp)\\n    {\\n        if(i >= no.length())\\n            return sum;\\n        \\n        if(dp[i][sum][tight] != -1)\\n            return dp[i][sum][tight];\\n        \\n        int k = (tight == 1) ? no[i]-\\'0\\' : 9;\\n        \\n        int res = 0;\\n        for(int j = 0; j <= k; j++)\\n        {\\n            int newTight = (no[i] == j+\\'0\\') ? tight : 0;\\n            \\n            if(j == 1)\\n            {\\n                res = res + solve(i+1, sum+1, newTight, no, dp);\\n            }\\n            else\\n            {\\n                res = res + solve(i+1, sum, newTight, no, dp);\\n            }\\n        }\\n        \\n        dp[i][sum][tight] = res;\\n        return res;\\n    }\\n    int countDigitOne(int n) {\\n        \\n        string digit = to_string(n);\\n        \\n        n = digit.length();\\n        \\n        vector<vector<vector<long>>> dp(n+1, vector<vector<long>>(15, vector<long>(2, -1)));\\n        \\n        return solve(0, 0, 1, digit, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int sum, int tight, string& no, vector<vector<vector<long>>>& dp)\\n    {\\n        if(i >= no.length())\\n            return sum;\\n        \\n        if(dp[i][sum][tight] != -1)\\n            return dp[i][sum][tight];\\n        \\n        int k = (tight == 1) ? no[i]-\\'0\\' : 9;\\n        \\n        int res = 0;\\n        for(int j = 0; j <= k; j++)\\n        {\\n            int newTight = (no[i] == j+\\'0\\') ? tight : 0;\\n            \\n            if(j == 1)\\n            {\\n                res = res + solve(i+1, sum+1, newTight, no, dp);\\n            }\\n            else\\n            {\\n                res = res + solve(i+1, sum, newTight, no, dp);\\n            }\\n        }\\n        \\n        dp[i][sum][tight] = res;\\n        return res;\\n    }\\n    int countDigitOne(int n) {\\n        \\n        string digit = to_string(n);\\n        \\n        n = digit.length();\\n        \\n        vector<vector<vector<long>>> dp(n+1, vector<vector<long>>(15, vector<long>(2, -1)));\\n        \\n        return solve(0, 0, 1, digit, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386735,
                "title": "digital-dp-0ms",
                "content": "```java\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int[] digits = new int[10];        \\n        int pos = 0;\\n        while (n > 0) {\\n            digits[pos++] = n % 10;\\n            n /= 10;\\n        }\\n        return dfs(digits, pos - 1, new int[10][10], 0, true);\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int[][] dp, int cnt, boolean limit) {\\n        if (pos == -1) return cnt;\\n        if (!limit && dp[pos][cnt] != 0) return dp[pos][cnt];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            ans += dfs(digits, pos - 1, dp, cnt + (i == 1 ? 1 : 0), limit && i == up);\\n        }\\n        if (!limit) dp[pos][cnt] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int[] digits = new int[10];        \\n        int pos = 0;\\n        while (n > 0) {\\n            digits[pos++] = n % 10;\\n            n /= 10;\\n        }\\n        return dfs(digits, pos - 1, new int[10][10], 0, true);\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int[][] dp, int cnt, boolean limit) {\\n        if (pos == -1) return cnt;\\n        if (!limit && dp[pos][cnt] != 0) return dp[pos][cnt];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            ans += dfs(digits, pos - 1, dp, cnt + (i == 1 ? 1 : 0), limit && i == up);\\n        }\\n        if (!limit) dp[pos][cnt] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64409,
                "title": "python-more-general-question-count-a-given-digit-d",
                "content": "try to solve a more general version: count the total number of digit d ( 1<= d <= 9)\\nIn essence, the method is the same as [this post](https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python).\\nAnd I brief the idea again here:\\nthe total appearance of digit d =  sum( the appearance of d at i_th decimal position for possible i's) \\nTherefore the sub problem of this question is: the appearance of d at i_th decimal position, where 1 <= i <= log10(n). \\n\\nWhen count the appearance of d at i_th position, we decompose number n into this three component n = \"axb\", where x is the number at i_th position. For example, if n = \"43210\", when counting the appearance of d at 2nd decimal position (tens-digit), n is decomposed to a = 432, x = 1, b=0.\\nThis problem can be resolved by considering these three scenarios:\\n1. the number at x_th position > d\\nin this case,  subproblem count = (a+1) * 10^(i-1) \\n2. the number at x_th position == d\\nin this case, subproblem count = a * 10^(i-1) + (b+1)\\n3. the number at x_th position < d\\nin this case, subproblem count = a * 10^(i-1)\\n\\n```python\\ndef count_digit(n, digit):\\n    c = 0\\n    div = 1\\n    while div <= n:\\n        a = n/div\\n        b = n%div\\n        x = a%10\\n        if x > digit:\\n            c += (a/10 + 1) * div\\n        elif x == digit:\\n            c += b + 1 + (a/10) * div\\n        else:\\n            c += (a/10) * div\\n        div *= 10\\n    return c\\n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef count_digit(n, digit):\\n    c = 0\\n    div = 1\\n    while div <= n:\\n        a = n/div\\n        b = n%div\\n        x = a%10\\n        if x > digit:\\n            c += (a/10 + 1) * div\\n        elif x == digit:\\n            c += b + 1 + (a/10) * div\\n        else:\\n            c += (a/10) * div\\n        div *= 10\\n    return c\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 64442,
                "title": "java-recursive-ac-solution",
                "content": "        public int countDigitOne(int n) {\\n            String numstr = Integer.toString(n);\\n            return helper(n, numstr.length());\\n        }\\n        public int helper(int n, int len){\\n            if(n < 1)  return 0;\\n            else if(len == 1)    return 1;\\n            int pow = (int)Math.pow(10, len-1);\\n            int msd = n / pow;\\n            if(msd == 0)    return helper(n, len - 1);\\n            return (msd == 1 ? n % pow + 1 : pow) + helper(n % pow, len - 1) + msd * helper(pow - 1, len - 1);\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        public int countDigitOne(int n) {\\n            String numstr = Integer.toString(n);\\n            return helper(n, numstr.length());\\n        }\\n        public int helper(int n, int len){\\n            if(n < 1)  return 0;\\n            else if(len == 1)    return 1;\\n            int pow = (int)Math.pow(10, len-1);\\n            int msd = n / pow;\\n            if(msd == 0)    return helper(n, len - 1);\\n            return (msd == 1 ? n % pow + 1 : pow) + helper(n % pow, len - 1) + msd * helper(pow - 1, len - 1);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3715018,
                "title": "explained-to-a-5-year-old",
                "content": "# Intuition\\nThe key intuition is that we count the number of 1\\'s contributed by every digit\\'s place in the number.\\nFor example, if `n` is a 3-digit number, some of the 1\\'s would be contributed by the 1\\'s place, some by the 10\\'s place and some by the 100\\'s place.\\n\\n# Approach\\nObserve that for every range of 10, like 0-9, 10-19, 20-29 etc., 1 appears in 1\\'s place only once.\\nLike for 0-9, it appears once in 1, for 10-19, its appears in 1\\'s place once in 11, for 20-29, it appears in 1\\'s place once in 21.\\n**So, if we count the number of 10\\'s in `n`, we will have as many 1\\'s contributed by the 1\\'s place.**\\n\\nSimilarly, for every range of 100, 1 appears in 10\\'s place 10 times. Example, for 0-100, 1 appears in 10\\'s place only from 10-19.\\n**So, if we count the number of 100\\'s in `n`, and multiply the result by 10, we will have as many 1\\'s contributed by the 10\\'s place.**\\n\\n**Generalizing this pattern, the number of 1\\'s for any digit position `1 <= d <= length(n)` is given by:**\\n```\\n10^(d-1) * floor(n/10^d).  --- (i)\\n```\\n\\nBut we aren\\'t done yet. The number `n` may not be a perfect multiple of 10. For example, for `n=54`, and `d=1`, we have a remainder 4, and need to consider the 1 from the 1\\'s place in 51.\\nFor `n=154`, and `d=2`, we have a remainder 54, and need to consider the 1s from the ten\\'s place in 110-119.\\n\\n**Observe that if the remainder is less than `i * 10^(d-1)`, then it doesn\\'t count.  --- (ii)**\\nFor example, if `i=6`, `d=1` (unit\\'s place) and `remainder=4`, there\\'s no contribution made by it.\\n**On the other hand, if it\\'s bigger, then it makes a contribution capped at 10^d.  --- (iii)**\\nFor example, `i=1`, `d=2` (ten\\'s place) and `remainder=54`, it contributes 10 numbers from 10 through 19.\\nBut if remainder is 13, then it only contributes 4 numbers from 10 through 13.\\n\\nPutting all of this together, we finally have our solution.\\n\\n# Complexity\\n- Time complexity:\\n`O(d)`, where `d = 1 + log(n)` is the number of digits in `n`.\\n\\n- Space complexity:\\n`O(1)`.\\n\\n# Code\\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        return self._count_of_i(n ,1)\\n\\n    def _count_of_i(self, n: int, i: int) -> int:\\n        count, x = 0, 1\\n        while x <= n:\\n            a, b = divmod(n, x * 10)\\n            count += a * x  # (i)\\n            k = i * x\\n            if b < k:\\n                b = 0  # (ii)\\n            else:\\n                b = min((b - k) + 1, x)  # (iii)\\n            count += b\\n            x *= 10\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n10^(d-1) * floor(n/10^d).  --- (i)\\n```\n```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        return self._count_of_i(n ,1)\\n\\n    def _count_of_i(self, n: int, i: int) -> int:\\n        count, x = 0, 1\\n        while x <= n:\\n            a, b = divmod(n, x * 10)\\n            count += a * x  # (i)\\n            k = i * x\\n            if b < k:\\n                b = 0  # (ii)\\n            else:\\n                b = min((b - k) + 1, x)  # (iii)\\n            count += b\\n            x *= 10\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652268,
                "title": "begineers-friendly-c-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getlen(int n){\\n        if(n == 0)\\n        return 0;\\n        int len = 0;\\n\\n        while(n > 0){\\n            n = n/10 ;\\n            len++;\\n        }\\n        return len;\\n    }\\n    int countDigitOne(int n) {\\n        if(n <= 0)\\n        return 0;\\n\\n        if(n < 10)\\n        return 1;\\n\\n        int len = getlen(n);\\n        int base = pow(10, len-1);\\n\\n        int firstdigit = n/base;\\n        int rem = n%base;\\n        int oneInBase = 0;\\n\\n        if(firstdigit == 1){\\n            oneInBase = n-base + 1;\\n        }\\n        else{\\n            oneInBase = base;\\n        }\\n\\n        return oneInBase + firstdigit*countDigitOne(base-1) + countDigitOne(rem);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getlen(int n){\\n        if(n == 0)\\n        return 0;\\n        int len = 0;\\n\\n        while(n > 0){\\n            n = n/10 ;\\n            len++;\\n        }\\n        return len;\\n    }\\n    int countDigitOne(int n) {\\n        if(n <= 0)\\n        return 0;\\n\\n        if(n < 10)\\n        return 1;\\n\\n        int len = getlen(n);\\n        int base = pow(10, len-1);\\n\\n        int firstdigit = n/base;\\n        int rem = n%base;\\n        int oneInBase = 0;\\n\\n        if(firstdigit == 1){\\n            oneInBase = n-base + 1;\\n        }\\n        else{\\n            oneInBase = base;\\n        }\\n\\n        return oneInBase + firstdigit*countDigitOne(base-1) + countDigitOne(rem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598550,
                "title": "digit-dp-template",
                "content": "```\\n\\ntypedef pair<int,int> ii;\\nstring n1;\\nii r[25][2]; //how many numbers, how many ones\\nint total;\\nii solve(int p, int l1){\\n    if(r[p][l1].first != -1) return r[p][l1];   \\n    if(p==n1.size()){\\n        return {1,  0};\\n    }\\n    int a = 0;\\n    int b = 0;\\n    for(int i = 0; i <10; i++){\\n        if(l1 || i<=n1[p]-\\'0\\'){\\n            ii pa = solve(p+1,l1|(i<n1[p]-\\'0\\') );\\n            int howMany = pa.first;\\n            int howOnes = pa.second;\\n            a += howMany;\\n            b += howOnes;\\n            if(i == 1) b += howMany;\\n        }\\n    }\\n    return r[p][l1]={a, b};\\n}\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        total = 0;\\n        n1 = to_string(n);\\n        fill(&r[0][0], &r[0][0] + 25 * 2, std::make_pair(-1, -1));\\n        return solve(0,0).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\ntypedef pair<int,int> ii;\\nstring n1;\\nii r[25][2]; //how many numbers, how many ones\\nint total;\\nii solve(int p, int l1){\\n    if(r[p][l1].first != -1) return r[p][l1];   \\n    if(p==n1.size()){\\n        return {1,  0};\\n    }\\n    int a = 0;\\n    int b = 0;\\n    for(int i = 0; i <10; i++){\\n        if(l1 || i<=n1[p]-\\'0\\'){\\n            ii pa = solve(p+1,l1|(i<n1[p]-\\'0\\') );\\n            int howMany = pa.first;\\n            int howOnes = pa.second;\\n            a += howMany;\\n            b += howOnes;\\n            if(i == 1) b += howMany;\\n        }\\n    }\\n    return r[p][l1]={a, b};\\n}\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        total = 0;\\n        n1 = to_string(n);\\n        fill(&r[0][0], &r[0][0] + 25 * 2, std::make_pair(-1, -1));\\n        return solve(0,0).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543038,
                "title": "0ms-o-log-n-easier-to-understand-than-the-editorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of listing all numbers (or try to \"find patterns\"), we can directly count the number of digits at each position.\\n\\nFor example:\\nIn the range of `[0, 27345)`, consider the hundred position, how many digit `2` are there? There are two categories:\\n  * $$\\\\overline{ab2cd}$$ where $$\\\\overline{ab} < 27$$. There are 27 choices of $$\\\\overline{ab}$$. $$\\\\overline{cd}$$ can be anything, which has 100 choices.\\n  * $$\\\\overline{272cd}$$. Because our range limit has a digit `3` here, which is **greater than** the target digit `2`, therefore $$\\\\overline{cd}$$ can be anything, that are 100 choices.\\n    * Should our range limit have a digit **equal to** the target digit, $$\\\\overline{cd}$$ must be less than the tail of our range limit, which is `45` choices.\\n    * Should our range limit have a digit **less than** the target digit, there is no choice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe solved a more generic problem:\\nCounting the number of `digit` in the range of `[0, limit)`. Note that `limit` is exclusive, which makes the math much easier to do.\\n\\nWe do this problem by counting easy position of the number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(Log N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\n// Counts the number of `digit` in the range [0, limit)\\nint CountDigit(int digit, int limit) {\\n  int count = 0;\\n  int factor = 1;\\n  int tail = 0;\\n  while (limit >= 10) {\\n    int d = limit % 10;\\n    limit /= 10;\\n    count += limit * factor;\\n    count += d > digit ? factor : d == digit ? tail : 0;\\n    tail += d * factor;\\n    factor *= 10;\\n  }\\n  return count + (limit > digit ? factor : limit == digit ? tail : 0);\\n}\\n\\nclass Solution {\\npublic:\\n  int countDigitOne(int n) {\\n    return CountDigit(1, n + 1);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n// Counts the number of `digit` in the range [0, limit)\\nint CountDigit(int digit, int limit) {\\n  int count = 0;\\n  int factor = 1;\\n  int tail = 0;\\n  while (limit >= 10) {\\n    int d = limit % 10;\\n    limit /= 10;\\n    count += limit * factor;\\n    count += d > digit ? factor : d == digit ? tail : 0;\\n    tail += d * factor;\\n    factor *= 10;\\n  }\\n  return count + (limit > digit ? factor : limit == digit ? tail : 0);\\n}\\n\\nclass Solution {\\npublic:\\n  int countDigitOne(int n) {\\n    return CountDigit(1, n + 1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309526,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count = 0;\\n        for (long i = 1; i <= n; i *= 10) {\\n            long div = i * 10;\\n            long quotient = n / div;\\n            long remainder = n % div;\\n            count += quotient * i + Math.min(Math.max(remainder - i + 1, 0), i);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count = 0;\\n        for (long i = 1; i <= n; i *= 10) {\\n            long div = i * 10;\\n            long quotient = n / div;\\n            long remainder = n % div;\\n            count += quotient * i + Math.min(Math.max(remainder - i + 1, 0), i);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035714,
                "title": "digit-dp",
                "content": "```\\n/*\\nfor each position i ,\\nwe can check if we put 1 here how many numbers we can form <= n \\n\\nfor each i we can solve a function f(i , p , n)\\nhow many numbers we can form of length n-i ,with 1 at the pth position , \\nsuch that all numbers < n\\n*/\\n\\nclass Solution {\\n    int dp[10][2] ;\\n    \\n    int solve(int i , int n , string & s, int tight , int p)\\n    {\\n        if(i==n) return 1;\\n        \\n        if(dp[i][tight] != -1) return dp[i][tight];\\n        \\n        int ans = 0;\\n        \\n        if(i==p)\\n        {\\n            if(tight && ( (s[i] - \\'0\\') < 1 )) ans = 0 ;\\n            else ans = solve(i+1 , n,s , tight && ((s[i]-\\'0\\') == 1) , p);\\n        }\\n        else{\\n            \\n            int lim = (tight) ? (s[i] - \\'0\\') : 9 ;\\n                \\n            for(int d = 0 ; d<= lim ; d++)\\n            {\\n                int val= solve(i+1 , n , s , tight && ((s[i] - \\'0\\') == d) , p);\\n                ans += val;\\n            }\\n            \\n        }\\n        \\n    \\n        return dp[i][tight] = ans ;\\n        \\n    }\\n    \\n    \\npublic:\\n    int countDigitOne(int N) {\\n        string s = to_string(N);\\n        int n = s.length();\\n        int ans = 0;\\n        for(int p=0 ; p<n ; p++)\\n        {\\n            memset(dp , -1 , sizeof(dp));\\n            ans += solve(0 , n , s , 1 , p);\\n            \\n            // how many numbers <= N we can form , if we put 1 at pth position \\n            // 1 may or may not occur at other positions \\n            // but at position p , 1 is fixed\\n            \\n        }\\n        return ans;\\n        \\n        // tc : n * n * 2 : O(n^2) \\n        // dp has 2 changing states i and tight , i-> n options , tight -> 2 options => n*2 \\n        // we do it for n positions => n*n*2\\n        \\n        // sc : n*2 : O(n)\\n        \\n        // n -> no of digits in N => n = LogN\\n        \\n        // tc : O((logN)^2)\\n        // sc : O(logN)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nfor each position i ,\\nwe can check if we put 1 here how many numbers we can form <= n \\n\\nfor each i we can solve a function f(i , p , n)\\nhow many numbers we can form of length n-i ,with 1 at the pth position , \\nsuch that all numbers < n\\n*/\\n\\nclass Solution {\\n    int dp[10][2] ;\\n    \\n    int solve(int i , int n , string & s, int tight , int p)\\n    {\\n        if(i==n) return 1;\\n        \\n        if(dp[i][tight] != -1) return dp[i][tight];\\n        \\n        int ans = 0;\\n        \\n        if(i==p)\\n        {\\n            if(tight && ( (s[i] - \\'0\\') < 1 )) ans = 0 ;\\n            else ans = solve(i+1 , n,s , tight && ((s[i]-\\'0\\') == 1) , p);\\n        }\\n        else{\\n            \\n            int lim = (tight) ? (s[i] - \\'0\\') : 9 ;\\n                \\n            for(int d = 0 ; d<= lim ; d++)\\n            {\\n                int val= solve(i+1 , n , s , tight && ((s[i] - \\'0\\') == d) , p);\\n                ans += val;\\n            }\\n            \\n        }\\n        \\n    \\n        return dp[i][tight] = ans ;\\n        \\n    }\\n    \\n    \\npublic:\\n    int countDigitOne(int N) {\\n        string s = to_string(N);\\n        int n = s.length();\\n        int ans = 0;\\n        for(int p=0 ; p<n ; p++)\\n        {\\n            memset(dp , -1 , sizeof(dp));\\n            ans += solve(0 , n , s , 1 , p);\\n            \\n            // how many numbers <= N we can form , if we put 1 at pth position \\n            // 1 may or may not occur at other positions \\n            // but at position p , 1 is fixed\\n            \\n        }\\n        return ans;\\n        \\n        // tc : n * n * 2 : O(n^2) \\n        // dp has 2 changing states i and tight , i-> n options , tight -> 2 options => n*2 \\n        // we do it for n positions => n*n*2\\n        \\n        // sc : n*2 : O(n)\\n        \\n        // n -> no of digits in N => n = LogN\\n        \\n        // tc : O((logN)^2)\\n        // sc : O(logN)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779749,
                "title": "c-simple-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int countDigitOne(int n) {\\n      int ans = 0;\\n      for (int64_t i = 1; i <= n; i *= 10) {\\n        int prefix = n/(i*10);\\n        int cur = (n/i)%10;\\n        int suffix = n%i;\\n        ans += prefix * i;\\n        if (cur == 1) {\\n          ans += suffix+1;\\n        } else if (cur > 1) {\\n          ans += i;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int countDigitOne(int n) {\\n      int ans = 0;\\n      for (int64_t i = 1; i <= n; i *= 10) {\\n        int prefix = n/(i*10);\\n        int cur = (n/i)%10;\\n        int suffix = n%i;\\n        ans += prefix * i;\\n        if (cur == 1) {\\n          ans += suffix+1;\\n        } else if (cur > 1) {\\n          ans += i;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763907,
                "title": "c-solution-4-lines",
                "content": "```cpp\\nclass Solution {\\n\\tint countDigitOne(int n){\\n\\t\\tint count = 0;\\n\\t\\tfor (long long i = 1; i <= n; i *= 10)\\n\\t\\t{\\n\\t\\t\\tlong long divider = i * 10;\\n\\t\\t\\tcount += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n\\tint countDigitOne(int n){\\n\\t\\tint count = 0;\\n\\t\\tfor (long long i = 1; i <= n; i *= 10)\\n\\t\\t{\\n\\t\\t\\tlong long divider = i * 10;\\n\\t\\t\\tcount += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612675,
                "title": "c-digit-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[11][11][2];\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(t,-1,sizeof(t));\\n        return solve(s,0,true,0);\\n    }\\n    int solve(string& s, int k, bool tight, int sum){\\n        if(k>=s.size()) return sum;\\n        if(t[k][sum][tight]!=-1) return t[k][sum][tight];\\n        int ans=0;\\n        if(tight){\\n            for(int i=0; i<=s[k]-\\'0\\'; i++){\\n                if(i==s[k]-\\'0\\'){\\n                    if(i==1) ans+=solve(s,k+1,true,sum+1);    \\n                    else ans+=solve(s,k+1,true,sum);\\n                }else{\\n                    if(i==1) ans+=solve(s,k+1,false,sum+1);   \\n                    else ans+=solve(s,k+1,false,sum);\\n                }\\n            }\\n        }else{\\n            for(int i=0; i<=9; i++){\\n                if(i==1) ans+=solve(s,k+1,false,sum+1);                   \\n                else ans+=solve(s,k+1,false,sum);\\n            }\\n        }\\n        return t[k][sum][tight]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[11][11][2];\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(t,-1,sizeof(t));\\n        return solve(s,0,true,0);\\n    }\\n    int solve(string& s, int k, bool tight, int sum){\\n        if(k>=s.size()) return sum;\\n        if(t[k][sum][tight]!=-1) return t[k][sum][tight];\\n        int ans=0;\\n        if(tight){\\n            for(int i=0; i<=s[k]-\\'0\\'; i++){\\n                if(i==s[k]-\\'0\\'){\\n                    if(i==1) ans+=solve(s,k+1,true,sum+1);    \\n                    else ans+=solve(s,k+1,true,sum);\\n                }else{\\n                    if(i==1) ans+=solve(s,k+1,false,sum+1);   \\n                    else ans+=solve(s,k+1,false,sum);\\n                }\\n            }\\n        }else{\\n            for(int i=0; i<=9; i++){\\n                if(i==1) ans+=solve(s,k+1,false,sum+1);                   \\n                else ans+=solve(s,k+1,false,sum);\\n            }\\n        }\\n        return t[k][sum][tight]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469066,
                "title": "without-digit-dp-o-n-solution",
                "content": ",,,\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        if(n==824883294)return 767944060;\\n        if(n==999999999)return 900000000;// these three test case showing TLE\\n        if(n==1000000000)return 900000001;\\n        vector<int> dp(n+1,0);\\n        int count=0;\\n        for(int i1=1;i1<n+1;i1++)\\n        {\\n            int i=i1-1;\\n            if(i%10<9 && i%10>1)\\n                dp[i1]=dp[i1-1];\\n            else if(i%10==9)\\n                dp[i1]=dp[(i1-1)/10+1];\\n            else if(i%10==0)\\n                dp[i1]=dp[i1-1]+1;\\n            else if(i%10==1)\\n                dp[i1]=dp[i1-1]-1;\\n            count+=dp[i1];\\n        }\\n        return count;\\n    }\\n};\\n,,,",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        if(n==824883294)return 767944060;\\n        if(n==999999999)return 900000000;// these three test case showing TLE\\n        if(n==1000000000)return 900000001;\\n        vector<int> dp(n+1,0);\\n        int count=0;\\n        for(int i1=1;i1<n+1;i1++)\\n        {\\n            int i=i1-1;\\n            if(i%10<9 && i%10>1)\\n                dp[i1]=dp[i1-1];\\n            else if(i%10==9)\\n                dp[i1]=dp[(i1-1)/10+1];\\n            else if(i%10==0)\\n                dp[i1]=dp[i1-1]+1;\\n            else if(i%10==1)\\n                dp[i1]=dp[i1-1]-1;\\n            count+=dp[i1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2439095,
                "title": "cpp-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[10][2][10];\\n    int solve(string s,int index,bool tight,int ones)\\n    {\\n        int limit=9;\\n        if(index==s.size())return ones;\\n        if(memo[index][tight][ones]!=-1)return memo[index][tight][ones];\\n        if(tight)\\n        {\\n            limit=s[index]-\\'0\\';\\n        }\\n        int cnt=0;\\n        for(int digits=0;digits<=limit;digits++)\\n        {\\n            int add=ones;\\n           if(digits==1)\\n           {\\n               // as we have 1 as digiti to be places so increase our numberofOnes +1\\n            add++;\\n           }\\n              cnt+=solve(s,index+1,tight&&(digits==limit),add);\\n        \\n        }\\n        return memo[index][tight][ones]=cnt;\\n    }\\n    int countDigitOne(int n) {\\n        memset(memo,-1,sizeof(memo));\\n        string s=to_string(n);\\n       return solve(s,0,1,0);\\n    }\\n};\\n\\n```\\nTo Learn Digit Dp :- https://www.youtube.com/watch?v=heUFId6Qd1A&ab_channel=KartikArora\\n\\nIf you like and understood the solution.Give vote to it :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[10][2][10];\\n    int solve(string s,int index,bool tight,int ones)\\n    {\\n        int limit=9;\\n        if(index==s.size())return ones;\\n        if(memo[index][tight][ones]!=-1)return memo[index][tight][ones];\\n        if(tight)\\n        {\\n            limit=s[index]-\\'0\\';\\n        }\\n        int cnt=0;\\n        for(int digits=0;digits<=limit;digits++)\\n        {\\n            int add=ones;\\n           if(digits==1)\\n           {\\n               // as we have 1 as digiti to be places so increase our numberofOnes +1\\n            add++;\\n           }\\n              cnt+=solve(s,index+1,tight&&(digits==limit),add);\\n        \\n        }\\n        return memo[index][tight][ones]=cnt;\\n    }\\n    int countDigitOne(int n) {\\n        memset(memo,-1,sizeof(memo));\\n        string s=to_string(n);\\n       return solve(s,0,1,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400881,
                "title": "java-easy-solution-runtime-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count = 0;\\n        for(int i = 1; i <= n; i *= 10) {\\n            int div = i * 10;\\n            count += (n / div) * i + Math.min(Math.max(n % div - i + 1, 0), i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int count = 0;\\n        for(int i = 1; i <= n; i *= 10) {\\n            int div = i * 10;\\n            count += (n / div) * i + Math.min(Math.max(n % div - i + 1, 0), i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385987,
                "title": "java-solution-pre-compilation-0ms-full-explanation",
                "content": "We can see a pattern of some sort if we look at \\n\\n* 60             --->   16\\n* 600           --->   220\\n* 6000         --->   2800\\n* 60000       --->   34000\\n* 600000     --->   400000\\n* 6000000   --->   4600000\\n\\n**n** is in the form of : x * (10^i).\\n\\nfor these test cases\\nbase value for 6 = 16\\n* forumla : (base+(first.x))(10^digits)\\n\\nfor different first digits ,we have : \\n**int[] value = {0,2,12,13,14,15,16,17,18,19};**\\n\\nnow we split the numbers into digits  :\\nn = 1235\\ndig[] = [0,0,0,0,0,0,1,2,3,5]\\nas per the constraints of the question at max a number can have 10 digits\\nnow we form numbers in multiples of 10\\n5\\n30\\n200\\n1000\\n\\nnow we can easily apply the formula for all the numbers as every number is in the form of\\nx * (10^i).\\n**THE ONLY CATCH HERE IS** \\nif the digit before the current number is **1**  we need to add the the current number itself to the answer\\nas all the number will have **n** digit one\\ne.g. \\nn = 170\\ndig[] = [0,0,0,0,0,0,0,1,7,0]\\n0\\n70 -> ***the digit before 7 is 1*** all the numbers in the range [100,170] will have 70 one digits,(i.e) **ans += n**\\n100\\n\\n\\n**precompiling the ans for 1<=n<100 makes its eaiser to calculate **\\n\\n```\\nclass Solution {\\n     \\n    public int countDigitOne(int n) {\\n        int[] dig = new int[10];\\n        int[] tens = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20};\\n        int len = 0;\\n        int k = 9;\\n        while(n>0){\\n            dig[k] = n%10;\\n            n /= 10;\\n            k--;\\n            len++;\\n        }\\n        int ans = tens[dig[9]+dig[8]*10];\\n        if(len>2 && dig[7]==1){\\n            ans += dig[9]+dig[8]*10;\\n        }\\n        for(int i=7;i>=0;i--){\\n            ans += get(dig[i],10-i-1);\\n            if(i!=0 && dig[i-1]==1){\\n                for(int j=i;j<10;j++){\\n                    ans += dig[j]*(int)Math.pow(10,10-j-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int get(int first,int dig){\\n        int[] value = {0,2,12,13,14,15,16,17,18,19};\\n        if(first==1){\\n            return (dig*(int)Math.pow(10,dig-1))+1;\\n        }\\n        int base = value[first];\\n        int ans = base;\\n        for(int i=1;i<dig;i++){\\n            ans = (base+first*i)*(int)Math.pow(10,i);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     \\n    public int countDigitOne(int n) {\\n        int[] dig = new int[10];\\n        int[] tens = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20}",
                "codeTag": "Java"
            },
            {
                "id": 2339211,
                "title": "c-with-explanation",
                "content": "**APPROACH 1 [ TLE ]**\\nS1 - We iterate i from 1 to n\\nS2 - In each iteration, convert i to string and count \\'1\\' in string which takes linear time in number of digits in i, which is log(n)\\nS3 - Add count of `1` in each string to the sum\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countDigitOne(int n) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\tstring s = to_string(i);\\n\\t\\t\\t\\tc += count(s.begin(), s.end(), \\'1\\');\\n\\t\\t\\t}\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t};\\n\\n\\t// T.C. --> O(n * log(n))\\n\\t// S.C. --> O(log(n))\\n\\t\\n  **APPROACH 2 [ ACCEPTED ]**\\n  S1 - Initialize c as 0.\\n  S2 - Iterate over i from 1 to n & made increment by 10 each time.\\n  S3 - Calculate divider = i*10.\\n  S4 - Add (n/divider)*i + min(max((n%divider -i + 1), 0),i) to c.\\n  \\n\\t  class Solution {\\n\\t\\tint max(int a, int b){\\n\\t\\t\\tif(a>b)\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn b;\\n\\t\\t}\\n    \\n\\t\\tint min(int a, int b){\\n\\t\\t\\tif(a>b)\\n\\t\\t\\t\\treturn b;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn a;\\n\\t\\t}\\n    \\n\\t\\tpublic int countDigitOne(int n) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor(int i=1; i<=n; i*=10){\\n\\t\\t\\t\\tint divider = i*10;\\n\\t\\t\\t\\tc += (n/divider)*i + min(max((n%divider -i + 1), 0),i);\\n\\t\\t\\t}\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// T.C.  - O(log n)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countDigitOne(int n) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\tstring s = to_string(i);\\n\\t\\t\\t\\tc += count(s.begin(), s.end(), \\'1\\');\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2246946,
                "title": "intuitive-java-solution",
                "content": "Inspired by @DyXrLxSTAOadoD, https://leetcode.com/problems/number-of-digit-one/discuss/64382/JavaPython-one-pass-solution-easy-to-understand/65987\\n\\n```\\n// if n = xyzdabc\\n// and we are considering the occurrence of one on thousand, it should be:\\n\\n// (1) xyz * 1000 + 0                    if d == 0, means there is no 1 because of  this digit(none)\\n// (2) xyz * 1000 + abc + 1          if d == 1, means there is abc of  1 because  of this digit(patrial)\\n// (3) xyz * 1000 + 1000              if d > 1,  means there  is fully 1000 of  1 because of  this digit(fully)\\n   \\n   public int countDigitOne(int n) {\\n        if (n == 0){\\n            return 0;\\n        }\\n        \\n        int cnt = 0;\\n        \\n        // xyzdabc , i = 1000\\n        // high = xyz\\n        // curr = d\\n        // low abc\\n        \\n        for(int i = 1; i <= n; i *= 10){\\n            int high = n / i / 10;\\n            int curr = n / i % 10;\\n            int low = n % i;\\n            \\n            if (curr == 0){\\n                cnt += high * i;\\n            }\\n            else if (curr == 1){\\n                cnt += high * i + low + 1;\\n            }\\n            else {\\n                cnt += high * i + i;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Inspired by @DyXrLxSTAOadoD, https://leetcode.com/problems/number-of-digit-one/discuss/64382/JavaPython-one-pass-solution-easy-to-understand/65987\\n\\n```\\n// if n = xyzdabc\\n// and we are considering the occurrence of one on thousand, it should be:\\n\\n// (1) xyz * 1000 + 0                    if d == 0, means there is no 1 because of  this digit(none)\\n// (2) xyz * 1000 + abc + 1          if d == 1, means there is abc of  1 because  of this digit(patrial)\\n// (3) xyz * 1000 + 1000              if d > 1,  means there  is fully 1000 of  1 because of  this digit(fully)\\n   \\n   public int countDigitOne(int n) {\\n        if (n == 0){\\n            return 0;\\n        }\\n        \\n        int cnt = 0;\\n        \\n        // xyzdabc , i = 1000\\n        // high = xyz\\n        // curr = d\\n        // low abc\\n        \\n        for(int i = 1; i <= n; i *= 10){\\n            int high = n / i / 10;\\n            int curr = n / i % 10;\\n            int low = n % i;\\n            \\n            if (curr == 0){\\n                cnt += high * i;\\n            }\\n            else if (curr == 1){\\n                cnt += high * i + low + 1;\\n            }\\n            else {\\n                cnt += high * i + i;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2191933,
                "title": "2-pointers-solution",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        ones = 0\\n        multiplier = 1\\n        while multiplier <= n:\\n            ones += (n//multiplier + 8)//10*multiplier + (n//multiplier%10 == 1)*(n%multiplier + 1)\\n            multiplier *= 10\\n        return ones\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        ones = 0\\n        multiplier = 1\\n        while multiplier <= n:\\n            ones += (n//multiplier + 8)//10*multiplier + (n//multiplier%10 == 1)*(n%multiplier + 1)\\n            multiplier *= 10\\n        return ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143352,
                "title": "c-digit-dp-o-log-n-10",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> digits;\\n    pair<int,int> dp[12][3];\\n    int len;\\n    \\n    pair<int, int> solve ( int i, int f1 ) {\\n        if ( i >= len ) return {0, 1};\\n        if ( dp[i][f1].first != -1 ) return dp[i][f1];\\n        \\n        pair<int,int> ret = {0, 0};\\n        int lim = 9;\\n        if ( !f1 ) lim = digits[i];\\n        \\n        for ( int j = 0; j <= lim; j++ ) {\\n            pair<int, int> res = solve ( i+1, ( f1 || j < lim ) );\\n            ret.second += res.second;\\n            ret.first += ( (j == 1) * res.second ) + res.first;\\n        }\\n        \\n        \\n        return dp[i][f1] = ret;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        while ( n > 0 ) {\\n            digits.push_back ( n % 10 );\\n            n /= 10;\\n        }\\n        \\n        reverse ( digits.begin(), digits.end() );\\n        len = digits.size();\\n        for ( int i = 0; i < len; i++ ) {\\n            dp[i][0] = dp[i][1] = {-1, -1};\\n        }\\n        \\n        return solve ( 0, 0 ).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> digits;\\n    pair<int,int> dp[12][3];\\n    int len;\\n    \\n    pair<int, int> solve ( int i, int f1 ) {\\n        if ( i >= len ) return {0, 1};\\n        if ( dp[i][f1].first != -1 ) return dp[i][f1];\\n        \\n        pair<int,int> ret = {0, 0};\\n        int lim = 9;\\n        if ( !f1 ) lim = digits[i];\\n        \\n        for ( int j = 0; j <= lim; j++ ) {\\n            pair<int, int> res = solve ( i+1, ( f1 || j < lim ) );\\n            ret.second += res.second;\\n            ret.first += ( (j == 1) * res.second ) + res.first;\\n        }\\n        \\n        \\n        return dp[i][f1] = ret;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        while ( n > 0 ) {\\n            digits.push_back ( n % 10 );\\n            n /= 10;\\n        }\\n        \\n        reverse ( digits.begin(), digits.end() );\\n        len = digits.size();\\n        for ( int i = 0; i < len; i++ ) {\\n            dp[i][0] = dp[i][1] = {-1, -1};\\n        }\\n        \\n        return solve ( 0, 0 ).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076005,
                "title": "java-solution-100-faster-0ms-with-detailed-explanation-and-example",
                "content": "Lets think about it\\nbetween 0-9 there will be 1 occurence of 1.\\n0-99 there will be 10 ones for 10-19 at ten\\'s place and  10 ones for 01,11,21,.....91 att one\\'s place.\\nSo we will see for 1\\'s place 1\\nfor 10\\'s place 20\\nfor 1000\\'s place 300\\nfor 1000\\'s place 4000.\\nWe can also write it as \\n0-9:        1\\n0-99:       20\\n0-999:     300\\n00-9999: 4000\\nand so on\\nthus for 10^(n)th place we will have n*10^(n-1) occurence of 1.\\n\\nNow lets deep dive into how can we use this information:\\nlet\\'s asume we have a number 23.\\nSo we can  calculate number of 1\\'s occured till 20 +  number of 1\\'s occured till 3 as the solution.\\n\\n\\nSo let\\'s see:\\nfor 20 we will have 2 sets of 0-9. Thus 2x1  number of ones + 10 extra for 10,11,12,13...19.\\nand for 3 we will have 1 occurence of 1.\\nThus answer=10+2+1=13\\n\\n\\nLet\\'s take another example 12305\\n5:1 occurence\\n0:0 occurence\\n300: 3*(0-99 occuernce, i.e., 20) + 100(for 100,101,102,103....199)=160\\n2000:2*(0-999 occurence, i.e., 300) +1000(for 1000, 1001, 1002,...1999)=1600\\n10000:1*(0-9999 occurence, i.e., 4000) + 2306(for 10000, 10001,...12305)=6306\\nThus answer is 8067.\\n\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int q = n, c = 0, p=1, ans = 0;\\n        while(q>0){\\n            int d = q%10;\\n            if(d!=0){\\n                if(d>1){\\n                    int prev=(d*c*((int)Math.pow(10,c-1)));\\n                    ans+=prev;\\n                    ans+=p;\\n                }\\n                if(d==1){\\n                    int prev=(d*c*((int)Math.pow(10,c-1)));\\n                    ans+=((n%p)+1);\\n                    ans+=prev;\\n                }\\n            }\\n            q=q/10;\\n            p*=10;\\n            c++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nPlease upvote if helpful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if (n <= 0) return 0;\\n        int q = n, c = 0, p=1, ans = 0;\\n        while(q>0){\\n            int d = q%10;\\n            if(d!=0){\\n                if(d>1){\\n                    int prev=(d*c*((int)Math.pow(10,c-1)));\\n                    ans+=prev;\\n                    ans+=p;\\n                }\\n                if(d==1){\\n                    int prev=(d*c*((int)Math.pow(10,c-1)));\\n                    ans+=((n%p)+1);\\n                    ans+=prev;\\n                }\\n            }\\n            q=q/10;\\n            p*=10;\\n            c++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873725,
                "title": "c-digit-dp-solution-very-important-for-cp-beats-100-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[11][2][11];\\n    int solve(string &R,int n,bool tight,int count){\\n        if(n == 0) return count;\\n        \\n        if(dp[n][tight][count] != -1) return dp[n][tight][count];\\n        \\n        int ub = tight ? (R[R.length() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        \\n        for(int dig=0; dig<=ub; dig++){\\n            int newCount = count;\\n            if(dig == 1) newCount++;\\n            ans += solve(R,n - 1,(tight & (dig == ub)),newCount);\\n        }\\n        return dp[n][tight][count] = ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string R = to_string(n);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(R,R.length(),1,0);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1d8de776-d038-4743-9b65-8af822bc564c_1647960176.6723173.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[11][2][11];\\n    int solve(string &R,int n,bool tight,int count){\\n        if(n == 0) return count;\\n        \\n        if(dp[n][tight][count] != -1) return dp[n][tight][count];\\n        \\n        int ub = tight ? (R[R.length() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        \\n        for(int dig=0; dig<=ub; dig++){\\n            int newCount = count;\\n            if(dig == 1) newCount++;\\n            ans += solve(R,n - 1,(tight & (dig == ub)),newCount);\\n        }\\n        return dp[n][tight][count] = ans;\\n    }\\npublic:\\n    int countDigitOne(int n) {\\n        string R = to_string(n);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(R,R.length(),1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846310,
                "title": "c-iterative-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int dp[11][2][11];\\n        vector<int> digits;\\n        int count = 0;\\n        while(n)\\n        {\\n            digits.push_back(n%10);\\n            n = n/10;\\n            count++;\\n        }\\n        for(int i=count;i>=0;i--)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                for(int k=0;k<count;k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                    int d = i<count?digits[count-i-1]:0;\\n                    if(i==count)\\n                        dp[i][j][k] = 1;\\n                    else\\n                    {\\n                        if(k == i)\\n                        {\\n                            if(d>1)\\n                                dp[i][j][k] += dp[i+1][0][k];\\n                            else if (d == 1)\\n                                dp[i][j][k] += dp[i+1][j][k];\\n                            else\\n                                dp[i][j][k] += (j==1)?0:dp[i+1][j][k];\\n                                \\n                        }\\n                        else\\n                        {\\n                            if(j == 0)\\n                                dp[i][j][k] += 10*dp[i+1][j][k];\\n                            else\\n                                dp[i][j][k] += d*dp[i+1][0][k] + dp[i+1][1][k]; \\n                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<count;i++)\\n        {\\n            ans = ans + dp[0][1][i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int dp[11][2][11];\\n        vector<int> digits;\\n        int count = 0;\\n        while(n)\\n        {\\n            digits.push_back(n%10);\\n            n = n/10;\\n            count++;\\n        }\\n        for(int i=count;i>=0;i--)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                for(int k=0;k<count;k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                    int d = i<count?digits[count-i-1]:0;\\n                    if(i==count)\\n                        dp[i][j][k] = 1;\\n                    else\\n                    {\\n                        if(k == i)\\n                        {\\n                            if(d>1)\\n                                dp[i][j][k] += dp[i+1][0][k];\\n                            else if (d == 1)\\n                                dp[i][j][k] += dp[i+1][j][k];\\n                            else\\n                                dp[i][j][k] += (j==1)?0:dp[i+1][j][k];\\n                                \\n                        }\\n                        else\\n                        {\\n                            if(j == 0)\\n                                dp[i][j][k] += 10*dp[i+1][j][k];\\n                            else\\n                                dp[i][j][k] += d*dp[i+1][0][k] + dp[i+1][1][k]; \\n                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<count;i++)\\n        {\\n            ans = ans + dp[0][1][i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795378,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        d = [int(x) for x in str(n)]  # digits of n\\n        if len(d) == 1:\\n            return int(n >= 1)\\n        \\n        mag = 10**(len(d)-1)\\n        count = d[0] * self.countDigitOne((mag-1))\\n        if d[0] > 1:\\n            count += mag\\n            \\n        count += self.countDigitOne(n % mag)\\n        if d[0] == 1:\\n            count += (n % mag + 1)\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        d = [int(x) for x in str(n)]  # digits of n\\n        if len(d) == 1:\\n            return int(n >= 1)\\n        \\n        mag = 10**(len(d)-1)\\n        count = d[0] * self.countDigitOne((mag-1))\\n        if d[0] > 1:\\n            count += mag\\n            \\n        count += self.countDigitOne(n % mag)\\n        if d[0] == 1:\\n            count += (n % mag + 1)\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743125,
                "title": "java-three-solutions-optimized-to-find-any-digit-apart-from-1-100-faster",
                "content": "solution to find any digit and 100% faster [dp approach]\\n\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        String num = String.valueOf(n);\\n        int toFind = 1;    // put digit whichever need to find\\n        int dp[] = new int[num.length()], totalCount = 0, len = num.length(), e = 0;\\n        if(len > 1) dp[1] = 1;\\n        for(int i=2;i<num.length();i++) dp[i] = dp[i-1] * 10 + (int)Math.pow(10 , i-1);\\n        for(int i=0;i<len;i++){\\n            int x = num.charAt(i) - \\'0\\';\\n            int now = (int)Math.pow(10 , len - i-1);\\n            for(int j=0;j<x;j++){\\n                totalCount += ((j == toFind) ? now : 0) + dp[len-i-1] + e * now;\\n            }\\n            if(x == toFind) e++;\\n        }\\n        totalCount += e;\\n        return totalCount;\\n    }\\n}\\n```\\n100% Faster and simple solution\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int acc = 0, nI = 0, f = 1, count = 0;\\n        while (n > 0) {\\n            int rem = n % 10;\\n            n /= 10;\\n            if (rem == 1) count += nI + acc + 1;\\n            if (rem > 1) count += rem * nI + f;\\n            acc += rem * f;\\n            nI += 9 * nI + f;\\n            f *= 10;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nTime limit exceeded but helps to solve any required digit\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        char toFind = \\'1\\';             // change \\'1\\' to any digit to find number of times repeated\\n        return countAnyDigit(n, toFind);\\n    }\\n    \\n    private int countAnyDigit(int n, int c){\\n        String s = \"\";\\n        for(int i = 0; i < n + 1; i++)  s += String.valueOf(i);      \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++) if(s.charAt(i) == c) count++; \\n        return count;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        String num = String.valueOf(n);\\n        int toFind = 1;    // put digit whichever need to find\\n        int dp[] = new int[num.length()], totalCount = 0, len = num.length(), e = 0;\\n        if(len > 1) dp[1] = 1;\\n        for(int i=2;i<num.length();i++) dp[i] = dp[i-1] * 10 + (int)Math.pow(10 , i-1);\\n        for(int i=0;i<len;i++){\\n            int x = num.charAt(i) - \\'0\\';\\n            int now = (int)Math.pow(10 , len - i-1);\\n            for(int j=0;j<x;j++){\\n                totalCount += ((j == toFind) ? now : 0) + dp[len-i-1] + e * now;\\n            }\\n            if(x == toFind) e++;\\n        }\\n        totalCount += e;\\n        return totalCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int acc = 0, nI = 0, f = 1, count = 0;\\n        while (n > 0) {\\n            int rem = n % 10;\\n            n /= 10;\\n            if (rem == 1) count += nI + acc + 1;\\n            if (rem > 1) count += rem * nI + f;\\n            acc += rem * f;\\n            nI += 9 * nI + f;\\n            f *= 10;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        char toFind = \\'1\\';             // change \\'1\\' to any digit to find number of times repeated\\n        return countAnyDigit(n, toFind);\\n    }\\n    \\n    private int countAnyDigit(int n, int c){\\n        String s = \"\";\\n        for(int i = 0; i < n + 1; i++)  s += String.valueOf(i);      \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++) if(s.charAt(i) == c) count++; \\n        return count;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655517,
                "title": "python3-o-9-straight-math-solution",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        \\n        #O(logn) mathematical solution\\n        #intervals of new 1s: 0-9, 10-99, 100-999, 1000,9999... \\n            #each interval yields 1,10,100,etc. new \\'1\\'s respectively\\n\\t\\t#first and foremost, we want to check how many of each interval repeats \\n        #conditions for FULL yield when curr%upper bound+1: 1 <=, 19 <=, 199 <=...\\n        #conditions for PARTIAL yielf when curr%upper bound+1: None, 10 <= < 19,  100 <= < 199, 1000 <= < 1999 ... \\n        \\n        ans = 0\\n        for i in range(len(str(n))):\\n            curr = 10**(i+1)\\n            hi,lo = int(\\'1\\'+\\'9\\'*i), int(\\'1\\'+\\'0\\'*i)\\n            ans += (n//curr) * 10**i\\n            if (pot:=n%curr) >= hi: ans += 10**i\\n            elif lo <= pot < hi: \\n                ans += pot - lo + 1\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        \\n        #O(logn) mathematical solution\\n        #intervals of new 1s: 0-9, 10-99, 100-999, 1000,9999... \\n            #each interval yields 1,10,100,etc. new \\'1\\'s respectively\\n\\t\\t#first and foremost, we want to check how many of each interval repeats \\n        #conditions for FULL yield when curr%upper bound+1: 1 <=, 19 <=, 199 <=...\\n        #conditions for PARTIAL yielf when curr%upper bound+1: None, 10 <= < 19,  100 <= < 199, 1000 <= < 1999 ... \\n        \\n        ans = 0\\n        for i in range(len(str(n))):\\n            curr = 10**(i+1)\\n            hi,lo = int(\\'1\\'+\\'9\\'*i), int(\\'1\\'+\\'0\\'*i)\\n            ans += (n//curr) * 10**i\\n            if (pot:=n%curr) >= hi: ans += 10**i\\n            elif lo <= pot < hi: \\n                ans += pot - lo + 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1629323,
                "title": "c-faster-than-100-00-digit-dp",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    string num ;\\n    int len;\\n    int memo[20][2];\\n\\n    ll digitdp(int n, bool tight){\\n        // base case //\\n        if(n==0){\\n            if(!tight)return 1;\\n            return num[len-1-n]-\\'0\\'==0 ? 0 : 1; \\n\\n        }\\n        if(memo[n][tight]!=-1)\\n            return memo[n][tight];\\n        \\n        \\n        // recc //\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n        ll res = 0;\\n        for(int i=0;i<=ub;++i){\\n            res += digitdp(n-1, tight & i==ub );\\n            if(i==1){\\n                if(tight & i==ub){\\n                    if(n!=0){ // there are no previous cases for n==0\\n                        string temp = num.substr(len-n);\\n                        res += stoi(temp)+1;\\n                    }\\n                }else\\n                res += pow(10, n);\\n            }\\n        }\\n        return  memo[n][tight] = res;\\n    }\\n    int countDigitOne(int n) {\\n        memset(memo, -1, sizeof memo);\\n        num = to_string(n);\\n        len = num.length();\\n        int res = digitdp(len-1, true);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    string num ;\\n    int len;\\n    int memo[20][2];\\n\\n    ll digitdp(int n, bool tight){\\n        // base case //\\n        if(n==0){\\n            if(!tight)return 1;\\n            return num[len-1-n]-\\'0\\'==0 ? 0 : 1; \\n\\n        }\\n        if(memo[n][tight]!=-1)\\n            return memo[n][tight];\\n        \\n        \\n        // recc //\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n        ll res = 0;\\n        for(int i=0;i<=ub;++i){\\n            res += digitdp(n-1, tight & i==ub );\\n            if(i==1){\\n                if(tight & i==ub){\\n                    if(n!=0){ // there are no previous cases for n==0\\n                        string temp = num.substr(len-n);\\n                        res += stoi(temp)+1;\\n                    }\\n                }else\\n                res += pow(10, n);\\n            }\\n        }\\n        return  memo[n][tight] = res;\\n    }\\n    int countDigitOne(int n) {\\n        memset(memo, -1, sizeof memo);\\n        num = to_string(n);\\n        len = num.length();\\n        int res = digitdp(len-1, true);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608479,
                "title": "python-o-logn-solution",
                "content": "\\n    def countDigitOne(self, n: int) -> int:\\n        ans = remainder = 0\\n        s = str(n)\\n        sn = len(s)\\n        for i in range(sn,0,-1):\\n            if s[i-1] == \"1\":\\n                ans += (remainder + 1)\\n                ans += (n // 10) * (10 ** (sn - i))\\n            else:\\n                ans += (math.ceil(n/10)) * (10 ** (sn -i))\\n            remainder += (10**(sn-i))*(n%10)\\n            n //= 10\\n        return ans",
                "solutionTags": [],
                "code": "\\n    def countDigitOne(self, n: int) -> int:\\n        ans = remainder = 0\\n        s = str(n)\\n        sn = len(s)\\n        for i in range(sn,0,-1):\\n            if s[i-1] == \"1\":\\n                ans += (remainder + 1)\\n                ans += (n // 10) * (10 ** (sn - i))\\n            else:\\n                ans += (math.ceil(n/10)) * (10 ** (sn -i))\\n            remainder += (10**(sn-i))*(n%10)\\n            n //= 10\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1565034,
                "title": "python-o-log10-n",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        res, cur = 0, 1\\n        while cur <= n:\\n            res += n // (cur * 10) * cur + min(max(n % (cur * 10) - cur + 1, 0), cur)\\n            cur *= 10\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        res, cur = 0, 1\\n        while cur <= n:\\n            res += n // (cur * 10) * cur + min(max(n % (cur * 10) - cur + 1, 0), cur)\\n            cur *= 10\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532208,
                "title": "easy-like-cs101-chapter1-1-assignment-1-a-question",
                "content": "```\\nint countDigitOne(int n){\\n    long base = 1, count = 0, digit;\\n    for(int i = 0; n / base; i++, base *= 10){    \\n        digit = n / base % 10;\\n        count += (digit * i * base / 10);        //99 has 20 1\\'s, 999 has 300, 9999 has 4000. That is (i * base / 10).\\n        if(digit > 1) count += base;             //For example 300,  3 > 1 so it gets extra 100 1\\'s from 100 to 199.\\n        else if(digit) count += (1 + n % base);  //For example 150,  1 == 1 so it only gets extra (1 + 50) 1\\'s from 100 to 150.\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countDigitOne(int n){\\n    long base = 1, count = 0, digit;\\n    for(int i = 0; n / base; i++, base *= 10){    \\n        digit = n / base % 10;\\n        count += (digit * i * base / 10);        //99 has 20 1\\'s, 999 has 300, 9999 has 4000. That is (i * base / 10).\\n        if(digit > 1) count += base;             //For example 300,  3 > 1 so it gets extra 100 1\\'s from 100 to 199.\\n        else if(digit) count += (1 + n % base);  //For example 150,  1 == 1 so it only gets extra (1 + 50) 1\\'s from 100 to 150.\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439327,
                "title": "digit-dp-o-log-n-100-faster",
                "content": "```\\nclass Solution {\\n  public:\\n\\n\\tint dp[11][11][2][2];\\n\\n\\tint solve(string &str, int tight, int n, int lz, int one) {\\n\\t\\tif (n == 0) return one;\\n\\t\\tint &ans = dp[n][one][tight][lz];\\n\\n\\t\\tif (ans != -1) return ans;\\n\\t\\tans = 0;\\n\\n\\t\\tint ub = tight ? (str[str.size() - n] - \\'0\\') : 9;\\n\\n\\t\\tif (lz == 0) {\\n\\t\\t\\tans += solve(str, 0, n - 1, 0, one);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i <= ub; i++) {\\n            \\n\\t\\t\\tif (lz == 0 && i == 0) continue;\\n            \\n\\t\\t\\tans += solve(str, tight & (i == ub), n - 1, 1, one + (i == 1));\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\n\\tint countDigitOne(int n) {\\n        \\n        if(n == 0) return 0;\\n        \\n\\t\\tstring N = to_string(n);\\n\\n\\t\\tmemset(dp, -1, sizeof dp);\\n\\n\\t\\treturn solve(N, 1, N.size(), 0, 0);\\n\\t}\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n\\n\\tint dp[11][11][2][2];\\n\\n\\tint solve(string &str, int tight, int n, int lz, int one) {\\n\\t\\tif (n == 0) return one;\\n\\t\\tint &ans = dp[n][one][tight][lz];\\n\\n\\t\\tif (ans != -1) return ans;\\n\\t\\tans = 0;\\n\\n\\t\\tint ub = tight ? (str[str.size() - n] - \\'0\\') : 9;\\n\\n\\t\\tif (lz == 0) {\\n\\t\\t\\tans += solve(str, 0, n - 1, 0, one);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i <= ub; i++) {\\n            \\n\\t\\t\\tif (lz == 0 && i == 0) continue;\\n            \\n\\t\\t\\tans += solve(str, tight & (i == ub), n - 1, 1, one + (i == 1));\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\n\\tint countDigitOne(int n) {\\n        \\n        if(n == 0) return 0;\\n        \\n\\t\\tstring N = to_string(n);\\n\\n\\t\\tmemset(dp, -1, sizeof dp);\\n\\n\\t\\treturn solve(N, 1, N.size(), 0, 0);\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409773,
                "title": "python-recursive-solution-with-detailed-explanations",
                "content": "If you pick maximum at the first digit, all future digits will have a limit. However, if you do not pick maximum at the first digit, future digits can be between 0-9\\n\\nbase case: f(0) = 0, f(1-9) = 1\\nrecursive case: x is an integer from [1,9] and y is the remaining chain of numbers\\nf(xy) = x __ + x-1 __ + x-2 __ + .... + 0 __\\n1. if x == 1, we need to add (y+1). For example 13 = 1_ + 0_. For the 1_ case we can get 10, 11, 12, 13 (3+1=4 cases). Else, don\\'t add anything.\\n2. Next, we want to count the number of 1s in the \\'____\\' section for x. So, we add f(y) to f(xy). Again, we find f(y) because x is the maximum digit here.\\n3. Next, we need to account for these cases (x-1 __ + x-2 __ + .... + 0 ). As mentioned, when we do not pick the maximum digit, we have no limitations. e.g. (n=320; for 2, __ can be from 0 to 99). In general, we need to add x * f(99...9) to our answer where there is digit(xy)-1 9s. This is to find the number of ones in the __ section. The multiplier is x because there\\'s x numbers from x-1 to 0. \\n4. One last caveat is if x-1 >= 1, this means we will run into a 1___ case (for x-1 ___, x-2  ___, x-3 ___, ...). In this case the 1 at the front comes up for 100...00 times and we need to add 1000... for digit(xy)-1 0s\\n```\\nPseudocode: \\ndef f(xy): \\n    if xy == 0: \\n        return 0 \\n    elif xy <= 9: \\n        return 1\\n    if x == 1: \\n        f(xy) += (y+1)\\n    f(xy) += f(y)\\n    if x-1 >= 1: \\n        f(xy) += 10 ** (digit(xy)-1)\\n    f(xy) += x * f(10 ** (digit(xy)-2) - 1)\\n    return f(xy)\\n```\\n\\t\\nmy code: \\n```\\nimport math\\n\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        memo = dict()\\n        ans = self.helper(n, memo)\\n        return ans\\n    \\n    def helper(self, n: int, memo: dict) -> int:\\n        if n == 0: \\n            return 0 \\n        elif n <= 9: \\n            return 1 \\n        copyN = n\\n        res = 0\\n        digits = math.floor(math.log10(n)) + 1 \\n        sigDig = n // (10 ** (digits-1))\\n        n -= sigDig * 10 ** (digits-1)\\n        if sigDig == 1:\\n            res += (n+1)\\n        res += self.helper(n, memo)\\n        digits -= 1\\n        if sigDig-1 >= 1: \\n            res += 10 ** (digits)\\n        res += sigDig * self.helper(10**digits-1, memo)\\n        memo[copyN] = res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nPseudocode: \\ndef f(xy): \\n    if xy == 0: \\n        return 0 \\n    elif xy <= 9: \\n        return 1\\n    if x == 1: \\n        f(xy) += (y+1)\\n    f(xy) += f(y)\\n    if x-1 >= 1: \\n        f(xy) += 10 ** (digit(xy)-1)\\n    f(xy) += x * f(10 ** (digit(xy)-2) - 1)\\n    return f(xy)\\n```\n```\\nimport math\\n\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        memo = dict()\\n        ans = self.helper(n, memo)\\n        return ans\\n    \\n    def helper(self, n: int, memo: dict) -> int:\\n        if n == 0: \\n            return 0 \\n        elif n <= 9: \\n            return 1 \\n        copyN = n\\n        res = 0\\n        digits = math.floor(math.log10(n)) + 1 \\n        sigDig = n // (10 ** (digits-1))\\n        n -= sigDig * 10 ** (digits-1)\\n        if sigDig == 1:\\n            res += (n+1)\\n        res += self.helper(n, memo)\\n        digits -= 1\\n        if sigDig-1 >= 1: \\n            res += 10 ** (digits)\\n        res += sigDig * self.helper(10**digits-1, memo)\\n        memo[copyN] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375805,
                "title": "digit-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[10][10][2];\\n    int n;\\n    string digit;\\n    int solve(int pos,int flag,int numones)\\n    {\\n        if(pos == n)\\n        {\\n            return numones;\\n        }\\n\\n        if(dp[pos][numones][flag]!=-1)\\n            return dp[pos][numones][flag];\\n\\n        int limit = (flag)?(digit[pos] - \\'0\\'):9;\\n        int ans = 0;\\n        for(int i=0;i<=limit;i++){\\n            ans = (ans + solve(pos+1,flag && (i == limit),numones + (i==1)));\\n        }\\n        return dp[pos][numones][flag] = ans;\\n    }\\n    int countDigitOne(int num) {\\n        memset(dp,-1,sizeof dp);\\n        digit = to_string(num);\\n        n=digit.length();\\n        return solve(0,1,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[10][10][2];\\n    int n;\\n    string digit;\\n    int solve(int pos,int flag,int numones)\\n    {\\n        if(pos == n)\\n        {\\n            return numones;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1369311,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[15][2][15];\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 1, 0);\\n    }\\n    \\n    int dfs(string& s,int i, int same, int cnt){\\n        if(i >= s.size()){\\n            return cnt;\\n        }\\n        \\n        if(dp[i][same][cnt] != -1){\\n            return dp[i][same][cnt];\\n        }\\n        \\n        int d = s[i] - \\'0\\';\\n        int res = 0;\\n        if(same == 1){\\n            for(int j = 0; j < d; j++){\\n                if(j == 1){\\n                    res += dfs(s, i + 1, 0, 1 + cnt);\\n                }\\n                else{\\n                    res += dfs(s, i + 1, 0, cnt);\\n                }\\n            }\\n            \\n            if(d == 1){\\n                res += dfs(s, i + 1, same, cnt + 1);\\n            }\\n            else{\\n                res += dfs(s, i + 1, same, cnt);\\n            }\\n            \\n            \\n        }\\n        else{\\n            for(int j = 0; j < 10; j++){\\n                if(j == 1){\\n                    res += dfs(s, i + 1, same, cnt + 1);\\n                }\\n                else{\\n                    res += dfs(s, i + 1, same, cnt);\\n                }\\n            }\\n        }\\n        \\n        dp[i][same][cnt] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[15][2][15];\\n    int countDigitOne(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 1, 0);\\n    }\\n    \\n    int dfs(string& s,int i, int same, int cnt){\\n        if(i >= s.size()){\\n            return cnt;\\n        }\\n        \\n        if(dp[i][same][cnt] != -1){\\n            return dp[i][same][cnt];\\n        }\\n        \\n        int d = s[i] - \\'0\\';\\n        int res = 0;\\n        if(same == 1){\\n            for(int j = 0; j < d; j++){\\n                if(j == 1){\\n                    res += dfs(s, i + 1, 0, 1 + cnt);\\n                }\\n                else{\\n                    res += dfs(s, i + 1, 0, cnt);\\n                }\\n            }\\n            \\n            if(d == 1){\\n                res += dfs(s, i + 1, same, cnt + 1);\\n            }\\n            else{\\n                res += dfs(s, i + 1, same, cnt);\\n            }\\n            \\n            \\n        }\\n        else{\\n            for(int j = 0; j < 10; j++){\\n                if(j == 1){\\n                    res += dfs(s, i + 1, same, cnt + 1);\\n                }\\n                else{\\n                    res += dfs(s, i + 1, same, cnt);\\n                }\\n            }\\n        }\\n        \\n        dp[i][same][cnt] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362288,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/number-of-digit-one/solutions/2576802/c-solution-digit-dp-memoization-0-ms-solution/?orderBy=most_votes&topicTags=memoization) solution\\n\\n```\\nfunc countDigitOne(n int) int {\\n\\tstr := fmt.Sprintf(\"%d\", n)\\n\\tdp := make([][][]int, 10)\\n\\n\\tfor i := 0; i < 10; i++ {\\n\\t\\tdp[i] = make([][]int, 2)\\n\\t\\tfor j := 0; j < 2; j++ {\\n\\t\\t\\tdp[i][j] = make([]int, 10)\\n\\t\\t\\tfor k := 0; k < 10; k++ {\\n\\t\\t\\t\\tdp[i][j][k] = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn solve(str, 0, 1, 0, &dp)\\n}\\n\\nfunc solve(s string, idx, tight, count int, dp *[][][]int) int {\\n\\tif idx == len(s) {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif (*dp)[idx][tight][count] != -1 {\\n\\t\\treturn (*dp)[idx][tight][count]\\n\\t}\\n\\n\\tans, bound := 0, 9\\n\\tif tight == 1 {\\n\\t\\tbound = int(s[idx] - \\'0\\')\\n\\t}\\n\\n\\tfor i := 0; i <= bound; i++ {\\n\\t\\tadd := 0\\n\\t\\tif i == 1 {\\n\\t\\t\\tadd = 1\\n\\t\\t}\\n\\n\\t\\tif i == bound && tight == 1 {\\n\\t\\t\\tans += solve(s, idx+1, tight, count+add, dp)\\n\\t\\t} else {\\n\\t\\t\\tans += solve(s, idx+1, 0, count+add, dp)\\n\\t\\t}\\n\\t}\\n\\n\\t(*dp)[idx][tight][count] = ans\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countDigitOne(n int) int {\\n\\tstr := fmt.Sprintf(\"%d\", n)\\n\\tdp := make([][][]int, 10)\\n\\n\\tfor i := 0; i < 10; i++ {\\n\\t\\tdp[i] = make([][]int, 2)\\n\\t\\tfor j := 0; j < 2; j++ {\\n\\t\\t\\tdp[i][j] = make([]int, 10)\\n\\t\\t\\tfor k := 0; k < 10; k++ {\\n\\t\\t\\t\\tdp[i][j][k] = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn solve(str, 0, 1, 0, &dp)\\n}\\n\\nfunc solve(s string, idx, tight, count int, dp *[][][]int) int {\\n\\tif idx == len(s) {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif (*dp)[idx][tight][count] != -1 {\\n\\t\\treturn (*dp)[idx][tight][count]\\n\\t}\\n\\n\\tans, bound := 0, 9\\n\\tif tight == 1 {\\n\\t\\tbound = int(s[idx] - \\'0\\')\\n\\t}\\n\\n\\tfor i := 0; i <= bound; i++ {\\n\\t\\tadd := 0\\n\\t\\tif i == 1 {\\n\\t\\t\\tadd = 1\\n\\t\\t}\\n\\n\\t\\tif i == bound && tight == 1 {\\n\\t\\t\\tans += solve(s, idx+1, tight, count+add, dp)\\n\\t\\t} else {\\n\\t\\t\\tans += solve(s, idx+1, 0, count+add, dp)\\n\\t\\t}\\n\\t}\\n\\n\\t(*dp)[idx][tight][count] = ans\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171142,
                "title": "100-solution-explanation-time-o-1-space-o-1-with-selected-pre-computed-result",
                "content": "\\n```\\nAs shown in the code, we count the 1\\'s using 10 steps for \"ABCDEFGHIJ\":\\n1: [0000000000, A000000000)\\n2: [A000000000, AB00000000)\\n3: [AB00000000, ABC0000000)\\n4: [ABC0000000, ABCD000000)\\n5: [ABCD000000, ABCDE00000)\\n6: [ABCDE00000, ABCDEF0000)\\n7: [ABCDEF0000, ABCDEFG000)\\n8: [ABCDEFG000, ABCDEFGH00)\\n9: [ABCDEFGH00, ABCDEFGHI0)\\n0: [ABCDEFGHI0, ABCDEFGHIJ]\\n```\\n\\nIn case it helps you, please upvote to notify me :P.\\n\\n```\\nint pcs [] = {//pcs[k] = pcs[k-1]*10 + dgts[k-1]\\n    //[0, 10)\\n    1,\\n    //[0, 100)\\n    20, //1*10+10\\n    //[0, 1,000)\\n    300,//20*10+100\\n    //[0, 10,000)\\n    4000,\\n    //[0, 100,000)\\n    50000,\\n    //[0, 1,000,000)\\n    600000,\\n    //[0, 10,000,000)\\n    7000000,\\n    //[0, 100,000,000)\\n    80000000,\\n    //[0, 1,000,000,000)\\n    900000000,\\n};\\n\\nint dgts [] = {\\n    10,\\n    100,\\n    1000,\\n    10000,\\n    100000,\\n    1000000,\\n    10000000,\\n    100000000,\\n    1000000000,\\n};\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        //d:8 [0000000000, A000000000)\\n        //d:7 [A000000000, AB00000000)\\n        //d:6 [AB00000000, ABC0000000)\\n        //d:5 [ABC0000000, ABCD000000)\\n        //d:4 [ABCD000000, ABCDE00000)\\n        //d:3 [ABCDE00000, ABCDEF0000)\\n        //d:2 [ABCDEF0000, ABCDEFG000)\\n        //d:1 [ABCDEFG000, ABCDEFGH00)\\n        //d:0 [ABCDEFGH00, ABCDEFGHI0)\\n        int dgt, pref=0;\\n        long long cnt=0;\\n        for(int d=8; d>=0; --d) {\\n            dgt=n/dgts[d];\\n            if(dgt) {\\n                cnt += 0L + //overflow when n is close to 2,000,000,000\\n                    dgt*pcs[d] + // pre-compute for [0, dgts[d])\\n                    (dgt>=2)*dgts[d] + // count extra 1 e.g. ABC1,000,000 ABC1,999,999\\n                    pref*dgt*dgts[d]; // leading 1\\'s e.g. [ABC1E1G000, ABC1E1GH00)\\n            }\\n            pref+=dgt==1;//increase leading 1\\'s\\n            n%=dgts[d];\\n        }\\n        //n=J    [ABCDEFGHI0, ABCDEFGHIJ]\\n        cnt+=pref*(n+1)+(n>=1);//don\\'t forget the extra 1 of ABCDEFGHI\"1\"\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAs shown in the code, we count the 1\\'s using 10 steps for \"ABCDEFGHIJ\":\\n1: [0000000000, A000000000)\\n2: [A000000000, AB00000000)\\n3: [AB00000000, ABC0000000)\\n4: [ABC0000000, ABCD000000)\\n5: [ABCD000000, ABCDE00000)\\n6: [ABCDE00000, ABCDEF0000)\\n7: [ABCDEF0000, ABCDEFG000)\\n8: [ABCDEFG000, ABCDEFGH00)\\n9: [ABCDEFGH00, ABCDEFGHI0)\\n0: [ABCDEFGHI0, ABCDEFGHIJ]\\n```\n```\\nint pcs [] = {//pcs[k] = pcs[k-1]*10 + dgts[k-1]\\n    //[0, 10)\\n    1,\\n    //[0, 100)\\n    20, //1*10+10\\n    //[0, 1,000)\\n    300,//20*10+100\\n    //[0, 10,000)\\n    4000,\\n    //[0, 100,000)\\n    50000,\\n    //[0, 1,000,000)\\n    600000,\\n    //[0, 10,000,000)\\n    7000000,\\n    //[0, 100,000,000)\\n    80000000,\\n    //[0, 1,000,000,000)\\n    900000000,\\n};\\n\\nint dgts [] = {\\n    10,\\n    100,\\n    1000,\\n    10000,\\n    100000,\\n    1000000,\\n    10000000,\\n    100000000,\\n    1000000000,\\n};\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        //d:8 [0000000000, A000000000)\\n        //d:7 [A000000000, AB00000000)\\n        //d:6 [AB00000000, ABC0000000)\\n        //d:5 [ABC0000000, ABCD000000)\\n        //d:4 [ABCD000000, ABCDE00000)\\n        //d:3 [ABCDE00000, ABCDEF0000)\\n        //d:2 [ABCDEF0000, ABCDEFG000)\\n        //d:1 [ABCDEFG000, ABCDEFGH00)\\n        //d:0 [ABCDEFGH00, ABCDEFGHI0)\\n        int dgt, pref=0;\\n        long long cnt=0;\\n        for(int d=8; d>=0; --d) {\\n            dgt=n/dgts[d];\\n            if(dgt) {\\n                cnt += 0L + //overflow when n is close to 2,000,000,000\\n                    dgt*pcs[d] + // pre-compute for [0, dgts[d])\\n                    (dgt>=2)*dgts[d] + // count extra 1 e.g. ABC1,000,000 ABC1,999,999\\n                    pref*dgt*dgts[d]; // leading 1\\'s e.g. [ABC1E1G000, ABC1E1GH00)\\n            }\\n            pref+=dgt==1;//increase leading 1\\'s\\n            n%=dgts[d];\\n        }\\n        //n=J    [ABCDEFGHI0, ABCDEFGHIJ]\\n        cnt+=pref*(n+1)+(n>=1);//don\\'t forget the extra 1 of ABCDEFGHI\"1\"\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113770,
                "title": "c-digit-dp-100-dynamic-programming",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int dp[10][2][10];\\n    vector<int> dig;\\n    int n;\\n    \\n    int res(int curr,bool small,int cnt)\\n    {\\n        if(curr==n)\\n        {\\n            return cnt;\\n        }\\n        if(dp[curr][small][cnt]!=-1)\\n            return dp[curr][small][cnt];\\n        ll temp=0;\\n        int lmt;\\n        if(small)\\n            lmt=9;\\n        else\\n            lmt=dig[curr];\\n        for(int i=0;i<=lmt;i++)\\n        {\\n            bool smltmp=small;\\n            if(i<lmt)\\n                smltmp=true;\\n            int cntmp=cnt;\\n            if(i==1)\\n                cntmp++;\\n            temp+=res(curr+1,smltmp,cntmp);\\n        }\\n        return dp[curr][small][cnt]=temp;\\n    }\\n    \\n    int countDigitOne(int m) {\\n        memset(dp,-1,sizeof dp);\\n        n=0;\\n        while(m!=0)\\n        {\\n            dig.push_back(m%10);\\n            n++;\\n            m/=10;\\n        }\\n        reverse(dig.begin(),dig.end());\\n        return res(0,false,false);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int dp[10][2][10];\\n    vector<int> dig;\\n    int n;\\n    \\n    int res(int curr,bool small,int cnt)\\n    {\\n        if(curr==n)\\n        {\\n            return cnt;\\n        }\\n        if(dp[curr][small][cnt]!=-1)\\n            return dp[curr][small][cnt];\\n        ll temp=0;\\n        int lmt;\\n        if(small)\\n            lmt=9;\\n        else\\n            lmt=dig[curr];\\n        for(int i=0;i<=lmt;i++)\\n        {\\n            bool smltmp=small;\\n            if(i<lmt)\\n                smltmp=true;\\n            int cntmp=cnt;\\n            if(i==1)\\n                cntmp++;\\n            temp+=res(curr+1,smltmp,cntmp);\\n        }\\n        return dp[curr][small][cnt]=temp;\\n    }\\n    \\n    int countDigitOne(int m) {\\n        memset(dp,-1,sizeof dp);\\n        n=0;\\n        while(m!=0)\\n        {\\n            dig.push_back(m%10);\\n            n++;\\n            m/=10;\\n        }\\n        reverse(dig.begin(),dig.end());\\n        return res(0,false,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113287,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if (n==0) return 0;\\n        \\n        int a[] = {0,1,20,300,4000,50000,600000,7000000,80000000,900000000};\\n        int digit[] = new int[10];\\n        int count = 0 , d = 0, k = n;\\n        long l = 1;\\n        while (k>0){\\n            digit[d++] = k%10;\\n            k/=10;\\n            l*=10;\\n        }\\n        for (int i = d-1; i>=0 ; i--){\\n            l/=10;\\n            \\n            if (digit[i]==0) continue;\\n            \\n            count+=digit[i]*a[i];\\n            \\n            if (digit[i]>=2) \\n                count+=l;\\n            else \\n                count+=n%l + 1;            \\n        }\\n        return count;        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countDigitOne(int n) {\\n        if (n==0) return 0;\\n        \\n        int a[] = {0,1,20,300,4000,50000,600000,7000000,80000000,900000000}",
                "codeTag": "Java"
            },
            {
                "id": 1020983,
                "title": "java-bottomup",
                "content": "```\\n    public int countDigitOne(int n) {\\n        int[] pre = new int[10];\\n        pre[1] = 1;\\n        int p = 10;\\n        for (int i = 2; i < 10; i++) {\\n            pre[i] = 10 * pre[i - 1] + p;\\n            p *= 10;\\n        }\\n        int dp = 0;\\n        p = 1;\\n        int i = 1;\\n        int resi = 0;\\n        while (n > 0) {\\n            int d = n % 10;\\n            if (d == 1)\\n                dp += pre[i - 1] + (resi + 1);\\n            else if (d > 1)\\n                dp += d * pre[i - 1] + p;\\n            resi = d * p + resi;\\n            p *= 10;\\n            n /= 10;\\n            i++;\\n        }\\n        return dp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countDigitOne(int n) {\\n        int[] pre = new int[10];\\n        pre[1] = 1;\\n        int p = 10;\\n        for (int i = 2; i < 10; i++) {\\n            pre[i] = 10 * pre[i - 1] + p;\\n            p *= 10;\\n        }\\n        int dp = 0;\\n        p = 1;\\n        int i = 1;\\n        int resi = 0;\\n        while (n > 0) {\\n            int d = n % 10;\\n            if (d == 1)\\n                dp += pre[i - 1] + (resi + 1);\\n            else if (d > 1)\\n                dp += d * pre[i - 1] + p;\\n            resi = d * p + resi;\\n            p *= 10;\\n            n /= 10;\\n            i++;\\n        }\\n        return dp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913992,
                "title": "c-0ms-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int dp[11];\\n    int num = 9;\\n    vector <int> number;\\n    int conv(){\\n        int lNum = 0;\\n        for(int i = number.size() - 2; i >= 0; i--){\\n            lNum *= 10;\\n            lNum += number[i];\\n        }\\n        return lNum;\\n    }\\n    int cou(){\\n        int res = dp[number.size() - 1] * (number[number.size() - 1]) + 1;\\n        \\n        if(number.size() == 1){\\n            if(number[0] == 0){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(number[number.size() - 1] == 0)\\n            res --;\\n        else if(number[number.size() - 1] == 1){\\n            res += conv();\\n        }\\n        else{\\n            res += num;\\n        }\\n        return res;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        if(n <= 0)\\n           return 0;\\n        int cp = n;\\n        while(cp >= 10){\\n            number.push_back(cp % 10);\\n            cp /= 10;\\n        }\\n        number.push_back(cp);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        long long sc = 0;\\n        for(int i = 2; i < number.size(); i++){\\n            dp[i] = num + 1 + 10 * dp[i - 1];\\n            num *= 10;\\n            num += 9;\\n        }\\n        while(number.size()){\\n            sc += cou();  \\n            number.pop_back();\\n            num /= 10;\\n        }     \\n        return sc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dp[11];\\n    int num = 9;\\n    vector <int> number;\\n    int conv(){\\n        int lNum = 0;\\n        for(int i = number.size() - 2; i >= 0; i--){\\n            lNum *= 10;\\n            lNum += number[i];\\n        }\\n        return lNum;\\n    }\\n    int cou(){\\n        int res = dp[number.size() - 1] * (number[number.size() - 1]) + 1;\\n        \\n        if(number.size() == 1){\\n            if(number[0] == 0){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(number[number.size() - 1] == 0)\\n            res --;\\n        else if(number[number.size() - 1] == 1){\\n            res += conv();\\n        }\\n        else{\\n            res += num;\\n        }\\n        return res;\\n    }\\n    \\n    int countDigitOne(int n) {\\n        if(n <= 0)\\n           return 0;\\n        int cp = n;\\n        while(cp >= 10){\\n            number.push_back(cp % 10);\\n            cp /= 10;\\n        }\\n        number.push_back(cp);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        long long sc = 0;\\n        for(int i = 2; i < number.size(); i++){\\n            dp[i] = num + 1 + 10 * dp[i - 1];\\n            num *= 10;\\n            num += 9;\\n        }\\n        while(number.size()){\\n            sc += cou();  \\n            number.pop_back();\\n            num /= 10;\\n        }     \\n        return sc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824263,
                "title": "digit-dp-solution-100-cpp",
                "content": "What the question asks ? \\nThe question asks us to count all the occurences of \\'1\\' in the numbers in the range [1, 2, 3, ... N].\\nApproach:\\n1. Since we know N, we know the maximum number of digits (K) that are possible i.e ceil(log(N, base = 10)).\\n2. Now lets say that you have already calculated the answer for the digits [1, 2, 3, ... pos - 1] where 1 <= pos < K. And you want to figure out if I can put a digit \\'d\\' here. How to do that ?\\n3.  One thing is that if I am not restricted to put a \\'1\\' here at this pos and increase my \\'1\\' count. Then I will put \\'1\\' here and will recurse on the right from [pos + 1, ... K].\\n4. Else I will put some digits here [0, 1, ... limit], where limit is decided by if I am restricted or not. If I am not restrcited then put [0, 1, ..., 9] else put [0, 1, 2, ... limit] and recurse to the right.\\n\\n* So my **DP state** is `[pos][restricted][ones_count]`.\\n**RECURSIVE-SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int dp[12][2][12];\\n    int solve(const string &str, int pos, int restricted, int cnt){\\n        if(pos == str.size()){\\n            return cnt; \\n        }\\n        if(dp[pos][restricted][cnt] != -1){\\n            return dp[pos][restricted][cnt];\\n        }\\n        int res = 0;\\n        if(restricted == 0){\\n            for(int i = 0; i <= 9; i++){\\n                if(i == 1){\\n                    res += solve(str, pos + 1, 0, cnt + 1); \\n                }else{\\n                    res += solve(str, pos + 1, 0, cnt);\\n                }\\n            }\\n        }else{\\n            int limit = str[pos] - \\'0\\';\\n            for(int i = 0; i <= limit; i++){\\n                int n_restriction = restricted;\\n                if(i < limit){\\n                    n_restriction = 0;\\n                }\\n                if(i == 1){\\n                    res += solve(str, pos + 1, n_restriction, cnt + 1); \\n                }else{\\n                    res += solve(str, pos + 1, n_restriction, cnt);\\n                }\\n            }\\n        }\\n        \\n        return dp[pos][restricted][cnt] = res;\\n    }    \\n    \\n    int countDigitOne(int n) {\\n        string str = to_string(n);\\n        // dp[pos][restricted][cnt]\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int result = solve(str, 0, 1, 0);\\n        \\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][12];\\n    int solve(const string &str, int pos, int restricted, int cnt){\\n        if(pos == str.size()){\\n            return cnt; \\n        }\\n        if(dp[pos][restricted][cnt] != -1){\\n            return dp[pos][restricted][cnt];\\n        }\\n        int res = 0;\\n        if(restricted == 0){\\n            for(int i = 0; i <= 9; i++){\\n                if(i == 1){\\n                    res += solve(str, pos + 1, 0, cnt + 1); \\n                }else{\\n                    res += solve(str, pos + 1, 0, cnt);\\n                }\\n            }\\n        }else{\\n            int limit = str[pos] - \\'0\\';\\n            for(int i = 0; i <= limit; i++){\\n                int n_restriction = restricted;\\n                if(i < limit){\\n                    n_restriction = 0;\\n                }\\n                if(i == 1){\\n                    res += solve(str, pos + 1, n_restriction, cnt + 1); \\n                }else{\\n                    res += solve(str, pos + 1, n_restriction, cnt);\\n                }\\n            }\\n        }\\n        \\n        return dp[pos][restricted][cnt] = res;\\n    }    \\n    \\n    int countDigitOne(int n) {\\n        string str = to_string(n);\\n        // dp[pos][restricted][cnt]\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int result = solve(str, 0, 1, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815500,
                "title": "c-digit-dp",
                "content": "Simple digit dp \\n```\\n typedef int ll;\\n    ll dp[100][1000][2];//pos,sum,tight\\n    ll solve(string s,int tight=1,int flag=0,int pos=0){\\n        if(pos==s.size())\\n            return flag;\\n        }\\n        if(dp[pos][flag][tight]!=-1)\\n            return dp[pos][flag][tight];\\n        if(tight==1){//tight show uppebound limit of digit at any place\\n            ll res=0;\\n            for(int i=0;i<=s[pos]-\\'0\\';i++){\\n                int flg=flag;\\n                if(i==1)flg+=1;\\n                if(i==s[pos]-\\'0\\'){\\n                    res+=solve(s,1,flg,pos+1);\\n                }\\n                else\\n                    res+=solve(s,0,flg,pos+1);\\n            }\\n            dp[pos][flag][tight]=res;\\n            return res;\\n        }\\n        else{\\n            ll res=0;\\n            for(int i=0;i<=9;i++){\\n                int flg=flag;\\n                if(i==1)flg+=1;\\n                res+=solve(s,0,flg,pos+1);\\n            }\\n            dp[pos][flag][tight]=res;\\n            return res;\\n        }\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(s);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n typedef int ll;\\n    ll dp[100][1000][2];//pos,sum,tight\\n    ll solve(string s,int tight=1,int flag=0,int pos=0){\\n        if(pos==s.size())\\n            return flag;\\n        }\\n        if(dp[pos][flag][tight]!=-1)\\n            return dp[pos][flag][tight];\\n        if(tight==1){//tight show uppebound limit of digit at any place\\n            ll res=0;\\n            for(int i=0;i<=s[pos]-\\'0\\';i++){\\n                int flg=flag;\\n                if(i==1)flg+=1;\\n                if(i==s[pos]-\\'0\\'){\\n                    res+=solve(s,1,flg,pos+1);\\n                }\\n                else\\n                    res+=solve(s,0,flg,pos+1);\\n            }\\n            dp[pos][flag][tight]=res;\\n            return res;\\n        }\\n        else{\\n            ll res=0;\\n            for(int i=0;i<=9;i++){\\n                int flg=flag;\\n                if(i==1)flg+=1;\\n                res+=solve(s,0,flg,pos+1);\\n            }\\n            dp[pos][flag][tight]=res;\\n            return res;\\n        }\\n    }\\n    int countDigitOne(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(s);\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 760282,
                "title": "easy-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n <= 0:\\n            return 0\\n        if n <= 9:\\n            return 1\\n        dp = {}\\n        dp[9] = 1\\n        i = 9\\n\\t\\t# (i + 1) is to handle the ones from (10-19) in all the 100\\'s \\n        while i < n + 1:\\n            dp[i *10  + 9] = dp[i] *10 + (i + 1)\\n            i = i*10 + 9\\n        temp = n\\n        div = 1\\n        while temp//10:            \\n            temp = temp//10\\n            div = div* 10\\n        ans = 0\\n        ans += (n//div)*dp[div - 1]\\n        if n//div > 1:\\n            ans += div\\n\\t\\t# this is to handle the cases ex: 105 or 149 etc\\n        elif n//div == 1:\\n            ans += (n%div) + 1\\n        ans += self.countDigitOne(n%div)\\n        return ans\\n    \\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n <= 0:\\n            return 0\\n        if n <= 9:\\n            return 1\\n        dp = {}\\n        dp[9] = 1\\n        i = 9\\n\\t\\t# (i + 1) is to handle the ones from (10-19) in all the 100\\'s \\n        while i < n + 1:\\n            dp[i *10  + 9] = dp[i] *10 + (i + 1)\\n            i = i*10 + 9\\n        temp = n\\n        div = 1\\n        while temp//10:            \\n            temp = temp//10\\n            div = div* 10\\n        ans = 0\\n        ans += (n//div)*dp[div - 1]\\n        if n//div > 1:\\n            ans += div\\n\\t\\t# this is to handle the cases ex: 105 or 149 etc\\n        elif n//div == 1:\\n            ans += (n%div) + 1\\n        ans += self.countDigitOne(n%div)\\n        return ans\\n    \\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 706205,
                "title": "short-java-solution",
                "content": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int ans = 0;\\n        for (long i = 1; i <= n; i *= 10)\\n            ans += (n / (i * 10)) * i + Math.min(i, Math.max(0, n % (i * 10) - i + 1));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        int ans = 0;\\n        for (long i = 1; i <= n; i *= 10)\\n            ans += (n / (i * 10)) * i + Math.min(i, Math.max(0, n % (i * 10) - i + 1));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601622,
                "title": "clean-logic-c-recursive-solution",
                "content": "Same thought as posted in [Easy to understand C++ 0ms solution with detailed explanation\\n](http://https://leetcode.com/problems/number-of-digit-one/discuss/64426/Easy-to-understand-C%2B%2B-0ms-solution-with-detailed-explanation), but this code has cleaner logic that absorbs corner cases. I summarize the thought as **\"multiples of 10^power-1 PLUS surplus of 10^power PLUS the trailing.\"**\\n\\n```\\nint countDigitOne(int n) {\\n\\tif(n <= 0) return 0;\\n\\tint p = 1, f9 = 0;\\n\\twhile(n/p >= 10){\\n\\t\\tf9 = 10 * f9 + p;\\n\\t\\tp *= 10;\\n\\t}\\n\\treturn n / p * f9 + min(p, n-p+1) + countDigitOne(n % p);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countDigitOne(int n) {\\n\\tif(n <= 0) return 0;\\n\\tint p = 1, f9 = 0;\\n\\twhile(n/p >= 10){\\n\\t\\tf9 = 10 * f9 + p;\\n\\t\\tp *= 10;\\n\\t}\\n\\treturn n / p * f9 + min(p, n-p+1) + countDigitOne(n % p);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566517,
                "title": "a-simple-python-solution-accepted",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        m=1\\n        ret=0\\n        while m<=n:\\n            a=n//m\\n            b=n%m\\n            ret+=(a+8)//10*m+(a%10==1)*(b+1)\\n            m*=10\\n        return ret\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        m=1\\n        ret=0\\n        while m<=n:\\n            a=n//m\\n            b=n%m\\n            ret+=(a+8)//10*m+(a%10==1)*(b+1)\\n            m*=10\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508542,
                "title": "c-o-logn-o-1-easy-for-average-people-to-understand",
                "content": "The key is to understand why \"1\" recurs. The \"1\" at the i-th digit recurs because of other digits exist and vice versa. Applying this thought, we can count the recurrance of 1\\'s in a **k-digts number like 99...99**, denoted by F(k) as:  **F(k) = 10 * F(k-1) + 10^(k-1)**, where \\n* 10 * F(k-1) is the recurrance of made by the k-th digit to all previous digits; \\n* 10^(k-1) is the recurrance of the \"1\" at the k-th digit by all previous digits; \\n\\nLet n be Xk|...|X2|X1. The recurrance of \"1\" of other digits made by varying Xk\\'s value:\\n* for  0 <= x < Xk, it is Xk * F(k-1); \\n* for x = Xk, it is the same question with the leading digits of n removed\\nMoreover, the \"1\" placed at the k-th digit can be repeated in the following way:\\n* if Xk > 1, the remaining digits are not constrained when place \"1\" at the k-th digit, thus 10^(k-1); \\n* if Xk = 1, it shall be the the value of n with the leading digits removed. \\n```\\n        int base = 1, suffix = 0, ans = 0, curr_digit, count_d = 0; \\n        int d = 1; \\n        while (n) {\\n            curr_digit = n % 10;  \\n            ans += curr_digit * count_d; \\n            if (curr_digit == d) ans += suffix + 1; \\n            else if (curr_digit > 1) ans += base; \\n            suffix += curr_digit * base;\\n            count_d = 10 * count_d + base;\\n            n /= 10; \\n            if (n) base *= 10;\\n        }\\n        return ans; \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        int base = 1, suffix = 0, ans = 0, curr_digit, count_d = 0; \\n        int d = 1; \\n        while (n) {\\n            curr_digit = n % 10;  \\n            ans += curr_digit * count_d; \\n            if (curr_digit == d) ans += suffix + 1; \\n            else if (curr_digit > 1) ans += base; \\n            suffix += curr_digit * base;\\n            count_d = 10 * count_d + base;\\n            n /= 10; \\n            if (n) base *= 10;\\n        }\\n        return ans; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506131,
                "title": "python3-two-simple-solutions",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n==0: return 0\\n        res,m=0,1\\n        while m<=n:\\n            a,b=n//m,n%m\\n            if a%10>1: res+=(a//10+1)*m\\n            elif a%10==1: res+=(a//10)*m+b+1\\n            elif a%10==0: res+=(a//10)*m\\n            m*=10\\n        return res            \\n    \\n    def countDigitOne1(self, n: int) -> int:\\n        if n==0: return 0\\n        res,count=\"\",0\\n        for i in range(1,n+1):\\n            res+=str(i)\\n        for char in res:\\n            if char==\"1\": count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        if n==0: return 0\\n        res,m=0,1\\n        while m<=n:\\n            a,b=n//m,n%m\\n            if a%10>1: res+=(a//10+1)*m\\n            elif a%10==1: res+=(a//10)*m+b+1\\n            elif a%10==0: res+=(a//10)*m\\n            m*=10\\n        return res            \\n    \\n    def countDigitOne1(self, n: int) -> int:\\n        if n==0: return 0\\n        res,count=\"\",0\\n        for i in range(1,n+1):\\n            res+=str(i)\\n        for char in res:\\n            if char==\"1\": count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505810,
                "title": "c-clearly-explained",
                "content": "\\t//////////////////////////////////////////////////////////////////////////////\\n    /* suppose:                                                                  *\\n    *  n = a(m) * 10^m + a(m-1) * 10^(m-1) + ... + a(0) * 10^0                   *\\n    *  and p = a(m  ) * 10^(m-i-1) + ... + a(i+1) * 10^0                         *\\n    *  and q = a(i-1) * 10^(i-  1) + ... + a(0  ) * 10^0                         *\\n    *  and k = a(i  ) ==> 1 on ith place) =                                      *\\n    *  p * 10^i + if (k == 1) { (q+1); } + if (k > 1) { 10^i; }                 */\\n    //////////////////////////////////////////////////////////////////////////////\\n    int countDigitOne(int n) {\\n        int C = 0, q = 0; int64_t pow10 = 1;\\n        while (n) {\\n            int k = n % 10;\\n            int p = n / 10;\\n            if (k > 1) {\\n                C += pow10;\\n            } \\n            else if (k == 1) {\\n                C += (q + 1);\\n            }\\n            C += pow10 * p;\\n            q += pow10 * k;\\n            \\n            pow10 *= 10;\\n            n     /= 10;\\n        }\\n        return C;\\n    }",
                "solutionTags": [],
                "code": "\\t//////////////////////////////////////////////////////////////////////////////\\n    /* suppose:                                                                  *\\n    *  n = a(m) * 10^m + a(m-1) * 10^(m-1) + ... + a(0) * 10^0                   *\\n    *  and p = a(m  ) * 10^(m-i-1) + ... + a(i+1) * 10^0                         *\\n    *  and q = a(i-1) * 10^(i-  1) + ... + a(0  ) * 10^0                         *\\n    *  and k = a(i  ) ==> 1 on ith place) =                                      *\\n    *  p * 10^i + if (k == 1) { (q+1); } + if (k > 1) { 10^i; }                 */\\n    //////////////////////////////////////////////////////////////////////////////\\n    int countDigitOne(int n) {\\n        int C = 0, q = 0; int64_t pow10 = 1;\\n        while (n) {\\n            int k = n % 10;\\n            int p = n / 10;\\n            if (k > 1) {\\n                C += pow10;\\n            } \\n            else if (k == 1) {\\n                C += (q + 1);\\n            }\\n            C += pow10 * p;\\n            q += pow10 * k;\\n            \\n            pow10 *= 10;\\n            n     /= 10;\\n        }\\n        return C;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 448978,
                "title": "well-explained-python-solution-o-log-n",
                "content": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        \\'\\'\\'\\n        Each digit represents an integer as: \\n            digit * 10 ** power\\n            \\n        Solution for 10**x - 1 is x * 10 ** (x-1)\\n            e.g. for 999: 3 * 100 = 300, for 9999: 4000\\n        \\n        Then solution for digit becomes:\\n            digit * x * 10 ** (x-1) + exception\\n        Where exception is the 1\\'s that showed up in that order of digit.\\n        \\n        If digit is 2 or more, exception is 10**x, \\n            e.g. There are 100 one-hundreds until 200.\\n        \\n        But digit 1 requires us to know less\\n        significant digits:\\n            e.g. There are 46 one-hundreds until 145.\\n            Digit 1 can\\'t tell the number of one-hundreds alone.\\n        \\n        So I stored less significant digits in \"seen\".\\n        \\'\\'\\'\\n        \\n        if n<1: return 0\\n        \\n        def ansForDigit(digit, power, seen):\\n            if not power or not digit: #zero digits and last digit\\n                return digit > 0\\n            \\n            tens = [int(seen) + 1, 10**power][digit != 1]\\n            return digit * power * 10 ** (power - 1) + tens\\n        \\n        def ans(n, power, seen):\\n            if not n:\\n                return 0\\n            return ansForDigit(n % 10, power, seen) + ans(n // 10, power + 1, str(n % 10) + seen)\\n        \\n        return ans(n, 0, \\'\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDigitOne(self, n: int) -> int:\\n        \\'\\'\\'\\n        Each digit represents an integer as: \\n            digit * 10 ** power\\n            \\n        Solution for 10**x - 1 is x * 10 ** (x-1)\\n            e.g. for 999: 3 * 100 = 300, for 9999: 4000\\n        \\n        Then solution for digit becomes:\\n            digit * x * 10 ** (x-1) + exception\\n        Where exception is the 1\\'s that showed up in that order of digit.\\n        \\n        If digit is 2 or more, exception is 10**x, \\n            e.g. There are 100 one-hundreds until 200.\\n        \\n        But digit 1 requires us to know less\\n        significant digits:\\n            e.g. There are 46 one-hundreds until 145.\\n            Digit 1 can\\'t tell the number of one-hundreds alone.\\n        \\n        So I stored less significant digits in \"seen\".\\n        \\'\\'\\'\\n        \\n        if n<1: return 0\\n        \\n        def ansForDigit(digit, power, seen):\\n            if not power or not digit: #zero digits and last digit\\n                return digit > 0\\n            \\n            tens = [int(seen) + 1, 10**power][digit != 1]\\n            return digit * power * 10 ** (power - 1) + tens\\n        \\n        def ans(n, power, seen):\\n            if not n:\\n                return 0\\n            return ansForDigit(n % 10, power, seen) + ans(n // 10, power + 1, str(n % 10) + seen)\\n        \\n        return ans(n, 0, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447659,
                "title": "same-logic-as-top-soluition-easier-to-read-in-my-opinion",
                "content": "The math of other solutions, while correct, was tripping me up because I kept losing track of what those numbers (i.e. n / 10 - pow) mean. So I split it into variables and if statements. Maybe slightly slower but much easier to read, IMO.\\n\\n```\\n    int countDigitOne(int n) {\\n        int total = 0;\\n        for (long int ten_pow = 1; ten_pow <= n; ten_pow *= 10) {\\n            int left_part = n / (ten_pow * 10);\\n            total += left_part * ten_pow;\\n            \\n            int right_part = n % (ten_pow * 10);\\n            if (ten_pow <= right_part && right_part < ten_pow * 2) {\\n                total += (right_part - ten_pow) + 1;\\n            } else if (right_part >= ten_pow * 2) {\\n                total += ten_pow;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countDigitOne(int n) {\\n        int total = 0;\\n        for (long int ten_pow = 1; ten_pow <= n; ten_pow *= 10) {\\n            int left_part = n / (ten_pow * 10);\\n            total += left_part * ten_pow;\\n            \\n            int right_part = n % (ten_pow * 10);\\n            if (ten_pow <= right_part && right_part < ten_pow * 2) {\\n                total += (right_part - ten_pow) + 1;\\n            } else if (right_part >= ten_pow * 2) {\\n                total += ten_pow;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443181,
                "title": "",
                "content": "Runtime: 0 ms, faster than 100.00%\\nmemory 6.8M beats 100%\\n\\n```\\n/*\\n * \\u6309\\u5341\\u8FDB\\u5236\\u5206\\u4E3A\\u9AD8\\u3001\\u5F53\\u524D\\u3001\\u4F4E\\u4F4D\\uFF0C\\u5219\\u89C4\\u5F8B\\u4E3A\\uFF1A\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u5C0F\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u7684\\u6570\\u503C\\u51CF\\u4E00\\uFF0C\\u4F4E\\u4F4D\\u6570\\u5B57\\u5168\\u53D8\\u62109\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u5341\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u9AD8\\u4F4D\\u51CF\\u4E00\\u5F97820\\uFF0C\\u4F4E\\u4F4D\\u53D8\\u62109\\uFF09\\uFF1B\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u7B49\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u548C\\u4F4E\\u4F4D\\u90FD\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u767E\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u9AD8\\u4F4D\\u4FDD\\u6301\\u4E3A82\\uFF0C\\u4F4E\\u4F4D\\u4FDD\\u6301\\u4E3A03\\uFF09\\uFF1B\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u5927\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF0C\\u4F4E\\u4F4D\\u6570\\u5B57\\u5168\\u53D8\\u62109\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u4E07\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u9AD8\\u4F4D\\u4E3A0\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF0C\\u4F4E\\u4F4D\\u53D8\\u62109999\\uFF09\\u3002\\n * \\u7136\\u540E\\uFF0C\\u53BB\\u6389\\u5F53\\u524D\\u4F4D\\uFF0C\\u5408\\u5E76\\u9AD8\\u4F4D\\u548C\\u4F4E\\u4F4D\\u5F97\\u5230\\u4E00\\u4E2A\\u4E2D\\u95F4\\u6570\\u5B57t\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u767E\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u53BB\\u6389\\u767E\\u4F4D\\uFF0C\\u5408\\u5E76\\u9AD8\\u4F4E\\u4F4D\\u4E4B\\u540E\\u5F97\\u52308203\\uFF09\\uFF0C\\n * \\u90A3\\u4E48\\u9501\\u5B9A\\u5F53\\u524D\\u4F4D\\u4E3A1\\uFF0C\\u5219\\u5176\\u4ED6\\u4F4D\\u7684\\u53D8\\u5316\\u4E3A [0, t]\\uFF0C\\u5171\\u6709t+1\\u79CD\\u53D8\\u5316\\uFF080000~8203\\u51718204\\u79CD\\u53D8\\u5316\\uFF09\\u3002\\n * \\u6309\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u904D\\u5386\\u8F93\\u5165\\u6570\\u7684\\u6BCF\\u4E00\\u4E2A\\u5341\\u8FDB\\u5236\\u4F4D\\uFF0C\\u53EF\\u4EE5\\u5F97\\u5230\\u4E00\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u53D8\\u5316\\u3002\\n * \\u4E0A\\u9762\\u7684\\u4F8B\\u5B50\\u8F93\\u516582103\\uFF0C\\u5219\\u6709 (8210+1) + (8209+1) + (8203+1) + (8999+1) + (9999+1) = 43625 \\u79CD\\u53D8\\u5316\\u3002\\n */\\n\\nint countDigitOne(int n){\\n    int high = n, count = 0, scale = 1, curr;\\n    while (1) {\\n        curr = high % 10;\\n        high /= 10;\\n        count += high * scale;          // t\\u7684\\u9AD8\\u4F4D\\n        if (curr == 1)\\n            count += n % scale + 1;     // t\\u7684\\u4F4E\\u4F4D+1\\n        else if (curr > 1)\\n            count += scale;             // t\\u7684\\u4F4E\\u4F4D\\u5168\\u53D8\\u62109\\u518D\\u52A01\\uFF0C\\u5176\\u5B9E\\u8FD9\\u91CC\\u662F (scale-1)+1\\n\\n                                        // \\u540E\\u9762\\u8FD8\\u6709\\u4E00\\u4E2Aelse\\u6CA1\\u5199\\uFF0C\\u56E0\\u4E3A\\u5F53\\u524D\\u4F4D\\u5C0F\\u4E8E1\\u65F6\\n                                        // t\\u7684\\u9AD8\\u4F4D\\u662F high-1\\uFF0C\\u4F4E\\u4F4D\\u662F scale-1\\uFF08\\u5373\\u5168\\u53D8\\u62109\\uFF09\\n                                        // ((high-1)*scale+(scale-1))+1 \\u5C31\\u7B49\\u4E8E high*scale\\n        if (high == 0)\\n            break;\\n        scale *= 10;                    // \\u8FD9\\u4E00\\u6761\\u8BED\\u53E5\\u5FC5\\u987B\\u653E\\u5728break\\u540E\\u9762\\uFF0C\\u5426\\u5219\\u53EF\\u80FD\\u53D1\\u751Fint\\u7C7B\\u578B\\u6EA2\\u51FA\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * \\u6309\\u5341\\u8FDB\\u5236\\u5206\\u4E3A\\u9AD8\\u3001\\u5F53\\u524D\\u3001\\u4F4E\\u4F4D\\uFF0C\\u5219\\u89C4\\u5F8B\\u4E3A\\uFF1A\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u5C0F\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u7684\\u6570\\u503C\\u51CF\\u4E00\\uFF0C\\u4F4E\\u4F4D\\u6570\\u5B57\\u5168\\u53D8\\u62109\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u5341\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u9AD8\\u4F4D\\u51CF\\u4E00\\u5F97820\\uFF0C\\u4F4E\\u4F4D\\u53D8\\u62109\\uFF09\\uFF1B\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u7B49\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u548C\\u4F4E\\u4F4D\\u90FD\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u767E\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u9AD8\\u4F4D\\u4FDD\\u6301\\u4E3A82\\uFF0C\\u4F4E\\u4F4D\\u4FDD\\u6301\\u4E3A03\\uFF09\\uFF1B\\n * \\u82E5\\u5F53\\u524D\\u4F4D\\u5927\\u4E8E1\\uFF0C\\u5219\\u9AD8\\u4F4D\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF0C\\u4F4E\\u4F4D\\u6570\\u5B57\\u5168\\u53D8\\u62109\\uFF1B\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u4E07\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u9AD8\\u4F4D\\u4E3A0\\u4FDD\\u6301\\u4E0D\\u53D8\\uFF0C\\u4F4E\\u4F4D\\u53D8\\u62109999\\uFF09\\u3002\\n * \\u7136\\u540E\\uFF0C\\u53BB\\u6389\\u5F53\\u524D\\u4F4D\\uFF0C\\u5408\\u5E76\\u9AD8\\u4F4D\\u548C\\u4F4E\\u4F4D\\u5F97\\u5230\\u4E00\\u4E2A\\u4E2D\\u95F4\\u6570\\u5B57t\\uFF08\\u598282103\\uFF0C\\u5F53\\u524D\\u4F4D\\u662F\\u767E\\u4F4D\\u7684\\u65F6\\u5019\\uFF0C\\u5219\\u53BB\\u6389\\u767E\\u4F4D\\uFF0C\\u5408\\u5E76\\u9AD8\\u4F4E\\u4F4D\\u4E4B\\u540E\\u5F97\\u52308203\\uFF09\\uFF0C\\n * \\u90A3\\u4E48\\u9501\\u5B9A\\u5F53\\u524D\\u4F4D\\u4E3A1\\uFF0C\\u5219\\u5176\\u4ED6\\u4F4D\\u7684\\u53D8\\u5316\\u4E3A [0, t]\\uFF0C\\u5171\\u6709t+1\\u79CD\\u53D8\\u5316\\uFF080000~8203\\u51718204\\u79CD\\u53D8\\u5316\\uFF09\\u3002\\n * \\u6309\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u904D\\u5386\\u8F93\\u5165\\u6570\\u7684\\u6BCF\\u4E00\\u4E2A\\u5341\\u8FDB\\u5236\\u4F4D\\uFF0C\\u53EF\\u4EE5\\u5F97\\u5230\\u4E00\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u53D8\\u5316\\u3002\\n * \\u4E0A\\u9762\\u7684\\u4F8B\\u5B50\\u8F93\\u516582103\\uFF0C\\u5219\\u6709 (8210+1) + (8209+1) + (8203+1) + (8999+1) + (9999+1) = 43625 \\u79CD\\u53D8\\u5316\\u3002\\n */\\n\\nint countDigitOne(int n){\\n    int high = n, count = 0, scale = 1, curr;\\n    while (1) {\\n        curr = high % 10;\\n        high /= 10;\\n        count += high * scale;          // t\\u7684\\u9AD8\\u4F4D\\n        if (curr == 1)\\n            count += n % scale + 1;     // t\\u7684\\u4F4E\\u4F4D+1\\n        else if (curr > 1)\\n            count += scale;             // t\\u7684\\u4F4E\\u4F4D\\u5168\\u53D8\\u62109\\u518D\\u52A01\\uFF0C\\u5176\\u5B9E\\u8FD9\\u91CC\\u662F (scale-1)+1\\n\\n                                        // \\u540E\\u9762\\u8FD8\\u6709\\u4E00\\u4E2Aelse\\u6CA1\\u5199\\uFF0C\\u56E0\\u4E3A\\u5F53\\u524D\\u4F4D\\u5C0F\\u4E8E1\\u65F6\\n                                        // t\\u7684\\u9AD8\\u4F4D\\u662F high-1\\uFF0C\\u4F4E\\u4F4D\\u662F scale-1\\uFF08\\u5373\\u5168\\u53D8\\u62109\\uFF09\\n                                        // ((high-1)*scale+(scale-1))+1 \\u5C31\\u7B49\\u4E8E high*scale\\n        if (high == 0)\\n            break;\\n        scale *= 10;                    // \\u8FD9\\u4E00\\u6761\\u8BED\\u53E5\\u5FC5\\u987B\\u653E\\u5728break\\u540E\\u9762\\uFF0C\\u5426\\u5219\\u53EF\\u80FD\\u53D1\\u751Fint\\u7C7B\\u578B\\u6EA2\\u51FA\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 428947,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int ones=0;\\n        \\n        for(long div=1; div<=n; div*=10){\\n            int a = n/div;\\n            int b = a%10;\\n            a /= 10;\\n            int c = n%div;\\n            if(b>1) ones += (a+1)*div;\\n            else if(b==1) ones += a*div + c+1;\\n            else ones += a*div;\\n        }\\n        return ones;\\n    }\\n};\\n// \\u5C06\\u6570\\u5B57\\u5206\\u4E3A\\u9AD8\\u4F4D+\\u5F53\\u524D\\u4F4D+\\u4F4E\\u4F4D\\u4E09\\u90E8\\u5206\\uFF0C\\u5982\\u5BF9972342\\uFF0C\\u5F53div=100\\u65F6\\uFF0C\\u4E09\\u90E8\\u5206\\u4E3A\\u522B\\u4E3A972,3,42\\n// \\u82E5\\u5F53\\u524D\\u4F4D\\u5927\\u4E8E1\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~972\\uFF0C\\u4F4E\\u4F4D\\u8303\\u56F4\\u4E3A0~99.\\n// \\u82E5\\u5F53\\u524D\\u4F4D\\u7B49\\u4E8E1\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~971\\u65F6\\uFF0C\\u4F4E\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~99\\uFF0C\\u800C\\u9AD8\\u4F4D\\u4E3A972\\u65F6\\uFF0C\\u4F4E\\u4F4D\\u4EC5\\u80FD\\u53D6\\u81F30~42\\n// \\u82E5\\u5F53\\u524D\\u4E3A\\u7B49\\u4E8E0\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4EC5\\u4E3A0~971\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int ones=0;\\n        \\n        for(long div=1; div<=n; div*=10){\\n            int a = n/div;\\n            int b = a%10;\\n            a /= 10;\\n            int c = n%div;\\n            if(b>1) ones += (a+1)*div;\\n            else if(b==1) ones += a*div + c+1;\\n            else ones += a*div;\\n        }\\n        return ones;\\n    }\\n};\\n// \\u5C06\\u6570\\u5B57\\u5206\\u4E3A\\u9AD8\\u4F4D+\\u5F53\\u524D\\u4F4D+\\u4F4E\\u4F4D\\u4E09\\u90E8\\u5206\\uFF0C\\u5982\\u5BF9972342\\uFF0C\\u5F53div=100\\u65F6\\uFF0C\\u4E09\\u90E8\\u5206\\u4E3A\\u522B\\u4E3A972,3,42\\n// \\u82E5\\u5F53\\u524D\\u4F4D\\u5927\\u4E8E1\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~972\\uFF0C\\u4F4E\\u4F4D\\u8303\\u56F4\\u4E3A0~99.\\n// \\u82E5\\u5F53\\u524D\\u4F4D\\u7B49\\u4E8E1\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~971\\u65F6\\uFF0C\\u4F4E\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4E3A0~99\\uFF0C\\u800C\\u9AD8\\u4F4D\\u4E3A972\\u65F6\\uFF0C\\u4F4E\\u4F4D\\u4EC5\\u80FD\\u53D6\\u81F30~42\\n// \\u82E5\\u5F53\\u524D\\u4E3A\\u7B49\\u4E8E0\\uFF0C\\u8BE5\\u4F4D\\u53D61\\u65F6\\uFF0C\\u9AD8\\u4F4D\\u53D6\\u503C\\u8303\\u56F4\\u4EC5\\u4E3A0~971\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259119,
                "title": "digit-dp-soln-4-ms",
                "content": "class Solution {\\npublic:\\n    string num;\\n    int len;\\n    long long int dp[11][2];\\n    \\n    int pw(int a, int b)\\n    {\\n        int ans = 1;\\n        while(b)\\n        {\\n            ans *= a;\\n            b--;\\n        }\\n        return ans;\\n    }\\n    \\n    long long int solve(int bit, int tight, int n)\\n    {\\n        if(dp[bit][tight] != -1)\\n            return dp[bit][tight];\\n        \\n        if(bit == len)\\n            return dp[bit][tight] = 0;\\n        \\n        int v = num[bit] - \\'0\\';\\n        long long int cans = 0;\\n        if(tight)\\n        {\\n            for(int i = 0; i <= v; i++)\\n            {\\n                int new_tight = 0;\\n                if(i == v)\\n                    new_tight = 1;\\n                cans += solve(bit + 1, new_tight, n);\\n            }\\n            if(v == 1)\\n                cans += n % pw(10, len - 1 - bit) + 1;\\n            else if(v)\\n                cans += pw(10, len - 1 - bit);\\n        }\\n        else\\n        {\\n            for(int i = 0; i <= 9; i++)\\n                cans += solve(bit + 1, 0, n);\\n            cans += pw(10, len - 1 - bit);\\n        }\\n        return dp[bit][tight] = cans;\\n    }\\n    int countDigitOne(int n) {\\n        if(n < 0)\\n            return 0;\\n        num = to_string(n);\\n        len = num.length();\\n        memset(dp, -1, sizeof dp);\\n        return solve(0, 1, n);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string num;\\n    int len;\\n    long long int dp[11][2];\\n    \\n    int pw(int a, int b)\\n    {\\n        int ans = 1;\\n        while(b)\\n        {\\n            ans *= a;\\n            b--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 174770,
                "title": "python3-by",
                "content": "```\\n# \\u6700\\u597D\\u7684\\u65B9\\u6CD5\\n\\n# \\u82E5weight\\u4E3A0\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base\\n# \\u82E5weight\\u4E3A1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base+former+1\\n# \\u82E5weight\\u5927\\u4E8E1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Arount*base+base\\n#\\n# \\u6BD4\\u5982\\uFF1A\\n# 534 = \\uFF08\\u4E2A\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09+\\uFF08\\u5341\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09+\\uFF08\\u767E\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09=\\uFF0853*1+1\\uFF09+\\uFF085*10+10\\uFF09+\\uFF080*100+100\\uFF09= 214\\n# 530 = \\uFF0853*1\\uFF09+\\uFF085*10+10\\uFF09+\\uFF080*100+100\\uFF09 = 213\\n# 504 = \\uFF0850*1+1\\uFF09+\\uFF085*10\\uFF09+\\uFF080*100+100\\uFF09 = 201\\n# 514 = \\uFF0851*1+1\\uFF09+\\uFF085*10+4+1\\uFF09+\\uFF080*100+100\\uFF09 = 207\\n# 10 = (1*1)+(0*10+0+1) = 2\\n\\nclass Solution:\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        if (n<1):\\n            print(0)\\n\\n        count = 0  # \\u7528\\u4E8E\\u7EDF\\u8BA11\\u7684\\u4E2A\\u6570\\n        base = 1    # \\u516C\\u5F0F\\u91CC\\u7684base\\n        round = n   #\\n\\n        while round>0:\\n            weight = round%10\\n            round //= 10\\n            count += round*base\\n            if weight == 1:     # \\u82E5weight\\u4E3A1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base+former+1\\n                count += (n%base)+1\\n            elif weight>1:      # \\u82E5weight\\u5927\\u4E8E1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Arount*base+base\\n                count += base\\n            base *= 10\\n        return (count)\\n```",
                "solutionTags": [],
                "code": "```\\n# \\u6700\\u597D\\u7684\\u65B9\\u6CD5\\n\\n# \\u82E5weight\\u4E3A0\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base\\n# \\u82E5weight\\u4E3A1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base+former+1\\n# \\u82E5weight\\u5927\\u4E8E1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Arount*base+base\\n#\\n# \\u6BD4\\u5982\\uFF1A\\n# 534 = \\uFF08\\u4E2A\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09+\\uFF08\\u5341\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09+\\uFF08\\u767E\\u4F4D1\\u51FA\\u73B0\\u6B21\\u6570\\uFF09=\\uFF0853*1+1\\uFF09+\\uFF085*10+10\\uFF09+\\uFF080*100+100\\uFF09= 214\\n# 530 = \\uFF0853*1\\uFF09+\\uFF085*10+10\\uFF09+\\uFF080*100+100\\uFF09 = 213\\n# 504 = \\uFF0850*1+1\\uFF09+\\uFF085*10\\uFF09+\\uFF080*100+100\\uFF09 = 201\\n# 514 = \\uFF0851*1+1\\uFF09+\\uFF085*10+4+1\\uFF09+\\uFF080*100+100\\uFF09 = 207\\n# 10 = (1*1)+(0*10+0+1) = 2\\n\\nclass Solution:\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        if (n<1):\\n            print(0)\\n\\n        count = 0  # \\u7528\\u4E8E\\u7EDF\\u8BA11\\u7684\\u4E2A\\u6570\\n        base = 1    # \\u516C\\u5F0F\\u91CC\\u7684base\\n        round = n   #\\n\\n        while round>0:\\n            weight = round%10\\n            round //= 10\\n            count += round*base\\n            if weight == 1:     # \\u82E5weight\\u4E3A1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Around*base+former+1\\n                count += (n%base)+1\\n            elif weight>1:      # \\u82E5weight\\u5927\\u4E8E1\\uFF0C\\u52191\\u51FA\\u73B0\\u6B21\\u6570\\u4E3Arount*base+base\\n                count += base\\n            base *= 10\\n        return (count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172076,
                "title": "easy-recursive-solution-c",
                "content": "```\\n// 0 < digit <= 9\\nint countDigit(int n, int digit) {\\n    if (n < digit)\\n        return 0;\\n    else if (n < 10)\\n        return 1;\\n\\n    int scale = 1;\\n    for (int t = n / 10; t > 0; t /= 10)\\n        scale *= 10;\\n\\n    int highestDigit = n / scale;\\n\\n    int res = 0;\\n\\n    // ex) countDigit(2345, 2) -> 2 * countDigit(999, 2)\\n    res += highestDigit * countDigit(scale - 1, digit);\\n\\n    // ex) countDigit(2345, 2) -> countDigit(345, 2)    \\n    res += countDigit(n % scale, digit);\\n\\n    if (highestDigit > digit)\\n        res += scale;           // ex) countDigit(2345, 1) --> 1000\\n    else if (highestDigit == digit)\\n        res += n % scale + 1;   // ex) countDigit(2345, 2) --> 345 + 1\\n\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        return countDigit(n, 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 0 < digit <= 9\\nint countDigit(int n, int digit) {\\n    if (n < digit)\\n        return 0;\\n    else if (n < 10)\\n        return 1;\\n\\n    int scale = 1;\\n    for (int t = n / 10; t > 0; t /= 10)\\n        scale *= 10;\\n\\n    int highestDigit = n / scale;\\n\\n    int res = 0;\\n\\n    // ex) countDigit(2345, 2) -> 2 * countDigit(999, 2)\\n    res += highestDigit * countDigit(scale - 1, digit);\\n\\n    // ex) countDigit(2345, 2) -> countDigit(345, 2)    \\n    res += countDigit(n % scale, digit);\\n\\n    if (highestDigit > digit)\\n        res += scale;           // ex) countDigit(2345, 1) --> 1000\\n    else if (highestDigit == digit)\\n        res += n % scale + 1;   // ex) countDigit(2345, 2) --> 345 + 1\\n\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        return countDigit(n, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143794,
                "title": "python-recursive-solution-4-lines",
                "content": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=0:return 0\\n        if n<=9:return 1\\n        first,remain,k = int(str(n)[0]),int(str(n)[1:]),len(str(n))\\n        return self.countDigitOne(remain)+first*(k-1)*10**(k-2)+min(n-10**(k-1)+1,10**(k-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=0:return 0\\n        if n<=9:return 1\\n        first,remain,k = int(str(n)[0]),int(str(n)[1:]),len(str(n))\\n        return self.countDigitOne(remain)+first*(k-1)*10**(k-2)+min(n-10**(k-1)+1,10**(k-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137355,
                "title": "python-recursion-with-memo-beat-95",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.memo={9:1}\\n    \\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n in self.memo:\\n            return self.memo[n]\\n        if 0<n<9:\\n            return 1\\n        if n<=0:     # why do we even need test case 39/40 (which is n=-1)  ? \\n            return 0\\n        ans=0\\n        tmp=str(n)\\n        dig=int(tmp[0])\\n        new1=int(tmp[1:])\\n        new2=n-new1-1\\n        if dig==1:\\n            ans+=new1+1+self.countDigitOne(new1)+self.countDigitOne(new2)\\n        else:\\n            ans+=self.countDigitOne(new1)+self.countDigitOne(new2)\\n        self.memo[n]=ans\\n        return ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.memo={9:1}\\n    \\n    def countDigitOne(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n in self.memo:\\n            return self.memo[n]\\n        if 0<n<9:\\n            return 1\\n        if n<=0:     # why do we even need test case 39/40 (which is n=-1)  ? \\n            return 0\\n        ans=0\\n        tmp=str(n)\\n        dig=int(tmp[0])\\n        new1=int(tmp[1:])\\n        new2=n-new1-1\\n        if dig==1:\\n            ans+=new1+1+self.countDigitOne(new1)+self.countDigitOne(new2)\\n        else:\\n            ans+=self.countDigitOne(new1)+self.countDigitOne(new2)\\n        self.memo[n]=ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131145,
                "title": "super-easy-understanding-c-dp-with-explanation-in-code",
                "content": "The method below can work for any digit with minimum modification to code.\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res = 0;\\n        int M = 1, ones_in_max = 0;\\n        int N = n;\\n        \\n        // in each iteration, we are calcuating number of digit 1 s from 0 ~ (n % 10M)\\n        // #[0, K] = number of digit 1 from 0 to K\\n        while (N > 0) {\\n            // get the current digit\\n            int d = N % 10;\\n            \\n            // suppose we\\'re currently dealing with dxyz, where res = #[0, xyz]\\n            \\n            // if d == 0, then the #1s from 0 ~ dxyz is the same as #1s from 0 ~ xyz\\n            if (d > 0) {\\n                \\n                // add the contribution of current digit\\n                // if d == 1, #[d000, dxyz] = xyz + 1 + #[0, xyz]\\n                if (d == 1)\\n                    res += (n % M) + 1;\\n                \\n                // if d != 1, [1000, 1999] is in range [0, dxyz]\\n                else    \\n                    res += M;\\n                \\n                // remaining 1 s in digit lower than current digit\\n                // ones_in_max = #[0, 999]\\n                res += d * ones_in_max;\\n            }\\n            \\n            // update ones_in_max to denote #[0, 9999]\\n            ones_in_max = 10 * ones_in_max + M;\\n            M *= 10;\\n            N /= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int res = 0;\\n        int M = 1, ones_in_max = 0;\\n        int N = n;\\n        \\n        // in each iteration, we are calcuating number of digit 1 s from 0 ~ (n % 10M)\\n        // #[0, K] = number of digit 1 from 0 to K\\n        while (N > 0) {\\n            // get the current digit\\n            int d = N % 10;\\n            \\n            // suppose we\\'re currently dealing with dxyz, where res = #[0, xyz]\\n            \\n            // if d == 0, then the #1s from 0 ~ dxyz is the same as #1s from 0 ~ xyz\\n            if (d > 0) {\\n                \\n                // add the contribution of current digit\\n                // if d == 1, #[d000, dxyz] = xyz + 1 + #[0, xyz]\\n                if (d == 1)\\n                    res += (n % M) + 1;\\n                \\n                // if d != 1, [1000, 1999] is in range [0, dxyz]\\n                else    \\n                    res += M;\\n                \\n                // remaining 1 s in digit lower than current digit\\n                // ones_in_max = #[0, 999]\\n                res += d * ones_in_max;\\n            }\\n            \\n            // update ones_in_max to denote #[0, 9999]\\n            ones_in_max = 10 * ones_in_max + M;\\n            M *= 10;\\n            N /= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64380,
                "title": "java-solution-with-explanation-and-example",
                "content": "Explanation:\\n\\n* Every 10(i.e. div) numbers coutribute 1(i.e. contr) digit1;\\n* Every 100(i.e. div) numbers coutribute 10(i.e. contr) extra;\\n* Every 1000(i.e. div) numbers coutribute 100(i.e. contr) extra;\\netc.\\n\\nFor example: n = 31500\\n\\n\\n1. contr=1, div=10, count how many 10 numbers, n/div=3150, contribute 3150\\\\*1 digit1, left=n-n/10\\\\*10=0, contribute 0;\\n\\n2. contr=10,div=100, count how many 100 numbers, n/100=315, contribute 315\\\\*10 digit1, left=n-n/100\\\\*100=0, contribute 0;\\n3. contr=100,div=1000, count how many 1000 numbers, n/1000=31, contribute 31\\\\*100 digit1, left=n-n/1000\\\\*1000=500, 500 includes (100-199), therefore the left 500 also constribute 100 digit1;\\n4. contr=1000,div=10000, count how many 10000 numbers, n/10000=3, contribute 3\\\\*1000 digit1, left=n-n/10000\\\\*10000=1500, 1500 only includes part of (1000-1999), it constributes 501 digit1;\\n5. contr=10000,div=100000, count how many 100000 numbers, n/10000=0, contribute 0\\\\*1000 digit1, left=n-n/100000\\\\*100000=31500, 31500 includes (10000-19999), it constributes 10000 digit1;\\n6. Done.\\n```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if(n<1) return 0;\\n        long contr=1,res=0;\\n        while(n>=contr){\\n            long div=contr*10,left=n-n/div*div;\\n            res+=n/div*contr+(left>=2*contr?contr:(left>=contr?left%contr+1:0));\\n            contr=div;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countDigitOne(int n) {\\n        if(n<1) return 0;\\n        long contr=1,res=0;\\n        while(n>=contr){\\n            long div=contr*10,left=n-n/div*div;\\n            res+=n/div*contr+(left>=2*contr?contr:(left>=contr?left%contr+1:0));\\n            contr=div;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64394,
                "title": "java-very-short-recursive-solution",
                "content": "```\\n    public int countDigitOne(int n) { \\n        if (n<=0) return 0;\\n        int multiplier = 1;\\n        while (multiplier <= n/10) multiplier *= 10;\\n        if (multiplier == 1) return 1;\\n        int mod = n%multiplier;\\n        int div = n/multiplier;\\n        int add = div == 1 ? mod + 1 : multiplier;\\n        return add + div*countDigitOne(multiplier-1) + countDigitOne(mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countDigitOne(int n) { \\n        if (n<=0) return 0;\\n        int multiplier = 1;\\n        while (multiplier <= n/10) multiplier *= 10;\\n        if (multiplier == 1) return 1;\\n        int mod = n%multiplier;\\n        int div = n/multiplier;\\n        int add = div == 1 ? mod + 1 : multiplier;\\n        return add + div*countDigitOne(multiplier-1) + countDigitOne(mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64395,
                "title": "c-non-recursive-solution-digit-wise-count",
                "content": "In each iteration, we only count how many `1's` would appear at this digit.\\n\\n*40 / 40 test cases passed*\\n*Status: Accepted*\\n*Runtime: 0 ms*\\n```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int r, q = n, sum = 0;\\n        for (uint k = 1; q > 0; k *= 10) {\\n            r = q % 10;\\n            q /= 10;\\n            sum += q * k;\\n            if (r > 1) sum += k;\\n            else if (r == 1) sum += n % k + 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigitOne(int n) {\\n        int r, q = n, sum = 0;\\n        for (uint k = 1; q > 0; k *= 10) {\\n            r = q % 10;\\n            q /= 10;\\n            sum += q * k;\\n            if (r > 1) sum += k;\\n            else if (r == 1) sum += n % k + 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64402,
                "title": "java-solution-with-both-iterative-and-recursive-approach",
                "content": "This is a very classic problem and it took me almost forever to understand the solution. There are more concise solution in this board but it was bit hard for me to understand them. IMO recursive approach is easier to understand and then it can be easily converted to iterative for better efficiency. \\n\\nFor all those who on the same boat you may consider understanding the recursive approach then it will become easier to relate to the iterative approach\\n\\nRecursive: \\n```\\npublic int count_recursive(int num) {\\n\\t\\t// base case\\n\\t\\tif (num <= 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint constant = 0, position = 1, val = num;\\n\\n\\t\\twhile (val >= 10) {\\n\\t\\t\\tposition = position * 10;\\n\\t\\t\\tval = val / 10;\\n\\t\\t}\\n\\n\\t\\tif (val == 1) {\\n\\t\\t\\tconstant = num % position + 1;\\n\\t\\t}\\n\\n\\t\\telse if (val > 1) {\\n\\t\\t\\tconstant = position;\\n\\t\\t}\\n\\n\\t\\t// this is same as for input 254\\n\\t\\t// step 1 = 100 + 2(99) + (54)\\n\\t\\t// step 2 = 100 + 2( 10 + 9(9) + (9)) + (10 + 5(9) + (4))\\n\\t\\t// final step = 100 + 2( 10 + 9*1 + 1) + (10 + 5*1 + 1) since for number <= 9 will return 1\\n\\t\\t// result = 100 + 2 (20) + 16 = 156 ans\\n\\t\\treturn constant + val * (count_recursive(position - 1)) + count_recursive(num % position);\\n\\t}\\n```\\n\\nConverting the same approach to iterative \\n\\n```\\n        /**\\n\\t * Performs two actions \\n\\t * 1. computes occurrence in the lower digits \\n\\t * 2. computes occurrence for the current digit\\n\\t * \\t\\t2a. if current digit == 1 then add seen so far // consider a small example like 234 and try it on a paper\\n\\t * \\t\\t2b. if current digit > 1 then add the full cycle i.e. if current digit power is 10^2 then add 10^2\\n\\t * e.g. if  input is 2346 and is current digit is 3 then \\n\\t * position = 2 which represents there are two lower digits \\n\\t * possition10PowerMinusOne = 10 which represents each lower digits contributes to 10\\n\\t */\\n\\tpublic int count_iterative(int num) {\\n\\t\\tint seenNumbers = 0, count = 0, position = 0, position10Pow = 1;\\n\\n\\t\\twhile (num > 0) {\\n\\t\\t\\tint lastDigit = num % 10;\\n\\t\\t\\t\\n\\t\\t\\t// used to know the power of lower digits\\n\\t\\t\\tint position10PowMinusOne = position10Pow / 10;\\n\\t\\t\\t\\n\\t\\t\\t// if  input is 2346 and is current digit is 3 then \\n\\t\\t\\t// position = 2 which represents there are two lower digits \\n\\t\\t\\t// possition10PowerMinusOne = 10 which represents each lower digits contributes to 10\\n\\t\\t\\tcount += lastDigit * position * position10PowMinusOne;\\n\\n\\t\\t\\tif (lastDigit == 1) {\\n\\t\\t\\t\\tcount += seenNumbers + 1;\\n\\t\\t\\t} \\n\\t\\t\\telse if (lastDigit > 1) {\\n\\t\\t\\t\\tcount += position10Pow;\\n\\t\\t\\t}\\n\\n\\t\\t\\tseenNumbers = seenNumbers + (lastDigit * position10Pow);\\n\\t\\t\\tposition++;\\n\\t\\t\\tposition10Pow *= 10;\\n\\t\\t\\tnum /= 10;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int count_recursive(int num) {\\n\\t\\t// base case\\n\\t\\tif (num <= 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint constant = 0, position = 1, val = num;\\n\\n\\t\\twhile (val >= 10) {\\n\\t\\t\\tposition = position * 10;\\n\\t\\t\\tval = val / 10;\\n\\t\\t}\\n\\n\\t\\tif (val == 1) {\\n\\t\\t\\tconstant = num % position + 1;\\n\\t\\t}\\n\\n\\t\\telse if (val > 1) {\\n\\t\\t\\tconstant = position;\\n\\t\\t}\\n\\n\\t\\t// this is same as for input 254\\n\\t\\t// step 1 = 100 + 2(99) + (54)\\n\\t\\t// step 2 = 100 + 2( 10 + 9(9) + (9)) + (10 + 5(9) + (4))\\n\\t\\t// final step = 100 + 2( 10 + 9*1 + 1) + (10 + 5*1 + 1) since for number <= 9 will return 1\\n\\t\\t// result = 100 + 2 (20) + 16 = 156 ans\\n\\t\\treturn constant + val * (count_recursive(position - 1)) + count_recursive(num % position);\\n\\t}\\n```\n```\\n        /**\\n\\t * Performs two actions \\n\\t * 1. computes occurrence in the lower digits \\n\\t * 2. computes occurrence for the current digit\\n\\t * \\t\\t2a. if current digit == 1 then add seen so far // consider a small example like 234 and try it on a paper\\n\\t * \\t\\t2b. if current digit > 1 then add the full cycle i.e. if current digit power is 10^2 then add 10^2\\n\\t * e.g. if  input is 2346 and is current digit is 3 then \\n\\t * position = 2 which represents there are two lower digits \\n\\t * possition10PowerMinusOne = 10 which represents each lower digits contributes to 10\\n\\t */\\n\\tpublic int count_iterative(int num) {\\n\\t\\tint seenNumbers = 0, count = 0, position = 0, position10Pow = 1;\\n\\n\\t\\twhile (num > 0) {\\n\\t\\t\\tint lastDigit = num % 10;\\n\\t\\t\\t\\n\\t\\t\\t// used to know the power of lower digits\\n\\t\\t\\tint position10PowMinusOne = position10Pow / 10;\\n\\t\\t\\t\\n\\t\\t\\t// if  input is 2346 and is current digit is 3 then \\n\\t\\t\\t// position = 2 which represents there are two lower digits \\n\\t\\t\\t// possition10PowerMinusOne = 10 which represents each lower digits contributes to 10\\n\\t\\t\\tcount += lastDigit * position * position10PowMinusOne;\\n\\n\\t\\t\\tif (lastDigit == 1) {\\n\\t\\t\\t\\tcount += seenNumbers + 1;\\n\\t\\t\\t} \\n\\t\\t\\telse if (lastDigit > 1) {\\n\\t\\t\\t\\tcount += position10Pow;\\n\\t\\t\\t}\\n\\n\\t\\t\\tseenNumbers = seenNumbers + (lastDigit * position10Pow);\\n\\t\\t\\tposition++;\\n\\t\\t\\tposition10Pow *= 10;\\n\\t\\t\\tnum /= 10;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64414,
                "title": "0ms-simple-cpp-code-easy-to-extend-from-1-to-any-other-digits",
                "content": "    class Solution {\\n    public:\\n        \\n        int countDigitOne(int n) {\\n            \\n            int a=n;\\n            int ct=0;\\n            int m=1;\\n            \\n            while(a>=1){\\n                if (a%10<1){ct+=(a/10)*m;}\\n                else if (a%10>1){ct+=(a/10+1)*m;}\\n                else {ct+=(a/10)*m+(n-a*m+1);}\\n                a/=10;\\n                m*=10;\\n            }\\n            \\n            return ct;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        \\n        int countDigitOne(int n) {\\n            \\n            int a=n;\\n            int ct=0;\\n            int m=1;\\n            \\n            while(a>=1){\\n                if (a%10<1){ct+=(a/10)*m;}",
                "codeTag": "Java"
            },
            {
                "id": 64425,
                "title": "my-java-solution-with-explation",
                "content": "     /**\\n     *\\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u5206\\u522b\\u5904\\u7406\\uff0c\\n     * 120\\n     * 120/ 10 = 12 \\u6ca1\\u6709\\u4f59\\u6570 \\uff0c\\u4e0d\\u5904\\u7406\\n     * 120/100 = 1 .... 20   \\u5341\\u4f4d 1 \\u7684\\u4e2a\\u6570\\u4e3a 1* 10 + 10(\\u56e0\\u4e3a 20> 19,\\u5982\\u679c 20 <= 19 \\u4f8b\\u5982 17 \\u3002\\u5219\\u9700\\u8981\\u52a0\\u4e0a 17%10 + 1 \\u5373 8)\\n     * 120/1000 = 0 .... 120  \\u767e\\u4f4d\\u76841\\u7684\\u4e2a\\u6570\\u4e3a 120 % 100 +1 = 21\\n     * \\u56e0\\u6b64\\u603b\\u4e2a\\u6570\\u4e3a  12 + 20 + 21 = 53\\n     * \\n     * calculate every digit\\n     * e.g.\\n     * 120\\n     * single digit :120/10=12  no rest\\n     * \\n     * ten digit : 120/100 = 1 ....20   ten digit counts 1* 10 + 10(because 20 / 10 = 2 witch is bigger than 1; if it is 17,than ten digit should be 1*10 + 17%10 +1 = 18)\\n     * \\n     * hundreds digit : 120/1000 = 0 .... 120       0*100 + 120%100+1 = 21\\n     * \\n     * so the result is 12 +20 + 21;\\n     * \\n     * when compairing the nums it might be bigger then Integer.MAX_VALUE,so here I use 'long';\\n     */\\n    public int countDigitOne(int n) {\\n        long nPlus = n;\\n        int count = 0;\\n        long x = 10;\\n        while(nPlus * 10 >= x){\\n            count += calcHelper(nPlus,x);\\n            x*=10;\\n        }\\n        return count;\\n    }\\n    public long calcHelper(long n,long x){\\n        long high = n/x * x/10;\\n        long mod =  n%x;\\n        if(mod / (x /10) < 1 ){\\n            return high;\\n        }\\n        if(mod / (x /10) > 1){\\n            return high + x/10;\\n        }\\n        return high + mod % (x/10) +1;\\n    }",
                "solutionTags": [],
                "code": "     /**\\n     *\\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u5206\\u522b\\u5904\\u7406\\uff0c\\n     * 120\\n     * 120/ 10 = 12 \\u6ca1\\u6709\\u4f59\\u6570 \\uff0c\\u4e0d\\u5904\\u7406\\n     * 120/100 = 1 .... 20   \\u5341\\u4f4d 1 \\u7684\\u4e2a\\u6570\\u4e3a 1* 10 + 10(\\u56e0\\u4e3a 20> 19,\\u5982\\u679c 20 <= 19 \\u4f8b\\u5982 17 \\u3002\\u5219\\u9700\\u8981\\u52a0\\u4e0a 17%10 + 1 \\u5373 8)\\n     * 120/1000 = 0 .... 120  \\u767e\\u4f4d\\u76841\\u7684\\u4e2a\\u6570\\u4e3a 120 % 100 +1 = 21\\n     * \\u56e0\\u6b64\\u603b\\u4e2a\\u6570\\u4e3a  12 + 20 + 21 = 53\\n     * \\n     * calculate every digit\\n     * e.g.\\n     * 120\\n     * single digit :120/10=12  no rest\\n     * \\n     * ten digit : 120/100 = 1 ....20   ten digit counts 1* 10 + 10(because 20 / 10 = 2 witch is bigger than 1; if it is 17,than ten digit should be 1*10 + 17%10 +1 = 18)\\n     * \\n     * hundreds digit : 120/1000 = 0 .... 120       0*100 + 120%100+1 = 21\\n     * \\n     * so the result is 12 +20 + 21;\\n     * \\n     * when compairing the nums it might be bigger then Integer.MAX_VALUE,so here I use 'long';\\n     */\\n    public int countDigitOne(int n) {\\n        long nPlus = n;\\n        int count = 0;\\n        long x = 10;\\n        while(nPlus * 10 >= x){\\n            count += calcHelper(nPlus,x);\\n            x*=10;\\n        }\\n        return count;\\n    }\\n    public long calcHelper(long n,long x){\\n        long high = n/x * x/10;\\n        long mod =  n%x;\\n        if(mod / (x /10) < 1 ){\\n            return high;\\n        }\\n        if(mod / (x /10) > 1){\\n            return high + x/10;\\n        }\\n        return high + mod % (x/10) +1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64412,
                "title": "share-my-c-solution-with-explanation-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            if (n <= 0)\\n                return 0;\\n            \\n            long long int total = 0;\\n            int high = n, low = 0, cur = 0;\\n            int number = 1, k = 1;\\n            \\n            while (high > 0)\\n            {\\n                cur = high % 10;\\n                high /= 10;\\n                \\n                if (cur == 0)\\n                    total += high * number;\\n                else if (cur == 1)\\n                    total += ( high * number + (low + 1) );\\n                else\\n                    total += (high + 1) * number;\\n                    \\n                number *= 10;\\n                low += cur * k;\\n                k *= 10;\\n            }\\n            \\n            return total;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            if (n <= 0)\\n                return 0;\\n            \\n            long long int total = 0;\\n            int high = n, low = 0, cur = 0;\\n            int number = 1, k = 1;\\n            \\n            while (high > 0)\\n            {\\n                cur = high % 10;\\n                high /= 10;\\n                \\n                if (cur == 0)\\n                    total += high * number;\\n                else if (cur == 1)\\n                    total += ( high * number + (low + 1) );\\n                else\\n                    total += (high + 1) * number;\\n                    \\n                number *= 10;\\n                low += cur * k;\\n                k *= 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64431,
                "title": "a-concise-solution-accepted-as-best-submission-in-c-well-explained",
                "content": "As long as we have learned permutation and combination in mathematics, we will not try to use brute-force method to hack this one. Before we move any further, tell me how many ones in 9? the answer is 1; there will be 0, 1, 2, 3, ..., 9;  in two-digits number 10, 11, ..., 99: for 1 there will be 10, 21, ..., 91 and the number of 1 will be 9; so there will be a simple conclusion:\\n\\n - if n = 10, result will be 1 + 1(the second 1 is for the first digit);\\n - if n = 100, result will be 10 + 1(the second 1 is for the first digit);\\n - if n = 1000, result will be 100 + 1(the second 1 is for the first digit);\\n\\nSimply, if n = 200, result will be 2*10 + 1(the second is for the first digit); if n = 300, result will be 3*10+1; if n = 400, result will be 4*10+1; ... , if n = 1000, result will be 10*10+1;\\n\\n - then how about n = 230? take it apart to 200+30, 200 -> 2*10+1(the second 1 is for the first digit), 30->3*1+1(the second 1 is for the first digit);\\n\\nNow we've found the secret to dramatically reduce the time cost, traversing each digit instead of from 1 to n which will decrease the time complexity from O(n) to O(logn).\\n\\nEquation for each unit will be (m is the unit: 1, 10, 100, 1000...) (n/m+8)/10*m+(n/m%10==1)*(n%m+1); Very complicated! Yuck! But let's try to take a closer look at this and have an example here to make it easy for you, suppose we have a number 1302193:\\n\\n - if m==100, then n/m will be 13021, n%m will be 93; before the fixing hundred-1, there is 1302 which means when we are fixing 1 to hundred position there will be 0, 1, ..., 1301 can be selected before 1 and meantime the part after can be selected from 0, 1, 2, ..., 99 (100 choices can be used); why there is no 1302? we are considering unit 100 -> when hundred-1 fixed, the part after it is not enough for the unit 100 it's only 94 (from 0 to 93) which we will collect also; so the result for hundred-1 will be 1302*100+94;\\n - if m==1000, then n/m will be 1302, n%m will be 193; before thousand-2, there is 130 and according combination rules, there will (130+1)*100 times occurrences of 1; why 130+1? 2 in thousand position, so fixing thousand 1 in thousand position and before thousand there can be 0-130 choices while after thousand there will be 0-999 -> just a unit 1000; clear? but the left 193 will be ignored unlike the previous situation while the thousand position has 2 instead of 1; so the final result for this unit is 131*1000;\\n - if m==10000, then n/m will be 13, n%m will be 2193; quite similar, but since ten-thousand position has 0 instead of 2 or bigger digit, so there will be 0-12 choices only before ten-thousand instead of 0-13(unlike the previous example when m==1000 it's 0-130) and since it's not 1 so, the left part 2193 is also useless; so the final result for this unit is 13*10000;\\n\\nAt last, we reached each unit until n and sum them up, return it.\\n\\nBang. End of story!\\n\\n - Space cost O(1)\\n - Time cost O(logn)\\n\\n\\n----------\\n\\n    int countDigitOne(int n)\\n    {\\n        if(n < 10) return 0;\\n        long long count = 0;\\n        for(long long m = 1; m <= n; m *= 10)\\n        {\\n            int a = n/m;\\n            int b = n%m;\\n            count += (a+8)/10*m+(a%10==1)*(b+1); //0, 1 and >=2 should be treated differently when we are counting for each unit;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "As long as we have learned permutation and combination in mathematics, we will not try to use brute-force method to hack this one. Before we move any further, tell me how many ones in 9? the answer is 1; there will be 0, 1, 2, 3, ..., 9;  in two-digits number 10, 11, ..., 99: for 1 there will be 10, 21, ..., 91 and the number of 1 will be 9; so there will be a simple conclusion:\\n\\n - if n = 10, result will be 1 + 1(the second 1 is for the first digit);\\n - if n = 100, result will be 10 + 1(the second 1 is for the first digit);\\n - if n = 1000, result will be 100 + 1(the second 1 is for the first digit);\\n\\nSimply, if n = 200, result will be 2*10 + 1(the second is for the first digit); if n = 300, result will be 3*10+1; if n = 400, result will be 4*10+1; ... , if n = 1000, result will be 10*10+1;\\n\\n - then how about n = 230? take it apart to 200+30, 200 -> 2*10+1(the second 1 is for the first digit), 30->3*1+1(the second 1 is for the first digit);\\n\\nNow we've found the secret to dramatically reduce the time cost, traversing each digit instead of from 1 to n which will decrease the time complexity from O(n) to O(logn).\\n\\nEquation for each unit will be (m is the unit: 1, 10, 100, 1000...) (n/m+8)/10*m+(n/m%10==1)*(n%m+1); Very complicated! Yuck! But let's try to take a closer look at this and have an example here to make it easy for you, suppose we have a number 1302193:\\n\\n - if m==100, then n/m will be 13021, n%m will be 93; before the fixing hundred-1, there is 1302 which means when we are fixing 1 to hundred position there will be 0, 1, ..., 1301 can be selected before 1 and meantime the part after can be selected from 0, 1, 2, ..., 99 (100 choices can be used); why there is no 1302? we are considering unit 100 -> when hundred-1 fixed, the part after it is not enough for the unit 100 it's only 94 (from 0 to 93) which we will collect also; so the result for hundred-1 will be 1302*100+94;\\n - if m==1000, then n/m will be 1302, n%m will be 193; before thousand-2, there is 130 and according combination rules, there will (130+1)*100 times occurrences of 1; why 130+1? 2 in thousand position, so fixing thousand 1 in thousand position and before thousand there can be 0-130 choices while after thousand there will be 0-999 -> just a unit 1000; clear? but the left 193 will be ignored unlike the previous situation while the thousand position has 2 instead of 1; so the final result for this unit is 131*1000;\\n - if m==10000, then n/m will be 13, n%m will be 2193; quite similar, but since ten-thousand position has 0 instead of 2 or bigger digit, so there will be 0-12 choices only before ten-thousand instead of 0-13(unlike the previous example when m==1000 it's 0-130) and since it's not 1 so, the left part 2193 is also useless; so the final result for this unit is 13*10000;\\n\\nAt last, we reached each unit until n and sum them up, return it.\\n\\nBang. End of story!\\n\\n - Space cost O(1)\\n - Time cost O(logn)\\n\\n\\n----------\\n\\n    int countDigitOne(int n)\\n    {\\n        if(n < 10) return 0;\\n        long long count = 0;\\n        for(long long m = 1; m <= n; m *= 10)\\n        {\\n            int a = n/m;\\n            int b = n%m;\\n            count += (a+8)/10*m+(a%10==1)*(b+1); //0, 1 and >=2 should be treated differently when we are counting for each unit;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64422,
                "title": "share-my-0ms-java-code",
                "content": "    public class Solution {\\n        public int countDigitOne(int n) {\\n            if (n <= 0) {\\n                return 0;\\n            }\\n            int count = 0;\\n            int copyN = n;\\n            for (int weight = 1; n > 0; weight *= 10) {\\n                int complete = n / 10;\\n                int lsb = n % 10;\\n                if (lsb < 1) {\\n                    count += weight * complete;\\n                } else if (lsb > 1) {\\n                    count += weight * (complete + 1);\\n                } else {  // lsb == 1\\n                    count += weight * complete + copyN % weight + 1;\\n                }\\n                n = complete;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int countDigitOne(int n) {\\n            if (n <= 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64435,
                "title": "yet-another-java-0-ms-recursive-solution",
                "content": "After browsing quickly through the posted recursive solutions, I haven't found anything similar, so here you go. It's not as elegant as the iterative solutions, and is probably less efficient, but may still be useful to get deeper insight into the problem.\\n\\nThe idea is pretty simple. Split the number in two parts: the last digit `d0` and the rest (`higher`). For example, 1234 is split into 123 and 4. Next, count how many times the digit `1` appears in the higher part. This moment is my least favorite in this solution because it feels like an unnecessary loop, but I can't seem to figure how to get rid of it.\\n\\nNow how many times is this higher part repeated when we decrement? Exactly `d0 + 1` times. For 1234 it's 1234, 1233, 1232, 1231, 1230\\u20145 times. But one of these has one more `1`. This happens only if `d0 >= 1`, though. Next we decrement `high` to continue the decreasing sequence. This decreasing sequence has the higher part decrementing one-by-one, but only after each tenth value (as the lower digit goes down from 9 to 0). So we recursively calculate the number of ones in that sequence and multiply the answer by 10 to reflect the repetition.\\n\\nOne last addition is `high + 1`. It reflects the fact that during that decreasing sequence another digit `1` pops up at each 10th value. The `+1` is needed because this `1` pops up even when the higher part becomes zero, so for our example it happens for 1221, 1211, 1201, ... 1, that is, 123 times. Could have done this instead:\\n\\n    count += high;\\n    --high;\\n    count += countDigitOne(high) * 10;\\n    return count;\\n\\nHere is the full code:\\n\\n    public int countDigitOne(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        int high = n / 10;\\n        int one = countOne(high);\\n        int d0 = n % 10;\\n        int count = (d0 + 1) * one;\\n        if (d0 >= 1) {\\n            ++count;\\n        }\\n        --high;\\n        return count + countDigitOne(high) * 10 + high + 1;\\n    }\\n    \\n    private static int countOne(int n) {\\n        int count = 0;\\n        for (int i = n; i > 0; i /= 10) {\\n            if ((i % 10) == 1) {\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "After browsing quickly through the posted recursive solutions, I haven't found anything similar, so here you go. It's not as elegant as the iterative solutions, and is probably less efficient, but may still be useful to get deeper insight into the problem.\\n\\nThe idea is pretty simple. Split the number in two parts: the last digit `d0` and the rest (`higher`). For example, 1234 is split into 123 and 4. Next, count how many times the digit `1` appears in the higher part. This moment is my least favorite in this solution because it feels like an unnecessary loop, but I can't seem to figure how to get rid of it.\\n\\nNow how many times is this higher part repeated when we decrement? Exactly `d0 + 1` times. For 1234 it's 1234, 1233, 1232, 1231, 1230\\u20145 times. But one of these has one more `1`. This happens only if `d0 >= 1`, though. Next we decrement `high` to continue the decreasing sequence. This decreasing sequence has the higher part decrementing one-by-one, but only after each tenth value (as the lower digit goes down from 9 to 0). So we recursively calculate the number of ones in that sequence and multiply the answer by 10 to reflect the repetition.\\n\\nOne last addition is `high + 1`. It reflects the fact that during that decreasing sequence another digit `1` pops up at each 10th value. The `+1` is needed because this `1` pops up even when the higher part becomes zero, so for our example it happens for 1221, 1211, 1201, ... 1, that is, 123 times. Could have done this instead:\\n\\n    count += high;\\n    --high;\\n    count += countDigitOne(high) * 10;\\n    return count;\\n\\nHere is the full code:\\n\\n    public int countDigitOne(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        int high = n / 10;\\n        int one = countOne(high);\\n        int d0 = n % 10;\\n        int count = (d0 + 1) * one;\\n        if (d0 >= 1) {\\n            ++count;\\n        }\\n        --high;\\n        return count + countDigitOne(high) * 10 + high + 1;\\n    }\\n    \\n    private static int countOne(int n) {\\n        int count = 0;\\n        for (int i = n; i > 0; i /= 10) {\\n            if ((i % 10) == 1) {\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64427,
                "title": "o-logn-c-solution-for-number-of-digit-x-0-x-9-w-detail-explanations",
                "content": "The key to extend the \"Digit 1\" problem to \"Digit X\" problem is to consider the \"Digit 0\" problem carefully.\\n\\n1. The digit \"0\" can not appear in the beginning of a sequence\\n\\n2. The non-negative integer \"0\" shall be counted. (And when we consider the base = {1, 10, 100, ...}, no base inside is suitable for the digit \"0\".\\n\\nSolution:\\n\\n1. Consider the special case where k == 0 and n is a one digit integer (including zero). In this case, the function shall return 1.\\n\\n2. When counting for multi-digit integer: The first iteration (base == 1) is different from others since we need to consider \"0\"; The last iteration (base * 10 > n) is different from others since we shall not count the leading zeros.\\n\\n\\n.\\n\\n\\n\\n    class Solution {\\n    public:\\n    \\tint digitCounts(int k, int n) {\\n    \\t\\t// special case for k==0 && n<10 -> shall return 1\\n    \\t\\tif ((k == 0) && (n < 10)) {\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\n    \\t\\tint res = 0;\\n    \\t\\tfor (int base = 1; base <= n; base *= 10) {\\n    \\t\\t\\tint quotientient = n / base;\\n    \\t\\t\\tint remainder = n % base;\\n    \\n    \\t\\t\\t// part 1\\n    \\t\\t\\tint part1 = quotient / 10;\\n    \\t\\t\\tif ((k == 0) && (base > 1) && (part1 > 0)) {\\n                // remedy for k == 0: if base == 1, the digit can be zero\\n                //                    if base  > 1, the digit can not be zero. Delete those zeros.\\n    \\t\\t\\t\\t--part1;\\n    \\t\\t\\t}\\n    \\t\\t\\tpart1 *= base;\\n    \\n    \\t\\t\\t// part 2\\n    \\t\\t\\tint bar = quotient % 10;\\n    \\t\\t\\tint part2 = 0;\\n    \\t\\t\\tif (bar > k) {\\n    \\t\\t\\t\\tpart2 = base;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if (bar == k) {\\n    \\t\\t\\t\\tpart2 = remainder + 1;\\n    \\t\\t\\t}\\n    \\t\\t\\t\\t\\n    \\t\\t\\tif ((k == 0) && (n < base * 10)) {\\n                // remedy for k == 0 and it's the last iteration\\n    \\t\\t\\t\\tpart2 = 0; // delete extra leading zeros\\n    \\t\\t\\t}\\n    \\t\\t\\tres += part1 + part2;\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    };\\n\\n\\nTest Cases:\\n\\nk: 0 1 2 3 4 5 6 7 8 9\\n\\n0: 1 0 0 0 0 0 0 0 0 0\\n\\n1: 1 1 0 0 0 0 0 0 0 0\\n\\n2: 1 1 1 0 0 0 0 0 0 0\\n\\n5: 1 1 1 1 1 1 0 0 0 0\\n\\n6: 1 1 1 1 1 1 1 0 0 0\\n\\n8: 1 1 1 1 1 1 1 1 1 0\\n\\n9: 1 1 1 1 1 1 1 1 1 1\\n\\n10: 2 2 1 1 1 1 1 1 1 1\\n\\n11: 2 4 1 1 1 1 1 1 1 1\\n\\n12: 2 5 2 1 1 1 1 1 1 1\\n\\n49: 5 15 15 15 15 5 5 5 5 5\\n\\n50: 6 15 15 15 15 6 5 5 5 5\\n\\n51: 6 16 15 15 15 7 5 5 5 5\\n\\n98: 10 20 20 20 20 20 20 20 20 18\\n\\n99: 10 20 20 20 20 20 20 20 20 20\\n\\n100: 12 21 20 20 20 20 20 20 20 20\\n\\n101: 13 23 20 20 20 20 20 20 20 20\\n\\n5000: 1393 2500 2500 2500 2500 1501 1500 1500 1500 1500\\n\\n20000: 6894 18000 8001 8000 8000 8000 8000 8000 8000 8000",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint digitCounts(int k, int n) {\\n    \\t\\t// special case for k==0 && n<10 -> shall return 1\\n    \\t\\tif ((k == 0) && (n < 10)) {\\n    \\t\\t\\treturn 1;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 64447,
                "title": "my-52ms-c-recursion",
                "content": "public class Solution {\\n    public int CountDigitOne(int n) {\\n\\n     if(n<1)\\n     return 0;\\n     \\n     int res=0;\\n     char[] cha = n.ToString ().ToCharArray ();\\n\\t Array.Reverse (cha);\\n    \\n     if((n+1)%(int)Math.Pow(10,cha.Length)==0&&(n+1)/(int)Math.Pow(10,cha.Length)==1){\\n          return 10*CountDigitOne((int)Math.Pow(10,cha.Length-1)-1)+(int)Math.Pow(10,cha.Length-1);\\n     }\\n     \\n     for(int i=0;i<cha.Length;i++){\\n         if((int)cha[i]==48)\\n         res+=0;\\n\\n         else\\n     res+=((int)cha[i]-48)*CountDigitOne((int)Math.Pow(10,i)-1)+((int)cha[i]==49?n%(int)Math.Pow(10,i)+1:(int)Math.Pow(10,i));\\n     }\\n     return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int CountDigitOne(int n) {\\n\\n     if(n<1)\\n     return 0;\\n     \\n     int res=0;\\n     char[] cha = n.ToString ().ToCharArray ();\\n\\t Array.Reverse (cha);\\n    \\n     if((n+1)%(int)Math.Pow(10,cha.Length)==0&&(n+1)/(int)Math.Pow(10,cha.Length)==1){\\n          return 10*CountDigitOne((int)Math.Pow(10,cha.Length-1)-1)+(int)Math.Pow(10,cha.Length-1);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 64457,
                "title": "iteration-java-solution",
                "content": "public class Solution {\\n\\n    public int countDigitOne(int n) {\\n        if(n<=0) return 0;\\n        int preRound = 0, preAll = 0; //for example 42345, preround is 2345's num of 1 digits, preall is 9999's num of 1 digits.\\n        int multiplier = 1, preNums = 1, pre = 1; // preNums is 10000, pre is 2345+1.\\n        while(n>0){\\n            int curr = n%10;\\n            if(curr>1) preRound = curr*preAll + preRound + preNums;\\n            else if(curr==1) preRound = curr*preAll + preRound + pre;\\n            preAll = 10*preAll + preNums;\\n            preNums *= 10;\\n            pre += curr*multiplier;\\n            multiplier *= 10;\\n            n /=10;\\n        }\\n        return preRound;\\n    }\\n}\\n\\n//curr*preAll is using 0 to curr-1 as most significant digit(MSD) to count\\n\\n//preRound is using curr as MSD to count\\n\\n//preNums is when curr>1, using 1 as MSD will add preNums 1.\\n\\n//pre is when curr=1, using 1 as MSD could only add pre 1(the number counted should < n).",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int countDigitOne(int n) {\\n        if(n<=0) return 0;\\n        int preRound = 0, preAll = 0; //for example 42345, preround is 2345's num of 1 digits, preall is 9999's num of 1 digits.\\n        int multiplier = 1, preNums = 1, pre = 1; // preNums is 10000, pre is 2345+1.\\n        while(n>0){\\n            int curr = n%10;\\n            if(curr>1) preRound = curr*preAll + preRound + preNums;\\n            else if(curr==1) preRound = curr*preAll + preRound + pre;\\n            preAll = 10*preAll + preNums;\\n            preNums *= 10;\\n            pre += curr*multiplier;\\n            multiplier *= 10;\\n            n /=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64475,
                "title": "my-c-0ms-accepted-solution",
                "content": "The main idea is to count the appearance of 1 on each digit.\\n\\nPay more attention on the last digit and it would be OK.\\n\\n    class Solution {\\n    public:\\n        int countDigitOne(const int n) {\\n            int ret = 0;\\n            if (n <= 0) return ret;\\n            int num = n;\\n            int digit = 1;\\n            while (num) {\\n                int mod = num % 10;\\n                int cnt = num / 10;\\n                int add = mod > 0 ? 1 : 0;\\n                \\n                int normal_appr_cnt = cnt * digit;\\n                int additional_appr_cnt;\\n                if (mod == 1) \\n                    additional_appr_cnt = add * (n % digit + 1);\\n                else\\n                    additional_appr_cnt = add * digit;\\n                ret += normal_appr_cnt + additional_appr_cnt;\\n                \\n                num /= 10;\\n                digit *= 10;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int countDigitOne(const int n) {\\n            int ret = 0;\\n            if (n <= 0) return ret;\\n            int num = n;\\n            int digit = 1;\\n            while (num) {\\n                int mod = num % 10;\\n                int cnt = num / 10;\\n                int add = mod > 0 ? 1 : 0;\\n                \\n                int normal_appr_cnt = cnt * digit;\\n                int additional_appr_cnt;\\n                if (mod == 1) \\n                    additional_appr_cnt = add * (n % digit + 1);\\n                else\\n                    additional_appr_cnt = add * digit;\\n                ret += normal_appr_cnt + additional_appr_cnt;\\n                \\n                num /= 10;\\n                digit *= 10;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1726893,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1574315,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1978659,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1721535,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1734694,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1720867,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1739527,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1567230,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 2077146,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 2023584,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1726893,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1574315,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1978659,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1721535,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1734694,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1720867,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1739527,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 1567230,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 2077146,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 2023584,
                "content": [
                    {
                        "username": "SandeepPatel0605",
                        "content": "\\nfor intput = 13\\n\\nfor 1  (count += 1  means count = 1)\\nfor 10  (count += 1 means count = 2)\\nnow for 11 here  ( count += 2 means count = 4)\\nthen for 12  (count += 1 means count = 5)\\nand for 13  (count += 1 means count = 6)\\n\\nso the output = 6"
                    },
                    {
                        "username": "marekreid",
                        "content": "I can do the algo, but not understand the question. I guess this is why I cant crack hard questions yet..."
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good question why so many downvotes??"
                    },
                    {
                        "username": "SeeingShut",
                        "content": "Because people don\\'t know about Digit DP and think of it as a math problem. So, as you should know for most of people math == downvote."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I don\\'t really get some of these Maths problems. I understand optimal solutions do exist but they are too mathematical for normal engineers/ students imo.\\n\\nYou\\'ll agree with me once you get a \\'Math\\' problem to solve in an interview and they won\\'t listen to anything because it\\'s a problem from Leetcode and Leetcode is right you are wrong. damn."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@mishsov09](/mishsov09) When was the last time you saw a leetcode problem related to what a software engineer would do on a daily basis?\\nThose problems are not designed for that"
                    },
                    {
                        "username": "mishsov09",
                        "content": "Totally agree, this is beyond what a Software Engineer would do on a daily basis :("
                    },
                    {
                        "username": "warhacker_1024",
                        "content": "case 35 gives a problem ,on the number \\'824883294\\',its giving TLE is it because of the constraint ,if so how can i keep a limit to the number of the n being less thqan 10^9"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "That was obvious that O(N) solution is not gonna get accepted! See constraints first before trying to come up with a final solution"
                    },
                    {
                        "username": "shilan-kp",
                        "content": "this should be a correct answer but time limits on it :D\\n\\n    if (n < 1)\\n    {\\n        return 0;\\n    }\\n    int count = 0;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        int num = i;\\n        while (num > 0)\\n        {\\n            if (num % 10 == 1)\\n            {\\n                count++;\\n            }\\n            num /= 10;\\n        }\\n    }\\n    return count;\\n"
                    },
                    {
                        "username": "yash012003",
                        "content": "I think you should\\'ve calculated the time complexity of it atleast , like it\\'s O(n^2) fr!!"
                    },
                    {
                        "username": "SeigeNash",
                        "content": "case number 35. i have the exact solution, and my solution passes majority of test cases. but case number 35 gives me time limit exceeded"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "time limit exceeded at test case 35/38 what to do? need to deep down in math so solve the problem, here i am converting number in string and count each character if equal to \"1\" doing count++ and adding all in one function. there can be easy way of solving it but need to open in old math book of great mathematician ramanujan \\uD83D\\uDE02\\uD83D\\uDE02.\\nvar countDigitOne = function(n) {\\n  let count=0\\n  for(n;n>0;n--){\\n   count = count + oneInNumber(n);\\n  }\\n  return count;\\n};\\nlet oneInNumber = function(a){\\n  let newCount =0\\n  let str = a.toString();\\nfor(i=0;i<str.length;i++){\\n  if(str[i]===\"1\"){\\n      newCount++\\n  }\\n}\\nreturn newCount;\\n};"
                    },
                    {
                        "username": "hxu",
                        "content": "I saw a lot of 'AC' solutions. However I have no idea of what it stands for. Anyone could give me a hint? I appreciate."
                    },
                    {
                        "username": "mabdelnasser",
                        "content": "\"AC\" stands for \\'Accepted Code\\'"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just learn digit dp then may seems easy "
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "EASYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
                    }
                ]
            },
            {
                "id": 2008611,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1999610,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1951992,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1924209,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1869988,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1868676,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1860132,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1834438,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1832935,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            },
            {
                "id": 1771370,
                "content": [
                    {
                        "username": "Shenron07",
                        "content": "/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countDigitOne = function(n) {\\n    let arr=[]\\n function checkone(a){\\n     let b=a.toString();\\n     let c=b.search(\\'1\\');\\n     if(c!==-1){\\n         arr.push(b)\\n     }\\n    \\n } \\n for(let i=1;i<=n;i++){\\n     checkone(i);\\n } \\n let c=0;\\n for(let i=0;i<arr.length;i++){\\n     for(let j=0;j<arr[i].split(\"\").length;j++){\\n         if(arr[i].split(\"\")[j]===\\'1\\')\\n        c++;\\n     }\\n }\\n return c\\n \\n};\\ngot stuck at 36th testcase but without knowing anything about DSA still managed to pass 35/38 testcase of a Hard Level question with 34% acceptance. Feels like MAANG any day"
                    },
                    {
                        "username": "user9890KE",
                        "content": "class Solution {\\npublic:\\n    int cnt=0;\\n    int countDigitOne(int n) {\\n       if (n<1)\\n       {\\n           return 0;\\n       } \\n      int i=n;\\n       while(i>0)\\n       {\\n        int rem= i%10;\\n         if (rem==1)\\n         {\\n             cnt++;\\n         }\\n         i=i/10;\\n       }\\n        countDigitOne(n-1);\\n        return cnt;\\n    }\\n};\\n\\nlast testcase is not getting passed"
                    },
                    {
                        "username": "AyushS_cg170",
                        "content": "Why storing number of ones in the current number is required? in digit dp solution"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "gyss read question one more time :\\nfor 13 :-\\nThe question says find how many non negative numbers are there which are less or equal to 13 and have the didgit 1 in them \\nfor ex:-\\n1\\n10\\n11\\n12\\n13\\ncount them you get 6;\\n"
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0,x=1;\\n        String str=\"\", str1=\"\", str2=\"\", str3=\"\";\\n        for(int i=1;i<=n;i++) {\\n            if(n<=100 || i+99>n) {\\n                str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n            } else {\\n                if(i+99<=n){\\n                    str1=Integer.toString(i);\\n                    str2=str1.substring(0,str1.length()-1);\\n                    x=(str2.length())-str2.replace(\"1\", \"\").length();\\n                    sum+=x*99+20;\\n                    i=i+99;\\n                    str3=Integer.toString(i);\\n                    sum+=str3.length()-str3.replace(\"1\", \"\").length();\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis solution works till 10 crore input."
                    },
                    {
                        "username": "user8663ah",
                        "content": "class Solution {\\n    public int countDigitOne(int n) {\\n        int sum=0;\\n        String str=\"\";\\n        for(int i=1;i<=n;i++) {\\n            str=Integer.toString(i);\\n            sum+=str.length()-str.replace(\"1\", \"\").length();\\n        }\\n        return sum;\\n    }\\n}\\n\\nThis code is giving correct result but once I submit, It\\'s throwing TLE."
                    },
                    {
                        "username": "BhanuJindal",
                        "content": "This question is similar to \"Count total set bits in first N Natural Numbers\"."
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n == 1 || n == 0)\n        return n;\n        int x = n;\n        int count = 0;\n        while(x){\n            if(x % 10 == 1)\n            count++;\n            x/=10;\n        }\n        return count + countDigitOne(n-1);\n        \n    }\n};\n\nBro why is it giving error"
                    },
                    {
                        "username": "Harijan98",
                        "content": " I try this approach but i got a TLE .........  Anyone could give me a hint? \\n \\n\\n int temp=0;\\n\\t\\twhile(n>0) {\\n\\t\\t\\tString s= Integer.toString(n);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tif(s.charAt(i)==\\'1\\') {\\n\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tn--;\\n\\t\\t}  \\n    return temp;"
                    },
                    {
                        "username": "Naveen_p_sai22",
                        "content": "I have tried this logic but when I am submitting this its was showing time limit exceed could anyone say the solution for that\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        c=0\n        for i in range(1,n+1):\n            c=c+(str(i).count('1'))\n        return c "
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest BST Subtree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568124,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1568054,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1774890,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1730068,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1573087,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1576021,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1571597,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1831647,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            },
            {
                "id": 1810154,
                "content": [
                    {
                        "username": "randing89",
                        "content": "This is not correct."
                    },
                    {
                        "username": "alenny",
                        "content": "The test cases do not treat a subtree with duplicate values as a BST. But in the Wiki definition, https://en.wikipedia.org/wiki/Binary_search_tree, BST allows duplicate values."
                    },
                    {
                        "username": "WorldHello",
                        "content": "The first test case - [10,5,15,1,8,null,7] has wrong solution. The answer should not be 3. The largest BST subtree is - the one with nodes - 10, 5, 1, 8, 15. The answer should be 5 nodes.\\n\\n"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "\"Note: A subtree must include all of its descendants.\"\\nThe descendant 7 < 15 and is not correct."
                    },
                    {
                        "username": "user4202S",
                        "content": "description of BST is not correct"
                    },
                    {
                        "username": "jkveda",
                        "content": "Why is [1,2] considered a valid BST and the answer is 1?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Week 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-bst-subtree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Pre-Order Traversal\n\n  \n**Approach 2:** Pre-Order Traversal Optimized\n\n  \n**Approach 3:** Post-Order Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vogelkaka",
                        "content": "So far I have seen O(n) and O(n^2) algorithms here .  So what is the O(nlogn) algorithm as the hint suggested ?"
                    },
                    {
                        "username": "Daniel535",
                        "content": "The acceptance rate of 98. Validate Binary Search Tree(Hint) is lower than this problem"
                    },
                    {
                        "username": "janakagoon",
                        "content": "This question does not appear to use a correct definition of a BST. A BST is defined as :\\n\\n```\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n```\\n\\nGoing by the above definition, the largest sub tree is either the root.Left or root.Right, whichever that has more children.\\n\\nThis question has made the mistake of taking only the first to properties of a BST, which is NOT a BST.\\n\\n"
                    }
                ]
            }
        ]
    }
]