[
    {
        "title": "Course Schedule II",
        "question_content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n&nbsp;\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n&nbsp;\nConstraints:\n\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.",
        "solutions": [
            {
                "id": 59317,
                "title": "two-ac-solution-in-java-using-bfs-and-dfs-with-explanation",
                "content": "This question asks for an order in which prerequisite courses must be taken first. This prerequisite relationship reminds one of directed graphs. Then, the problem reduces to find a topological sort order of the courses, which would be a DAG if it has a valid order.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] incLinkCounts = new int[numCourses];\\n        List<List<Integer>> adjs = new ArrayList<>(numCourses);\\n        initialiseGraph(incLinkCounts, adjs, prerequisites);\\n        //return solveByBFS(incLinkCounts, adjs);\\n        return solveByDFS(adjs);\\n    }\\n\\nThe first step is to transform it into a directed graph. Since it is likely to be sparse,we use adjacency list graph data structure. 1 -> 2 means 1 must be taken before 2.\\n\\n    private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\\n        int n = incLinkCounts.length;\\n        while (n-- > 0) adjs.add(new ArrayList<>());\\n        for (int[] edge : prerequisites) {\\n            incLinkCounts[edge[0]]++;\\n            adjs.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\nHow can we obtain a topological sort order of a DAG?\\n\\nWe observe that if a node has incoming edges, it has prerequisites. Therefore, the first few in the order must be those with no prerequisites, i.e. no incoming edges. Any non-empty DAG must have at least one node without incoming links. You can draw a small graph to convince yourself. If we visit these few and remove all edges attached to them, we are left with a smaller DAG, which is the same problem. This will then give our BFS solution.\\n\\n    private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\\n        int[] order = new int[incLinkCounts.length];\\n        Queue<Integer> toVisit = new ArrayDeque<>();\\n        for (int i = 0; i < incLinkCounts.length; i++) {\\n            if (incLinkCounts[i] == 0) toVisit.offer(i);\\n        }\\n        int visited = 0;\\n        while (!toVisit.isEmpty()) {\\n            int from = toVisit.poll();\\n            order[visited++] = from;\\n            for (int to : adjs.get(from)) {\\n                incLinkCounts[to]--;\\n                if (incLinkCounts[to] == 0) toVisit.offer(to);\\n            }\\n        }\\n        return visited == incLinkCounts.length ? order : new int[0]; \\n    }\\n\\nAnother way to think about it is the last few in the order must be those which are not prerequisites of other courses. Thinking it recursively means if one node has unvisited child node, you should visit them first before you put this node down in the final order array. This sounds like the post-order of a DFS. Since we are putting nodes down in the reverse order, we should reverse it back to correct ordering or use a stack.\\n\\n    private int[] solveByDFS(List<List<Integer>> adjs) {\\n        BitSet hasCycle = new BitSet(1);\\n        BitSet visited = new BitSet(adjs.size());\\n        BitSet onStack = new BitSet(adjs.size());\\n        Deque<Integer> order = new ArrayDeque<>();\\n        for (int i = adjs.size() - 1; i >= 0; i--) {\\n            if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\\n        }\\n        int[] orderArray = new int[adjs.size()];\\n        for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\\n        return orderArray;\\n    }\\n    \\n    private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\\n        visited.set(from);\\n        onStack.set(from);\\n        for (int to : adjs.get(from)) {\\n            if (visited.get(to) == false) {\\n                if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\\n            } else if (onStack.get(to) == true) {\\n                return false;\\n            }\\n        }\\n        onStack.clear(from);\\n        order.push(from);\\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "This question asks for an order in which prerequisite courses must be taken first. This prerequisite relationship reminds one of directed graphs. Then, the problem reduces to find a topological sort order of the courses, which would be a DAG if it has a valid order.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] incLinkCounts = new int[numCourses];\\n        List<List<Integer>> adjs = new ArrayList<>(numCourses);\\n        initialiseGraph(incLinkCounts, adjs, prerequisites);\\n        //return solveByBFS(incLinkCounts, adjs);\\n        return solveByDFS(adjs);\\n    }\\n\\nThe first step is to transform it into a directed graph. Since it is likely to be sparse,we use adjacency list graph data structure. 1 -> 2 means 1 must be taken before 2.\\n\\n    private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\\n        int n = incLinkCounts.length;\\n        while (n-- > 0) adjs.add(new ArrayList<>());\\n        for (int[] edge : prerequisites) {\\n            incLinkCounts[edge[0]]++;\\n            adjs.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\nHow can we obtain a topological sort order of a DAG?\\n\\nWe observe that if a node has incoming edges, it has prerequisites. Therefore, the first few in the order must be those with no prerequisites, i.e. no incoming edges. Any non-empty DAG must have at least one node without incoming links. You can draw a small graph to convince yourself. If we visit these few and remove all edges attached to them, we are left with a smaller DAG, which is the same problem. This will then give our BFS solution.\\n\\n    private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\\n        int[] order = new int[incLinkCounts.length];\\n        Queue<Integer> toVisit = new ArrayDeque<>();\\n        for (int i = 0; i < incLinkCounts.length; i++) {\\n            if (incLinkCounts[i] == 0) toVisit.offer(i);\\n        }\\n        int visited = 0;\\n        while (!toVisit.isEmpty()) {\\n            int from = toVisit.poll();\\n            order[visited++] = from;\\n            for (int to : adjs.get(from)) {\\n                incLinkCounts[to]--;\\n                if (incLinkCounts[to] == 0) toVisit.offer(to);\\n            }\\n        }\\n        return visited == incLinkCounts.length ? order : new int[0]; \\n    }\\n\\nAnother way to think about it is the last few in the order must be those which are not prerequisites of other courses. Thinking it recursively means if one node has unvisited child node, you should visit them first before you put this node down in the final order array. This sounds like the post-order of a DFS. Since we are putting nodes down in the reverse order, we should reverse it back to correct ordering or use a stack.\\n\\n    private int[] solveByDFS(List<List<Integer>> adjs) {\\n        BitSet hasCycle = new BitSet(1);\\n        BitSet visited = new BitSet(adjs.size());\\n        BitSet onStack = new BitSet(adjs.size());\\n        Deque<Integer> order = new ArrayDeque<>();\\n        for (int i = adjs.size() - 1; i >= 0; i--) {\\n            if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\\n        }\\n        int[] orderArray = new int[adjs.size()];\\n        for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\\n        return orderArray;\\n    }\\n    \\n    private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\\n        visited.set(from);\\n        onStack.set(from);\\n        for (int to : adjs.get(from)) {\\n            if (visited.get(to) == false) {\\n                if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\\n            } else if (onStack.get(to) == true) {\\n                return false;\\n            }\\n        }\\n        onStack.clear(from);\\n        order.push(from);\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59330,
                "title": "concise-java-solution-based-on-bfs-with-comments",
                "content": "    public int[] findOrder(int numCourses, int[][] prerequisites) { \\n        if (numCourses == 0) return null;\\n        // Convert graph presentation from edges to indegree of adjacent list.\\n        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\\n        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\\n            indegree[prerequisites[i][0]]++;    \\n    \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0) {\\n                // Add the course to the order because it has no prerequisites.\\n                order[index++] = i;\\n                queue.offer(i);\\n            }\\n    \\n        // How many courses don't need prerequisites. \\n        while (!queue.isEmpty()) {\\n            int prerequisite = queue.poll(); // Already finished this prerequisite course.\\n            for (int i = 0; i < prerequisites.length; i++)  {\\n                if (prerequisites[i][1] == prerequisite) {\\n                    indegree[prerequisites[i][0]]--; \\n                    if (indegree[prerequisites[i][0]] == 0) {\\n                        // If indegree is zero, then add the course to the order.\\n                        order[index++] = prerequisites[i][0];\\n                        queue.offer(prerequisites[i][0]);\\n                    }\\n                } \\n            }\\n        }\\n    \\n        return (index == numCourses) ? order : new int[0];\\n    }",
                "solutionTags": [],
                "code": "    public int[] findOrder(int numCourses, int[][] prerequisites) { \\n        if (numCourses == 0) return null;\\n        // Convert graph presentation from edges to indegree of adjacent list.\\n        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\\n        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\\n            indegree[prerequisites[i][0]]++;    \\n    \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0) {\\n                // Add the course to the order because it has no prerequisites.\\n                order[index++] = i;\\n                queue.offer(i);\\n            }\\n    \\n        // How many courses don't need prerequisites. \\n        while (!queue.isEmpty()) {\\n            int prerequisite = queue.poll(); // Already finished this prerequisite course.\\n            for (int i = 0; i < prerequisites.length; i++)  {\\n                if (prerequisites[i][1] == prerequisite) {\\n                    indegree[prerequisites[i][0]]--; \\n                    if (indegree[prerequisites[i][0]] == 0) {\\n                        // If indegree is zero, then add the course to the order.\\n                        order[index++] = prerequisites[i][0];\\n                        queue.offer(prerequisites[i][0]);\\n                    }\\n                } \\n            }\\n        }\\n    \\n        return (index == numCourses) ? order : new int[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 190393,
                "title": "topological-sort-template-general-approach",
                "content": "```Topological Sort is Easy``` -- The General Template\\n*\\n**What we need ?**  \\n```1. HashMap<Node, Indegree> inDegree```: A in-degree map, which record each nodes in-degree. \\n```2. HashMap<Node, List<Node>children> topoMap```: A topo-map which record the Node\\'s children\\n\\n**What we do ?**  \\n```1. Init```:  Init the two HashMaps.\\n```2. Build Map```: Put the child into parent\\'s list ; Increase child\\'s in-degree by 1.\\n```3. Find Node with 0 in-degree```: Iterate the inDegree map, find the Node has 0 inDegree. (If none, there must be a circle)\\n```4. Decrease the children\\'s inDegree by 1```: Decrease step3\\'s children\\'s inDegree by 1.\\n```5. Remove this Node```: Remove step3\\'s Node from inDegree. Break current iteration.\\n```6. Do 3-5 until inDegree is Empty```: Use a while loop\\n\\n```java\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Topological sort\\n        // Edge case\\n        if(numCourses <= 0) return new int[0];\\n        \\n        //1. Init Map\\n        HashMap<Integer, Integer> inDegree = new HashMap<>();\\n        HashMap<Integer, List<Integer>> topoMap = new HashMap<>();\\n        for(int i = 0; i < numCourses; i++) {\\n            inDegree.put(i, 0);\\n            topoMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        //2. Build Map\\n        for(int[] pair : prerequisites) {\\n            int curCourse = pair[0], preCourse = pair[1];\\n            topoMap.get(preCourse).add(curCourse);  // put the child into it\\'s parent\\'s list\\n            inDegree.put(curCourse, inDegree.get(curCourse) + 1); // increase child inDegree by 1\\n        }\\n        //3. find course with 0 indegree, minus one to its children\\'s indegree, until all indegree is 0\\n        int[] res = new int[numCourses];\\n        int base = 0;\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;   // use to check whether there is cycle\\n            for(int key : inDegree.keySet()) {  // find nodes with 0 indegree\\n                if(inDegree.get(key) == 0) {\\n                    res[base ++] = key;\\n                    List<Integer> children = topoMap.get(key);  // get the node\\'s children, and minus their inDegree\\n                    for(int child : children) \\n                        inDegree.put(child, inDegree.get(child) - 1);\\n                    inDegree.remove(key);      // remove the current node with 0 degree and start over\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)  // there is a circle --> All Indegree are not 0\\n                return new int[0];\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Alien Dictionary**\\n```java\\npublic class Solution {\\n    /**\\n     * @param words: a list of words\\n     * @return: a string which is correct order\\n     */\\n    public String alienOrder(String[] words) {\\n        // Topo sort\\n        // Edge case\\n        if(words == null || words.length == 0) return \"\";\\n        \\n        //1. Init inDegree & topoMap\\n        HashMap<Character, Integer> inDegree = new HashMap<>();\\n        HashMap<Character, List<Character>> topoMap = new HashMap<>();\\n        for(String word : words)\\n            for(char c : word.toCharArray()) {\\n                inDegree.put(c, 0);\\n                topoMap.put(c, new ArrayList<Character>());\\n            }\\n        \\n        //2. Build Map\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String w1 = words[i], w2 = words[i + 1];\\n            for(int j = 0; j < Math.min(w1.length(), w2.length()); j++) {\\n                char parent = w1.charAt(j), child = w2.charAt(j);\\n                if(parent != child) {\\n                    inDegree.put(child, inDegree.get(child) + 1);\\n                    topoMap.get(parent).add(child);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        //3. Topo sort\\n        StringBuilder res = new StringBuilder();\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;\\n            for(Character c : inDegree.keySet()) {\\n                if(inDegree.get(c) == 0) {\\n                    flag = true;\\n                    res.append(c);\\n                    List<Character> children = topoMap.get(c);\\n                    for(Character ch : children)\\n                        inDegree.put(ch, inDegree.get(ch) - 1);\\n                    inDegree.remove(c);\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                return \"\";\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Topological Sort is Easy```\n```1. HashMap<Node, Indegree> inDegree```\n```2. HashMap<Node, List<Node>children> topoMap```\n```1. Init```\n```2. Build Map```\n```3. Find Node with 0 in-degree```\n```4. Decrease the children\\'s inDegree by 1```\n```5. Remove this Node```\n```6. Do 3-5 until inDegree is Empty```\n```java\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Topological sort\\n        // Edge case\\n        if(numCourses <= 0) return new int[0];\\n        \\n        //1. Init Map\\n        HashMap<Integer, Integer> inDegree = new HashMap<>();\\n        HashMap<Integer, List<Integer>> topoMap = new HashMap<>();\\n        for(int i = 0; i < numCourses; i++) {\\n            inDegree.put(i, 0);\\n            topoMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        //2. Build Map\\n        for(int[] pair : prerequisites) {\\n            int curCourse = pair[0], preCourse = pair[1];\\n            topoMap.get(preCourse).add(curCourse);  // put the child into it\\'s parent\\'s list\\n            inDegree.put(curCourse, inDegree.get(curCourse) + 1); // increase child inDegree by 1\\n        }\\n        //3. find course with 0 indegree, minus one to its children\\'s indegree, until all indegree is 0\\n        int[] res = new int[numCourses];\\n        int base = 0;\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;   // use to check whether there is cycle\\n            for(int key : inDegree.keySet()) {  // find nodes with 0 indegree\\n                if(inDegree.get(key) == 0) {\\n                    res[base ++] = key;\\n                    List<Integer> children = topoMap.get(key);  // get the node\\'s children, and minus their inDegree\\n                    for(int child : children) \\n                        inDegree.put(child, inDegree.get(child) - 1);\\n                    inDegree.remove(key);      // remove the current node with 0 degree and start over\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)  // there is a circle --> All Indegree are not 0\\n                return new int[0];\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    /**\\n     * @param words: a list of words\\n     * @return: a string which is correct order\\n     */\\n    public String alienOrder(String[] words) {\\n        // Topo sort\\n        // Edge case\\n        if(words == null || words.length == 0) return \"\";\\n        \\n        //1. Init inDegree & topoMap\\n        HashMap<Character, Integer> inDegree = new HashMap<>();\\n        HashMap<Character, List<Character>> topoMap = new HashMap<>();\\n        for(String word : words)\\n            for(char c : word.toCharArray()) {\\n                inDegree.put(c, 0);\\n                topoMap.put(c, new ArrayList<Character>());\\n            }\\n        \\n        //2. Build Map\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String w1 = words[i], w2 = words[i + 1];\\n            for(int j = 0; j < Math.min(w1.length(), w2.length()); j++) {\\n                char parent = w1.charAt(j), child = w2.charAt(j);\\n                if(parent != child) {\\n                    inDegree.put(child, inDegree.get(child) + 1);\\n                    topoMap.get(parent).add(child);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        //3. Topo sort\\n        StringBuilder res = new StringBuilder();\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;\\n            for(Character c : inDegree.keySet()) {\\n                if(inDegree.get(c) == 0) {\\n                    flag = true;\\n                    res.append(c);\\n                    List<Character> children = topoMap.get(c);\\n                    for(Character ch : children)\\n                        inDegree.put(ch, inDegree.get(ch) - 1);\\n                    inDegree.remove(c);\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                return \"\";\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59316,
                "title": "c-bfs-and-dfs",
                "content": "Similar to [Course Schedule](https://leetcode.com/problems/course-schedule/ ), during the process of visiting the nodes, store them in order to a `vector`. In DFS, you may need an additional `reverse`.\\n\\n**BFS**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> degrees = computeIndegrees(g);\\n        vector<int> order;\\n        for (int i = 0; i < numCourses; i++) {\\n            int j = 0;\\n            for (; j < numCourses; j++) {\\n                if (!degrees[j]) {\\n                    order.push_back(j);\\n                    break;\\n                }\\n            }\\n            if (j == numCourses) {\\n                return {};\\n            }\\n            degrees[j]--;\\n            for (int v : g[j]) {\\n                degrees[v]--;\\n            }\\n        }        \\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeIndegrees(graph& g) {\\n        vector<int> degrees(g.size(), 0);\\n        for (auto adj : g) {\\n            for (int v : adj) {\\n                degrees[v]++;\\n            }\\n        }\\n        return degrees;\\n    }\\n};\\n```\\n\\n**DFS**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> order;\\n        vector<bool> todo(numCourses, false), done(numCourses, false);\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!done[i] && !acyclic(g, todo, done, i, order)) {\\n                return {};\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node, vector<int>& order) {\\n        if (todo[node]) {\\n            return false;\\n        }\\n        if (done[node]) {\\n            return true;\\n        }\\n        todo[node] = done[node] = true;\\n        for (int neigh : g[node]) {\\n            if (!acyclic(g, todo, done, neigh, order)) {\\n                return false;\\n            }\\n        }\\n        order.push_back(node);\\n        todo[node] = false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> degrees = computeIndegrees(g);\\n        vector<int> order;\\n        for (int i = 0; i < numCourses; i++) {\\n            int j = 0;\\n            for (; j < numCourses; j++) {\\n                if (!degrees[j]) {\\n                    order.push_back(j);\\n                    break;\\n                }\\n            }\\n            if (j == numCourses) {\\n                return {};\\n            }\\n            degrees[j]--;\\n            for (int v : g[j]) {\\n                degrees[v]--;\\n            }\\n        }        \\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeIndegrees(graph& g) {\\n        vector<int> degrees(g.size(), 0);\\n        for (auto adj : g) {\\n            for (int v : adj) {\\n                degrees[v]++;\\n            }\\n        }\\n        return degrees;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> order;\\n        vector<bool> todo(numCourses, false), done(numCourses, false);\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!done[i] && !acyclic(g, todo, done, i, order)) {\\n                return {};\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node, vector<int>& order) {\\n        if (todo[node]) {\\n            return false;\\n        }\\n        if (done[node]) {\\n            return true;\\n        }\\n        todo[node] = done[node] = true;\\n        for (int neigh : g[node]) {\\n            if (!acyclic(g, todo, done, neigh, order)) {\\n                return false;\\n            }\\n        }\\n        order.push_back(node);\\n        todo[node] = false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59455,
                "title": "fast-python-dfs-solution-with-inline-explanation",
                "content": "Runs takes 80ms\\n\\n    class Solution:\\n        # @param {integer} numCourses\\n        # @param {integer[][]} prerequisites\\n        # @return {integer[]}\\n        def findOrder(self, numCourses, prerequisites):\\n            # use DFS to parse the course structure\\n            self.graph = collections.defaultdict(list) # a graph for all courses\\n            self.res = [] # start from empty\\n            for pair in prerequisites:\\n                self.graph[pair[0]].append(pair[1]) \\n            self.visited = [0 for x in xrange(numCourses)] # DAG detection \\n            for x in xrange(numCourses):\\n                if not self.DFS(x):\\n                    return []\\n                 # continue to search the whole graph\\n            return self.res\\n        \\n        def DFS(self, node):\\n            if self.visited[node] == -1: # cycle detected\\n                return False\\n            if self.visited[node] == 1:\\n                return True # has been finished, and been added to self.res\\n            self.visited[node] = -1 # mark as visited\\n            for x in self.graph[node]:\\n                if not self.DFS(x):\\n                    return False\\n            self.visited[node] = 1 # mark as finished\\n            self.res.append(node) # add to solution as the course depenedent on previous ones\\n            return True",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 1642354,
                "title": "c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs",
                "content": "We are given `N` courses and an array of prerequisite courses `P` where <code>P[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that <code>a<sub>i</sub></code> is a prerequisite to <code>b<sub>i</sub></code>. We need to return order of courses to take to finish all courses satisfying the prerequisite constraints.\\n\\n ---\\n \\n \\u2714\\uFE0F ***Solution - I (Topological Sort - BFS)***\\n\\nWe need to take the courses in an ordering which satisfies the prerequisite constraints. This means that any course can only be taken when all its prerequisite course is already completed. We can visualize this problem as a graph where courses are nodes and edge from one course to the next means that 1st node is prerequisite of the 2nd. Then, we can visit a node only when all of its previous connected nodes leading to it are already visited. This is nothing but **Topological sort**. It refers to an order of vertices in which for every edge `u \\u2794 v`, `u` comes before `v` in the ordering. In this approach, we will be using BFS for topological sort.\\n\\nWe can observe that the only courses possible to take at the beginning are those without any prerequisites. We will maintain an array `indegree` which denotes the number of incoming edges to a node. This will basically tell us the number of prerequisite courses of a node. If there are no prerequisite courses remaining, then we can take that course.\\n\\n Thus, we initialize and fill up a queue with all courses having 0 prerequisites. This denotes the 1st level of BFS traversal, or in other words, the set of courses that we can start our ordering with. Then, we can perform a simple BFS. In each iteration, we pop the current course `cur` and see if we are eligible to take any courses for which `cur` was a prerequisite. The process continues till we have explored all possible courses starting from 0 prerequisite courses.\\n\\nFinally, we return `ans` if all courses are finished. If it is impossible to finish all courses, we return empty array. This case will occur only when the graph formed contains a cycle. It can be proved that a solution will always exist for a DAG.\\n\\nThe algorithm can be summarized as -\\n* Form adjacency list graph from `P`  & compute `indegree` for each node\\n* For the 1st level of BFS iteration, fill up the queue with courses having indegree<sub>i</sub> = 0, i.e, courses with no prerequisites\\n* At each iteration, pop & add the course from queue to ordering `ans`\\n* Decrement indegree of each course for which current course was prerequisite. If the indegree for those courses becomes 0, we can take it next by adding it to queue\\n* Continue the process till queue isn\\'t empty\\n* Finally, return `ans` if it contains `N` courses denoting all courses can be finished, otherwise we know that the graph contains cycle & its impossible to finish all courses in which case we return `[]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);                   // {prerequisite-course : [list of next courses]}\\n        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course\\n        for(auto& pre : P) \\n            G[pre[1]].push_back(pre[0]),            // forming adjacency list graph\\n            indegree[pre[0]]++;                     \\n        \\n        queue<int> q;\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites\\n        \\n        while(size(q)) {\\n            auto cur = q.front(); q.pop();\\n            ans.push_back(cur);                     // cur has no remaining pre courses, so we can take it now\\n            for(auto nextCourse : G[cur]) \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    q.push(nextCourse);             // then we can take it\\n        }\\n        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished\\n        return {};                                      \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, q, ans = defaultdict(list), [0]*N, deque(), []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                q.append(i)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    q.append(nextCourse)\\n                    \\n        return ans if len(ans) == N else []\\n```\\n\\n***Time Complexity :*** <code>O(N + E)</code>, where `N` is the number of courses and `E` is the number of edges, i.e, `P.length`. We require `O(E)` to form adjacency list and `O(N + E)` for standard BFS traversal.\\n***Space Complexity :*** `O(N + E)`, required for queue and storing prerequisites as adjacency list graph in `G`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Topological Sort  - DFS)***\\n\\nA similar logic as above can be implemented using DFS traversal as well. Firstly, we form the adjacency list graph `G` and `indegree` of each node. Then, similar to previous approach, we can begin DFS at courses having no prerequisite. At each recursive level of DFS, we will mark the current course as visited, so that we dont start another DFS from that course and start recursive DFS if we are eligible to take any next courses for which current course was a prerequisite. The process is summarized below -\\n\\n* Form adjacency list graph from `P` & compute `indegree` for each node\\n* Start a DFS from course having indegree<sub>i</sub> = 0, i.e, courses with no prerequisites\\n* At each DFS recursion, add the current course to `ans` & mark it as visited\\n* Decrement indegree of each course for which current course was prerequisite. If the indegree for those courses becomes 0, we can include it next by starting DFS call from that course\\n* Repeat the process by starting DFS from each course having `indegree == 0`\\n* Finally, return `ans` if it contains all `N` courses, else return `[]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);\\n        vector<int> ans, indegree(N);\\n        for(auto& pre : P)\\n            G[pre[1]].push_back(pre[0]),\\n            indegree[pre[0]]++;\\n        \\n        function<void(int)> dfs = [&](int cur) {\\n            ans.push_back(cur);                     // take cur course & push it into ordering\\n            indegree[cur] = -1;                     // and mark it as visited\\n            for(auto nextCourse : G[cur])          \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    dfs(nextCourse);                // then we can take it\\n        };\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0)                    // we can start with courses having no prequisites\\n                dfs(i);\\n        \\n        if(size(ans) == N) return ans;\\n        return {};\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, ans = defaultdict(list), [0]*N, []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        def dfs(cur):\\n            ans.append(cur)\\n            indegree[cur] = -1\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    dfs(nextCourse)            \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                dfs(i)\\n\\n        return ans if len(ans) == N else []\\n```\\n\\n***Time Complexity :*** <code>O(N + E)</code>, We require `O(E)` to form adjacency list and `O(N + E)` for standard DFS traversal.\\n***Space Complexity :*** `O(N + E)`, required for recursive stack and storing prerequisites as adjacency list graph in `G`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);                   // {prerequisite-course : [list of next courses]}\\n        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course\\n        for(auto& pre : P) \\n            G[pre[1]].push_back(pre[0]),            // forming adjacency list graph\\n            indegree[pre[0]]++;                     \\n        \\n        queue<int> q;\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites\\n        \\n        while(size(q)) {\\n            auto cur = q.front(); q.pop();\\n            ans.push_back(cur);                     // cur has no remaining pre courses, so we can take it now\\n            for(auto nextCourse : G[cur]) \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    q.push(nextCourse);             // then we can take it\\n        }\\n        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished\\n        return {};                                      \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, q, ans = defaultdict(list), [0]*N, deque(), []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                q.append(i)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    q.append(nextCourse)\\n                    \\n        return ans if len(ans) == N else []\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);\\n        vector<int> ans, indegree(N);\\n        for(auto& pre : P)\\n            G[pre[1]].push_back(pre[0]),\\n            indegree[pre[0]]++;\\n        \\n        function<void(int)> dfs = [&](int cur) {\\n            ans.push_back(cur);                     // take cur course & push it into ordering\\n            indegree[cur] = -1;                     // and mark it as visited\\n            for(auto nextCourse : G[cur])          \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    dfs(nextCourse);                // then we can take it\\n        };\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0)                    // we can start with courses having no prequisites\\n                dfs(i);\\n        \\n        if(size(ans) == N) return ans;\\n        return {};\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, ans = defaultdict(list), [0]*N, []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        def dfs(cur):\\n            ans.append(cur)\\n            indegree[cur] = -1\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    dfs(nextCourse)            \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                dfs(i)\\n\\n        return ans if len(ans) == N else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741784,
                "title": "python-topological-sort-with-recurcive-dfs-explained",
                "content": "This is the classical problem about **topological sort**: (for more details you can look https://en.wikipedia.org/wiki/Topological_sorting). The basic idea of topological for directed graphs is to check if there cycle in this graph. For example if you have in your schedule dependencies like `0 -> 5`, `5-> 3` and `3 -> 0`, then we say, that cycle exists and in this case we need to return `False`.\\n\\nThere are different ways to do topological sort, I prefer to use `dfs`. The idea is to use classical `dfs` traversal, but color our nodes into `3` different colors, `0 (white)` for node which is not visited yet, `1 (gray)` for node which is in process of visiting (not all its neibours are processed), and `2 (black)` for node which is fully visited (all its neibours are already processed). The proof can be found for example in classical Cormen book (note, that here we have slightly different notation with inversed edges, so we do not need to reverse list in the end).\\n\\nSo, basically we have three variables: `self.Visited = [0] * numCourses` where we keep our colors, define `self.FoundCycle = 0`, we keep it for early stopping, if we found cycle we do not need to continue and we can iterrurupt earlier and `Ans` is the list we need to return of fully visited nodes. Note, that graph can be not necessarily connected, so we need to start our `dfs` from all nodes.\\n\\n**Comlexity.** We use classical dfs, so time comlexity is `O(E+V)`, where `E` is number of edges and `V` is number of vertices. Space complexity is also `O(E+V)` because we work with adjacency lists.\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses, prerequisites):\\n        self.adj_dict = defaultdict(set)\\n        for i, j in prerequisites:\\n            self.adj_dict[i].add(j)\\n\\n        self.Visited = [0] * numCourses\\n        self.Ans, self.FoundCycle = [], 0\\n        \\n        for i in range(numCourses):\\n            if self.FoundCycle == 1: break      # early stop if the loop is found\\n            if self.Visited[i] == 0:\\n                self.dfs(i)\\n     \\n        return [] if self.FoundCycle == 1 else self.Ans\\n\\n    def dfs(self, start):\\n        if self.FoundCycle == 1:   return     # early stop if the loop is found    \\n        if self.Visited[start] == 1:\\n            self.FoundCycle = 1               # loop is found\\n        if self.Visited[start] == 0:           # node is not visited yet, visit it\\n            self.Visited[start] = 1             # color current node as gray\\n            for neib in self.adj_dict[start]:   # visit all its neibours\\n                self.dfs(neib)\\n            self.Visited[start] = 2             # color current node as black\\n            self.Ans.append(start)              # add node to answer\\n```\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses, prerequisites):\\n        self.adj_dict = defaultdict(set)\\n        for i, j in prerequisites:\\n            self.adj_dict[i].add(j)\\n\\n        self.Visited = [0] * numCourses\\n        self.Ans, self.FoundCycle = [], 0\\n        \\n        for i in range(numCourses):\\n            if self.FoundCycle == 1: break      # early stop if the loop is found\\n            if self.Visited[i] == 0:\\n                self.dfs(i)\\n     \\n        return [] if self.FoundCycle == 1 else self.Ans\\n\\n    def dfs(self, start):\\n        if self.FoundCycle == 1:   return     # early stop if the loop is found    \\n        if self.Visited[start] == 1:\\n            self.FoundCycle = 1               # loop is found\\n        if self.Visited[start] == 0:           # node is not visited yet, visit it\\n            self.Visited[start] = 1             # color current node as gray\\n            for neib in self.adj_dict[start]:   # visit all its neibours\\n                self.dfs(neib)\\n            self.Visited[start] = 2             # color current node as black\\n            self.Ans.append(start)              # add node to answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59321,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [set() for _ in range(numCourses)]\\n        outdegree = [[] for _ in range(numCourses)]\\n        for p in prerequisites:\\n            indegree[p[0]].add(p[1])\\n            outdegree[p[1]].append(p[0])\\n        ret, start = [], [i for i in range(numCourses) if not indegree[i]]\\n        while start: # start contains courses without prerequisites\\n            newStart = [] \\n            for i in start:\\n                ret.append(i)\\n                for j in outdegree[i]:\\n                    indegree[j].remove(i)\\n                    if not indegree[j]:\\n                        newStart.append(j)\\n            start = newStart # newStart contains new courses with no prerequisites\\n        return ret if len(ret) == numCourses else [] # can finish if ret contains all courses \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [set() for _ in range(numCourses)]\\n        outdegree = [[] for _ in range(numCourses)]\\n        for p in prerequisites:\\n            indegree[p[0]].add(p[1])\\n            outdegree[p[1]].append(p[0])\\n        ret, start = [], [i for i in range(numCourses) if not indegree[i]]\\n        while start: # start contains courses without prerequisites\\n            newStart = [] \\n            for i in start:\\n                ret.append(i)\\n                for j in outdegree[i]:\\n                    indegree[j].remove(i)\\n                    if not indegree[j]:\\n                        newStart.append(j)\\n            start = newStart # newStart contains new courses with no prerequisites\\n        return ret if len(ret) == numCourses else [] # can finish if ret contains all courses \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161141,
                "title": "c-topological-solution",
                "content": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses, vector<int>());\\n        queue<int> nodes;\\n        vector<int> indegrees(numCourses, 0);\\n        int visit_node_size = 0;\\n        vector<int> result;\\n        \\n        for (auto item : prerequisites) {\\n            graph[item.second].push_back(item.first);\\n            ++ indegrees[item.first];\\n        }\\n        for (int node_id = 0; node_id < indegrees.size(); ++ node_id) {\\n            if (indegrees[node_id] == 0) {\\n                nodes.push(node_id);\\n            }\\n        }\\n        while (!nodes.empty()) {\\n            ++ visit_node_size;\\n            int node_id = nodes.front();\\n            nodes.pop();\\n            result.push_back(node_id);\\n            for (auto neighber_id : graph[node_id]) {\\n                -- indegrees[neighber_id];\\n                if (indegrees[neighber_id] == 0) {\\n                    nodes.push(neighber_id);\\n                }\\n            }\\n        }\\n        \\n        return visit_node_size == numCourses ? result : vector<int>();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses, vector<int>());\\n        queue<int> nodes;\\n        vector<int> indegrees(numCourses, 0);\\n        int visit_node_size = 0;\\n        vector<int> result;\\n        \\n        for (auto item : prerequisites) {\\n            graph[item.second].push_back(item.first);\\n            ++ indegrees[item.first];\\n        }\\n        for (int node_id = 0; node_id < indegrees.size(); ++ node_id) {\\n            if (indegrees[node_id] == 0) {\\n                nodes.push(node_id);\\n            }\\n        }\\n        while (!nodes.empty()) {\\n            ++ visit_node_size;\\n            int node_id = nodes.front();\\n            nodes.pop();\\n            result.push_back(node_id);\\n            for (auto neighber_id : graph[node_id]) {\\n                -- indegrees[neighber_id];\\n                if (indegrees[neighber_id] == 0) {\\n                    nodes.push(neighber_id);\\n                }\\n            }\\n        }\\n        \\n        return visit_node_size == numCourses ? result : vector<int>();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762346,
                "title": "python-bfs-beats-98-with-detailed-explanation-and-comments",
                "content": "The high level for this solution: We create a graph and prereq dict to track which nodes we have visited and if we\\'re able to travel to certain nodes (if there are no preqs for the intended next course - aka we\\'ve taken the prereqs or there are no prereqs.).\\nEg. 4, [[1,0],[2,0],[3,1],[3,2]]\\nStarting: q: deque([0])\\npreqs: {0: set(), 1: {0}, 2: {0}, 3: {1, 2}}\\ngraph: {0: {1, 2}, 1: {3}, 2: {3}}\\nWe start with course 0 because it has no preqs.\\nLooking at our graph, 0 has 2 neighbors 1 and 2\\nWe check 1 and 2 to see that if we have taken course 0 whether we can take them.\\nWe determine this by removing 0 (course we have taken) from 1 and 2\\'s prereqs and if there are no additional prereqs we take them (add them to our queue).\\nAfter taking 0, 1 and 2 added: deque([1, 2]) \\n1 and 2 added because they are neighbors (from our graph): {0: {1, 2}, 1: {3}, 2: {3}}) \\nAnd after taking course 0 now have no prereqs: {0: set(), 1: set(), 2: set(), 3: {1, 2}}\\nNow we visit 1 as it\\'s first in our FIFO queue.\\nLooking at course 1\\'s neighbors in our graph there\\'s 3, \\n{0: {1, 2}, 1: {3}, 2: {3}}\\nbut it has a prereq we haven\\'t taken 2,\\n{0: set(), 1: set(), 2: set(), 3: {2}}\\nWhich is still in our queue: deque([2])\\nSo we don\\'t add anything in this iter and then pop 2 from our q.\\nNow we\\'ve taken 2, we can hit 3 from our graph: 0: {1, 2}, 1: {3}, 2: {3}}\\nwe have now taken 2 so we remove the prereq: {0: set(), 1: set(), 2: set(), 3: set()}\\nAnd we add 3 to the queue.\\ndeque([3])\\nWe then pop 3, append 3 to our taken list and len(taken) == numCourses so we\\'re done!\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)\\n\\t\\t# before we can visit the key.\\n        preq = {i:set() for i in range(numCourses)}\\n\\t\\t# Create a graph for adjacency and traversing.\\n        graph = collections.defaultdict(set)\\n        for i,j in prerequisites:\\n\\t\\t    # Preqs store requirments as their given.\\n            preq[i].add(j)\\n\\t\\t\\t# Graph stores nodes and neighbors.\\n            graph[j].add(i)\\n        \\n        q = collections.deque([])\\n\\t\\t# We need to find a starting location, aka courses that have no prereqs.\\n        for k, v in preq.items():\\n            if len(v) == 0:\\n                q.append(k)\\n\\t\\t# Keep track of which courses have been taken.\\n        taken = []\\n        while q:\\n            course = q.popleft()\\n            taken.append(course)\\n\\t\\t\\t# If we have visited the numCourses we\\'re done.\\n            if len(taken) == numCourses:\\n                return taken\\n\\t\\t\\t# For neighboring courses.\\n            for cor in graph[course]:\\n\\t\\t\\t    # If the course we\\'ve just taken was a prereq for the next course, remove it from its prereqs.\\n                preq[cor].remove(course)\\n\\t\\t\\t\\t# If we\\'ve taken all of the preqs for the new course, we\\'ll visit it.\\n                if not preq[cor]:\\n                    q.append(cor)\\n\\t\\t# If we didn\\'t hit numCourses in our search we know we can\\'t take all of the courses.\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)\\n\\t\\t# before we can visit the key.\\n        preq = {i:set() for i in range(numCourses)}\\n\\t\\t# Create a graph for adjacency and traversing.\\n        graph = collections.defaultdict(set)\\n        for i,j in prerequisites:\\n\\t\\t    # Preqs store requirments as their given.\\n            preq[i].add(j)\\n\\t\\t\\t# Graph stores nodes and neighbors.\\n            graph[j].add(i)\\n        \\n        q = collections.deque([])\\n\\t\\t# We need to find a starting location, aka courses that have no prereqs.\\n        for k, v in preq.items():\\n            if len(v) == 0:\\n                q.append(k)\\n\\t\\t# Keep track of which courses have been taken.\\n        taken = []\\n        while q:\\n            course = q.popleft()\\n            taken.append(course)\\n\\t\\t\\t# If we have visited the numCourses we\\'re done.\\n            if len(taken) == numCourses:\\n                return taken\\n\\t\\t\\t# For neighboring courses.\\n            for cor in graph[course]:\\n\\t\\t\\t    # If the course we\\'ve just taken was a prereq for the next course, remove it from its prereqs.\\n                preq[cor].remove(course)\\n\\t\\t\\t\\t# If we\\'ve taken all of the preqs for the new course, we\\'ll visit it.\\n                if not preq[cor]:\\n                    q.append(cor)\\n\\t\\t# If we didn\\'t hit numCourses in our search we know we can\\'t take all of the courses.\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59342,
                "title": "java-dfs-double-cache-visiting-each-vertex-once-433ms",
                "content": "    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adj = new ArrayList<>(numCourses);\\n            for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());\\n            for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            boolean[] visited = new boolean[numCourses];\\n            Stack<Integer> stack = new Stack<>();\\n            for (int i = 0; i < numCourses; i++) {\\n                if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];\\n            }\\n            int i = 0;\\n            int[] result = new int[numCourses];\\n            while (!stack.isEmpty()) {\\n                result[i++] = stack.pop();\\n            }\\n            return result;\\n        }\\n        \\n        private boolean topologicalSort(List<List<Integer>> adj, int v, Stack<Integer> stack, boolean[] visited, boolean[] isLoop) {\\n            if (visited[v]) return true;\\n            if (isLoop[v]) return false;\\n            isLoop[v] = true;\\n            for (Integer u : adj.get(v)) {\\n                if (!topologicalSort(adj, u, stack, visited, isLoop)) return false;\\n            }\\n            visited[v] = true;\\n            stack.push(v);\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adj = new ArrayList<>(numCourses);\\n            for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());\\n            for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            boolean[] visited = new boolean[numCourses];\\n            Stack<Integer> stack = new Stack<>();\\n            for (int i = 0; i < numCourses; i++) {\\n                if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 742323,
                "title": "c-beginner-topological-sort-cycle-detection-using-dfs",
                "content": "#### This Is a really good question when it comes to building a concrete base for your Graph related problems.\\n\\n**Main Concepts:**\\n- DFS\\n- Topological Sort\\n- Cycle detection\\n\\n> For a really well excuted DFS using STL\\'s : [DFS_STL](https://gist.github.com/sr6033/3d4a018fc0ae598616ca11f134e060c5)\\n> For a better understanding about Topological Sort : [TopoSort](https://www.youtube.com/watch?v=ddTC4Zovtbc)\\n\\nI will talk about all these points in great detail.\\n\\n------\\n\\n**Global Variables**\\n> The following data structures are used.\\n\\n* Stack to store the Topological order : `stack<int> S`\\n* Vector \\'V\\' to store visited nodes : `vector<int> V`\\n* Vector \\'P\\' to store nodes in recursive stack : `vector<int> P`\\n* Map to store the graph : `map<int, vector<int> > G`\\n* Bool variable to store if there is a cycle: `bool cycle`\\n\\n------\\n\\n**Basic DFS**\\n> This is the heart of the code, But it needs a little modification to do a Topological Sort.\\n```\\nvoid DFS(int n)\\n{        \\n\\tfor(int i=0;i<n;++i)\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n\\nvoid DFS_recur(int curr)\\n{        \\n\\tV[curr] = true;\\n\\tcout << curr << \" \";\\n\\t\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n```\\n\\n------\\n\\n**Custom DFS for TopoLogical Sort**\\n> We only need to update the DFS_recur function.\\n```\\nvoid DFS_recur(int curr)\\n{\\n\\tV[curr] = true;\\n\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n\\n\\tS.push(curr);\\n}\\n```\\n\\nHere if we just add a **S.push(curr)** we will get the topological order in the Stack.\\nThink about it we will push only if we reach a **terminal node** in the graph.\\n\\n------\\n\\n**Custom DFS for Cycle Detection**\\n> We will use a vector \\'P\\' to keep track of elements in the recursion stack.\\n```\\nvoid DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n```\\n\\nThis code will set the **cycle variable to true** as soon as a cycle is detected.\\n\\nHow do we detect the cycle?\\n> **Lets consider the followig Graph**\\n<img src=https://user-images.githubusercontent.com/66634743/87854395-cc302600-c922-11ea-9a54-c45e83f4e7b1.png width=300 height=200>\\n> **The map will be as follows**\\n> | Parent | Children |\\n> | - | - |\\n> | 0 | [ 1 ] |\\n> | 1 | [ 2 ] |\\n> | 2 | [ 4 ] |\\n> | 3 | [ 1 ] |\\n> | 4 | [ 3, 5 ] |\\n> **The vectors P and V**\\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | F | F | F | F | F | F |\\n> | **P** | F | F | F | F | F | F |\\n> 0 will be the **curr** first, resulting in the following. P[0] = true means that 0 is in the recursive stack.\\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | T | F | F | F | F | F |\\n> | **P** | T | F | F | F | F | F |\\n> Then we valuate its child:\\n>> **curr = 1**\\n>>> **curr = 2**\\n>>>> **curr = 4**\\n>>>>> **curr = 3**\\n>>>>> \\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | T | T | T | F | T | F |\\n> | **P** | T | T | T | F | T | F |\\n> Now we see that **3\\'s child is 1**. Lets see what happens.\\n>> \\n``` \\nvoid DFS_recur(int curr)                   // curr = 3\\n{\\n\\tif(cycle) return;                      // cycle = false\\n\\n\\tV[curr] = true;                        // V[3] = true\\n\\tP[curr] = true;                        // P[3] = true\\n\\n\\tfor(int i : G[curr])                   // only one element in the vector, [ 1 ] \\n\\t{   \\n\\t\\tif(P[i] == true) cycle = true;     // P[1] == true therefore cycle = true\\n\\t\\tif(!V[i]) DFS_recur(i);            // recur with i = 1\\n\\t// Jump to DFS_recur(1)\\n\\nvoid DFS_recur(int curr)                   // curr = 1\\n{\\n\\tif(cycle) return;                      // cycle = true therefore return\\n\\t/*this will keep returning till the whole recursive stack in empty.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\tall the was till the initial curr = 0\\n\\tThen in the main function*/\\n\\t\\n\\tif(cycle) return {};                   // cycle = true return []\\n        return Ans;\\n```\\n\\n------\\n\\n**Complete Code**\\n```\\nclass Solution {\\npublic:\\n    stack<int> S;\\n    vector<int> V;\\n    vector<int> P;\\n    bool cycle;\\n    map<int, vector<int> > G;\\n    \\n    void DFS(int n)\\n    {        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(!V[i]) DFS_recur(i);\\n        }\\n    }\\n    \\n    void DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) \\n    {\\n        vector<int> Ans;\\n        V.assign(n, false);\\n        P.assign(n, false);\\n        cycle = false;\\n        for(auto i : prerequisites)\\n        {\\n            G[i[1]].push_back(i[0]);\\n        }\\n\\n        DFS(n);\\n        \\n        while(!S.empty())\\n        {\\n            Ans.push_back(S.top());\\n            S.pop();\\n        }\\n        \\n        if(cycle) return {};\\n        return Ans;\\n    }\\n};\\n```\\n\\n------\\n***I dont know if this is any better than the explainations by others, this is a beginner friendly approach. \\nI have tried my best to break it down step by step, Let me know if it helped you.\\nIf you want to have a better understanding try dry running it using a success case (acyclic case)***",
                "solutionTags": [],
                "code": "```\\nvoid DFS(int n)\\n{        \\n\\tfor(int i=0;i<n;++i)\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n\\nvoid DFS_recur(int curr)\\n{        \\n\\tV[curr] = true;\\n\\tcout << curr << \" \";\\n\\t\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n```\n```\\nvoid DFS_recur(int curr)\\n{\\n\\tV[curr] = true;\\n\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n\\n\\tS.push(curr);\\n}\\n```\n```\\nvoid DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n```\n``` \\nvoid DFS_recur(int curr)                   // curr = 3\\n{\\n\\tif(cycle) return;                      // cycle = false\\n\\n\\tV[curr] = true;                        // V[3] = true\\n\\tP[curr] = true;                        // P[3] = true\\n\\n\\tfor(int i : G[curr])                   // only one element in the vector, [ 1 ] \\n\\t{   \\n\\t\\tif(P[i] == true) cycle = true;     // P[1] == true therefore cycle = true\\n\\t\\tif(!V[i]) DFS_recur(i);            // recur with i = 1\\n\\t// Jump to DFS_recur(1)\\n\\nvoid DFS_recur(int curr)                   // curr = 1\\n{\\n\\tif(cycle) return;                      // cycle = true therefore return\\n\\t/*this will keep returning till the whole recursive stack in empty.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\tall the was till the initial curr = 0\\n\\tThen in the main function*/\\n\\t\\n\\tif(cycle) return {};                   // cycle = true return []\\n        return Ans;\\n```\n```\\nclass Solution {\\npublic:\\n    stack<int> S;\\n    vector<int> V;\\n    vector<int> P;\\n    bool cycle;\\n    map<int, vector<int> > G;\\n    \\n    void DFS(int n)\\n    {        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(!V[i]) DFS_recur(i);\\n        }\\n    }\\n    \\n    void DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) \\n    {\\n        vector<int> Ans;\\n        V.assign(n, false);\\n        P.assign(n, false);\\n        cycle = false;\\n        for(auto i : prerequisites)\\n        {\\n            G[i[1]].push_back(i[0]);\\n        }\\n\\n        DFS(n);\\n        \\n        while(!S.empty())\\n        {\\n            Ans.push_back(S.top());\\n            S.pop();\\n        }\\n        \\n        if(cycle) return {};\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 59535,
                "title": "short-and-simple",
                "content": "Took 99ms.\\n\\n    class Solution:\\n        def findOrder(self, numCourses, prerequisites):\\n            from collections import *\\n            pre, suc = defaultdict(int), defaultdict(list)\\n            for a, b in prerequisites:\\n                pre[a] += 1\\n                suc[b].append(a)\\n            free = set(range(numCourses)) - set(pre)\\n            out = []\\n            while free:\\n                a = free.pop()\\n                out.append(a)\\n                for b in suc[a]:\\n                    pre[b] -= 1\\n                    pre[b] or free.add(b)\\n            return out * (len(out) == numCourses)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Took 99ms.\\n\\n    class Solution:\\n        def findOrder(self, numCourses, prerequisites):\\n            from collections import *\\n            pre, suc = defaultdict(int), defaultdict(list)\\n            for a, b in prerequisites:\\n                pre[a] += 1\\n                suc[b].append(a)\\n            free = set(range(numCourses)) - set(pre)\\n            out = []\\n            while free:\\n                a = free.pop()\\n                out.append(a)\\n                for b in suc[a]:\\n                    pre[b] -= 1\\n                    pre[b] or free.add(b)\\n            return out * (len(out) == numCourses)",
                "codeTag": "Java"
            },
            {
                "id": 266867,
                "title": "python-topological-sort-bfs-and-dfs-reserve-order",
                "content": "A regular topological sort problem. A good case for practice.\\n\\nThe first approach is BFS and we build the topological order in order: each time we put the node with `0` indegree at the front of the remaining sequence.\\n\\nWe need to maintain two graphes: ```dst``` sets edges as source->destination while the ```src``` sets edges as destination->source. \\n\\nFor our sorted array, each time we append the node which has no sources (`src` indegree is `0`) to it. And each time we pick one node in sorted array (ganranteed that all of its prerequisite nodes are sorted in front of it so none of rest nodes are its prerequisites) and check its destination nodes(children node in ```dst```). Then we \"remove\" it as a prerequsite from its destination nodes by decreasing all those destination nodes\\' indegree by `1`. Once any of those destination nodes has `0` indegree, we can put them into the sorted array.\\n\\nBesides, if there is a cycle in it, then schedule is not arrangable so we should return []. \\nIn such case, those nodes in the cycle will always has at least a source node (also in that cycle) so they will never be appended in the sorted array. After we finished our serach, if sorted array\\'s size is less than number of courses, then there is a cycle it it.\\n```\\ndef findOrder(n, prerequisites):\\n    src, dst = collections.Counter(), [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        src[d] += 1\\n\\t\\tdst[s].add(d)\\n    ans = [x for x in range(n) if not src[x]]\\n    for s in ans:\\n        for d in dst[s]:\\n            src[d] -= 1\\n            if not src[d]: \\n                ans.append(d)\\n    return ans if len(ans) == n else []\\n```\\n\\nThe second approach is DFS. Since the DFS searches the graph down to the end (the node with no outbound edges) and those nodes should be put at the end of the order, we can use this feature to build the topological order in reserved order: each time we reach the end of a DFS or finish searching the node (so it has no unvisited outbound edges), we put it  at the back of the remaining sequence.\\n\\n**In such way, we only need to build one destination graph, setting edges as source->destination. There is no need to remove any edges. And once we detect any directed cycle in DFS, we can stop right away. So I think DFS is a better way to do topological sort.** And each time we finised search a branch, the root of branch has no unvisitied outbound edges and we can safely add it into the order.\\n\\nAnd cycle can be detected during the DFS. And we need to set 3 visit status. 0 -> not visited; 1 -> visited, -1 -> visited and in the same DFS branch. So if we meet a node with status -1, we find a directed cycle. If we meet a node with status 1, we stop DFS from that node.\\n```\\ndef findOrder(self, n, prerequisites):\\n    G = [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        G[s].add(d)\\n    vis, orders = [0] * n, []\\n\\n    def dfs_circle(x):\\n        vis[x] = -1\\n        for y in G[x]:\\n            if vis[y] < 0 or (not vis[y] and dfs_circle(y)):\\n                return True\\n        vis[x] = 1\\n        orders.append(x)\\n        return False\\n\\n\\tfor x in range(numCourses):\\n\\t    if not vis[x] and dfs_circle(x):\\n\\t        return []\\n    return orders[::-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dst```\n```src```\n```dst```\n```\\ndef findOrder(n, prerequisites):\\n    src, dst = collections.Counter(), [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        src[d] += 1\\n\\t\\tdst[s].add(d)\\n    ans = [x for x in range(n) if not src[x]]\\n    for s in ans:\\n        for d in dst[s]:\\n            src[d] -= 1\\n            if not src[d]: \\n                ans.append(d)\\n    return ans if len(ans) == n else []\\n```\n```\\ndef findOrder(self, n, prerequisites):\\n    G = [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        G[s].add(d)\\n    vis, orders = [0] * n, []\\n\\n    def dfs_circle(x):\\n        vis[x] = -1\\n        for y in G[x]:\\n            if vis[y] < 0 or (not vis[y] and dfs_circle(y)):\\n                return True\\n        vis[x] = 1\\n        orders.append(x)\\n        return False\\n\\n\\tfor x in range(numCourses):\\n\\t    if not vis[x] and dfs_circle(x):\\n\\t        return []\\n    return orders[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 892071,
                "title": "solution-based-on-kahn-s-algorithm-detailed-explantion",
                "content": "```\\n/* (https://leetcode.com/problems/course-schedule-ii/)\\n\\nSolution2:- Based on Kahn\\'s Algorithm (BFS + Queue)\\n\\nTime complexity:- O(V+E) where V is the number of vertices and E is the number of Edges.\\n\\nWhat is Kahn\\'s Algorithm?\\n=> This is the algorithm to do topological sorting. In this algorithm we will follow three steps:-\\n1. We will find indegree of every node means we will calculate the adjacent nodes of that vertice which are dependent on it.\\n2. We will push the node with 0 indegree into the queue.\\n3. Then we will remove all the nodes one by one from the queue and will reduce the indegree of their adjacent nodes which are prerequisites for it.\\n\\nWe will take a count variable to check if there is a deadlock(cycle) in the graph. Because if there is a cycle in the graph then it means we cant apply \\ntopological sort in it and there will be no way to complete all the courses.\\n\\nSo, for DAG(Directed acyclic graph) our count variable should be equal to the total no of nodes in the graph.\\n\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            // will push all the nodes with the indegree 0 in the queue as we have completed all the prerequisites for it.\\n            if (indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            // one by one we will take every element of the queue and will traverse the adjacency list of it \\n            // and will remove that node and will reduce the indegree of the adjacent nodes which are\\n            // prerequisites for it.\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                // and will push the node having 0 indegree in the queue.\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            // and after processing current node, will push it in the ans.\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites)\\n    {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); // Adjacency matrix.\\n        vector<int> indegree(numCourses, 0); // indegree array.\\n\\n        // traversing all the nodes of the graph.\\n        for (int i = 0; i < n; i++)\\n        {\\n            // filling adjacency matrix for all the nodes of the graph.\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            // also filling indegree value for all nodes.\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```\\n**If you like the solution and the explanation then please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/* (https://leetcode.com/problems/course-schedule-ii/)\\n\\nSolution2:- Based on Kahn\\'s Algorithm (BFS + Queue)\\n\\nTime complexity:- O(V+E) where V is the number of vertices and E is the number of Edges.\\n\\nWhat is Kahn\\'s Algorithm?\\n=> This is the algorithm to do topological sorting. In this algorithm we will follow three steps:-\\n1. We will find indegree of every node means we will calculate the adjacent nodes of that vertice which are dependent on it.\\n2. We will push the node with 0 indegree into the queue.\\n3. Then we will remove all the nodes one by one from the queue and will reduce the indegree of their adjacent nodes which are prerequisites for it.\\n\\nWe will take a count variable to check if there is a deadlock(cycle) in the graph. Because if there is a cycle in the graph then it means we cant apply \\ntopological sort in it and there will be no way to complete all the courses.\\n\\nSo, for DAG(Directed acyclic graph) our count variable should be equal to the total no of nodes in the graph.\\n\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            // will push all the nodes with the indegree 0 in the queue as we have completed all the prerequisites for it.\\n            if (indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            // one by one we will take every element of the queue and will traverse the adjacency list of it \\n            // and will remove that node and will reduce the indegree of the adjacent nodes which are\\n            // prerequisites for it.\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                // and will push the node having 0 indegree in the queue.\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            // and after processing current node, will push it in the ans.\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites)\\n    {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); // Adjacency matrix.\\n        vector<int> indegree(numCourses, 0); // indegree array.\\n\\n        // traversing all the nodes of the graph.\\n        for (int i = 0; i < n; i++)\\n        {\\n            // filling adjacency matrix for all the nodes of the graph.\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            // also filling indegree value for all nodes.\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420402,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst findOrder = (numCourses, prerequisites) => {\\n  const inDegrees = Array(numCourses).fill(0);\\n  for (const [v] of prerequisites) {\\n    inDegrees[v]++;\\n  }\\n\\n  const q = [];\\n  for (let i = 0; i < inDegrees.length; i++) {\\n    const degree = inDegrees[i];\\n    if (degree === 0) q.push(i);\\n  }\\n\\n  const res = [];\\n  while (q.length) {\\n    const u0 = q.shift();\\n    numCourses--;\\n    res.push(u0);\\n    for (const [v, u] of prerequisites) {\\n      if (u === u0) {\\n        inDegrees[v]--;\\n        if (inDegrees[v] === 0) q.push(v);\\n      }\\n    }\\n  }\\n  return numCourses === 0 ? res : [];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```js\\nconst findOrder = (numCourses, prerequisites) => {\\n  const inDegrees = Array(numCourses).fill(0);\\n  for (const [v] of prerequisites) {\\n    inDegrees[v]++;\\n  }\\n\\n  const q = [];\\n  for (let i = 0; i < inDegrees.length; i++) {\\n    const degree = inDegrees[i];\\n    if (degree === 0) q.push(i);\\n  }\\n\\n  const res = [];\\n  while (q.length) {\\n    const u0 = q.shift();\\n    numCourses--;\\n    res.push(u0);\\n    for (const [v, u] of prerequisites) {\\n      if (u === u0) {\\n        inDegrees[v]--;\\n        if (inDegrees[v] === 0) q.push(v);\\n      }\\n    }\\n  }\\n  return numCourses === 0 ? res : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59390,
                "title": "java-6ms-topological-sort-solution-with-explanation",
                "content": "This problem is a classic graph topological sort problem. Each prerequisite has edges to the courses that require it.\\n\\nWe define **in degree** as the number of edges into a node in the graph. What we do is we remove the nodes that has in degree equals to 0, decrease the in degree of the nodes that require the current node, and repeat, until we've removed all the nodes (the successful case), or there's no node with in degree equals to 0 (the failed case).\\n\\nSo, we can do this using a priority queue, and make the in degree as the priority. Every time we poll a node from the queue, and decrease the priorities of the children of the node. If the polled node has in degree larger than 1, it means we failed. But since Java's priority queue doesn't support convenient decrease key operation, we have to remove one node and add it back, which causes bad performance.\\n\\n**Or we can use two pointers. We put the removed node in an array, and use a left pointer to iterate through the array and decrease the in degrees of the nodes than require the current node. And use a right pointer to add those nodes which have 0 in degree after the decreasing operation. Repeat this until all nodes are added.**\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            \\n            int[] inDeg = new int[numCourses];\\n            List<Integer>[] chl = new ArrayList[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                chl[i] = new ArrayList<Integer>();\\n            }\\n            \\n            int pre;\\n            int cour;\\n            \\n            for (int[] pair : prerequisites) {\\n                pre = pair[1];\\n                cour = pair[0];\\n                \\n                chl[pre].add(cour);\\n                inDeg[cour]++;\\n            }\\n            \\n            int[] res = new int[numCourses];\\n            int k = 0;\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (inDeg[i] == 0) {\\n                    res[k++] = i;\\n                }\\n            }\\n            \\n            if (k == 0) {\\n                return new int[0];\\n            }\\n            \\n            int j = 0;\\n            List<Integer> tmp;\\n            \\n            while (k < numCourses) {\\n                tmp = chl[res[j++]];\\n                \\n                for (int id : tmp) {\\n                    if (--inDeg[id] == 0) {\\n                        res[k++] = id;\\n                    }\\n                }\\n                \\n                if (j == k) {\\n                    return new int[0];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            \\n            int[] inDeg = new int[numCourses];\\n            List<Integer>[] chl = new ArrayList[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                chl[i] = new ArrayList<Integer>();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 526064,
                "title": "javascript-topological-sort",
                "content": "Wiki - https://en.wikipedia.org/wiki/Topological_sorting\\n\\n```javascript\\n/**\\n * @param {number} numCourses\\n * @param {number[][]} prerequisites\\n * @return {number[]}\\n */\\nvar findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    // build graph map\\n    if (graph.has(v)) {\\n      graph.get(v).push(e);\\n    } else {\\n      graph.set(v, [e]);\\n    }\\n    // build indegree array\\n    indegree[e]++;\\n  }\\n\\n  for (let i = 0; i < indegree.length; i++) {\\n    if (indegree[i] === 0) queue.push(i);\\n  }\\n\\n  while (queue.length) {\\n    const v = queue.shift();\\n    if (graph.has(v)) {\\n      for (const e of graph.get(v)) {\\n        indegree[e]--;\\n        if (indegree[e] === 0) queue.push(e);\\n      }\\n    }\\n    order.push(v);\\n  }\\n\\n  return numCourses === order.length ? order : [];\\n};\\n```\\n\\n* 44/44 cases passed (64 ms)\\n* Your runtime beats 96.3 % of javascript submissions\\n* Your memory usage beats 33.33 % of javascript submissions (38.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} numCourses\\n * @param {number[][]} prerequisites\\n * @return {number[]}\\n */\\nvar findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    // build graph map\\n    if (graph.has(v)) {\\n      graph.get(v).push(e);\\n    } else {\\n      graph.set(v, [e]);\\n    }\\n    // build indegree array\\n    indegree[e]++;\\n  }\\n\\n  for (let i = 0; i < indegree.length; i++) {\\n    if (indegree[i] === 0) queue.push(i);\\n  }\\n\\n  while (queue.length) {\\n    const v = queue.shift();\\n    if (graph.has(v)) {\\n      for (const e of graph.get(v)) {\\n        indegree[e]--;\\n        if (indegree[e] === 0) queue.push(e);\\n      }\\n    }\\n    order.push(v);\\n  }\\n\\n  return numCourses === order.length ? order : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1642760,
                "title": "c-easy-to-solve-detailed-explanation-of-topological-sort-using-dfs",
                "content": "**Intiuition:-**\\nFirst let\\'s reframe the question ,  We are given `numCourses` respresenting total number of courses and a array `prerequisites`  where `prerequisites[i] = [ai, bi]` .\\nWe must take `ai` if we want to take `bi` course. So after getting a gist we can convert those statements into graph by making nodes as courses. \\n```\\nLet\\'s understand this a bit more in a clear way. \\nSo we will make courses as our nodes and the nodes will be connected with each other . \\nFor Example : \\nIf to complete course number 3 the prerequisite is 2 and to complete course 2 the prerequisite is 1 then the formualted graph can be  1->2->3 . \\nThis type of sorting is known as topological sorting .\\n\\nSo after understanding the example we also got one more clue that the first course we learn should have no prerequisites then only \\nwe can learn that course otherwise we need to return an empty array []. \\n```\\nThe problem can be solved in two ways one is BFS and other is DFS . \\n\\n**Algorithm implemented using DFS:-**\\n1.Let\\'s initialize a 2d `graph` and an `result` and `indegree` vector  ,this vector will help us on whether the node is visited or not  i.e., all courses require before that course has taken or not.\\n2. After initializing, start the DFS traversal from the course which has 0 `prerequisites ` i.e whose indegree is 0 and make sure you mark it as `visited ` \\n3. After completion of a course add the `current course` to our `result` . Since we aded a course we will reduce the `indegree` for all the courses whose prerequisited was the current course.\\n4. If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n5. Now repeat the steps by calling dfs again for each course with `indegree` 0.\\n6. In the end return `result` if it contains all `numCourses` i.e Check size of result. `If size == numCourses`, return `result`, else `return an []`\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        //Initializing a 2d graph , result vector and indegree array\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> result, indegree(numCourses);\\n        \\n        //Indegree\\n        for(auto& prereq : prerequisites)\\n            graph[prereq[1]].push_back(prereq[0]),\\n            indegree[prereq[0]]++;\\n        \\n        //dfs call\\n        function<void(int)> dfs = [&](int current) {\\n            //Adding the current course into the result \\n            result.push_back(current);            \\n            //Making sure that the current course that we added is marked as visited\\n            indegree[current] = -1;                     \\n            \\n            //if any next course has a indegree of 0 ie if it has no prerequisites requirement than make dfs call for that course\\n            for(auto nextCourse : graph[current])          \\n                if(--indegree[nextCourse] == 0)     \\n                    dfs(nextCourse);                \\n        };\\n        \\n        // If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n        for(int i = 0; i < numCourses; i++)\\n            if(indegree[i] == 0) dfs(i);                   \\n        \\n        //In the end return `result` if it contains all `numCourses` else return  []\\n        if(size(result) == numCourses) return result;\\n        return {};\\n    }\\n};\\n```\\n**Time Complexity :** *`O(N + E)`* [O(E) to form adjacency list and O(N + E) for our DFS ].\\n**Space Complexity :** *`O(N + E)`*, [Used by recursive stack and prerequisites as adjacency list graph in `graph`]\\n\\n.......*Continuation from previous posts..\\nTill now in the Dr.Cheems Doge ancient ruins arc phase 2, \"Doggo,Dogenderous,Dogelina,Yomru and JThree all were trying to open the door of ancient ruin by their own ways .After failing several times they all took a pause while JThree started to circulate around the doors. After investigating the doors he found some clues based on an ancient story of four cardinal seasons. He referenced this theory as \\'Celestial dogemon\\', JThree told others about it but rest felt a bit uneasy after listening the story . So to verify this, they called a chopper and  a chopper picked them up and fleed towards the sky right above the ceiling they all verified theory and all were amazed by the view of Ancient laboratory...\"\\nPhase 3 to be continued in the next post*...........\\n\\n**Feel free to comment or upvote if you liked the post**\\nSpecial thanks to @archit91 :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nLet\\'s understand this a bit more in a clear way. \\nSo we will make courses as our nodes and the nodes will be connected with each other . \\nFor Example : \\nIf to complete course number 3 the prerequisite is 2 and to complete course 2 the prerequisite is 1 then the formualted graph can be  1->2->3 . \\nThis type of sorting is known as topological sorting .\\n\\nSo after understanding the example we also got one more clue that the first course we learn should have no prerequisites then only \\nwe can learn that course otherwise we need to return an empty array []. \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        //Initializing a 2d graph , result vector and indegree array\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> result, indegree(numCourses);\\n        \\n        //Indegree\\n        for(auto& prereq : prerequisites)\\n            graph[prereq[1]].push_back(prereq[0]),\\n            indegree[prereq[0]]++;\\n        \\n        //dfs call\\n        function<void(int)> dfs = [&](int current) {\\n            //Adding the current course into the result \\n            result.push_back(current);            \\n            //Making sure that the current course that we added is marked as visited\\n            indegree[current] = -1;                     \\n            \\n            //if any next course has a indegree of 0 ie if it has no prerequisites requirement than make dfs call for that course\\n            for(auto nextCourse : graph[current])          \\n                if(--indegree[nextCourse] == 0)     \\n                    dfs(nextCourse);                \\n        };\\n        \\n        // If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n        for(int i = 0; i < numCourses; i++)\\n            if(indegree[i] == 0) dfs(i);                   \\n        \\n        //In the end return `result` if it contains all `numCourses` else return  []\\n        if(size(result) == numCourses) return result;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390636,
                "title": "c-solution-topological-sort",
                "content": "Topological sort -> BFS-> kahn\\'s Algorithm\\n\\n**Time complexity - O(V* E)**\\nSimilar to Course Schedule 1: https://leetcode.com/problems/course-schedule/discuss/1390567/c-solution-9956-faster\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n       \\n        vector<int>adj[numCourses];\\n        queue<int>q;\\n        vector<int>indegree(numCourses,0);\\n        //store \\n         for(int i =0; i< prerequisites.size(); i++ ){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        //indegree u -> v\\n        for(int i =0; i < prerequisites.size(); i++){\\n            indegree[prerequisites[i][0]]++;\\n            \\n        }\\n        //push into q,indegree having 0\\n        for(int i =0; i< indegree.size(); i++){\\n            if(indegree[i] == 0)q.push(i);\\n        }\\n        vector<int>result;\\n        //Simple BFS and keep storing indegree values equal to 0 into result vector\\n        while(!q.empty()){\\n           int v = q.front();\\n            q.pop();\\n            for(auto it : adj[v]){\\n                indegree[it]--;\\n                 if(indegree[it] == 0)q.push(it);\\n            }\\n            result.emplace_back(v);\\n        }\\n        //check case \\n        if (result.size() != numCourses)\\n        result.clear();\\n        return result;\\n    }\\n};\\n```\\n**Please upvote if you like the solution and comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n       \\n        vector<int>adj[numCourses];\\n        queue<int>q;\\n        vector<int>indegree(numCourses,0);\\n        //store \\n         for(int i =0; i< prerequisites.size(); i++ ){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        //indegree u -> v\\n        for(int i =0; i < prerequisites.size(); i++){\\n            indegree[prerequisites[i][0]]++;\\n            \\n        }\\n        //push into q,indegree having 0\\n        for(int i =0; i< indegree.size(); i++){\\n            if(indegree[i] == 0)q.push(i);\\n        }\\n        vector<int>result;\\n        //Simple BFS and keep storing indegree values equal to 0 into result vector\\n        while(!q.empty()){\\n           int v = q.front();\\n            q.pop();\\n            for(auto it : adj[v]){\\n                indegree[it]--;\\n                 if(indegree[it] == 0)q.push(it);\\n            }\\n            result.emplace_back(v);\\n        }\\n        //check case \\n        if (result.size() != numCourses)\\n        result.clear();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59472,
                "title": "java-13ms-iterative-dfs-solution-with-explanation",
                "content": "Just FYI, here is [my solution for the other problem: Course Schedule][1].\\n\\nMapping of element value in `visited` array to colors in CLRS DFS algorithm: \\n0 -> White, -1 -> Gray, 1 -> Black\\n\\nWe need to peek a node in stack for the first time, and pop it for the second time we meet it. In other words, we need to keep a node in stack until the dfs search rooted at it has been finished, which is equivalent to the end of a recursive call.\\n\\nFor the end of the corresponding dfs search rooted at `prere`: -1 corresponding to `prere` as a normal node; 1 corresponding to `prere` as an end node of a cross edge. \\n\\nMy Java implementation of the iterative DFS algorithm based on its recursive counterpart in CLRS (13ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            ArrayDeque<Integer> stack = new ArrayDeque<>();\\n            ArrayDeque<Integer> auxStack = new ArrayDeque<>();\\n            int[] order = new int[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                int course = prerequisites[i][0], prere = prerequisites[i][1];\\n                graph.get(prere).add(course);\\n            }\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (visited[i] == 0) {\\n                    stack.push(i);\\n                    while (!stack.isEmpty()) {\\n                        Integer prere = stack.peek();\\n                        if(visited[prere] == 0) {\\n                            // start of dfs search rooted at prere\\n                            visited[prere] = -1;\\n                        }\\n                        else if (visited[prere] == -1){\\n                            // end of dfs search rooted at prere; prere is a normal node\\n                            stack.pop();\\n                            visited[prere] = 1;\\n                            auxStack.push(prere);\\n                            continue;\\n                        } \\n                        else if (visited[prere] == 1) {\\n                           // since prere is an end node of a cross edge; the dfs search rooted at prere\\n                           // has been finished as part of another dfs search rooted at another node\\n                           // we have no need to explore its neighbors again\\n                            stack.pop();\\n                            continue;\\n                        }\\n                        for (Integer course: graph.get(prere)) {\\n                            if (visited[course] == 0) {\\n                                stack.push(course);\\n                            }\\n                            else if (visited[course] == -1) {\\n                                return new int[0];\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            for (int i = 0; i<numCourses; i++) {\\n                order[i] = auxStack.pop();\\n            }\\n            return order;\\n        }\\n    }\\n\\nJust for comparison, here is my Java implementation of the recursive DFS algorithm in CLRS (8ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\\n            List<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();\\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            }\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (visited[i] == 0 && dfsDetectCycle(graph, visited, stack, i)) return new int[0];\\n            }\\n            int[] order = new int[numCourses];\\n            for (int i = 0; i < numCourses; i++) \\n                order[i] = stack.pop();\\n            return order;\\n        }\\n        \\n        private boolean dfsDetectCycle(List<ArrayList<Integer>> graph, int[] visited,\\n                                                  ArrayDeque<Integer> stack, int prere) {\\n            visited[prere] = -1; //Gray\\n            for (int course: graph.get(prere)) {\\n                if (visited[course] == -1) return true;\\n                else if (visited[course] == 0 && dfsDetectCycle(graph, visited, stack, course)) return true;\\n            }\\n            visited[prere] = 1; //Black\\n            stack.push(prere);\\n            return false;\\n        }\\n    }\\n\\n\\nMy Java implementation of the BFS solution with indegree (11ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] indegree = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            Queue<Integer> queue = new ArrayDeque<>();\\n            int count = 0;\\n            int[] order = new int[numCourses];\\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                int course = prerequisites[i][0], prere = prerequisites[i][1];\\n                indegree[course]++;\\n                graph.get(prere).add(course);\\n            }\\n            for (int i = 0; i < numCourses; i++) {\\n                if (indegree[i] == 0) \\n                    queue.offer(i);\\n            }\\n            \\n            while (!queue.isEmpty()) {\\n                Integer prere = queue.poll();\\n                order[count++] = prere;\\n                for (Integer course: graph.get(prere)) {\\n                    if (--indegree[course] == 0) \\n                        queue.offer(course);\\n                }\\n            }\\n            if(count == numCourses) {\\n                return order;\\n            }\\n            else {\\n                return new int[0];\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/71444/explained-java-12ms-iterative-solution-based-algorithm-clrs?show=71444#q71444",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            ArrayDeque<Integer> stack = new ArrayDeque<>();\\n            ArrayDeque<Integer> auxStack = new ArrayDeque<>();\\n            int[] order = new int[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 59486,
                "title": "ac-python-topological-sort-72-ms-o-v-e-time-and-o-v-e-space",
                "content": "    def findOrder(self, n, pres):\\n        ind = [[] for _ in xrange(n)]  # indegree\\n        oud = [0] * n  # outdegree\\n        for p in pres:\\n            oud[p[0]] += 1\\n            ind[p[1]].append(p[0])\\n        ans = []\\n        for i in xrange(n):\\n            if oud[i] == 0:\\n                ans.append(i)\\n        l = 0\\n        while l != len(ans):\\n            x = ans[l]\\n            l += 1\\n            for i in ind[x]:\\n                oud[i] -= 1\\n                if oud[i] == 0:\\n                    ans.append(i)\\n        return ans if l == n else []\\n\\n\\n    # 35 / 35 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 72 ms\\n    # 96.08%\\n\\nThe code is almost the same as \"course schedule\". The only difference is we keep the courses taken instead of remove them, everything else is the same.",
                "solutionTags": [],
                "code": "    def findOrder(self, n, pres):\\n        ind = [[] for _ in xrange(n)]  # indegree\\n        oud = [0] * n  # outdegree\\n        for p in pres:\\n            oud[p[0]] += 1\\n            ind[p[1]].append(p[0])\\n        ans = []\\n        for i in xrange(n):\\n            if oud[i] == 0:\\n                ans.append(i)\\n        l = 0\\n        while l != len(ans):\\n            x = ans[l]\\n            l += 1\\n            for i in ind[x]:\\n                oud[i] -= 1\\n                if oud[i] == 0:\\n                    ans.append(i)\\n        return ans if l == n else []\\n\\n\\n    # 35 / 35 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 72 ms\\n    # 96.08%\\n\\nThe code is almost the same as \"course schedule\". The only difference is we keep the courses taken instead of remove them, everything else is the same.",
                "codeTag": "Python3"
            },
            {
                "id": 146326,
                "title": "javascript-dfs",
                "content": "```js\\nfunction findOrder(numCourses, prerequisites) {\\n  const seen = new Set();\\n  const seeing = new Set();\\n  const res = [];\\n  \\n  const adj = [...Array(numCourses)].map(r => []);\\n  for (let [u, v] of prerequisites) {\\n    adj[v].push(u);\\n  }\\n  \\n  for (let c = 0; c < numCourses; c++) {\\n    if (!dfs(c)) {\\n      return [];\\n    }\\n  }\\n  return res.reverse();\\n  \\n  function dfs(v) {\\n    if (seen.has(v)) {\\n      return true;\\n    }\\n    if (seeing.has(v)) {\\n      return false;\\n    }\\n    \\n    seeing.add(v);\\n    for (let nv of adj[v]) {\\n      if (!dfs(nv)) {\\n        return false;\\n      }\\n    }\\n    seeing.delete(v);\\n    seen.add(v);\\n    res.push(v);\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction findOrder(numCourses, prerequisites) {\\n  const seen = new Set();\\n  const seeing = new Set();\\n  const res = [];\\n  \\n  const adj = [...Array(numCourses)].map(r => []);\\n  for (let [u, v] of prerequisites) {\\n    adj[v].push(u);\\n  }\\n  \\n  for (let c = 0; c < numCourses; c++) {\\n    if (!dfs(c)) {\\n      return [];\\n    }\\n  }\\n  return res.reverse();\\n  \\n  function dfs(v) {\\n    if (seen.has(v)) {\\n      return true;\\n    }\\n    if (seeing.has(v)) {\\n      return false;\\n    }\\n    \\n    seeing.add(v);\\n    for (let nv of adj[v]) {\\n      if (!dfs(nv)) {\\n        return false;\\n      }\\n    }\\n    seeing.delete(v);\\n    seen.add(v);\\n    res.push(v);\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59425,
                "title": "my-python-dfs-recursive-solution-same-algorithm-for-207-and-210",
                "content": "    class Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        course_array = [[] for i in xrange(numCourses)] # each sub-list records the pre-requisites\\n        visit = [0 for i in xrange(numCourses)]         # check whether these is a loop\\n        res = []                                        # the course ordering for #210\\n        for edge in prerequisites:\\n            course_array[edge[0]].append(edge[1])\\n\\n        # For #210, put courses that don't need prerequisites into ordering.\\n        i = 0\\n        while i < numCourses:\\n            if len(course_array[i]) == 0:\\n                res += i,               # add into ordering.\\n                visit[i] = -1           # visited.\\n            i += 1\\n\\n        def dfs(x, res):\\n            # find out this course is in a loop or not\\n            # True => in a loop => invalid course\\n            if visit[x] == -1:          # visit here earlier, there's no loop.\\n                return False\\n            if visit[x] == 1:           # there's a loop!\\n                return True\\n\\n            visit[x] = 1                # begin to check this node and its prerequisite\\n            for v in course_array[x]:\\n                if dfs(v, res):\\n                    return True\\n            visit[x] = -1               # check PASSED, add this course into ordering. \\n            res.append(x)               # For #210, Here prerequisite will be added earlier.\\n            return False\\n\\n        # begin from the root\\n        for i in xrange(numCourses):\\n            if dfs(i, res):\\n                return []           # if there's a loop => NOT possible to complete.\\n        \\n        return res        # In #207, just return True",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    class Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        course_array = [[] for i in xrange(numCourses)] # each sub-list records the pre-requisites\\n        visit = [0 for i in xrange(numCourses)]         # check whether these is a loop\\n        res = []                                        # the course ordering for #210\\n        for edge in prerequisites:\\n            course_array[edge[0]].append(edge[1])\\n\\n        # For #210, put courses that don't need prerequisites into ordering.\\n        i = 0\\n        while i < numCourses:\\n            if len(course_array[i]) == 0:\\n                res += i,               # add into ordering.\\n                visit[i] = -1           # visited.\\n            i += 1\\n\\n        def dfs(x, res):\\n            # find out this course is in a loop or not\\n            # True => in a loop => invalid course\\n            if visit[x] == -1:          # visit here earlier, there's no loop.\\n                return False\\n            if visit[x] == 1:           # there's a loop!\\n                return True\\n\\n            visit[x] = 1                # begin to check this node and its prerequisite\\n            for v in course_array[x]:\\n                if dfs(v, res):\\n                    return True\\n            visit[x] = -1               # check PASSED, add this course into ordering. \\n            res.append(x)               # For #210, Here prerequisite will be added earlier.\\n            return False\\n\\n        # begin from the root\\n        for i in xrange(numCourses):\\n            if dfs(i, res):\\n                return []           # if there's a loop => NOT possible to complete.\\n        \\n        return res        # In #207, just return True",
                "codeTag": "Java"
            },
            {
                "id": 3224528,
                "title": "210-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using topological sort. First, we need to build a graph to represent the courses and their prerequisites, and then perform topological sort on the graph to get the order of courses.\\n\\nHere is the step by step explanation:\\n\\n1. Build the graph:\\nWe can represent the courses and their prerequisites using a directed graph. Each course is a node in the graph, and each prerequisite relationship is an edge from the prerequisite to the course. We can build the graph using an adjacency list.\\n\\n2. Calculate the in-degree of each node:\\nIn-degree is the number of incoming edges for a node. We can calculate the in-degree of each node in the graph by counting the number of prerequisites for each course.\\n\\n3. Perform topological sort:\\nWe can perform topological sort on the graph using a queue. We start by adding all the nodes with in-degree 0 to the queue. Then, while the queue is not empty, we remove a node from the queue and add it to the result. For each of the node\\'s neighbors, we decrement their in-degree by 1. If a neighbor\\'s in-degree becomes 0, we add it to the queue.\\n\\n4. Check for cycle:\\nIf the result size is less than the number of courses, it means there is a cycle in the graph, and it is impossible to finish all courses.\\n\\n# Complexity\\n- Time complexity: 85.26%\\nBuilding the graph takes O(E), where E is the number of edges (prerequisites). Calculating the in-degree takes O(E). Performing topological sort takes O(V + E), where V is the number of nodes (courses). Therefore, the overall time complexity is O(V + E).\\n\\n- Space complexity: 83.92%\\nWe use O(V + E) space to store the graph and the in-degree. We also use O(V) space for the queue and the result. Therefore, the overall space complexity is O(V + E).\\n\\n# Code\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Step 1: Build the graph\\n        graph = defaultdict(list)\\n        for course, prereq in prerequisites:\\n            graph[prereq].append(course)\\n        \\n        # Step 2: Calculate the in-degree of each node\\n        in_degree = [0] * numCourses\\n        for course, prereq in prerequisites:\\n            in_degree[course] += 1\\n        \\n        # Step 3: Perform topological sort\\n        queue = deque()\\n        for i in range(numCourses):\\n            if in_degree[i] == 0:\\n                queue.append(i)\\n        \\n        result = []\\n        while queue:\\n            node = queue.popleft()\\n            result.append(node)\\n            for neighbor in graph[node]:\\n                in_degree[neighbor] -= 1\\n                if in_degree[neighbor] == 0:\\n                    queue.append(neighbor)\\n        \\n        # Step 4: Check for cycle\\n        if len(result) < numCourses:\\n            return []\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Step 1: Build the graph\\n        graph = defaultdict(list)\\n        for course, prereq in prerequisites:\\n            graph[prereq].append(course)\\n        \\n        # Step 2: Calculate the in-degree of each node\\n        in_degree = [0] * numCourses\\n        for course, prereq in prerequisites:\\n            in_degree[course] += 1\\n        \\n        # Step 3: Perform topological sort\\n        queue = deque()\\n        for i in range(numCourses):\\n            if in_degree[i] == 0:\\n                queue.append(i)\\n        \\n        result = []\\n        while queue:\\n            node = queue.popleft()\\n            result.append(node)\\n            for neighbor in graph[node]:\\n                in_degree[neighbor] -= 1\\n                if in_degree[neighbor] == 0:\\n                    queue.append(neighbor)\\n        \\n        # Step 4: Check for cycle\\n        if len(result) < numCourses:\\n            return []\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59536,
                "title": "c-using-3-colored-approach",
                "content": "Here, i have used 3 colored approach. Here w -> represent white means vertex yet not visited.\\ng -> gray , it means it is under DFS recursion and we again found the same node. This means cycle exists and return false.\\nb -> black node when DFS is done visiting the node. \\nThis method checks cycle as well as keeps storing answer in stack in case cycle doesn't exists.\\n\\n    \\n\\n    class Graph {\\n        public:\\n        int v;\\n        list <int> *adj;\\n        Graph(int v)\\n        {\\n            this->v=v;\\n            adj = new list<int> [v];\\n        }\\n        void addedges(int src , int dest)\\n           {\\n    \\t     adj[dest].push_back(src);\\n           }\\t\\n    };\\n    class Solution {\\n    public:\\n        stack <int> st;\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            Graph g(numCourses);\\n            for (int i=0 ; i < prerequisites.size() ; i++)\\n                    g.addedges(prerequisites[i].first , prerequisites[i].second);        \\n            vector <int> ans;\\n            if(!courseScheduleCheck(g))\\n                    return ans;              \\n            while(!st.empty())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n            return ans;       \\n        }\\n       bool courseScheduleCheck(Graph g)\\n        {\\n            int v = g.v;    \\n            vector <char> visit(v,'w');\\n            for(int i=0 ; i<v;i++)\\n            {        \\n               if(visit[i]== 'w')\\n                    if(iscycle(g,i,visit))\\n                        return false;\\n            }\\n            return true;\\n        }  \\n        bool iscycle(Graph g , int i, vector <char> & visit)\\n        {\\n            list <int> ::iterator it;\\n            for(it = g.adj[i].begin() ; it!=g.adj[i].end() ; it++)\\n            {\\n                if(visit[*it]== 'g')\\n                    return true;\\n                else\\n                {\\n                    if(visit[*it] != 'b')\\n                     {\\n                         visit[*it] = 'g';\\n                         if(iscycle(g,*it,visit))\\n                            return true;\\n                     }        \\n                }     \\n            }\\n             visit[i]='b';\\n             st.push(i);           \\n            return false;\\n        }            \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        stack <int> st;\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            Graph g(numCourses);\\n            for (int i=0 ; i < prerequisites.size() ; i++)\\n                    g.addedges(prerequisites[i].first , prerequisites[i].second);        \\n            vector <int> ans;\\n            if(!courseScheduleCheck(g))\\n                    return ans;              \\n            while(!st.empty())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1333151,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886870,
                "title": "c-dfs-commented",
                "content": "In this approach we are checking for cycles, if there is one then we will return empty array or return the visited arrays\\n0 -> unvisited\\n1 -> unexplored\\n2 -> visited\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node, vector<vector<int>>& graph, vector<int>& visited, vector<int>& result)\\n    {\\n        visited[node]=1;\\n        for(int i=0;i<graph[node].size();i++)\\n        {\\n            if(visited[graph[node][i]]==1)return false; // if this node is unexplored that means there is a cycle\\n            if(visited[graph[node][i]]==0)\\n            {\\n                if(!dfs(graph[node][i],graph,visited,result)) //return false \\n                    return false;\\n            }\\n        }\\n        visited[node]=2; //if function comes till here then we can mark the current node as 2 i.e, visited\\n        result.push_back(node); //we will push the visited nodes to the resulting array\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]); //making an adjacency list\\n        }\\n        vector<int> visited(numCourses,0);  //for keeping track of the nodes position.\\n\\t\\t//We first initialize every node as 0 i,e. unvisited\\n        vector<int> result; //result vector\\n        bool flag = true; \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                if(!dfs(i,graph,visited,result)){\\n                    flag = false; // it will return false if there is a cycle detected so we can break it \\n                    break;\\n                }\\n            }\\n        }\\n        if(!flag)\\n            return vector<int>();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node, vector<vector<int>>& graph, vector<int>& visited, vector<int>& result)\\n    {\\n        visited[node]=1;\\n        for(int i=0;i<graph[node].size();i++)\\n        {\\n            if(visited[graph[node][i]]==1)return false; // if this node is unexplored that means there is a cycle\\n            if(visited[graph[node][i]]==0)\\n            {\\n                if(!dfs(graph[node][i],graph,visited,result)) //return false \\n                    return false;\\n            }\\n        }\\n        visited[node]=2; //if function comes till here then we can mark the current node as 2 i.e, visited\\n        result.push_back(node); //we will push the visited nodes to the resulting array\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]); //making an adjacency list\\n        }\\n        vector<int> visited(numCourses,0);  //for keeping track of the nodes position.\\n\\t\\t//We first initialize every node as 0 i,e. unvisited\\n        vector<int> result; //result vector\\n        bool flag = true; \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                if(!dfs(i,graph,visited,result)){\\n                    flag = false; // it will return false if there is a cycle detected so we can break it \\n                    break;\\n                }\\n            }\\n        }\\n        if(!flag)\\n            return vector<int>();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646120,
                "title": "c-topological-sort-solution",
                "content": "This problem is essentially the same as [Course Schedule I](https://leetcode.com/problems/course-schedule/), except now we also need to output the ordering of courses. A topological sort works great for this because it has the property that if element `i` comes before element `j` in an array, then element `i` is a course that can be taken without taking the course represented by element `j`. The solution is basically [my solution to Course Schedule 1](https://leetcode.com/problems/course-schedule/discuss/645953/C%2B%2B-Topological-Sort-Solution), but with a slight modification to store each node once it has been discovered to have an indegree of 0, rather than simply decrementing the number of courses left to take.\\n\\nAll the courses can be taken if we can come up with a topological sorting of the courses that includes every single course. However, the input provided in the form of an array of edges is not very easy to work with, so we first convert it to an adjacency list representation. Then, we simply run a standard topological sort on the graph. We first loop through the adjacency list to get all the courses with no prerequisites (nodes of indegree 0), which will be the starting points of the topological ordering, and add them to our final result. Then, for each of those nodes, we \"remove\" the node from the graph by decrementing the indegree of all courses that it is a prerequisite for, and if any course ends up having an updated indegree of 0, then we add it to our result, as well as a queue of courses to process next and repeat the node removal process with.\\n\\nEvery time we \"remove\" a course from the graph, we decrement the number of courses to take by 1. Thus, at the end, we can simply check if the number of courses we can take (the size of the result) is equal to the number of courses we need to take: if so, then that means we were able to take all the courses and so we return the topological ordering; otherwise, we were not able to and so an empty array is returned.\\n\\nTraversing all the edges takes O(E) and then running topological sort takes O(V+E), so this solution takes O(V+E) overall. We also represent the input as an adjacency list, which takes up O(V+E) space.\\n\\nA bit wordy but easier to understand (in my opinion) than the super short solutions.\\n\\n```\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> degree(numCourses, 0);\\n        queue<int> zeroDegree;\\n        vector<int> topoOrder;\\n        for(int i = 0; i<prerequisites.size(); i++){\\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            degree[prerequisites[i][0]]++;\\n        }\\n\\n        for(int i = 0; i<degree.size(); i++){\\n            if(degree[i] == 0){\\n                zeroDegree.push(i);\\n                topoOrder.push_back(i);\\n            }\\n        }\\n\\n        while(!zeroDegree.empty()){\\n            int node = zeroDegree.front();\\n            zeroDegree.pop();\\n            for(int i = 0; i<graph[node].size(); i++){\\n                int connectedNode = graph[node][i];\\n                degree[connectedNode]--;\\n                if(degree[connectedNode] == 0){\\n                    zeroDegree.push(connectedNode);\\n                    topoOrder.push_back(connectedNode);\\n                }\\n            }\\n        }\\n        if(topoOrder.size() != numCourses){\\n            return vector<int>();\\n        }\\n        return topoOrder;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> degree(numCourses, 0);\\n        queue<int> zeroDegree;\\n        vector<int> topoOrder;\\n        for(int i = 0; i<prerequisites.size(); i++){\\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            degree[prerequisites[i][0]]++;\\n        }\\n\\n        for(int i = 0; i<degree.size(); i++){\\n            if(degree[i] == 0){\\n                zeroDegree.push(i);\\n                topoOrder.push_back(i);\\n            }\\n        }\\n\\n        while(!zeroDegree.empty()){\\n            int node = zeroDegree.front();\\n            zeroDegree.pop();\\n            for(int i = 0; i<graph[node].size(); i++){\\n                int connectedNode = graph[node][i];\\n                degree[connectedNode]--;\\n                if(degree[connectedNode] == 0){\\n                    zeroDegree.push(connectedNode);\\n                    topoOrder.push_back(connectedNode);\\n                }\\n            }\\n        }\\n        if(topoOrder.size() != numCourses){\\n            return vector<int>();\\n        }\\n        return topoOrder;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293048,
                "title": "detecting-cycle-in-directed-graph-problem",
                "content": "```\\nclass Solution {\\n    static class DetectCycleGraph {\\n\\t\\tprivate int V;\\n\\t\\tprivate List<List<Integer>> edges;\\n\\n\\t\\tDetectCycleGraph(int n) {\\n\\t\\t\\tthis.V = n;\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t\\tedges = new ArrayList<>();\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tedges.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic DetectCycleGraph() {\\n\\t\\t}\\n\\n\\t\\tprivate void addEdge(int i, int j) {\\n\\t\\t\\tedges.get(i).add(j);\\n\\t\\t}\\n\\n\\t\\tList<Integer> l = new ArrayList<>();\\n\\n\\t\\tpublic int[] isCycle(DetectCycleGraph graph) {\\n\\n\\t\\t\\tboolean[] visited = new boolean[this.V];\\n\\t\\t\\tboolean[] curRec = new boolean[this.V];\\n\\t\\t\\tfor (int i = 0; i < this.V; i++) {\\n\\t\\t\\t\\tif (isCycleUtil(visited, curRec, i))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] res = new int[V];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (Integer i : l) {\\n\\t\\t\\t\\tres[index] = i;\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isCycleUtil(boolean[] visited, boolean[] curRec, int i) {\\n\\n\\t\\t\\tif (visited[i] == false) {\\n\\n\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\tcurRec[i] = true;\\n\\n\\t\\t\\t\\tList<Integer> neighbours = edges.get(i);\\n\\t\\t\\t\\tfor (Integer v : neighbours) {\\n\\n\\t\\t\\t\\t\\tif (!visited[v] && isCycleUtil(visited, curRec, v))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (curRec[v])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl.add(new Integer(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurRec[i] = false;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\t\\tDetectCycleGraph graph = new DetectCycleGraph(numCourses);\\n\\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n\\t\\t\\tint[] sub = prerequisites[i];\\n\\t\\t\\tgraph.addEdge(sub[0], sub[1]);\\n\\t\\t}\\n\\t\\treturn graph.isCycle(graph);\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class DetectCycleGraph {\\n\\t\\tprivate int V;\\n\\t\\tprivate List<List<Integer>> edges;\\n\\n\\t\\tDetectCycleGraph(int n) {\\n\\t\\t\\tthis.V = n;\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t\\tedges = new ArrayList<>();\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tedges.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic DetectCycleGraph() {\\n\\t\\t}\\n\\n\\t\\tprivate void addEdge(int i, int j) {\\n\\t\\t\\tedges.get(i).add(j);\\n\\t\\t}\\n\\n\\t\\tList<Integer> l = new ArrayList<>();\\n\\n\\t\\tpublic int[] isCycle(DetectCycleGraph graph) {\\n\\n\\t\\t\\tboolean[] visited = new boolean[this.V];\\n\\t\\t\\tboolean[] curRec = new boolean[this.V];\\n\\t\\t\\tfor (int i = 0; i < this.V; i++) {\\n\\t\\t\\t\\tif (isCycleUtil(visited, curRec, i))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] res = new int[V];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (Integer i : l) {\\n\\t\\t\\t\\tres[index] = i;\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isCycleUtil(boolean[] visited, boolean[] curRec, int i) {\\n\\n\\t\\t\\tif (visited[i] == false) {\\n\\n\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\tcurRec[i] = true;\\n\\n\\t\\t\\t\\tList<Integer> neighbours = edges.get(i);\\n\\t\\t\\t\\tfor (Integer v : neighbours) {\\n\\n\\t\\t\\t\\t\\tif (!visited[v] && isCycleUtil(visited, curRec, v))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (curRec[v])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl.add(new Integer(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurRec[i] = false;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\t\\tDetectCycleGraph graph = new DetectCycleGraph(numCourses);\\n\\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n\\t\\t\\tint[] sub = prerequisites[i];\\n\\t\\t\\tgraph.addEdge(sub[0], sub[1]);\\n\\t\\t}\\n\\t\\treturn graph.isCycle(graph);\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59460,
                "title": "java-5-6ms-dfs-solution",
                "content": "To keep the dfs algorithm from loop, I used 0, 1, 2 to represent the states of \"unvisited\", \"visiting\", \"visited\", respectively.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List[] course=new List[numCourses];\\n        int[] map=new int[numCourses];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        for(int i=0;i<numCourses;i++)\\n        course[i]=new ArrayList<Integer>();\\n        for(int i=0;i<prerequisites.length;i++)\\n        course[prerequisites[i][0]].add(prerequisites[i][1]);\\n        for(int i=0;i<numCourses;i++)\\n        if(dfs(course,i,ans,map)==false) return new int[0];\\n        int[] an=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        an[i]=ans.get(i);\\n        return an;\\n    }\\n    public boolean dfs(List[] course,int req,List<Integer> ans,int[] map)\\n    {\\n        if(map[req]==0)\\n        {\\n            map[req]=1;\\n            for(int i=0;i<course[req].size();i++) \\n            if(dfs(course,(int)course[req].get(i),ans,map)==false) return false;\\n            map[req]=2;\\n        } \\n        else if(map[req]==1) return false;\\n        else if(map[req]==2) return true;\\n        ans.add(req);\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "To keep the dfs algorithm from loop, I used 0, 1, 2 to represent the states of \"unvisited\", \"visiting\", \"visited\", respectively.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List[] course=new List[numCourses];\\n        int[] map=new int[numCourses];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        for(int i=0;i<numCourses;i++)\\n        course[i]=new ArrayList<Integer>();\\n        for(int i=0;i<prerequisites.length;i++)\\n        course[prerequisites[i][0]].add(prerequisites[i][1]);\\n        for(int i=0;i<numCourses;i++)\\n        if(dfs(course,i,ans,map)==false) return new int[0];\\n        int[] an=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        an[i]=ans.get(i);\\n        return an;\\n    }\\n    public boolean dfs(List[] course,int req,List<Integer> ans,int[] map)\\n    {\\n        if(map[req]==0)\\n        {\\n            map[req]=1;\\n            for(int i=0;i<course[req].size();i++) \\n            if(dfs(course,(int)course[req].get(i),ans,map)==false) return false;\\n            map[req]=2;\\n        } \\n        else if(map[req]==1) return false;\\n        else if(map[req]==2) return true;\\n        ans.add(req);\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1213903,
                "title": "clean-java-dfs-topological-sort-with-comments",
                "content": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\t\\n\\t// build the adjacency list, with each course acting as a node.\\n    List<Integer> [] adj = new ArrayList[numCourses];\\n    for (int i = 0; i < numCourses; i++) adj[i] = new ArrayList<Integer>();\\n    for (int i = 0; i < prerequisites.length; i++) adj[prerequisites[i][0]].add(prerequisites[i][1]);\\n\\n    // this array is to track the visited nodes, initially all nodes are in state 0 (unvisisted).\\n    int[] visited = new int[numCourses];\\n    List<Integer> res = new ArrayList<>();\\n    \\n\\t// perform dfs on each node in the graph as the graph may not be fully connected.\\n    for (int i = 0; i < adj.length; i++) {\\n        if (visited[i] == 0)  {\\n\\t\\t\\t// if cycle found from any node return an empty array.\\n            if (topSort(i, res, adj, visited) == false) return new int[0];\\n        }\\n    }\\n\\t// if no cycles were found we can copy the ArrayList over to an array and return.\\n    int[] ans = new int[res.size()];\\n    for (int i = 0; i < res.size(); i++) ans[i] = res.get(i);\\n    return ans;\\n}\\n\\npublic boolean topSort(int curr, List<Integer> res, List<Integer> [] adj, int[] visited) {\\n    visited[curr] = 1; // mark the current node with state 1 (visiting).\\n    List<Integer> neighbours = adj[curr]; // get all neighbouring nodes.\\n    for (Integer i : neighbours) {\\n\\t\\t// if one of the neighbours is also being visited then there is a cycle.\\n        if(visited[i] == 1) return false; \\n        if (visited[i] == 0) {\\n\\t\\t\\t// perform top sort on all unvisisted neighbours.\\n            if (topSort(i, res, adj, visited) == false) return false;\\n        }\\n    }\\n\\t// mark current node with state 2 (visited) and add it to the list holding the result.\\n    visited[curr] = 2;\\n    res.add(curr);\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\t\\n\\t// build the adjacency list, with each course acting as a node.\\n    List<Integer> [] adj = new ArrayList[numCourses];\\n    for (int i = 0; i < numCourses; i++) adj[i] = new ArrayList<Integer>();\\n    for (int i = 0; i < prerequisites.length; i++) adj[prerequisites[i][0]].add(prerequisites[i][1]);\\n\\n    // this array is to track the visited nodes, initially all nodes are in state 0 (unvisisted).\\n    int[] visited = new int[numCourses];\\n    List<Integer> res = new ArrayList<>();\\n    \\n\\t// perform dfs on each node in the graph as the graph may not be fully connected.\\n    for (int i = 0; i < adj.length; i++) {\\n        if (visited[i] == 0)  {\\n\\t\\t\\t// if cycle found from any node return an empty array.\\n            if (topSort(i, res, adj, visited) == false) return new int[0];\\n        }\\n    }\\n\\t// if no cycles were found we can copy the ArrayList over to an array and return.\\n    int[] ans = new int[res.size()];\\n    for (int i = 0; i < res.size(); i++) ans[i] = res.get(i);\\n    return ans;\\n}\\n\\npublic boolean topSort(int curr, List<Integer> res, List<Integer> [] adj, int[] visited) {\\n    visited[curr] = 1; // mark the current node with state 1 (visiting).\\n    List<Integer> neighbours = adj[curr]; // get all neighbouring nodes.\\n    for (Integer i : neighbours) {\\n\\t\\t// if one of the neighbours is also being visited then there is a cycle.\\n        if(visited[i] == 1) return false; \\n        if (visited[i] == 0) {\\n\\t\\t\\t// perform top sort on all unvisisted neighbours.\\n            if (topSort(i, res, adj, visited) == false) return false;\\n        }\\n    }\\n\\t// mark current node with state 2 (visited) and add it to the list holding the result.\\n    visited[curr] = 2;\\n    res.add(curr);\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947592,
                "title": "java-simple-dfs-3ms",
                "content": "```\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<numCourses;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] pre:prerequisites)\\n            graph.get(pre[1]).add(pre[0]);\\n        \\n        boolean[] checked = new boolean[numCourses];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<numCourses;i++){\\n            boolean[] path = new boolean[numCourses];\\n            if(isCyclic(i,graph,stack,path,checked)==true)\\n                return new int[0];\\n        }\\n        int[] res = new int[numCourses];\\n        for(int i=0;i<numCourses;i++)\\n            res[i] = stack.pop();\\n        return res;\\n    }\\n    \\n    boolean isCyclic(int node,List<List<Integer>> graph,Stack<Integer> stack,boolean[] path,boolean[] checked){\\n        if(checked[node]==true)\\n            return false;\\n        if(path[node]==true)\\n            return true;\\n        path[node] = true;\\n        for(int adj:graph.get(node)){\\n            if(isCyclic(adj,graph,stack,path,checked)==true)\\n                return true;\\n        }\\n        stack.push(node);\\n        path[node] = false;\\n        checked[node] = true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<numCourses;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] pre:prerequisites)\\n            graph.get(pre[1]).add(pre[0]);\\n        \\n        boolean[] checked = new boolean[numCourses];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<numCourses;i++){\\n            boolean[] path = new boolean[numCourses];\\n            if(isCyclic(i,graph,stack,path,checked)==true)\\n                return new int[0];\\n        }\\n        int[] res = new int[numCourses];\\n        for(int i=0;i<numCourses;i++)\\n            res[i] = stack.pop();\\n        return res;\\n    }\\n    \\n    boolean isCyclic(int node,List<List<Integer>> graph,Stack<Integer> stack,boolean[] path,boolean[] checked){\\n        if(checked[node]==true)\\n            return false;\\n        if(path[node]==true)\\n            return true;\\n        path[node] = true;\\n        for(int adj:graph.get(node)){\\n            if(isCyclic(adj,graph,stack,path,checked)==true)\\n                return true;\\n        }\\n        stack.push(node);\\n        path[node] = false;\\n        checked[node] = true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59538,
                "title": "standard-bfs-method-for-course-schedule-ii",
                "content": "The idea is to start from courses upon which no other courses will depend(These courses all have the least  priority and should come at the last in the order list).  Then do standard BFS on these courses and try to find  courses that have next level of priority(These courses will come right before the least priority courses in the order list). And continue the process until we have no more courses to deal with. If there is no cycle in the prerequisites graph, then in this way we should be able to deal with all the courses. Otherwise there will be remaining courses left untended.  See the comments in the code for more information.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t// for each course in the map nextVertex, the corresponding set contains prerequisite courses for this course \\n        Map<Integer, Set<Integer>> nextVertex = new HashMap<>();\\n        // preVertex[i] indicates the number of courses that depend on course i\\n        int[] preVertex = new int[numCourses];\\n        \\n        // set up nextVertex and preVertex\\n        for (int i = 0; i < prerequisites.length; i++) {\\n        \\tif (!nextVertex.containsKey(prerequisites[i][0])) {\\n        \\t\\tnextVertex.put(prerequisites[i][0], new HashSet<>());\\n        \\t}\\n        \\t\\n        \\tif (nextVertex.get(prerequisites[i][0]).add(prerequisites[i][1])) {\\n        \\t\\tpreVertex[prerequisites[i][1]]++;\\n        \\t}\\n        }\\n        \\n        // queue for BFS, which will only hold courses currently upon which no other courses depend\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < preVertex.length; i++) {\\n        \\t// start from courses upon which no other courses depend. These courses should come last in the order list\\n        \\tif (preVertex[i] == 0) {\\n        \\t\\tqueue.offerLast(i);\\n        \\t}\\n        }\\n        \\n        // array for the result, which will be filled up from the end by index\\n        int[] res = new int[numCourses];\\n        int index = res.length - 1;\\n        \\n        while (!queue.isEmpty()) {\\n        \\tint key = queue.pollFirst(); // this is a course that no other courses will depend upon\\n        \\tres[index--] = key;          // so we put it at the end of the order list\\n        \\t\\n        \\t// since we are done with course \"key\", for any other course that course \"key\" is dependent on, we can decrease\\n        \\t// the corrresponding preVertex by one and check if it is qualified to be added to the queue.\\n        \\tif (nextVertex.containsKey(key)) {\\n        \\t\\tfor (int i : nextVertex.get(key)) {\\n        \\t\\t\\tif (--preVertex[i] == 0) {\\n        \\t\\t\\t\\tqueue.offerLast(i);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\t\\n        \\t--numCourses; // we are done with course \"key\", so reduce the remaining number of courses by 1\\n        }\\n        \\n        // if the remaining number of courses is not zero, then we cannot complete all the courses; otherwise return the result\\n        return numCourses == 0 ? res : new int[0];\\n    }",
                "solutionTags": [],
                "code": "The idea is to start from courses upon which no other courses will depend(These courses all have the least  priority and should come at the last in the order list).  Then do standard BFS on these courses and try to find  courses that have next level of priority(These courses will come right before the least priority courses in the order list). And continue the process until we have no more courses to deal with. If there is no cycle in the prerequisites graph, then in this way we should be able to deal with all the courses. Otherwise there will be remaining courses left untended.  See the comments in the code for more information.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t// for each course in the map nextVertex, the corresponding set contains prerequisite courses for this course \\n        Map<Integer, Set<Integer>> nextVertex = new HashMap<>();\\n        // preVertex[i] indicates the number of courses that depend on course i\\n        int[] preVertex = new int[numCourses];\\n        \\n        // set up nextVertex and preVertex\\n        for (int i = 0; i < prerequisites.length; i++) {\\n        \\tif (!nextVertex.containsKey(prerequisites[i][0])) {\\n        \\t\\tnextVertex.put(prerequisites[i][0], new HashSet<>());\\n        \\t}\\n        \\t\\n        \\tif (nextVertex.get(prerequisites[i][0]).add(prerequisites[i][1])) {\\n        \\t\\tpreVertex[prerequisites[i][1]]++;\\n        \\t}\\n        }\\n        \\n        // queue for BFS, which will only hold courses currently upon which no other courses depend\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < preVertex.length; i++) {\\n        \\t// start from courses upon which no other courses depend. These courses should come last in the order list\\n        \\tif (preVertex[i] == 0) {\\n        \\t\\tqueue.offerLast(i);\\n        \\t}\\n        }\\n        \\n        // array for the result, which will be filled up from the end by index\\n        int[] res = new int[numCourses];\\n        int index = res.length - 1;\\n        \\n        while (!queue.isEmpty()) {\\n        \\tint key = queue.pollFirst(); // this is a course that no other courses will depend upon\\n        \\tres[index--] = key;          // so we put it at the end of the order list\\n        \\t\\n        \\t// since we are done with course \"key\", for any other course that course \"key\" is dependent on, we can decrease\\n        \\t// the corrresponding preVertex by one and check if it is qualified to be added to the queue.\\n        \\tif (nextVertex.containsKey(key)) {\\n        \\t\\tfor (int i : nextVertex.get(key)) {\\n        \\t\\t\\tif (--preVertex[i] == 0) {\\n        \\t\\t\\t\\tqueue.offerLast(i);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\t\\n        \\t--numCourses; // we are done with course \"key\", so reduce the remaining number of courses by 1\\n        }\\n        \\n        // if the remaining number of courses is not zero, then we cannot complete all the courses; otherwise return the result\\n        return numCourses == 0 ? res : new int[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3530515,
                "title": "c-solution-topological-sort-kahn-s-algorithm",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(V + E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); \\n        vector<int> indegree(numCourses, 0); \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9bcb26b6-4375-43e4-93c7-c60a0e0d583b_1684235159.5613005.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); \\n        vector<int> indegree(numCourses, 0); \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406618,
                "title": "python-96-95-faster-bfs-dfs-explained",
                "content": "**In this question we have applied topological sorting method**\\n\\n**DFS Solution:**\\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:# this course had not been added into the res, but visited again; there is a cycle!\\n                return False\\n            if visited[sv]==1:# this course had been successfully added into the res\\n                return True\\n            visited[sv]=-1 # set the current course as currently being visited\\n            for u in adj[sv]:\\n                if not dfs(u,visited):\\n                    return False # if there is a cycle detected at any point, terminate!\\n            res.append(sv) # no cycle found, dfs finished, good to add the course into the res\\n            visited[sv]=1  # this course finished\\n            return True\\n        \\n        adj=[[] for i in range(numCourses)]\\n        res=[]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        for i in range(numCourses):\\n            if not dfs(i,visited):\\n                # if False, there must be a cycle; terminate by returning an empty list\\n                return []\\n        return res[::-1]\\n```\\n\\n**BFS Solution:**\\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        adj=[[] for i in range(numCourses)]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        indeg=[0]*numCourses\\n        res=[]\\n        q=deque()\\n        for i in range(numCourses):\\n            for j in adj[i]:\\n                indeg[j]+=1\\n        for i in range(numCourses):\\n            if indeg[i]==0:\\n                q.append(i)\\n        while q:\\n            u=q.popleft()\\n            res.append(u)\\n            for i in adj[u]:\\n                if indeg[i]!=0:\\n                    indeg[i]-=1\\n                if indeg[i]==0:\\n                    q.append(i)\\n        if len(res)!=numCourses:\\n            return []\\n        return res\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:# this course had not been added into the res, but visited again; there is a cycle!\\n                return False\\n            if visited[sv]==1:# this course had been successfully added into the res\\n                return True\\n            visited[sv]=-1 # set the current course as currently being visited\\n            for u in adj[sv]:\\n                if not dfs(u,visited):\\n                    return False # if there is a cycle detected at any point, terminate!\\n            res.append(sv) # no cycle found, dfs finished, good to add the course into the res\\n            visited[sv]=1  # this course finished\\n            return True\\n        \\n        adj=[[] for i in range(numCourses)]\\n        res=[]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        for i in range(numCourses):\\n            if not dfs(i,visited):\\n                # if False, there must be a cycle; terminate by returning an empty list\\n                return []\\n        return res[::-1]\\n```\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        adj=[[] for i in range(numCourses)]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        indeg=[0]*numCourses\\n        res=[]\\n        q=deque()\\n        for i in range(numCourses):\\n            for j in adj[i]:\\n                indeg[j]+=1\\n        for i in range(numCourses):\\n            if indeg[i]==0:\\n                q.append(i)\\n        while q:\\n            u=q.popleft()\\n            res.append(u)\\n            for i in adj[u]:\\n                if indeg[i]!=0:\\n                    indeg[i]-=1\\n                if indeg[i]==0:\\n                    q.append(i)\\n        if len(res)!=numCourses:\\n            return []\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1398163,
                "title": "c-topological-sort-each-line-clearly-explained",
                "content": "# Feel free to ask your doubts in comment \\n**There are 2 ways of Topological Sort**\\n* DFS \\n* BFS ( Kahn\\'s algorithm ) \\n\\nI have used Kahn\\'s algorithm, each and every line is having comment\\n\\n* **Time Complexity** : O( numCourses + prerequesties.size() ) \\n* **Space Complexity** : O( numCourses )\\n\\n```\\n// Questions directly hints of topological sort\\n// I will be doing topological sort using BFS which is popularly known as Kahn\\'s algorithm\\nclass Solution {\\npublic:\\n    vector<int> topologicalSort( vector<vector<int>>& G, int n ){\\n        vector<int> indegree( n, 0 ); // it keeps the track of number of incoming edges \\n        for( auto v : G ){\\n            for( auto u : v )\\n                indegree[u]++; // filling the indegree array\\n        }\\n        vector<int> ans; // this will contain the ordered courses\\n        queue<int> q; \\n        \\n        // now there will be atleast one node which will have no incoming edge\\n        // if there is no such node, course cant be finished as there is cycle \\n        // we will find the independent nodes and insert in queue\\n        for( int i=0; i<n; i++ )\\n            if( !indegree[i] ) \\n                q.push( i );\\n        \\n        // now the idea is to, pop each node, i.e. we will be doing independent courses one by one \\n        // and offcourse if a course will be done, the dependencies of its children will be decreased by 1\\n        // ans we will keep checking if the dependency of any node gets 0, if it gets 0, we will insert it into queue\\n        \\n        while( !q.empty() ){\\n            int v = q.front(); \\n            q.pop(); // independent course is done \\n            ans.push_back( v ); // pushed the course in answer vector \\n            \\n            // iterate on courses which were dependent on this course \\n            for( auto u : G[v] ){\\n                indegree[ u ]--; // decreasing the dependency\\n                if( !indegree[u] ) // checking if dependency became 0\\n                    q.push( u ); // pushed in queue to complete the course \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<vector<int>> G(n); // declare a adjacency list graph vector\\n        for( auto v : p ) // iterate over prerequesties to make graph\\n            G[ v[1] ].push_back( v[0] ); // v[1] need to be done before v[0], so edge from v[1]->v[0]\\n        \\n        auto orderedCourse = topologicalSort( G, n ); // ordered the course \\n        \\n        // now I need to check if all the courses are there in the ordered list \\n        // if yes => return \\n        if( orderedCourse.size() == n ) return orderedCourse;\\n        \\n        // if no => Courses can not be finished bcz. there might be cycle \\n        else return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// Questions directly hints of topological sort\\n// I will be doing topological sort using BFS which is popularly known as Kahn\\'s algorithm\\nclass Solution {\\npublic:\\n    vector<int> topologicalSort( vector<vector<int>>& G, int n ){\\n        vector<int> indegree( n, 0 ); // it keeps the track of number of incoming edges \\n        for( auto v : G ){\\n            for( auto u : v )\\n                indegree[u]++; // filling the indegree array\\n        }\\n        vector<int> ans; // this will contain the ordered courses\\n        queue<int> q; \\n        \\n        // now there will be atleast one node which will have no incoming edge\\n        // if there is no such node, course cant be finished as there is cycle \\n        // we will find the independent nodes and insert in queue\\n        for( int i=0; i<n; i++ )\\n            if( !indegree[i] ) \\n                q.push( i );\\n        \\n        // now the idea is to, pop each node, i.e. we will be doing independent courses one by one \\n        // and offcourse if a course will be done, the dependencies of its children will be decreased by 1\\n        // ans we will keep checking if the dependency of any node gets 0, if it gets 0, we will insert it into queue\\n        \\n        while( !q.empty() ){\\n            int v = q.front(); \\n            q.pop(); // independent course is done \\n            ans.push_back( v ); // pushed the course in answer vector \\n            \\n            // iterate on courses which were dependent on this course \\n            for( auto u : G[v] ){\\n                indegree[ u ]--; // decreasing the dependency\\n                if( !indegree[u] ) // checking if dependency became 0\\n                    q.push( u ); // pushed in queue to complete the course \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<vector<int>> G(n); // declare a adjacency list graph vector\\n        for( auto v : p ) // iterate over prerequesties to make graph\\n            G[ v[1] ].push_back( v[0] ); // v[1] need to be done before v[0], so edge from v[1]->v[0]\\n        \\n        auto orderedCourse = topologicalSort( G, n ); // ordered the course \\n        \\n        // now I need to check if all the courses are there in the ordered list \\n        // if yes => return \\n        if( orderedCourse.size() == n ) return orderedCourse;\\n        \\n        // if no => Courses can not be finished bcz. there might be cycle \\n        else return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447774,
                "title": "java-topological-sort-dfs-3ms",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> list = new ArrayList<>(numCourses);\\n        for(int i = 0; i < numCourses; i++) list.add(new ArrayList<Integer>());\\n        for(int[] p: prerequisites) list.get(p[0]).add(p[1]);\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        // 0: not visited | 1: visited | 2: visiting\\n        int[] visited = new int[numCourses];\\n        for(int i = 0; i < numCourses; i++) {\\n            if(dfs(list, visited, i, arr)) return new int[0];\\n        }\\n        \\n        int[] res = new int[arr.size()];\\n        for(int i = 0; !arr.isEmpty(); i++) res[i] = arr.remove(0);\\n        return res;\\n    }\\n    \\n    private boolean dfs(List<List<Integer>> list, int[] visited, int cur, List<Integer> arr) {\\n        if(visited[cur] == 2) return true;\\n        if(visited[cur] == 1) return false;\\n        visited[cur] = 2;\\n        for(int next: list.get(cur)) {\\n            if(dfs(list, visited, next, arr)) return true;\\n        }\\n        visited[cur] = 1;\\n        arr.add(cur);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> list = new ArrayList<>(numCourses);\\n        for(int i = 0; i < numCourses; i++) list.add(new ArrayList<Integer>());\\n        for(int[] p: prerequisites) list.get(p[0]).add(p[1]);\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        // 0: not visited | 1: visited | 2: visiting\\n        int[] visited = new int[numCourses];\\n        for(int i = 0; i < numCourses; i++) {\\n            if(dfs(list, visited, i, arr)) return new int[0];\\n        }\\n        \\n        int[] res = new int[arr.size()];\\n        for(int i = 0; !arr.isEmpty(); i++) res[i] = arr.remove(0);\\n        return res;\\n    }\\n    \\n    private boolean dfs(List<List<Integer>> list, int[] visited, int cur, List<Integer> arr) {\\n        if(visited[cur] == 2) return true;\\n        if(visited[cur] == 1) return false;\\n        visited[cur] = 2;\\n        for(int next: list.get(cur)) {\\n            if(dfs(list, visited, next, arr)) return true;\\n        }\\n        visited[cur] = 1;\\n        arr.add(cur);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203087,
                "title": "python-solution",
                "content": "We first build a directed graph `G` from `prerequisites`. The nodes are `0` to `n-1`, and there is an edge from `i` to `j` if `i` is the prerequisite of `j`. Then to get a correct order of the courses, we just need to topologically sort the graph, so that if there is an edge from `i` to `j` in `G`, `i` comes before `j` in the ordering.\\n\\nWe start by labelling each node `0`, meaning that they have not been dfs visited. We initialize a queue `res`. We iterate `i` in `range(numCourses)`, and if `i` has not been dfs visited, we dfs visit `i`. If any of such dfs visits return `False`, we return the empty list because the graph is not acyclic and cannot be topologically sorted; Else we return `list(res)`. For the dfs visit procedure, we first label `i` to be `1`, meaning that we are currently dfs visiting the descendants of `i` in the dfs tree. Then for each neighbor `j` of `i`, If `j` has label `1`, then `j` is a predecessor of `i` in the dfs visit, and ` i -> j` is a back edge, so the graph contains a cycle, we return `False`; Else if `j` has label `0`, it has not been visited, and we need to do `dfs(j)`. If `dfs(j)` returns `False`, it means that the dfs subgraph starting with `j` contains a cycle, and we need to return `False`. Finally, if no `dfs(j)` returns `False`, it means that the dfs subgraph starting with `i` is acyclic, we label `i` to be `2`, meaning that we finished dfs searches all the descendants of `i`, and append `i` to the head of the queue `res`, and we return `True`.\\n\\nThe time complexity is O(n+m), and the space complexity is O(n+m), where `n = numCourses`, and `m = len(prerequisites)`.\\n```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(i):\\n            color[i] = 1\\n            if i in graph:\\n                for j in graph[i]:\\n                    if color[j] == 1:\\n                        return False\\n                    elif color[j] == 0:\\n                        if not dfs(j):\\n                            return False\\n            res.appendleft(i)\\n            color[i] = 2\\n            return True\\n                            \\n        graph = {}\\n        for pair in prerequisites:\\n            if pair[1] in graph:\\n                graph[pair[1]].add(pair[0])\\n            else:\\n                graph[pair[1]] = set([pair[0]])\\n        color = [0]*numCourses\\n        res = collections.deque([])\\n        for i in range(numCourses):\\n            if color[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(i):\\n            color[i] = 1\\n            if i in graph:\\n                for j in graph[i]:\\n                    if color[j] == 1:\\n                        return False\\n                    elif color[j] == 0:\\n                        if not dfs(j):\\n                            return False\\n            res.appendleft(i)\\n            color[i] = 2\\n            return True\\n                            \\n        graph = {}\\n        for pair in prerequisites:\\n            if pair[1] in graph:\\n                graph[pair[1]].add(pair[0])\\n            else:\\n                graph[pair[1]] = set([pair[0]])\\n        color = [0]*numCourses\\n        res = collections.deque([])\\n        for i in range(numCourses):\\n            if color[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59475,
                "title": "a-simple-java-solution-with-queue",
                "content": "\\tpublic static int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\tint[] result = new int[numCourses];\\n\\t\\tint[] preCnt = new int[numCourses];\\n\\t\\tList<Integer>[] nextSet = new List[numCourses];\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tnextSet[i] = new ArrayList<>();\\n\\n\\t\\tfor(int[] p : prerequisites) {\\n\\t\\t\\tpreCnt[p[0]]++;\\n\\t\\t\\tnextSet[p[1]].add(p[0]);\\n\\t\\t}\\n\\n\\t\\tQueue<Integer> sourceNode = new LinkedList<Integer>();\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tif(preCnt[i] == 0)\\n\\t\\t\\t\\tsourceNode.add(i);\\n\\t\\t\\n\\t\\tfor(int i=0; i<numCourses; i++) {\\n\\t\\t\\tif(sourceNode.isEmpty())\\n\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\tint n = sourceNode.poll();\\n\\t\\t\\tresult[i] = n;\\n\\t\\t\\tfor(int next : nextSet[n]) {\\n\\t\\t\\t\\tpreCnt[next]--;\\n\\t\\t\\t\\tif(preCnt[next] == 0)\\n\\t\\t\\t\\t\\tsourceNode.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\nHere we keep adding those nodes has no incoming vertex source node. And once it's added, it will be removed from the graph and update the preCnt of the destination nodes. I use preCnt[i] to keep track the number of incomming vertex and use queue sourceNode to keep track the remain source node.",
                "solutionTags": [],
                "code": "\\tpublic static int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\tint[] result = new int[numCourses];\\n\\t\\tint[] preCnt = new int[numCourses];\\n\\t\\tList<Integer>[] nextSet = new List[numCourses];\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tnextSet[i] = new ArrayList<>();\\n\\n\\t\\tfor(int[] p : prerequisites) {\\n\\t\\t\\tpreCnt[p[0]]++;\\n\\t\\t\\tnextSet[p[1]].add(p[0]);\\n\\t\\t}\\n\\n\\t\\tQueue<Integer> sourceNode = new LinkedList<Integer>();\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tif(preCnt[i] == 0)\\n\\t\\t\\t\\tsourceNode.add(i);\\n\\t\\t\\n\\t\\tfor(int i=0; i<numCourses; i++) {\\n\\t\\t\\tif(sourceNode.isEmpty())\\n\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\tint n = sourceNode.poll();\\n\\t\\t\\tresult[i] = n;\\n\\t\\t\\tfor(int next : nextSet[n]) {\\n\\t\\t\\t\\tpreCnt[next]--;\\n\\t\\t\\t\\tif(preCnt[next] == 0)\\n\\t\\t\\t\\t\\tsourceNode.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\nHere we keep adding those nodes has no incoming vertex source node. And once it's added, it will be removed from the graph and update the preCnt of the destination nodes. I use preCnt[i] to keep track the number of incomming vertex and use queue sourceNode to keep track the remain source node.",
                "codeTag": "Unknown"
            },
            {
                "id": 3300472,
                "title": "best-dfs-bfs-solution",
                "content": "# Approach 1\\nDFS\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, vector<int> adj[], vector<int>& vis, vector <int>& tasks) {\\n        vis[node] = 2;\\n        for (auto it: adj[node]) {\\n            if (vis[it] == 0) {\\n                if (dfs(it, adj, vis, tasks) == true)\\n                    return true;\\n            } else if (vis[it] == 2) {\\n                return true;\\n            }\\n        }\\n        tasks.push_back(node);\\n        vis[node] = 1;\\n        return false;  \\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> vis(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        vector <int> tasks;    \\n        for (int i = 0; i < numCourses; i++) {\\n            if (vis[i] == 0) {\\n                if (dfs(i, adj, vis, tasks) == true)\\n                    return {};\\n            }\\n        }\\n        reverse(tasks.begin(), tasks.end());\\n        return tasks;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> indegree(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        for (int i = 0; i < numCourses; i++) \\n            for (auto it: adj[i]) \\n                indegree[it]++;\\n        queue <int> q;        \\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0)\\n                q.push(i);\\n        vector <int> tasks;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            tasks.push_back(node);\\n            for (auto it: adj[node]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if (tasks.size() == numCourses)\\n            return tasks;\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, vector<int> adj[], vector<int>& vis, vector <int>& tasks) {\\n        vis[node] = 2;\\n        for (auto it: adj[node]) {\\n            if (vis[it] == 0) {\\n                if (dfs(it, adj, vis, tasks) == true)\\n                    return true;\\n            } else if (vis[it] == 2) {\\n                return true;\\n            }\\n        }\\n        tasks.push_back(node);\\n        vis[node] = 1;\\n        return false;  \\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> vis(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        vector <int> tasks;    \\n        for (int i = 0; i < numCourses; i++) {\\n            if (vis[i] == 0) {\\n                if (dfs(i, adj, vis, tasks) == true)\\n                    return {};\\n            }\\n        }\\n        reverse(tasks.begin(), tasks.end());\\n        return tasks;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> indegree(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        for (int i = 0; i < numCourses; i++) \\n            for (auto it: adj[i]) \\n                indegree[it]++;\\n        queue <int> q;        \\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0)\\n                q.push(i);\\n        vector <int> tasks;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            tasks.push_back(node);\\n            for (auto it: adj[node]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if (tasks.size() == numCourses)\\n            return tasks;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042868,
                "title": "c-dfs-cycle-check-o-v-e-time-easy-to-understand",
                "content": "We can use DFS to detect cycle by transforming the vector of vector to an array of vectors (for our adjacency list). If we don\\'t detect a cycle, we can finish all the courses. While doing the DFS traversal, add the answer after checking for cycle in the adjacent nodes.\\n\\nTime complexity: O(V + E)\\nSpace complexity: O(V + E)\\n\\n```\\nclass Solution {\\nprivate:\\n    bool checkCycle(int start, vector<int> adjList[], vector<bool> &visited, vector<bool> &dfsCurrentVisit, vector<int> &ans) {\\n        // we visit the start vertex\\n        visited[start] = dfsCurrentVisit[start] = true;\\n        \\n        // for all nodes in the adjacency list of start vertex\\n        for(auto it : adjList[start]) {\\n            // if its not visited and we found a cycle\\n            if(!visited[it] && checkCycle(it, adjList, visited, dfsCurrentVisit, ans))\\n                return true;\\n            // if its visited in the current dfs call\\n            else if(dfsCurrentVisit[it])\\n                return true;\\n        }\\n        // adding start vertex to answer\\n        ans.push_back(start);\\n        // we will return from the current dfs call hence marking it as unvisited\\n        dfsCurrentVisit[start] = false;\\n        return false;\\n    }\\n    \\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites, vector<int> &ans) {\\n        // to label all vertices as visited or not\\n        vector<bool> visited(numCourses, false);\\n        // to label all vertices in the current dfs call as visited or not\\n        vector<bool> dfsCurrentVisit(numCourses, false);\\n        // array of vectors for adjacency list\\n        vector<int> adjList[numCourses];\\n        \\n        // constructing our adjacency list\\n        for(auto it : prerequisites) {\\n            adjList[it[0]].push_back(it[1]);\\n        }\\n        // checking all components for cycle\\n        for(int i = 0; i < numCourses; ++i) {\\n            // if we found a cycle we can\\'t finish all courses\\n            if(!visited[i] && checkCycle(i, adjList, visited, dfsCurrentVisit, ans))\\n                return false;\\n        }\\n        // no cycle so we have an answer\\n        return true;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> ans;\\n        if(numCourses == 1) return {0};\\n        if(canFinish(numCourses, prerequisites, ans))\\n            return ans;\\n        return {};\\n    }\\n};\\n```\\n\\nAnother solution that uses stack and maybe more intuitive according to the problem statement\\n\\n```\\nclass Solution {\\nprivate:\\n    bool isCycleDFS(int start, vector<int> adjList[], vector<bool> &visited, \\n                    vector<bool> &dfsVisit, stack<int> &courseDFS) {\\n        visited[start] = dfsVisit[start] = true;\\n        for(int adjNode : adjList[start]) {\\n            if(!visited[adjNode] and isCycleDFS(adjNode, adjList, visited, dfsVisit, courseDFS))\\n                return true;\\n            else if(dfsVisit[adjNode])\\n                return true;\\n        }\\n        dfsVisit[start] = false;\\n        courseDFS.push(start);\\n        return false;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        // lets first create our graph using adjacency list representation\\n        vector<int> adjList[numCourses];\\n        for(auto prereq : prerequisites)\\n            adjList[prereq[1]].push_back(prereq[0]);\\n        \\n        // now we will use DFS to iterate over our graph and check if we see a cycle\\n        // if we don\\'t see a cycle we will return our answer\\n        vector<int> courseOrder;\\n        stack<int> courseDFS;\\n        vector<bool> visited(numCourses), dfsVisit(numCourses);\\n        \\n        for(int i = 0; i < numCourses; ++i) {\\n            if(!visited[i] and isCycleDFS(i, adjList, visited, dfsVisit, courseDFS))\\n                return {};\\n        }\\n        // now add the courses done from the stack into our answer\\n        while(!courseDFS.empty()) {\\n            courseOrder.push_back(courseDFS.top());\\n            courseDFS.pop();\\n        }\\n        return courseOrder;\\n    }\\n};\\n```\\n\\nThanks for reading. An upvote would be appreciated. ^_^",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool checkCycle(int start, vector<int> adjList[], vector<bool> &visited, vector<bool> &dfsCurrentVisit, vector<int> &ans) {\\n        // we visit the start vertex\\n        visited[start] = dfsCurrentVisit[start] = true;\\n        \\n        // for all nodes in the adjacency list of start vertex\\n        for(auto it : adjList[start]) {\\n            // if its not visited and we found a cycle\\n            if(!visited[it] && checkCycle(it, adjList, visited, dfsCurrentVisit, ans))\\n                return true;\\n            // if its visited in the current dfs call\\n            else if(dfsCurrentVisit[it])\\n                return true;\\n        }\\n        // adding start vertex to answer\\n        ans.push_back(start);\\n        // we will return from the current dfs call hence marking it as unvisited\\n        dfsCurrentVisit[start] = false;\\n        return false;\\n    }\\n    \\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites, vector<int> &ans) {\\n        // to label all vertices as visited or not\\n        vector<bool> visited(numCourses, false);\\n        // to label all vertices in the current dfs call as visited or not\\n        vector<bool> dfsCurrentVisit(numCourses, false);\\n        // array of vectors for adjacency list\\n        vector<int> adjList[numCourses];\\n        \\n        // constructing our adjacency list\\n        for(auto it : prerequisites) {\\n            adjList[it[0]].push_back(it[1]);\\n        }\\n        // checking all components for cycle\\n        for(int i = 0; i < numCourses; ++i) {\\n            // if we found a cycle we can\\'t finish all courses\\n            if(!visited[i] && checkCycle(i, adjList, visited, dfsCurrentVisit, ans))\\n                return false;\\n        }\\n        // no cycle so we have an answer\\n        return true;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> ans;\\n        if(numCourses == 1) return {0};\\n        if(canFinish(numCourses, prerequisites, ans))\\n            return ans;\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool isCycleDFS(int start, vector<int> adjList[], vector<bool> &visited, \\n                    vector<bool> &dfsVisit, stack<int> &courseDFS) {\\n        visited[start] = dfsVisit[start] = true;\\n        for(int adjNode : adjList[start]) {\\n            if(!visited[adjNode] and isCycleDFS(adjNode, adjList, visited, dfsVisit, courseDFS))\\n                return true;\\n            else if(dfsVisit[adjNode])\\n                return true;\\n        }\\n        dfsVisit[start] = false;\\n        courseDFS.push(start);\\n        return false;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        // lets first create our graph using adjacency list representation\\n        vector<int> adjList[numCourses];\\n        for(auto prereq : prerequisites)\\n            adjList[prereq[1]].push_back(prereq[0]);\\n        \\n        // now we will use DFS to iterate over our graph and check if we see a cycle\\n        // if we don\\'t see a cycle we will return our answer\\n        vector<int> courseOrder;\\n        stack<int> courseDFS;\\n        vector<bool> visited(numCourses), dfsVisit(numCourses);\\n        \\n        for(int i = 0; i < numCourses; ++i) {\\n            if(!visited[i] and isCycleDFS(i, adjList, visited, dfsVisit, courseDFS))\\n                return {};\\n        }\\n        // now add the courses done from the stack into our answer\\n        while(!courseDFS.empty()) {\\n            courseOrder.push_back(courseDFS.top());\\n            courseDFS.pop();\\n        }\\n        return courseOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416975,
                "title": "python-clean-and-easy-to-understand-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        graph, self.stack, self.visited = defaultdict(list), [], {}\\n        for f,t in prerequisites:\\n            graph[t].append(f)\\n\\n        for i in range(numCourses):\\n            if i not in self.visited:\\n                self.dfs(graph,i)\\n                \\n        return list(reversed(self.stack)) if len(self.stack) == numCourses else []\\n    \\n    def dfs(self,graph,i):\\n\\t# visited[i] will be true for every i that is still in call stack, to catch a cycle if any.\\n\\t\\n        self.visited[i] = True\\n        for nbr in graph[i]:\\n            if nbr not in self.visited:\\n                self.dfs(graph,nbr)\\n\\t\\t\\t\\t# indicating that there is cycle in the graph,\\n\\t\\t\\t\\t# returning here will result in len(stack) being < 0 which will return []\\n\\t\\t\\t\\t# as topological sort is not for cyclic graph\\n            elif nbr in self.visited and self.visited[nbr]:\\n                return\\n\\t\\n\\t#before returning form dfs add i to stack and make visited[i] False, as not in call stack anymore.\\n\\t\\n        self.stack.append(i)\\n        self.visited[i] = False\\n```\\n* Read about **Topological Sort** to better understand this problem",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        graph, self.stack, self.visited = defaultdict(list), [], {}\\n        for f,t in prerequisites:\\n            graph[t].append(f)\\n\\n        for i in range(numCourses):\\n            if i not in self.visited:\\n                self.dfs(graph,i)\\n                \\n        return list(reversed(self.stack)) if len(self.stack) == numCourses else []\\n    \\n    def dfs(self,graph,i):\\n\\t# visited[i] will be true for every i that is still in call stack, to catch a cycle if any.\\n\\t\\n        self.visited[i] = True\\n        for nbr in graph[i]:\\n            if nbr not in self.visited:\\n                self.dfs(graph,nbr)\\n\\t\\t\\t\\t# indicating that there is cycle in the graph,\\n\\t\\t\\t\\t# returning here will result in len(stack) being < 0 which will return []\\n\\t\\t\\t\\t# as topological sort is not for cyclic graph\\n            elif nbr in self.visited and self.visited[nbr]:\\n                return\\n\\t\\n\\t#before returning form dfs add i to stack and make visited[i] False, as not in call stack anymore.\\n\\t\\n        self.stack.append(i)\\n        self.visited[i] = False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026664,
                "title": "clean-javascript-dfs-solution",
                "content": "**Runtime: 84 ms, faster than 99.24% of JavaScript online submissions for Course Schedule II.**\\n\\n```\\nlet visited;\\nlet graph;\\nlet stack;\\n\\nvar findOrder = function(numCourses, prerequisites) {\\n    \\n    graph = new Map();\\n    visited = new Array(numCourses).fill(0);\\n    stack = new Array();\\n    \\n    for(let [v, e] of prerequisites){\\n        if(graph.has(v)){\\n            let values = graph.get(v);\\n            values.push(e);\\n            graph.set(v, values)\\n        } else {\\n            graph.set(v, [e])\\n        }\\n    }\\n    \\n    for(let i = 0; i < numCourses; i++){\\n        if(visited[i] == 0 && DFS(i)) return [];\\n    }\\n    \\n    return stack;\\n}\\n\\n\\nfunction DFS(index){\\n    \\n    visited[index] = 1;\\n    let edges = graph.get(index);\\n    \\n    if(edges){\\n        for(let e of edges){\\n            if(visited[e] == 1) return true;\\n            if(visited[e] == 0 && DFS(e)) return true\\n        }  \\n    }\\n  \\n    visited[index] = 2;\\n    stack.push(index)\\n    return false\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nlet visited;\\nlet graph;\\nlet stack;\\n\\nvar findOrder = function(numCourses, prerequisites) {\\n    \\n    graph = new Map();\\n    visited = new Array(numCourses).fill(0);\\n    stack = new Array();\\n    \\n    for(let [v, e] of prerequisites){\\n        if(graph.has(v)){\\n            let values = graph.get(v);\\n            values.push(e);\\n            graph.set(v, values)\\n        } else {\\n            graph.set(v, [e])\\n        }\\n    }\\n    \\n    for(let i = 0; i < numCourses; i++){\\n        if(visited[i] == 0 && DFS(i)) return [];\\n    }\\n    \\n    return stack;\\n}\\n\\n\\nfunction DFS(index){\\n    \\n    visited[index] = 1;\\n    let edges = graph.get(index);\\n    \\n    if(edges){\\n        for(let e of edges){\\n            if(visited[e] == 1) return true;\\n            if(visited[e] == 0 && DFS(e)) return true\\n        }  \\n    }\\n  \\n    visited[index] = 2;\\n    stack.push(index)\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357095,
                "title": "swift-solution-dfs-straightforward-beats-100",
                "content": "```\\nclass Solution {\\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n        var preCourses = [Int:[Int]]()\\n        var order = [Int]()\\n        var isVisited = [Int:Bool]() // store each course visit status\\n        \\n        // store info in dict\\n        for relation in prerequisites {\\n            preCourses[relation[0], default: []].append(relation[1])\\n        }\\n        \\n        for course in 0..<numCourses {\\n            guard dfs(course, preCourses, &order, &isVisited) else { return [] } // when exists circle, there is no chance to show an order\\n        }\\n        return order\\n    }\\n    \\n    func dfs(_ course: Int, _ preCourses: [Int:[Int]], _ order: inout [Int], _ isVisited: inout [Int:Bool]) -> Bool {\\n        // check if fully visited;if checked unfully visited, which means existing circles, we return false and terminate searching\\n        if let fullyVisited = isVisited[course] { return fullyVisited } \\n        \\n        isVisited[course] = false // when start to visit\\n        \\n        for preCourse in preCourses[course] ?? [] {\\n            guard dfs(preCourse, preCourses, &order, &isVisited) else { return false }\\n        }\\n        \\n        isVisited[course] = true // when fully visited\\n        order.append(course)\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n        var preCourses = [Int:[Int]]()\\n        var order = [Int]()\\n        var isVisited = [Int:Bool]() // store each course visit status\\n        \\n        // store info in dict\\n        for relation in prerequisites {\\n            preCourses[relation[0], default: []].append(relation[1])\\n        }\\n        \\n        for course in 0..<numCourses {\\n            guard dfs(course, preCourses, &order, &isVisited) else { return [] } // when exists circle, there is no chance to show an order\\n        }\\n        return order\\n    }\\n    \\n    func dfs(_ course: Int, _ preCourses: [Int:[Int]], _ order: inout [Int], _ isVisited: inout [Int:Bool]) -> Bool {\\n        // check if fully visited;if checked unfully visited, which means existing circles, we return false and terminate searching\\n        if let fullyVisited = isVisited[course] { return fullyVisited } \\n        \\n        isVisited[course] = false // when start to visit\\n        \\n        for preCourse in preCourses[course] ?? [] {\\n            guard dfs(preCourse, preCourses, &order, &isVisited) else { return false }\\n        }\\n        \\n        isVisited[course] = true // when fully visited\\n        order.append(course)\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458796,
                "title": "dfs-order-of-courses-in-the-graph-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code declares a public class called Solution that implements a method called findOrder with two parameters: an integer numCourses and a 2D integer array prerequisites.\\n\\n- The code declares a list called ans as a public class variable. This list will store the order of courses to be taken.\\n\\n- The code declares a boolean flag called flag as a public class variable and initializes it to true. However, the flag is not used anywhere in the code.\\n\\n- The code creates a hash set called s to keep track of visited courses. This hash set will be used to prevent revisiting courses that have already been processed.\\n\\n- The code creates a hash map called hs to store the prerequisites for each course. The prerequisites are given in the prerequisites array as a list of pairs (c, prereqCourse), where c is the course and prereqCourse is its prerequisite. If a course has no prerequisites, it will not be added to this hash map.\\n\\n- The code loops through all the courses from 0 to numCourses - 1. For each course, it checks if it has been visited before by checking if it is in the hash set s. If the course has not been visited, the code calls the dfs method to perform depth-first search traversal.\\n\\n- The dfs method takes four parameters: a hash set s to keep track of visited courses, an integer i representing the current course being processed, a hash map adj representing the adjacency list of the graph (i.e., the list of courses and their prerequisites), and a hash set curr to keep track of the current path being traversed.\\n\\n- The dfs method first checks if the current course has been visited before by checking if it is in the hash set s. If it has been visited, it returns true. This check ensures that the algorithm does not revisit courses that have already been processed.\\n\\n- If the course does not have any prerequisites (i.e., it is not in the hash map adj), the dfs method adds it to the answer list ans, marks it as visited in the hash set s, and returns true. This check ensures that courses without prerequisites are processed first.\\n\\n- If the course has prerequisites, the dfs method adds the course to the hash set curr to keep track of the current path being traversed.\\n\\n- The dfs method loops through all the prerequisites of the current course and checks if any of them have already been visited (i.e., are in the hash set curr). If any of the prerequisites have already been visited, it returns false, indicating an invalid order of courses. This check ensures that the algorithm does not form a cycle in the graph.\\n\\n- If none of the prerequisites have been visited, the dfs method calls itself recursively with each prerequisite as input. If any of these recursive calls return false, the method also returns false.\\n\\n- If all the prerequisites have been visited, the dfs method removes the current course from the curr hash set, adds it to the answer list ans, marks it as visited in the hash set s, and returns true.\\n\\n- After all the courses have been visited, the findOrder method creates an integer array result of size numCourses and copies the order of courses from the ans list to the result array.\\n\\n- Finally, the findOrder method returns the result array as an \\'int[]\\' array by coverting ArrayList into int[].\\n\\n# Complexity\\n- Time complexity:\\n ```\\nThe overall time complexity of the code is O(N^2).\\n```\\n- Space complexity:\\n ```\\nThe overall Space complexity of the code is O(N^2).\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> ans = new ArrayList<>();\\n    boolean flag = true;\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        HashSet<Integer> s = new HashSet<>();\\n        HashMap<Integer, List<Integer>> hs = new HashMap<>();\\n        for (int[] pre : prerequisites) {\\n            int c = pre[0];\\n            int prereqCourse = pre[1];\\n            hs.putIfAbsent(c, new ArrayList<>());\\n            hs.get(c).add(prereqCourse);\\n        }\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!s.contains(i)) {\\n                if (!dfs(s, i, hs, new HashSet<>())) {\\n                    return new int[]{};\\n                }\\n            }\\n        }\\n        int[] result = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            result[i] = ans.get(i);\\n        }\\n        return result;\\n    }\\n    \\n    public boolean dfs(HashSet<Integer> s, int i, HashMap<Integer, List<Integer>> adj, HashSet<Integer> curr) {\\n        if (s.contains(i)) {\\n            return true;\\n        }\\n        if (!adj.containsKey(i)) {\\n            ans.add(i);\\n            s.add(i);\\n            return true;\\n        }\\n        curr.add(i);\\n        for (int pre : adj.get(i)) {\\n            if (curr.contains(pre) || !dfs(s, pre, adj, curr)) {\\n                return false;\\n            }\\n        }\\n        curr.remove(i);\\n        ans.add(i);\\n        s.add(i);\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nThe overall time complexity of the code is O(N^2).\\n```\n```\\nThe overall Space complexity of the code is O(N^2).\\n```\n```\\nclass Solution {\\n    public List<Integer> ans = new ArrayList<>();\\n    boolean flag = true;\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        HashSet<Integer> s = new HashSet<>();\\n        HashMap<Integer, List<Integer>> hs = new HashMap<>();\\n        for (int[] pre : prerequisites) {\\n            int c = pre[0];\\n            int prereqCourse = pre[1];\\n            hs.putIfAbsent(c, new ArrayList<>());\\n            hs.get(c).add(prereqCourse);\\n        }\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!s.contains(i)) {\\n                if (!dfs(s, i, hs, new HashSet<>())) {\\n                    return new int[]{};\\n                }\\n            }\\n        }\\n        int[] result = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            result[i] = ans.get(i);\\n        }\\n        return result;\\n    }\\n    \\n    public boolean dfs(HashSet<Integer> s, int i, HashMap<Integer, List<Integer>> adj, HashSet<Integer> curr) {\\n        if (s.contains(i)) {\\n            return true;\\n        }\\n        if (!adj.containsKey(i)) {\\n            ans.add(i);\\n            s.add(i);\\n            return true;\\n        }\\n        curr.add(i);\\n        for (int pre : adj.get(i)) {\\n            if (curr.contains(pre) || !dfs(s, pre, adj, curr)) {\\n                return false;\\n            }\\n        }\\n        curr.remove(i);\\n        ans.add(i);\\n        s.add(i);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392818,
                "title": "topological-sorting-breadth-first-search-c",
                "content": "\\n# Approach :\\nThe given code implements a topological sorting algorithm to find the order in which courses can be taken, given a list of prerequisites in the form of directed edges.\\n\\nThe main approach used in the code is as follows:\\n\\n1. Constructing the Graph: The code first constructs an adjacency list adj to represent the directed graph of courses and their prerequisites. The prerequisites are given in the form of a vector of vectors prereq, where each inner vector contains two elements: the prerequisite course and the course that depends on it. The adjacency list is constructed by iterating over the prereq vector and adding directed edges from prerequisite courses to the dependent courses in the adj list.\\n\\n1. Calculating Indegrees: Next, the code calculates the indegree (number of incoming edges) for each vertex in the adj list. This is done using a separate vector indegree of size V (where V is the number of courses) initialized to 0. The code iterates over the adj list and increments the indegree of each vertex (course) whenever it appears as a dependent course (i.e., as the destination of a directed edge) in the adj list.\\n\\n1. Performing BFS: The code then uses a queue-based Breadth-First Search (BFS) approach to perform topological sorting. It starts by adding all the vertices (courses) with an indegree of 0 to the queue, indicating that they have no dependencies and can be taken first. It then iteratively dequeues a vertex from the queue, adds it to the topo list (which stores the topological order), and reduces the indegree of its adjacent vertices (courses) by 1. If the indegree of an adjacent vertex becomes 0 after decrementing, it is also added to the queue. This process continues until the queue is empty.\\n\\n1. Checking for Valid Topological Order: After the BFS, if the size of the topo list is equal to the total number of courses (V), it means a valid topological order has been found, and the topo list contains the correct order in which the courses can be taken. In this case, the topo list is returned as the result. Otherwise, an empty vector is returned, indicating that no valid topological order is possible due to the presence of cycles in the graph.\\n\\nOverall, the code effectively uses the BFS-based topological sorting approach to find the order in which courses can be taken, given their prerequisites, and handles cases where no valid topological order is possible.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# Time complexity :\\nThe time complexity of the given code is dominated by the BFS-based topological sorting algorithm, which has a time complexity of $$O(V + E)$$, where V is the number of vertices (courses) and E is the number of edges (prerequisites). This is because in the worst case, we may need to visit all the vertices and edges in the graph once during the BFS traversal.\\n\\nIn addition to the BFS, the code also performs some additional operations such as constructing the adjacency list, calculating indegrees, and appending vertices to the topo list. These operations take $$O(V + E)$$ time in total because the adjacency list needs to be constructed by iterating over the prereq vector, and the indegrees need to be calculated by iterating over the adjacency list.\\n\\nTherefore, the overall time complexity of the code is $$O(V + E)$$, where V is the number of courses and E is the number of prerequisites.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity :\\nThe space complexity of the given code is primarily determined by the space used to store the adjacency list adj, the indegree vector, and the topo list, as well as the space used by the queue q for the BFS.\\n\\nThe adjacency list adj uses $$O(V + E)$$ space as it stores the edges between courses. The indegree vector also uses $$O(V)$$ space as it stores the indegrees of all the vertices. The topo list also uses $$O(V)$$ space as it stores the topological order of the courses.\\n\\nThe queue q used for the BFS can have a maximum of V vertices at any time, so it uses $$O(V)$$ space.\\n\\nTherefore, the overall space complexity of the code is $$O(V + E)$$, where V is the number of courses and E is the number of prerequisites.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prereq) {\\n        int V = numCourses;\\n        vector<int>adj[V]; // adjacency list to represent the directed graph\\n        // constructing the adjacency list from the given prerequisites\\n        for(auto it:prereq){\\n            vector<int> x = it;\\n            adj[x[1]].push_back(x[0]); // adding directed edge from prerequisite to the course\\n        }\\n        vector<int>topo; // to store topological order\\n        vector<int>indegree(V,0); // to store indegrees of all the vertices\\n        // calculating the indegrees of all the vertices\\n        for(int i=0;i<V;i++){\\n            for(auto it:adj[i]){\\n            indegree[it]++;\\n            }\\n        }\\n        queue<int>q; // to perform BFS\\n        // adding vertices with indegree 0 to the queue\\n        for(int i=0;i<V;i++){\\n            if(!indegree[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node); // adding the node to topological order\\n            // reducing the indegree of adjacent vertices and adding them to the queue if their indegree becomes 0\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(!indegree[it]){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(topo.size()==V) // if a valid topological order is found, return it\\n            return topo;\\n        return {}; // otherwise, return an empty vector\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![559f9a3b-35d8-4a33-997c-25bdc3011c6d_1680759592.848775.gif](https://assets.leetcode.com/users/images/27f775da-8040-45a3-a517-660cb70023f7_1680937174.0448825.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prereq) {\\n        int V = numCourses;\\n        vector<int>adj[V]; // adjacency list to represent the directed graph\\n        // constructing the adjacency list from the given prerequisites\\n        for(auto it:prereq){\\n            vector<int> x = it;\\n            adj[x[1]].push_back(x[0]); // adding directed edge from prerequisite to the course\\n        }\\n        vector<int>topo; // to store topological order\\n        vector<int>indegree(V,0); // to store indegrees of all the vertices\\n        // calculating the indegrees of all the vertices\\n        for(int i=0;i<V;i++){\\n            for(auto it:adj[i]){\\n            indegree[it]++;\\n            }\\n        }\\n        queue<int>q; // to perform BFS\\n        // adding vertices with indegree 0 to the queue\\n        for(int i=0;i<V;i++){\\n            if(!indegree[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node); // adding the node to topological order\\n            // reducing the indegree of adjacent vertices and adding them to the queue if their indegree becomes 0\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(!indegree[it]){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(topo.size()==V) // if a valid topological order is found, return it\\n            return topo;\\n        return {}; // otherwise, return an empty vector\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643104,
                "title": "java-topological-sort-handwritten-illustrations-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/093d02f9-2cc9-4952-9f90-b8118e236689_1640266790.9655185.png)\\n\\n```\\n//Time complexity: O(V+E), iterating over V verticies and their neighbours in total number of neighbours traversed will be equal to E edges in the graph\\n//Space Complexity:O(V+E), V verticies stored in graph as keys and in total E edges.\\nclass Solution {\\n    \\n    public int[] findOrder(int numCrs, int[][] preq) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int degree[] = new int[numCrs]; \\n        makeGraphCalDegree(preq, graph, degree);\\n        int resOrdr[] = new int[numCrs];\\n      \\n        findOrder(resOrdr, graph, degree);\\n//Checking if we found solution i.e. is it possible to finish all courses.\\n        boolean solNotPos = false;\\n        for(int deg : degree){\\n            if(deg != 0){\\n                solNotPos = true;\\n                break;\\n            }\\n        }\\n\\n        return solNotPos ? new int[0] : resOrdr;\\n    }\\n    private void findOrder(int resOrdr[], HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        Queue<Integer> que = new LinkedList<>();\\n        int numCrs = degree.length;\\n        for(int crs = 0; crs<numCrs; crs++){\\n            if(degree[crs] == 0){\\n                que.offer(crs);\\n            }\\n        }\\n        int rIndx = 0;\\n        while(!que.isEmpty()){\\n            int src = que.poll();\\n            resOrdr[rIndx++] = src;\\n            if(!graph.containsKey(src)) continue;\\n            for(int neigh : graph.get(src)){\\n                degree[neigh]--;\\n                if(degree[neigh] == 0){\\n                    que.offer(neigh);\\n                }\\n            }\\n        }\\n    }\\n    private void makeGraphCalDegree(int [][]preq, HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        for(int pr[] : preq){\\n            int dest = pr[0], src = pr[1];\\n            degree[dest]++;\\n            graph.putIfAbsent(src, new HashSet<>());\\n            graph.get(src).add(dest);\\n        }\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed.:)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "solutionTags": [],
                "code": "```\\n//Time complexity: O(V+E), iterating over V verticies and their neighbours in total number of neighbours traversed will be equal to E edges in the graph\\n//Space Complexity:O(V+E), V verticies stored in graph as keys and in total E edges.\\nclass Solution {\\n    \\n    public int[] findOrder(int numCrs, int[][] preq) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int degree[] = new int[numCrs]; \\n        makeGraphCalDegree(preq, graph, degree);\\n        int resOrdr[] = new int[numCrs];\\n      \\n        findOrder(resOrdr, graph, degree);\\n//Checking if we found solution i.e. is it possible to finish all courses.\\n        boolean solNotPos = false;\\n        for(int deg : degree){\\n            if(deg != 0){\\n                solNotPos = true;\\n                break;\\n            }\\n        }\\n\\n        return solNotPos ? new int[0] : resOrdr;\\n    }\\n    private void findOrder(int resOrdr[], HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        Queue<Integer> que = new LinkedList<>();\\n        int numCrs = degree.length;\\n        for(int crs = 0; crs<numCrs; crs++){\\n            if(degree[crs] == 0){\\n                que.offer(crs);\\n            }\\n        }\\n        int rIndx = 0;\\n        while(!que.isEmpty()){\\n            int src = que.poll();\\n            resOrdr[rIndx++] = src;\\n            if(!graph.containsKey(src)) continue;\\n            for(int neigh : graph.get(src)){\\n                degree[neigh]--;\\n                if(degree[neigh] == 0){\\n                    que.offer(neigh);\\n                }\\n            }\\n        }\\n    }\\n    private void makeGraphCalDegree(int [][]preq, HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        for(int pr[] : preq){\\n            int dest = pr[0], src = pr[1];\\n            degree[dest]++;\\n            graph.putIfAbsent(src, new HashSet<>());\\n            graph.get(src).add(dest);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642634,
                "title": "kahn-s-algorithm",
                "content": "**Idea?**\\n* For a given Condition *[a,b]*, course *b* must be completed before course *a* right? Can we put a **directed edge from course b to course a** denoting that we will complete the course a only when course b is completed?\\n* Yes, **Create a Graph G**, which will contain **directed edges** from **Bi to Ai** for all prerequisites, denoting that course Bi must be completed before we start course Ai.\\n* Can we have a specific ordering? Now, consider certain nodes of the graph which has **indegree as zero**. These nodes should be **processed first** because, there are no criteria for this node right?\\n* So, for all nodes which have indegree as zero, push them into the queue and each time for the adjacent neighbors of the current node, **decrease the indegree count of the adjacent node**, and when it becomes zero, it signifies that this node can be processed now...so push them into the queue.\\n* For the above steps, it is called **Kahn\\'s Algorithm for Topological Sorting of the Graph**.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses],in(numCourses);\\n        for(auto& v:prerequisites){\\n            adj[v[1]].push_back(v[0]); // create a directed edge\\n            in[v[0]]++; // indegree is incremented\\n        }\\n        queue<int> q;\\n        vector<int> ans; // stores answer\\n        for(int i=0;i<numCourses;i++){\\n            if(!in[i])\\n                q.push(i); // we can start will all those nodes which doesn\\'t have any prerequisites\\n        }\\n        while(!q.empty()){\\n            int v = q.front();q.pop();\\n            ans.push_back(v);\\n            for(auto&u :adj[v]){\\n                if(--in[u]==0) // when indegree of adjacent node becomes zero, means all prerequistes has been satisfied\\n                    q.push(u);\\n            }\\n        }\\n        if(ans.size()!=numCourses) // if we can\\'t cover all nodes, means there is a cycle in the graph, hence no ordering exists\\n            ans.clear();\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses],in(numCourses);\\n        for(auto& v:prerequisites){\\n            adj[v[1]].push_back(v[0]); // create a directed edge\\n            in[v[0]]++; // indegree is incremented\\n        }\\n        queue<int> q;\\n        vector<int> ans; // stores answer\\n        for(int i=0;i<numCourses;i++){\\n            if(!in[i])\\n                q.push(i); // we can start will all those nodes which doesn\\'t have any prerequisites\\n        }\\n        while(!q.empty()){\\n            int v = q.front();q.pop();\\n            ans.push_back(v);\\n            for(auto&u :adj[v]){\\n                if(--in[u]==0) // when indegree of adjacent node becomes zero, means all prerequistes has been satisfied\\n                    q.push(u);\\n            }\\n        }\\n        if(ans.size()!=numCourses) // if we can\\'t cover all nodes, means there is a cycle in the graph, hence no ordering exists\\n            ans.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067857,
                "title": "c-topological-sort",
                "content": "In this question, we basically have to check if there are any controversial prerequisites lists. For example, if we have B as a pre-requisite of A, then A can\\'t be a pre-requisite of B. Or say B is the prerequisite of A, C is prerequisite of B and A is prerequisite of C. This example fairly tells you what is the logic of the question. \\n* Like in Course Schedule I, we have to find whether or not there is a cycle. Furthermore we have to return the list in order those courses can be done.\\n* One point to note here is that, the input is very consistent and we don\\'t have to check for any cases like courses present in the prerequistes like being greater than numCourses, and courses always start from 0 - numCourses.\\n\\nOne approach is to first check whether the graph is cyclic or not and then performing DFS. We will traverse the graph twice here and once while making the graph. Other one, the one that I have followed here is to push the elements as we check for a cycle and in case, the graph is a cycle, we clear the array and return. \\n\\n\\nclass Solution {\\npublic:\\n\\n    bool isCyclic(vector<int> graph[], vector<int>& visited, int start,vector<int>& ans){\\n        if(visited[start]==2){ //base condition if we meet the same element while traversing one branch\\n            ans.clear(); \\n            return true;\\n        }\\n        visited[start]=2; //visiting index -2, visited -1, not visited -0\\n        \\n\\t\\tfor(int i=0;i<graph[start].size();i++)\\n            if(visited[graph[start][i]]!=1) \\n                if(isCyclic(graph,visited, graph[start][i],ans)){\\n                    ans.clear();\\n                    return true;\\n                }\\n        visited[start]=true;\\n        ans.push_back(start);\\n        return false;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> graph[numCourses], visited(numCourses,0), ans; \\n        for(int i=0;i<prerequisites.size();i++)\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                if(isCyclic(graph,visited,i,ans))\\n                    return ans;\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isCyclic(vector<int> graph[], vector<int>& visited, int start,vector<int>& ans){\\n        if(visited[start]==2){ //base condition if we meet the same element while traversing one branch\\n            ans.clear(); \\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 982542,
                "title": "python3-kahn-s-algorithm-beats-90-and-dfs-topological-sort",
                "content": "Kahn\\'s algorithm works by deleting nodes as you go and keeping track of how many incoming edges each vertex has.  When a vertex reaches 0 incoming edges, add it to the queue and continue processing until the queue is empty.\\n\\nStart with the vertices with no incoming edges in a queue and keep a list of vertices and the total number of incoming edges.  While the queue is not empty, pop an element off of it that contains a vertex with no edges, each time decrementing the \"degree\" of each neighboring vertex by 1.  If any of those neighbors reach a degree of 0 (meaning after removal, they have no incoming edges), add it to the queue.\\n\\nIf at the end of the loop, the size of the topological ordered list is not equal to the total number of courses, it means there is a cycle or a course is not listed in the prerequisites list.\\n\\nBoth algorithms take O(V + E) time and O(V + E) space, where V = # of vertices and E = # of edges.  Kahn\\'s performs better in leetcode (>90% time) vs DFS (>50% time) but it\\'s the same big O time complexity.\\n\\n**Kahn\\'s Algorithm**\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \"\"\"Kahn\\'s algorithm\"\"\"\\n        courses = defaultdict(list)\\n        indegree = defaultdict(int) # could also use collections.Counter here\\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            indegree[course] += 1\\n\\n        q = deque(i for i in range(numCourses) if i not in indegree)\\n        \\n        order, visited = [], set()\\n        \\n        # queue will store vertices with no incoming edges\\n        while q:\\n            course = q.popleft()\\n            order.append(course)\\n            visited.add(course)\\n            \\n            for next_course in courses[course]:\\n                if next_course in indegree:\\n                    indegree[next_course] -= 1\\n                    if indegree[next_course] == 0 and next_course not in visited:\\n                        q.append(next_course)\\n                        \\n\\t\\t# check if there is a cycle or a course is not listed\\n        return order if len(order) == numCourses else []\\n```\\n\\nThe DFS solution is the traditional [topological sort algorithm](https://en.wikipedia.org/wiki/Topological_sorting) using recursion.  It\\'s important to check for cycles by keeping track of what is currently being visited.  If at any point during the callstack, we are visiting a node that has already been visited, that means there is a cycle and the DAG is invalid for topological sorting.\\n\\n**DFS**\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        courses = defaultdict(list)\\n        visited = [0 for _ in range(numCourses)]\\n        order = []\\n        \\n        def dfs(course: int, visited: List[int], order: List[int]) -> bool:\\n            if visited[course] == -1:\\n                return False\\n            elif visited[course] == 1:\\n                return True\\n            \\n            # visiting\\n            visited[course] = -1\\n            for next_course in courses[course]:\\n                if not dfs(next_course, visited, order):\\n                    return False\\n                \\n            # visited\\n            visited[course] = 1\\n            order.append(course)\\n            \\n            return True\\n        \\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            \\n        return order[::-1] if all(dfs(course, visited, order) for course in range(numCourses)) else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \"\"\"Kahn\\'s algorithm\"\"\"\\n        courses = defaultdict(list)\\n        indegree = defaultdict(int) # could also use collections.Counter here\\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            indegree[course] += 1\\n\\n        q = deque(i for i in range(numCourses) if i not in indegree)\\n        \\n        order, visited = [], set()\\n        \\n        # queue will store vertices with no incoming edges\\n        while q:\\n            course = q.popleft()\\n            order.append(course)\\n            visited.add(course)\\n            \\n            for next_course in courses[course]:\\n                if next_course in indegree:\\n                    indegree[next_course] -= 1\\n                    if indegree[next_course] == 0 and next_course not in visited:\\n                        q.append(next_course)\\n                        \\n\\t\\t# check if there is a cycle or a course is not listed\\n        return order if len(order) == numCourses else []\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        courses = defaultdict(list)\\n        visited = [0 for _ in range(numCourses)]\\n        order = []\\n        \\n        def dfs(course: int, visited: List[int], order: List[int]) -> bool:\\n            if visited[course] == -1:\\n                return False\\n            elif visited[course] == 1:\\n                return True\\n            \\n            # visiting\\n            visited[course] = -1\\n            for next_course in courses[course]:\\n                if not dfs(next_course, visited, order):\\n                    return False\\n                \\n            # visited\\n            visited[course] = 1\\n            order.append(course)\\n            \\n            return True\\n        \\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            \\n        return order[::-1] if all(dfs(course, visited, order) for course in range(numCourses)) else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311215,
                "title": "different-python-solutions-bfs-dfs",
                "content": "Same solutions to solve topological sorting problems:\\n[Problem 207. Course schedule](https://leetcode.com/problems/course-schedule/discuss/311183/Different-Python-solutions-with-thinking-process),\\n[Problem 210. Course schedule II](https://leetcode.com/problems/course-schedule-ii/discuss/311215/Different-Python-solution-with-thinking-process).\\n\\nMethod 2 and 3 are more general. They can be a part of [Kosaraju\\'s algorithm](https://www.coursera.org/learn/algorithms-graphs-data-structures/lecture/rng2S/computing-strong-components-the-algorithm) to compute the strongly connected components.\\n\\nMethod 1: BFS: delete a source node step-by-step, don\\'t need to remove edges in the graph.\\nTime complexity: O(n + m) (98.58%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [0] * numCourses\\n        edges = [set() for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].add(u)\\n            indegree[u] += 1\\n        sources = [v for v in range(numCourses) if indegree[v] == 0]\\n        topo_order = []\\n        while sources:\\n            s = sources.pop(0) # can be any sequence to delete\\n            topo_order.append(s)\\n            for v in edges[s]:\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        if len(topo_order) != numCourses:\\n            return []\\n        else:\\n            return topo_order\\n```\\nMethod 2:  recursive DFS using a global variable \\'t\\' to record the finishing times,\\ntime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = True\\n            for j in edges[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            post[i] = t[0]\\n            t[0] += 1\\n            finish_order.append(i) \\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        t = [0]\\n        visited = [False] * numCourses\\n        post = [0] * numCourses\\n        finish_order = []\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                dfs(i)\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\\nMethod 3: iterative DFS using stack, and a global variable \\'t\\' to recording the finishing times,\\ntime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [False] * numCourses\\n        stack = []\\n        post = [0] * numCourses\\n        finish_order = []\\n        t = 0\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                visited[i] = True\\n                stack.append(i)\\n            while stack:\\n                no_next = True\\n                top = stack[-1]\\n                for j in edges[top]:\\n                    if not visited[j]:\\n                        visited[j] = True\\n                        stack.append(j)\\n                        no_next = False\\n                        break\\n                if no_next:\\n                    post[top] = t\\n                    t += 1\\n                    finish_order.append(top)\\n                    stack.pop()\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\\nMethod 4: recursive DFS: visited[i] == 0 means not visited before, visited[i] == 1 means visited in the current path, visited[i] == 2 means visited before.\\nTime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = 1\\n            for j in edges[i]:\\n                if visited[j] == 1:\\n                    return False\\n                elif visited[j] == 0:\\n                    if not dfs(j):\\n                        return False\\n            finish_order.append(i)\\n            visited[i] = 2\\n            return True\\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [0 for _ in range(numCourses)]\\n        finish_order = []\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return finish_order[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [0] * numCourses\\n        edges = [set() for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].add(u)\\n            indegree[u] += 1\\n        sources = [v for v in range(numCourses) if indegree[v] == 0]\\n        topo_order = []\\n        while sources:\\n            s = sources.pop(0) # can be any sequence to delete\\n            topo_order.append(s)\\n            for v in edges[s]:\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        if len(topo_order) != numCourses:\\n            return []\\n        else:\\n            return topo_order\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = True\\n            for j in edges[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            post[i] = t[0]\\n            t[0] += 1\\n            finish_order.append(i) \\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        t = [0]\\n        visited = [False] * numCourses\\n        post = [0] * numCourses\\n        finish_order = []\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                dfs(i)\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [False] * numCourses\\n        stack = []\\n        post = [0] * numCourses\\n        finish_order = []\\n        t = 0\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                visited[i] = True\\n                stack.append(i)\\n            while stack:\\n                no_next = True\\n                top = stack[-1]\\n                for j in edges[top]:\\n                    if not visited[j]:\\n                        visited[j] = True\\n                        stack.append(j)\\n                        no_next = False\\n                        break\\n                if no_next:\\n                    post[top] = t\\n                    t += 1\\n                    finish_order.append(top)\\n                    stack.pop()\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = 1\\n            for j in edges[i]:\\n                if visited[j] == 1:\\n                    return False\\n                elif visited[j] == 0:\\n                    if not dfs(j):\\n                        return False\\n            finish_order.append(i)\\n            visited[i] = 2\\n            return True\\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [0 for _ in range(numCourses)]\\n        finish_order = []\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return finish_order[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 59381,
                "title": "simple-ac-c-dfs-toposort-solution",
                "content": "    class Solution {\\n        vector<bool> visited;\\n        vector<int> path; \\n        vector<bool> rec;\\n        vector<list<int>> graph;\\n        \\n    public:\\n    \\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) \\n        {\\n            vector<int> cycle();\\n            \\n            if(prerequisites.empty())\\n            {\\n                for(int i = 0; i < numCourses; ++i)\\n                {\\n                    path.push_back(i);\\n                }\\n                return path;\\n            }\\n            \\n            graph.assign(numCourses, list<int>());\\n            visited.assign(numCourses, false);\\n            rec.assign(numCourses, false);\\n            \\n            for(int i = 0; i < prerequisites.size(); ++i)\\n            {\\n                graph[prerequisites[i].first].push_back(prerequisites[i].second);\\n            }\\n            \\n            for(int i = 0; i < graph.size(); ++i)\\n            {\\n                if(visited[i]) continue;\\n                if(isCycle(i)) return vector<int>();\\n            }\\n            \\n            return path;\\n        }\\n    \\n        bool isCycle(int course)\\n        {\\n            visited[course] = true;\\n            rec[course] = true;\\n            \\n            for(auto it = graph[course].begin(); it!=graph[course].end(); ++it)\\n            {\\n                if(!visited[*it])\\n                {\\n                    if(isCycle(*it)) return true;\\n                }\\n                if(rec[*it]) return true;\\n            }\\n            rec[course] = false;\\n            path.push_back(course);\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        vector<bool> visited;\\n        vector<int> path; \\n        vector<bool> rec;\\n        vector<list<int>> graph;\\n        \\n    public:\\n    \\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) \\n        {\\n            vector<int> cycle();\\n            \\n            if(prerequisites.empty())\\n            {\\n                for(int i = 0; i < numCourses; ++i)\\n                {\\n                    path.push_back(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3125036,
                "title": "topological-sort-kahn-s-algorithm",
                "content": "# Intuition\\nKahn\\'s algorithm is much easier to think about intuitively as will be clear from the following point/fact about topological ordering.\\n\\nThe first node in the topological ordering will be the node that doesn\\'t have any incoming edges. Essentially, any node that has an in-degree of 0 can start the topologically sorted order. If there are multiple such nodes, their relative order doesn\\'t matter and they can appear in any order.\\n\\nOur current algorithm is based on this idea. We first process all the nodes/course with 0 in-degree implying no prerequisite courses required. If we remove all these courses from the graph, along with their outgoing edges, we can find out the courses/nodes that should be processed next. These would again be the nodes with 0 in-degree. We can continuously do this until all the courses have been accounted for.\\n# Solution\\n- Let G(V,E)G(V, E)G(V,E) represent a directed, unweighted graph.\\n- Each course would represent a vertex in the graph.\\n- The edges are modeled after the prerequisite relationship between courses. So, we are **`given, that a pair such as [a,b] in the question means the course b is a prerequisite for the course a. This can be represented as a directed edge b \\u2794 a in the graph.`**\\n- The graph is a cyclic graph because there is a possibility of a cycle in the graph. If the graph would be acyclic, then an ordering of subjects as required in the question would always be possible. Since it\\'s mentioned that such an ordering may not always be possible, that means we have a cyclic graph.\\nLet\\'s look at a sample graph representing a set of courses where such an ordering is possible and one where such an ordering is not possible. \\n![image.png](https://assets.leetcode.com/users/images/96ab2f58-0252-47de-acfb-17b5c1b528b8_1675222209.7890244.png)\\n\\n\\n\\n\\n# Approach\\n\\n---\\n\\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree.\\n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree.\\n3. Add all the nodes with 0 in-degree to Q.\\nThe following steps are to be done until the Q becomes empty :\\n\\ni.   Pop a node from the Q. Let\\'s call this node, N.\\nii.   For all the neighbors of this node, N, reduce their in-degree by 1.\\niii.  If any of the nodes\\' in-degree reaches 0, add it to the Q.\\nAdd the node N to the list maintaining topologically sorted order.\\nContinue from step i\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/030c5933-fd0e-4121-9356-011df8d6bcca_1675219363.011586.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/a5b8a6de-8e61-460b-a70b-12e4ba33b7b8_1675219380.4713616.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/546ac47a-8bd4-480d-a7e2-5609740df478_1675219403.4589553.png)\\n![image.png](https://assets.leetcode.com/users/images/bfe54eff-0095-4af5-82f4-549d3edd2bc9_1675219432.0764031.png)\\n![image.png](https://assets.leetcode.com/users/images/9bd5ef41-2254-4cc6-95ce-b4ce51e2b1bc_1675219448.1810558.png)\\n![image.png](https://assets.leetcode.com/users/images/162cf5dc-b968-4bd9-8088-fe613f830c40_1675219467.4133434.png)\\n![image.png](https://assets.leetcode.com/users/images/9229c045-a436-4468-b54b-d4915a992235_1675219481.997302.png)\\n![image.png](https://assets.leetcode.com/users/images/3139ab59-1177-4bab-af75-9adf257f09d8_1675219496.9231634.png)\\n![image.png](https://assets.leetcode.com/users/images/9eb1de1a-d56f-402d-a265-8e943783cd84_1675219517.7548423.png)\\n![image.png](https://assets.leetcode.com/users/images/285fe13d-1290-4272-b1c7-ae206731563d_1675219530.1526.png)\\n![image.png](https://assets.leetcode.com/users/images/0d1c575a-31f6-4421-b4d2-a0fef0c4193a_1675219543.0513816.png)\\n![image.png](https://assets.leetcode.com/users/images/b9849b5f-7df1-413c-aa11-4b1279b2974e_1675219562.1890574.png)\\n![image.png](https://assets.leetcode.com/users/images/dde522e8-de72-41eb-814f-3b57366854c7_1675219580.0661752.png)\\n![image.png](https://assets.leetcode.com/users/images/4fd4f7d0-eec6-4161-a81f-ffe7739764fc_1675219590.8891854.png)\\n\\nAn important thing to note here is, using a queue is not a hard requirement for this algorithm. We can make use of a stack. That however, will give us a different ordering than what we might get from the queue because of the difference in access patterns between the two data-structures.\\n\\n\\n# Complexity\\n**Time Complexity:** O(V+E)O(V + E)O(V+E) where VVV represents the number of vertices and EEE represents the number of edges. We pop each node exactly once from the zero in-degree queue and that gives us VVV. Also, for each vertex, we iterate over its adjacency list and in totality, we iterate over all the edges in the graph which gives us EEE. Hence, O(V+E)O(V + E)O(V+E)\\n\\n**Space Complexity:** O(V+E)O(V + E)O(V+E). We use an intermediate queue data structure to keep all the nodes with 0 in-degree. In the worst case, there won\\'t be any prerequisite relationship and the queue will contain all the vertices initially since all of them will have 0 in-degree. That gives us O(V)O(V)O(V). Additionally, we also use the adjacency list to represent our graph initially. The space occupied is defined by the number of edges because for each node as the key, we have all its adjacent nodes in the form of a list as the value. Hence, O(E)O(E)O(E). So, the overall space complexity is O(V+E)O(V + E)O(V+E).\\n\\n# Video link: https://youtu.be/tggiFvaxjrY\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        int indegree[2005]={0};\\n        vector<int>graph[2006];\\n         for(auto i:pre)\\n         {\\n            int x=i[0],y=i[1];\\n            graph[y].push_back(x); \\n            indegree[x]++;\\n         }\\n\\n         queue<int>q;\\n         vector<int>ans;\\n         for(int i=0;i<n;i++)if(!indegree[i])q.push(i);\\n\\n         while(!q.empty())\\n         {\\n            int t=q.front();q.pop();\\n            ans.push_back(t);\\n            for(auto u:graph[t])\\n             {\\n                 indegree[u]--;\\n                 if(indegree[u]==0)q.push(u);\\n             }\\n         }\\n        \\n         if(ans.size()!=n)ans.clear();\\n         //reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```\\nIf you like this post then upvote please  ^_^",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        int indegree[2005]={0};\\n        vector<int>graph[2006];\\n         for(auto i:pre)\\n         {\\n            int x=i[0],y=i[1];\\n            graph[y].push_back(x); \\n            indegree[x]++;\\n         }\\n\\n         queue<int>q;\\n         vector<int>ans;\\n         for(int i=0;i<n;i++)if(!indegree[i])q.push(i);\\n\\n         while(!q.empty())\\n         {\\n            int t=q.front();q.pop();\\n            ans.push_back(t);\\n            for(auto u:graph[t])\\n             {\\n                 indegree[u]--;\\n                 if(indegree[u]==0)q.push(u);\\n             }\\n         }\\n        \\n         if(ans.size()!=n)ans.clear();\\n         //reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338090,
                "title": "go-solution-with-topological-sort",
                "content": "```\\nimport \"container/list\"\\n\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    adList := make(map[int][]int, numCourses)\\n    degree := make([]int, numCourses)\\n    ans := []int{}\\n    q := list.New()\\n    for _, node := range prerequisites {\\n        adList[node[1]] = append(adList[node[1]], node[0])\\n        degree[node[0]]++\\n    }\\n    for i:=0; i<numCourses; i++ {\\n        if degree[i] == 0 {\\n            q.PushBack(i)\\n        }\\n    }\\n    for q.Len() > 0 {\\n        f := q.Front().Value.(int)\\n        ans = append(ans, f)\\n        q.Remove(q.Front())\\n        numCourses--\\n        for _, d := range adList[f] {\\n            degree[d]--\\n            if degree[d] == 0 {\\n                q.PushBack(d)\\n            }\\n        }\\n    }\\n    if numCourses == 0 {\\n        return ans\\n    }\\n    return []int{}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```\\nimport \"container/list\"\\n\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    adList := make(map[int][]int, numCourses)\\n    degree := make([]int, numCourses)\\n    ans := []int{}\\n    q := list.New()\\n    for _, node := range prerequisites {\\n        adList[node[1]] = append(adList[node[1]], node[0])\\n        degree[node[0]]++\\n    }\\n    for i:=0; i<numCourses; i++ {\\n        if degree[i] == 0 {\\n            q.PushBack(i)\\n        }\\n    }\\n    for q.Len() > 0 {\\n        f := q.Front().Value.(int)\\n        ans = append(ans, f)\\n        q.Remove(q.Front())\\n        numCourses--\\n        for _, d := range adList[f] {\\n            degree[d]--\\n            if degree[d] == 0 {\\n                q.PushBack(d)\\n            }\\n        }\\n    }\\n    if numCourses == 0 {\\n        return ans\\n    }\\n    return []int{}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307798,
                "title": "c-faster-than-93-topological-sort-with-recursive-dfs-coloring-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int color[2001] = {0};\\n    // 0 -> white or unvisited\\n    // 1 -> gray or visiting\\n    // 2-> black or visited\\n    bool DFS(int v, vector<int> adj[], vector<int>&res) {\\n    if(color[v]==1) { // when you meet the same node twice which traversing the route , it has a cycle\\n        return false; // break from cycle\\n    }\\n\\tcolor[v] = 1;\\n\\n\\tfor(int u = 0; u < adj[v].size(); ++u ) {    \\n    \\tif(color[adj[v][u]]==0) { // visit only unvisited nodes\\n             if(!DFS(adj[v][u], adj, res)) { // if cycle discovered , break free and return false\\n                 return false;\\n             }\\n\\t\\t}\\n        if(color[adj[v][u]]==1) {\\n             return false;\\n         }\\n\\t\\t\\n\\t}\\n    color[v] = 2;\\n    res.push_back(v);\\n\\treturn true;\\n}    \\n\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    int n = prerequisites.size();\\n\\tvector<int> adj[numCourses];\\n\\tvector<int> res;\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tadj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n\\t}\\n\\t\\n\\tfor(int v = 0; v < numCourses; ++v) {\\n        if(color[v]==0) { \\n            if (!DFS(v, adj, res))  return {}; \\n        }\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int color[2001] = {0};\\n    // 0 -> white or unvisited\\n    // 1 -> gray or visiting\\n    // 2-> black or visited\\n    bool DFS(int v, vector<int> adj[], vector<int>&res) {\\n    if(color[v]==1) { // when you meet the same node twice which traversing the route , it has a cycle\\n        return false; // break from cycle\\n    }\\n\\tcolor[v] = 1;\\n\\n\\tfor(int u = 0; u < adj[v].size(); ++u ) {    \\n    \\tif(color[adj[v][u]]==0) { // visit only unvisited nodes\\n             if(!DFS(adj[v][u], adj, res)) { // if cycle discovered , break free and return false\\n                 return false;\\n             }\\n\\t\\t}\\n        if(color[adj[v][u]]==1) {\\n             return false;\\n         }\\n\\t\\t\\n\\t}\\n    color[v] = 2;\\n    res.push_back(v);\\n\\treturn true;\\n}    \\n\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    int n = prerequisites.size();\\n\\tvector<int> adj[numCourses];\\n\\tvector<int> res;\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tadj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n\\t}\\n\\t\\n\\tfor(int v = 0; v < numCourses; ++v) {\\n        if(color[v]==0) { \\n            if (!DFS(v, adj, res))  return {}; \\n        }\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136423,
                "title": "javascript-kahn-s-algo",
                "content": "```\\nvar findOrder = function(numCourses, prerequisites) {\\n    let inDegree = new Array(numCourses).fill(0);\\n    let queue = [];\\n    let res = [];\\n    \\n    for (let [course] of prerequisites) {\\n        inDegree[course] ++;\\n    }\\n    for (let course = 0; course < inDegree.length; course ++) {\\n        if (inDegree[course] === 0) {\\n            queue.push(course);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        let currentCourse = queue.pop();\\n        numCourses --;\\n        res.push(currentCourse);\\n        for (let [course, preq] of prerequisites) {\\n            if (currentCourse === preq) {\\n                inDegree[course] --;\\n                if (inDegree[course] === 0) {\\n                    queue.push(course)\\n                }\\n            }\\n \\n        }\\n    }\\n    return numCourses === 0 ? res : [];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findOrder = function(numCourses, prerequisites) {\\n    let inDegree = new Array(numCourses).fill(0);\\n    let queue = [];\\n    let res = [];\\n    \\n    for (let [course] of prerequisites) {\\n        inDegree[course] ++;\\n    }\\n    for (let course = 0; course < inDegree.length; course ++) {\\n        if (inDegree[course] === 0) {\\n            queue.push(course);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        let currentCourse = queue.pop();\\n        numCourses --;\\n        res.push(currentCourse);\\n        for (let [course, preq] of prerequisites) {\\n            if (currentCourse === preq) {\\n                inDegree[course] --;\\n                if (inDegree[course] === 0) {\\n                    queue.push(course)\\n                }\\n            }\\n \\n        }\\n    }\\n    return numCourses === 0 ? res : [];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 975877,
                "title": "dfs-easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> courses = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0; i<numCourses; i++){\\n            courses.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i<prerequisites.length; i++){\\n            courses.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        }\\n        \\n        int track []= new int[numCourses]; \\n        for(int i=0; i<numCourses; i++){\\n            if(dfs(courses, i, list, track)==false){\\n                return new int[0];\\n            }\\n        }\\n            \\n        int[] ans = list.stream().mapToInt(i->i).toArray();\\n        \\n        return ans;\\n    }\\n    \\n    public boolean dfs(List<List<Integer>> courses, int start, List<Integer> list, int track[]){\\n        \\n        if(track[start]==2) return true;\\n        if(track[start]==1) return false;\\n        \\n        track[start] = 1;\\n        \\n        for(int j=0; j<courses.get(start).size(); j++){\\n            if(dfs(courses, courses.get(start).get(j),list, track)==false) return false;\\n        }\\n        track[start] = 2;\\n        list.add(start);\\n        return true;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> courses = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0; i<numCourses; i++){\\n            courses.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i<prerequisites.length; i++){\\n            courses.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        }\\n        \\n        int track []= new int[numCourses]; \\n        for(int i=0; i<numCourses; i++){\\n            if(dfs(courses, i, list, track)==false){\\n                return new int[0];\\n            }\\n        }\\n            \\n        int[] ans = list.stream().mapToInt(i->i).toArray();\\n        \\n        return ans;\\n    }\\n    \\n    public boolean dfs(List<List<Integer>> courses, int start, List<Integer> list, int track[]){\\n        \\n        if(track[start]==2) return true;\\n        if(track[start]==1) return false;\\n        \\n        track[start] = 1;\\n        \\n        for(int j=0; j<courses.get(start).size(); j++){\\n            if(dfs(courses, courses.get(start).get(j),list, track)==false) return false;\\n        }\\n        track[start] = 2;\\n        list.add(start);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905012,
                "title": "animated-explanation-c-both-solutions-in-degrees-traversal-backtracking-dfs",
                "content": "Animated Video Explanation:\\nhttps://www.youtube.com/watch?v=3KBmTfKT_5s\\n\\nIn-Degree Traversal Code (Kahn\\'s Algorithm):\\n```\\nclass Solution {\\npublic:\\n     vector<int> topological_sort(int n, vector<vector<int>>& edges) {\\n      // convert to adjacency lists, and record in-degrees\\n      vector<vector<int>> adj(n);\\n      vector<int> in_degree(n);\\n      for (auto &p : edges) {\\n        adj[p[1]].push_back(p[0]);\\n        in_degree[p[0]]++;\\n      }\\n\\n      // initialize our todo queue with all the in_degree=0 nodes\\n      queue<int> todo;\\n      for (int i = 0; i < n; ++i) {\\n        if (in_degree[i] == 0)\\n          todo.push(i);\\n      }\\n\\n      // traverse our graph\\n      vector<int> ret;\\n      while (!todo.empty()) {\\n        int cur = todo.front();\\n        todo.pop();\\n        ret.push_back(cur);\\n        for (auto i : adj[cur]) {\\n          --in_degree[i];\\n          if (in_degree[i] == 0)\\n            todo.push(i);\\n        }\\n      }\\n\\n      // detect cycles\\n      if (ret.size() < n)\\n        return vector<int>();\\n\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```\\nBacktracking DFS Code:\\n```\\nclass Solution {\\npublic:\\n     const int BLUE = 0, GREEN = 1, RED = 2;\\n\\n    // returns TRUE if a cycle is detected\\n    // (and, if so, sets ret to an empty vector)\\n    bool backtracking_dfs(vector<vector<int>> &adj, vector<int> &ret,\\n                          vector<int> &color, int v) {\\n      // if we have already visited here, act appropriately\\n\\n      // if the color is green, a CYCLE has been detected\\n      if (color[v] == GREEN) {\\n        ret = vector<int>();\\n        return true;\\n      }\\n      // if the color is red, do nothing (already visited and recursed on)\\n      if (color[v] == RED) {\\n        return false;\\n      }\\n      // otherwise, add the current node to the stack of greens\\n      color[v] = GREEN;\\n      // then visit its neighbours\\n      for (int u : adj[v]) {\\n        // if any neighbour searches find a cycle, return true again\\n        if (backtracking_dfs(adj, ret, color, u))\\n          return true;\\n      }\\n      // done visiting all neighbours and their traversals too\\n      // remove from stack\\n      color[v] = RED;\\n      // add to return list\\n      ret.push_back(v);\\n\\n      // no cycle detected\\n      return false;\\n    }\\n\\n    // this becomes a helper function\\n    vector<int> topological_sort(int n, vector<vector<int>> edges) {\\n      vector<int> ret;\\n\\n      // convert edge list to adjacency lists\\n      vector<vector<int>> adj(n);\\n      for (auto &p : edges) {\\n        // construct the graph with the edges in reverse since the return vector\\n        // will be reversed if we do so\\n        adj[p[0]].push_back(p[1]);\\n      }\\n\\n      vector<int> color(n, BLUE);\\n\\n      // simulate a \"super node\", i.e. do the DFS from all starting positions\\n      for (int i = 0; i < n; ++i) {\\n        // if a cycle is detected, terminate early here too\\n        if (backtracking_dfs(adj, ret, color, i))\\n          return ret;\\n      }\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> topological_sort(int n, vector<vector<int>>& edges) {\\n      // convert to adjacency lists, and record in-degrees\\n      vector<vector<int>> adj(n);\\n      vector<int> in_degree(n);\\n      for (auto &p : edges) {\\n        adj[p[1]].push_back(p[0]);\\n        in_degree[p[0]]++;\\n      }\\n\\n      // initialize our todo queue with all the in_degree=0 nodes\\n      queue<int> todo;\\n      for (int i = 0; i < n; ++i) {\\n        if (in_degree[i] == 0)\\n          todo.push(i);\\n      }\\n\\n      // traverse our graph\\n      vector<int> ret;\\n      while (!todo.empty()) {\\n        int cur = todo.front();\\n        todo.pop();\\n        ret.push_back(cur);\\n        for (auto i : adj[cur]) {\\n          --in_degree[i];\\n          if (in_degree[i] == 0)\\n            todo.push(i);\\n        }\\n      }\\n\\n      // detect cycles\\n      if (ret.size() < n)\\n        return vector<int>();\\n\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     const int BLUE = 0, GREEN = 1, RED = 2;\\n\\n    // returns TRUE if a cycle is detected\\n    // (and, if so, sets ret to an empty vector)\\n    bool backtracking_dfs(vector<vector<int>> &adj, vector<int> &ret,\\n                          vector<int> &color, int v) {\\n      // if we have already visited here, act appropriately\\n\\n      // if the color is green, a CYCLE has been detected\\n      if (color[v] == GREEN) {\\n        ret = vector<int>();\\n        return true;\\n      }\\n      // if the color is red, do nothing (already visited and recursed on)\\n      if (color[v] == RED) {\\n        return false;\\n      }\\n      // otherwise, add the current node to the stack of greens\\n      color[v] = GREEN;\\n      // then visit its neighbours\\n      for (int u : adj[v]) {\\n        // if any neighbour searches find a cycle, return true again\\n        if (backtracking_dfs(adj, ret, color, u))\\n          return true;\\n      }\\n      // done visiting all neighbours and their traversals too\\n      // remove from stack\\n      color[v] = RED;\\n      // add to return list\\n      ret.push_back(v);\\n\\n      // no cycle detected\\n      return false;\\n    }\\n\\n    // this becomes a helper function\\n    vector<int> topological_sort(int n, vector<vector<int>> edges) {\\n      vector<int> ret;\\n\\n      // convert edge list to adjacency lists\\n      vector<vector<int>> adj(n);\\n      for (auto &p : edges) {\\n        // construct the graph with the edges in reverse since the return vector\\n        // will be reversed if we do so\\n        adj[p[0]].push_back(p[1]);\\n      }\\n\\n      vector<int> color(n, BLUE);\\n\\n      // simulate a \"super node\", i.e. do the DFS from all starting positions\\n      for (int i = 0; i < n; ++i) {\\n        // if a cycle is detected, terminate early here too\\n        if (backtracking_dfs(adj, ret, color, i))\\n          return ret;\\n      }\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741963,
                "title": "topological-sort-using-dfs-simple-understandable-solution-in-c",
                "content": "```\\nif you understand the intuition behind the logic plse give a upvote\\n```/*\\nThis is topological  order finding question but the twist is that the graph may be cyclic(not DAG)\\n\\nso basically i use dfs and check that two nodes are in same call stack and one of which is already visited then there is a cycle\\n\\nif there is any cycle then no topological order is possible\\n\\nif there is no cycle then just store the node values when the dfs call stack is going to end or simply when returning from the call and at last reverse the vector\\nI take a flag for checking cycle is present or not\\n*/\\nclass Solution {\\npublic:\\n    int f=0;\\n    void dfs(int node,vector<vector<int>> &graph,vector<int> &vis,vector<int> &ans){\\n        if(vis[node]!=0){\\n            return;\\n        }\\n        //cout<<\"called node \"<<node<<\\'\\\\n\\';\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(vis[x]==0){\\n                dfs(x,graph,vis,ans);\\n            }else if(vis[x]==1){\\n                f=1;\\n            }\\n        }\\n        vis[node]=2;\\n        ans.push_back(node);\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<int> ans;\\n        vector<vector<int>> graph(n);\\n        vector<int> vis(n,0);\\n        for(int i=0;i<p.size();i++){\\n            graph[p[i][1]].push_back(p[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(i,graph,vis,ans);   \\n        }\\n        if(f){\\n            ans.clear();\\n            return ans;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nif you understand the intuition behind the logic plse give a upvote\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477308,
                "title": "python-dfs",
                "content": "This is a classic topological sorting problem. We want to evaluate a directed acyclic graph and sort based on the traversal of this graph through the dependency relationships. More specifically a topological sort is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG. For example, a topological sorting of the following graph is \\u201C5 4 2 3 1 0\\u201D. There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is \\u201C4 5 2 3 1 0\\u201D. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no incoming edges).\\n\\nA clean python solution:\\n\\n```python\\nclass CycleError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    def findOrder(self, n: int, prerequisites: List[List[int]]) -> bool:\\n        graph = [[] for _ in range(n)]\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n\\n        visited = set()  # All visited elements.\\n        ordered = []     # Ordered returns DAG order traversal.\\n\\n        def search(node, parents):\\n            if node in parents:\\n                raise CycleError(node)\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            parents = parents.union((node,))\\n            for adj in graph[node]:\\n                search(adj, parents)\\n\\n            ordered.insert(0, node)\\n\\n        try:\\n            for node in range(n):\\n                search(node, set())\\n            return ordered\\n        except CycleError:\\n            return []\\n```",
                "solutionTags": [],
                "code": "```python\\nclass CycleError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    def findOrder(self, n: int, prerequisites: List[List[int]]) -> bool:\\n        graph = [[] for _ in range(n)]\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n\\n        visited = set()  # All visited elements.\\n        ordered = []     # Ordered returns DAG order traversal.\\n\\n        def search(node, parents):\\n            if node in parents:\\n                raise CycleError(node)\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            parents = parents.union((node,))\\n            for adj in graph[node]:\\n                search(adj, parents)\\n\\n            ordered.insert(0, node)\\n\\n        try:\\n            for node in range(n):\\n                search(node, set())\\n            return ordered\\n        except CycleError:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59394,
                "title": "share-my-cpp-topological-sort-solution",
                "content": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites)  {\\n\\tvector<int> result;\\n\\tvector<int> indegree(numCourses, 0);\\n\\tqueue<int> Q;\\n\\tvector<vector<int> > G(numCourses, vector<int>());    \\n\\n\\tfor (int i = 0; i < prerequisites.size(); i++)  {\\n\\t\\tint x = prerequisites[i].first;\\n\\t\\tint y = prerequisites[i].second;\\n\\t\\tG[y].push_back(x);\\n\\t\\tindegree[x]++;\\n\\t}\\n\\n\\tfor (int node = 0; node < numCourses; node++) {\\n\\t\\tif (indegree[node] == 0)\\n\\t\\t\\tQ.push(node);\\n\\t}\\n\\n\\twhile (!Q.empty()) {\\n\\t\\tint x = Q.front();\\n\\t\\tQ.pop();\\n\\t\\tresult.push_back(x);\\n\\t\\tfor (int i = 0; i < G[x].size(); i++) {\\n\\t\\t\\tint y = G[x][i];\\n\\t\\t\\tindegree[y]--;\\n\\t\\t\\tif (indegree[y] == 0) {\\n\\t\\t\\t\\tQ.push(y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (result.size() < numCourses)\\n\\t\\tresult.clear();\\n\\n\\treturn result;    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites)  {\\n\\tvector<int> result;\\n\\tvector<int> indegree(numCourses, 0);\\n\\tqueue<int> Q;\\n\\tvector<vector<int> > G(numCourses, vector<int>());    \\n\\n\\tfor (int i = 0; i < prerequisites.size(); i++)  {\\n\\t\\tint x = prerequisites[i].first;\\n\\t\\tint y = prerequisites[i].second;\\n\\t\\tG[y].push_back(x);\\n\\t\\tindegree[x]++;\\n\\t}\\n\\n\\tfor (int node = 0; node < numCourses; node++) {\\n\\t\\tif (indegree[node] == 0)\\n\\t\\t\\tQ.push(node);\\n\\t}\\n\\n\\twhile (!Q.empty()) {\\n\\t\\tint x = Q.front();\\n\\t\\tQ.pop();\\n\\t\\tresult.push_back(x);\\n\\t\\tfor (int i = 0; i < G[x].size(); i++) {\\n\\t\\t\\tint y = G[x][i];\\n\\t\\t\\tindegree[y]--;\\n\\t\\t\\tif (indegree[y] == 0) {\\n\\t\\t\\t\\tQ.push(y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (result.size() < numCourses)\\n\\t\\tresult.clear();\\n\\n\\treturn result;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59424,
                "title": "simple-yet-beating-them-all-in-cpp",
                "content": "    class Solution {\\n    public:\\n        vector<int> findOrder(int num, vector<pair<int, int>>& pres) {\\n            vector<vector<int>> graph(num);\\n            vector<int> indegrees(num, 0), v;\\n            stack<int> toVisit;\\n            int count = 0;\\n            for(auto& pair: pres)\\n            {\\n                graph[pair.second].push_back(pair.first);\\n                indegrees[pair.first]++;\\n            }\\n            for(int i = 0; i < num; i++)\\n                if(!indegrees[i]) toVisit.push(i);\\n            while(!toVisit.empty())\\n            {\\n                int from = toVisit.top();\\n                toVisit.pop();\\n                for(auto n: graph[from])\\n                    if(--indegrees[n] == 0) toVisit.push(n);\\n                count++;\\n                v.push_back(from);\\n            }\\n            return count==num? v : (v.clear(), v);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> findOrder(int num, vector<pair<int, int>>& pres) {\\n            vector<vector<int>> graph(num);\\n            vector<int> indegrees(num, 0), v;\\n            stack<int> toVisit;\\n            int count = 0;\\n            for(auto& pair: pres)\\n            {\\n                graph[pair.second].push_back(pair.first);\\n                indegrees[pair.first]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 59529,
                "title": "java-code-for-course-schedule-ii",
                "content": "    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            if (numCourses <= 0) {\\n    \\t\\t\\treturn null;\\n    \\t\\t}\\n    \\t\\tint[] res = new int[numCourses];\\n    \\t\\tint index = 0;\\n    \\t\\tif (prerequisites.length == 0 || prerequisites[0].length == 0) {\\n    \\t\\t\\twhile (index < numCourses) {\\n    \\t\\t\\t\\tres[index] = index++;\\n    \\t\\t\\t}\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n            int[] course = new int[numCourses];\\n    \\t\\tMap<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();\\n    \\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n    \\t\\t\\tint val = prerequisites[i][0];\\n    \\t\\t\\tint key = prerequisites[i][1];\\n    \\t\\t\\tif (!map.containsKey(key)) {\\n    \\t\\t\\t\\tmap.put(key, new ArrayList<Integer>());\\n    \\t\\t\\t}\\n    \\t\\t\\tmap.get(key).add(val);\\n    \\t\\t\\tcourse[val]++;\\n    \\t\\t}\\n    \\t\\tQueue<Integer> queue = new LinkedList<Integer>();\\n    \\t\\tfor (int i = 0; i < numCourses; i++) {\\n    \\t\\t\\tif (course[i] == 0) {\\n    \\t\\t\\t\\tqueue.add(i);\\n    \\t\\t\\t\\tres[index++] = i;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\tint cur = queue.poll();\\n    \\t\\t\\tif (map.get(cur) != null) {\\n    \\t\\t\\t\\tfor (int temp : map.get(cur)) {\\n    \\t\\t\\t\\t\\tcourse[temp]--;\\n    \\t\\t\\t\\t\\tif (course[temp] == 0) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(temp);\\n    \\t\\t\\t\\t\\t\\tres[index++] = temp;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i < numCourses; i++) {\\n    \\t\\t\\tif (course[i] != 0) {\\n    \\t\\t\\t\\treturn new int[0];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            if (numCourses <= 0) {\\n    \\t\\t\\treturn null;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3848242,
                "title": "java-easiest-solution-ever-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(V + E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(V + E)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/dc199378-24e8-4321-b63c-21e3c11d288b_1690897182.3665764.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Form Graph - Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Integer>> adjacencyList = new ArrayList<>();\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyList.add(new ArrayList<>());\\n        }\\n\\n        int numOfPrerequisites = prerequisites.length;\\n\\n        // Add edges to the graph based on prerequisites\\n        for (int i = 0; i < numOfPrerequisites; i++) {\\n            int course = prerequisites[i][0];\\n            int prerequisite = prerequisites[i][1];\\n            adjacencyList.get(prerequisite).add(course);\\n        }\\n\\n        // Perform Topological Sort\\n\\n        // Initialize an array to store the in-degree of each course\\n        int[] inDegree = new int[numCourses];\\n\\n        // Calculate in-degree for each course\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int neighbor : adjacencyList.get(i)) {\\n                inDegree[neighbor]++;\\n            }\\n        }\\n\\n        // Use a queue to store nodes with in-degree 0 (no prerequisites)\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        // Add courses with in-degree 0 to the queue\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        // Initialize an array to store the topological order of courses\\n        int[] topologicalOrder = new int[numCourses];\\n        int index = 0;\\n\\n        // Perform BFS to find the topological order\\n        while (!queue.isEmpty()) {\\n            int course = queue.peek();\\n            queue.remove();\\n            topologicalOrder[index++] = course;\\n\\n            // Decrease in-degree of neighbors and add them to the queue if their in-degree becomes 0\\n            for (int neighbor : adjacencyList.get(course)) {\\n                inDegree[neighbor]--;\\n\\n                if (inDegree[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        // If all courses are included in the topological order, return the order array\\n        if (index == numCourses) {\\n            return topologicalOrder;\\n        }\\n\\n        // If there is a cycle in the graph (not all courses are included), return an empty array\\n        int[] emptyArray = {};\\n        return emptyArray;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Form Graph - Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Integer>> adjacencyList = new ArrayList<>();\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyList.add(new ArrayList<>());\\n        }\\n\\n        int numOfPrerequisites = prerequisites.length;\\n\\n        // Add edges to the graph based on prerequisites\\n        for (int i = 0; i < numOfPrerequisites; i++) {\\n            int course = prerequisites[i][0];\\n            int prerequisite = prerequisites[i][1];\\n            adjacencyList.get(prerequisite).add(course);\\n        }\\n\\n        // Perform Topological Sort\\n\\n        // Initialize an array to store the in-degree of each course\\n        int[] inDegree = new int[numCourses];\\n\\n        // Calculate in-degree for each course\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int neighbor : adjacencyList.get(i)) {\\n                inDegree[neighbor]++;\\n            }\\n        }\\n\\n        // Use a queue to store nodes with in-degree 0 (no prerequisites)\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        // Add courses with in-degree 0 to the queue\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        // Initialize an array to store the topological order of courses\\n        int[] topologicalOrder = new int[numCourses];\\n        int index = 0;\\n\\n        // Perform BFS to find the topological order\\n        while (!queue.isEmpty()) {\\n            int course = queue.peek();\\n            queue.remove();\\n            topologicalOrder[index++] = course;\\n\\n            // Decrease in-degree of neighbors and add them to the queue if their in-degree becomes 0\\n            for (int neighbor : adjacencyList.get(course)) {\\n                inDegree[neighbor]--;\\n\\n                if (inDegree[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        // If all courses are included in the topological order, return the order array\\n        if (index == numCourses) {\\n            return topologicalOrder;\\n        }\\n\\n        // If there is a cycle in the graph (not all courses are included), return an empty array\\n        int[] emptyArray = {};\\n        return emptyArray;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588978,
                "title": "both-dfs-and-bfs-to-print-topological-order-c-dfs-bfs",
                "content": "# Intuition\\nUsing DFS and BFS i tried to use Topological sort\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n\\n# Code DFS\\n```\\nclass Solution {\\npublic:\\nbool dfs(vector<vector<int>> &ad,vector<bool> &vis,stack<int> &st,int i,vector<bool> & stk)\\n    {\\n        vis[i]=1;\\n        stk[i]=1;\\n        for(auto it:ad[i])\\n        {\\n            if(!vis[it])\\n            {\\n                if(dfs(ad,vis,st,it,stk))return true;\\n            }\\n            else if(stk[it])return true;\\n        }\\n        st.push(i);\\n        stk[i]=false;\\n        return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                if(dfs(ad,vis,st,i,stk))return {};\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Code BFS\\n```\\nclass Solution {\\npublic:\\nbool bfs(vector<vector<int>> adj,int V,stack<int> &st)\\n    {\\n        vector<int> indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        for(int i=0;i<V;i++)\\n        {\\n            int j=0;\\n            for(;j<V;j++)\\n            {\\n                if(indegree[j]==0)\\n                {  \\n                    st.push(j);\\n                    break;\\n                }\\n            }\\n            if(j==V)return false;\\n            indegree[j]--;\\n            for(auto it:adj[j])\\n            {\\n                indegree[it]--;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        if(bfs(ad,n,st)==false)return {};\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(vector<vector<int>> &ad,vector<bool> &vis,stack<int> &st,int i,vector<bool> & stk)\\n    {\\n        vis[i]=1;\\n        stk[i]=1;\\n        for(auto it:ad[i])\\n        {\\n            if(!vis[it])\\n            {\\n                if(dfs(ad,vis,st,it,stk))return true;\\n            }\\n            else if(stk[it])return true;\\n        }\\n        st.push(i);\\n        stk[i]=false;\\n        return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                if(dfs(ad,vis,st,i,stk))return {};\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321175,
                "title": "easy-to-understand-c-kahn-s-algorithm-bfs-topological-sorting-striver-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> indeg(n,0);\\n        vector<int> adj[n];\\n        queue<int> q;\\n        vector<int> topo;\\n        for(auto it:prerequisites) adj[it[1]].push_back(it[0]);\\n        for(int i=0;i<n;i++){\\n            for(auto it:adj[i]) indeg[it]++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                 q.push(i);\\n\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            topo.push_back(node);\\n            for(auto it:adj[node]){\\n                indeg[it]--;\\n                if(indeg[it]==0) q.push(it);\\n            }\\n        }\\n        if(topo.size()==n) return topo;\\n       return vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> indeg(n,0);\\n        vector<int> adj[n];\\n        queue<int> q;\\n        vector<int> topo;\\n        for(auto it:prerequisites) adj[it[1]].push_back(it[0]);\\n        for(int i=0;i<n;i++){\\n            for(auto it:adj[i]) indeg[it]++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                 q.push(i);\\n\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            topo.push_back(node);\\n            for(auto it:adj[node]){\\n                indeg[it]--;\\n                if(indeg[it]==0) q.push(it);\\n            }\\n        }\\n        if(topo.size()==n) return topo;\\n       return vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055663,
                "title": "topological-sort-c-indegree-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically here courses have dependencies to other course, so the problem boils down to topological sort in which total dependencies to a particular course is equivalent to the indegree of the node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will visulaize this problem as graph. Now after that we will calculate the indegree of each and every node. Node haveing 0 indegree is free from any course dependencies so we can simply put 0 indegree node to our ans. Now after exploring dependency free nodes we will update the nodes indegree of those nodes which have dependencies of previous explored nodes i.e we will decrease the neighbours node of curr exploring node to 1. In this way we will explore all node and get the correct topological sorted order. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are visiting every node\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor adjacency matrix of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\n        vector<int> indegree(numCourses, 0);\\n        vector<vector<int>> adj(numCourses);\\n        vector<int> ans;\\n\\n        for(auto x : prerequisites){\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0 ; i < numCourses; i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            ans.push_back(cur);\\n    \\n            for(auto neighbours: adj[cur]){\\n                indegree[neighbours]--;\\n                if(indegree[neighbours] == 0)\\n                    q.push(neighbours);\\n            }\\n        }\\n        if(ans.size() != numCourses) return {};\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/8a7f101f-fbb5-44ff-a9bc-4883e9d62969_1677837881.3926222.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\n        vector<int> indegree(numCourses, 0);\\n        vector<vector<int>> adj(numCourses);\\n        vector<int> ans;\\n\\n        for(auto x : prerequisites){\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0 ; i < numCourses; i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            ans.push_back(cur);\\n    \\n            for(auto neighbours: adj[cur]){\\n                indegree[neighbours]--;\\n                if(indegree[neighbours] == 0)\\n                    q.push(neighbours);\\n            }\\n        }\\n        if(ans.size() != numCourses) return {};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045278,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2944256,
                "title": "my-java-solution-using-kahn-s-algo",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prereq) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<numCourses; i++) graph.add(new ArrayList<>());\\n        \\n        \\n        int[] indegree = new int[numCourses];\\n        for(int i=0; i<prereq.length; i++){\\n            graph.get(prereq[i][1]).add(prereq[i][0]);\\n            indegree[prereq[i][0]]++;\\n        }\\n        \\n        Queue<Integer> que = new ArrayDeque<>();\\n        for(int i=0; i<indegree.length; i++) if(indegree[i] == 0) que.add(i);\\n        int[] ans = new int[numCourses];\\n        int idx=0;\\n        \\n        while(que.size()!=0){\\n            int rem = que.poll();\\n            ans[idx++] = rem;\\n            List<Integer> get = graph.get(rem);\\n            for(int ele : get){\\n                indegree[ele]--;\\n                if(indegree[ele] == 0) que.add(ele);\\n            }\\n        }\\n        if(idx!=numCourses) return new int[0];\\n        else return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findOrder(int numCourses, int[][] prereq) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<numCourses; i++) graph.add(new ArrayList<>());\\n        \\n        \\n        int[] indegree = new int[numCourses];\\n        for(int i=0; i<prereq.length; i++){\\n            graph.get(prereq[i][1]).add(prereq[i][0]);\\n            indegree[prereq[i][0]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2386578,
                "title": "simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        //Make The Graph\\n        vector<vector<int>> Graph(n);\\n        for(int i = 0 ; i < prerequisites.size() ; i++){\\n            Graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //I have Graph at this point...\\n        //i will make a dfs call on my graph and check whether there is any cycle in my graph or not.\\n        //it there is a cycle i can say that topo sort will not exist and return empty vector\\n        //else i will return the topo sort that i will get after dfs call(because toposort is same as \\n        //postorder traveral)\\n        vector<int> visited(n,0);\\n        //0 means that the given vertex is unvisited\\n        //1 means that the given vertex is in the path\\n        //2 means that the given vertex is processed and not the part of the given path\\n        vector<int> ans;\\n        function<int(int)> dfs = [&](int u){\\n            // mark\\n            visited[u] = 1;\\n            //for each not processed children make a dfs call.\\n            //if the vertex has visited[v] = 1 menas it is part of the current path so there is a cycle\\n            for(int i = 0 ; i < Graph[u].size() ; i++){\\n                int v = Graph[u][i];\\n                if(!visited[v]){\\n                    if(dfs(v) == -1)\\n                        return -1;\\n                }else if(visited[v] == 1){\\n                    //there is a cycle\\n                    return -1;\\n                }\\n            }\\n            visited[u] = 2;\\n            ans.push_back(u);\\n            return 2;\\n        };\\n        for(int i = 0 ; i < n ; i++){\\n            if(!visited[i]){\\n                if(dfs(i) == -1)\\n                    return {};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        //Make The Graph\\n        vector<vector<int>> Graph(n);\\n        for(int i = 0 ; i < prerequisites.size() ; i++){\\n            Graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //I have Graph at this point...\\n        //i will make a dfs call on my graph and check whether there is any cycle in my graph or not.\\n        //it there is a cycle i can say that topo sort will not exist and return empty vector\\n        //else i will return the topo sort that i will get after dfs call(because toposort is same as \\n        //postorder traveral)\\n        vector<int> visited(n,0);\\n        //0 means that the given vertex is unvisited\\n        //1 means that the given vertex is in the path\\n        //2 means that the given vertex is processed and not the part of the given path\\n        vector<int> ans;\\n        function<int(int)> dfs = [&](int u){\\n            // mark\\n            visited[u] = 1;\\n            //for each not processed children make a dfs call.\\n            //if the vertex has visited[v] = 1 menas it is part of the current path so there is a cycle\\n            for(int i = 0 ; i < Graph[u].size() ; i++){\\n                int v = Graph[u][i];\\n                if(!visited[v]){\\n                    if(dfs(v) == -1)\\n                        return -1;\\n                }else if(visited[v] == 1){\\n                    //there is a cycle\\n                    return -1;\\n                }\\n            }\\n            visited[u] = 2;\\n            ans.push_back(u);\\n            return 2;\\n        };\\n        for(int i = 0 ; i < n ; i++){\\n            if(!visited[i]){\\n                if(dfs(i) == -1)\\n                    return {};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885484,
                "title": "golang-using-topo-bfs-order",
                "content": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    var result []int\\n    \\n    var queue []int\\n    \\n    indegree := make(map[int][]int)\\n    adjacent := make(map[int][]int)\\n    count := 0\\n    \\n    for _,  prerequisite := range  prerequisites {\\n        src :=  prerequisite[1]\\n        dst :=  prerequisite[0]\\n        \\n        indegree[dst] = append(indegree[dst], src)\\n        adjacent[src] = append(adjacent[src], dst)\\n    }\\n    \\n    for i := 0; i < numCourses; i++ {\\n        if len(indegree[i]) == 0 {\\n            enqueue(&queue, i)\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    for len(queue) > 0 {\\n        dequeuedEle := dequeue(&queue)\\n        \\n        for _, vertex := range adjacent[dequeuedEle] {\\n            tmp := indegree[vertex]\\n            remove(&tmp, dequeuedEle)\\n            indegree[vertex] = tmp\\n\\n            if len(indegree[vertex]) == 0 {\\n                enqueue(&queue, vertex)\\n                result = append(result, vertex)\\n            }\\n        }\\n        \\n        count += 1\\n    }\\n\\n    if count == numCourses {\\n        return result\\n    }\\n    \\n    return []int{}\\n}\\n\\nfunc remove(lst *[]int, removedEle int) {\\n\\tif lst == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*lst) == 0 {\\n\\t\\tpanic(\"empty list\")\\n\\t}\\n\\n\\tfor idx, num := range *lst {\\n\\t\\tif num == removedEle {\\n\\t\\t\\t*lst = append((*lst)[:idx], (*lst)[idx+1:]...)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc enqueue(queue *[]int, newEle int) {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    *queue = append(*queue, newEle)\\n}\\n\\nfunc dequeue(queue *[]int) int {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    if len(*queue) == 0 {\\n        panic(\"empty queue\")\\n    }\\n    \\n    dequeuedEle := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedEle\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    var result []int\\n    \\n    var queue []int\\n    \\n    indegree := make(map[int][]int)\\n    adjacent := make(map[int][]int)\\n    count := 0\\n    \\n    for _,  prerequisite := range  prerequisites {\\n        src :=  prerequisite[1]\\n        dst :=  prerequisite[0]\\n        \\n        indegree[dst] = append(indegree[dst], src)\\n        adjacent[src] = append(adjacent[src], dst)\\n    }\\n    \\n    for i := 0; i < numCourses; i++ {\\n        if len(indegree[i]) == 0 {\\n            enqueue(&queue, i)\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    for len(queue) > 0 {\\n        dequeuedEle := dequeue(&queue)\\n        \\n        for _, vertex := range adjacent[dequeuedEle] {\\n            tmp := indegree[vertex]\\n            remove(&tmp, dequeuedEle)\\n            indegree[vertex] = tmp\\n\\n            if len(indegree[vertex]) == 0 {\\n                enqueue(&queue, vertex)\\n                result = append(result, vertex)\\n            }\\n        }\\n        \\n        count += 1\\n    }\\n\\n    if count == numCourses {\\n        return result\\n    }\\n    \\n    return []int{}\\n}\\n\\nfunc remove(lst *[]int, removedEle int) {\\n\\tif lst == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*lst) == 0 {\\n\\t\\tpanic(\"empty list\")\\n\\t}\\n\\n\\tfor idx, num := range *lst {\\n\\t\\tif num == removedEle {\\n\\t\\t\\t*lst = append((*lst)[:idx], (*lst)[idx+1:]...)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc enqueue(queue *[]int, newEle int) {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    *queue = append(*queue, newEle)\\n}\\n\\nfunc dequeue(queue *[]int) int {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    if len(*queue) == 0 {\\n        panic(\"empty queue\")\\n    }\\n    \\n    dequeuedEle := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedEle\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848781,
                "title": "dfs-implementation",
                "content": "Just like [course-schedule-i](https://leetcode.com/problems/course-schedule/) we can try to solve the problem using dfs. \\n\\nfor every course we can make a dfs call to check for *cycle* at same time, storing the path using a **vector**. If at any point we encounter a cycle we can return an empty vector. \\n\\nThe Tricky part here is how to store the path in which the courses should be taken, after dry running the code with given examles we can see **where** we should be pushing our element in the answer vector. Since this a dfs call the course(s) which require more number of courses to be completed before hand will come first in vector ( as this is leaf/bottom one ), now after traversals if there is no cycle we return the **vector** which is used to maintain the order of courses in reverse order.\\n\\n```\\nclass Solution {\\npublic:\\n     bool dfs(int i, unordered_map<int,vector<int>>& pre,vector<int>&visited,vector<int>&dfsvisited,vector<int>&v)\\n    {\\n        visited[i]=true;\\n        dfsvisited[i]=true;\\n        for(auto u:pre[i])\\n        {\\n            if(!visited[u] )\\n                if(dfs(u,pre,visited,dfsvisited,v))\\n                    return true;\\n            if(dfsvisited[u])return true;\\n        }\\n       v.push_back(i);\\n       dfsvisited[i]=false;\\n       return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& course) {\\n        vector<int>visited(n+1,false);\\n        vector<int>dfsvisited(n+1,false);\\n\\t\\t\\n        unordered_map<int,vector<int>>pre;\\n\\t\\t\\n        for(int i=0;i<course.size();i++)\\n        {\\n            pre[course[i][1]].push_back(course[i][0]);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(dfs(i,pre,visited,dfsvisited,v))\\n                {\\n                    v.clear();\\n                    return v;\\n                }\\n            }   \\n        }\\n        reverse(v.begin(),v.end()); \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool dfs(int i, unordered_map<int,vector<int>>& pre,vector<int>&visited,vector<int>&dfsvisited,vector<int>&v)\\n    {\\n        visited[i]=true;\\n        dfsvisited[i]=true;\\n        for(auto u:pre[i])\\n        {\\n            if(!visited[u] )\\n                if(dfs(u,pre,visited,dfsvisited,v))\\n                    return true;\\n            if(dfsvisited[u])return true;\\n        }\\n       v.push_back(i);\\n       dfsvisited[i]=false;\\n       return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& course) {\\n        vector<int>visited(n+1,false);\\n        vector<int>dfsvisited(n+1,false);\\n\\t\\t\\n        unordered_map<int,vector<int>>pre;\\n\\t\\t\\n        for(int i=0;i<course.size();i++)\\n        {\\n            pre[course[i][1]].push_back(course[i][0]);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(dfs(i,pre,visited,dfsvisited,v))\\n                {\\n                    v.clear();\\n                    return v;\\n                }\\n            }   \\n        }\\n        reverse(v.begin(),v.end()); \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670975,
                "title": "simple-topological-sort",
                "content": "consider each subject given as a node...we are given pairs where each pair has two subjects .the first subject of the pair has to be completed in order to study second and this condition has to be satisfied for all pairs. Its equivalent to finding topological sort for a given directed acyclic graph.(the ans is null if there exists a cycle ).This can be done easily using dfs +stack. feel free to ask questions about the code.....\\n```\\nclass Solution {\\npublic:\\n     bool vis[2001];\\n    bool dfsvis[2001];\\n    bool flag=true;\\n      vector<int>adj[2001];\\n    void dfs(int a,stack<int>&st)\\n    {\\n        vis[a]=true;\\n        dfsvis[a]=true;\\n        for(auto it:adj[a])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,st);\\n            }\\n            else if(dfsvis[it])\\n            {\\n                flag=false;\\n                return;\\n            }\\n        }\\n        st.push(a);\\n        dfsvis[a]=false;\\n        \\n    }\\n    \\n    \\n    \\n\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        vector<int>ans;\\n         stack<int>st;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            adj[pre[i][0]].push_back(pre[i][1]);\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,st);\\n            }\\n        }\\n        if(flag==false || st.empty())\\n        {\\n            return ans;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool vis[2001];\\n    bool dfsvis[2001];\\n    bool flag=true;\\n      vector<int>adj[2001];\\n    void dfs(int a,stack<int>&st)\\n    {\\n        vis[a]=true;\\n        dfsvis[a]=true;\\n        for(auto it:adj[a])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,st);\\n            }\\n            else if(dfsvis[it])\\n            {\\n                flag=false;\\n                return;\\n            }\\n        }\\n        st.push(a);\\n        dfsvis[a]=false;\\n        \\n    }\\n    \\n    \\n    \\n\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        vector<int>ans;\\n         stack<int>st;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            adj[pre[i][0]].push_back(pre[i][1]);\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,st);\\n            }\\n        }\\n        if(flag==false || st.empty())\\n        {\\n            return ans;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642887,
                "title": "c-kahn-s-algorithm-99-09-faster",
                "content": "```\\nvector<int> topoSort(vector<int> adj[], int n) {\\n        // Kahn\\'s Algorithm\\n        \\n        vector<int> inDegree(n, 0), ans;\\n        int count = 0;\\n        queue<int> q;\\n    \\n        for(int i = 0; i < n; i++) for(auto it : adj[i]) inDegree[it]++;\\n        for(int i = 0; i < n; i++) if(inDegree[i] == 0) q.push(i);\\n        \\n        while(q.size() != 0) {\\n            int node = q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(node);\\n            \\n            for(auto it : adj[node]) {\\n                if(inDegree[it]) {\\n                    inDegree[it]--;\\n                    if(inDegree[it] == 0) q.push(it);\\n                }\\n            }\\n        }\\n        if(count == n) return ans;\\n        return {};\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses];\\n        for(int i = 0; i < prerequisites.size(); i++)\\n            adj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<int> ans = topoSort(adj, numCourses);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> topoSort(vector<int> adj[], int n) {\\n        // Kahn\\'s Algorithm\\n        \\n        vector<int> inDegree(n, 0), ans;\\n        int count = 0;\\n        queue<int> q;\\n    \\n        for(int i = 0; i < n; i++) for(auto it : adj[i]) inDegree[it]++;\\n        for(int i = 0; i < n; i++) if(inDegree[i] == 0) q.push(i);\\n        \\n        while(q.size() != 0) {\\n            int node = q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(node);\\n            \\n            for(auto it : adj[node]) {\\n                if(inDegree[it]) {\\n                    inDegree[it]--;\\n                    if(inDegree[it] == 0) q.push(it);\\n                }\\n            }\\n        }\\n        if(count == n) return ans;\\n        return {};\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses];\\n        for(int i = 0; i < prerequisites.size(); i++)\\n            adj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<int> ans = topoSort(adj, numCourses);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428496,
                "title": "very-easy-topological-sort-apna-college",
                "content": "**Please Upvote if you like it**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        int n = numCourses;\\n        int m = prerequisites.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n            indeg[prerequisites[i][0]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(indeg[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front();\\n            q.pop();\\n            ans.push_back(x);\\n            \\n            for(auto it : adj[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if(ans.size() == n)\\n            return ans;\\n        return {};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        int n = numCourses;\\n        int m = prerequisites.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n            indeg[prerequisites[i][0]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1411551,
                "title": "java-99-faster-topo-sort-cycle-detection-using-dfs",
                "content": "```\\nclass Solution {\\n    \\n    public boolean dfs(int curr, ArrayList<ArrayList<Integer>> adj, boolean[] visit, \\n                    boolean[] dfsVisit, Queue<Integer> q){\\n        visit[curr] = true;\\n        dfsVisit[curr] = true;\\n        \\n        for(Integer v : adj.get(curr)){\\n            if(!visit[v]){\\n                if(dfs(v, adj, visit, dfsVisit, q)) return true;\\n            }\\n            else if(dfsVisit[v]) return true;\\n        }\\n        \\n        q.add(curr);\\n        dfsVisit[curr] = false;\\n        return false;\\n    }\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        for(int i=0;i<numCourses;i++) adj.add(new ArrayList());\\n        for(int[] e : prerequisites) adj.get(e[0]).add(e[1]);\\n        \\n        boolean[] visit = new boolean[numCourses];\\n        boolean[] dfsVisit = new boolean[numCourses];\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(!visit[i]){\\n                if(dfs(i, adj, visit, dfsVisit, q)) return new int[0];\\n            }\\n        }\\n        \\n        int[] res = new int[numCourses];\\n        int i = 0;\\n        while(!q.isEmpty()) res[i++] = q.remove();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean dfs(int curr, ArrayList<ArrayList<Integer>> adj, boolean[] visit, \\n                    boolean[] dfsVisit, Queue<Integer> q){\\n        visit[curr] = true;\\n        dfsVisit[curr] = true;\\n        \\n        for(Integer v : adj.get(curr)){\\n            if(!visit[v]){\\n                if(dfs(v, adj, visit, dfsVisit, q)) return true;\\n            }\\n            else if(dfsVisit[v]) return true;\\n        }\\n        \\n        q.add(curr);\\n        dfsVisit[curr] = false;\\n        return false;\\n    }\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        for(int i=0;i<numCourses;i++) adj.add(new ArrayList());\\n        for(int[] e : prerequisites) adj.get(e[0]).add(e[1]);\\n        \\n        boolean[] visit = new boolean[numCourses];\\n        boolean[] dfsVisit = new boolean[numCourses];\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(!visit[i]){\\n                if(dfs(i, adj, visit, dfsVisit, q)) return new int[0];\\n            }\\n        }\\n        \\n        int[] res = new int[numCourses];\\n        int i = 0;\\n        while(!q.isEmpty()) res[i++] = q.remove();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347278,
                "title": "c-cpp-explanation-all-approaches",
                "content": "```\\n/* LeetCode Question: https://leetcode.com/problems/course-schedule-ii/ */\\n/* We have n courses numbered from 0 to n-1. We also have a prerequisite array, each element is of the form [a, b] which\\nindicates that to take the course a the pre-requisite is the course b. So, basically we have to finish the course b before\\nwe can start the course a. If there is a way to complete all the courses then we have to return the order otherwise empty \\nvector */\\n\\n/* Intution: The graph would have edge like a-> b, means to go and do the course b we first have to complete or visit the course a.\\nSo, here we have to find the ordering of the nodes such that all the further nodes or child nodes will come after the parent node\\nwhich can be done using topological sort  */\\n\\n/* Time Complexity: O((E + V) + V) {one for topo sort and order for cycle detection} */\\n/* Space Complexity: O(E + E + V) { for storing adjacency list, recursion stack and topo sort } */\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<bool> &visited, stack<int> &s) {\\n        visited[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v])\\n                dfs(adj, v, visited, s);\\n        }\\n        \\n        /* After we have finished visiting all further nodes, now all the further nodes are in stack. Hence, we can push \\n        this node into the stack */\\n        s.push(node);\\n    }\\n    \\n    vector<int> getTopologicalSort(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        \\n        /* Normal DFS call for all the nodes */\\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i])\\n                dfs(adj, i, visited, s);\\n        }\\n        \\n        /* Pop all elements from stack to get topo sort */\\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    bool checkCycleExist(vector<int> adj[], int V, vector<int> &topoSort) {\\n        unordered_map<int, int> pos;\\n        \\n        for(int i=0; i<topoSort.size(); i++) {\\n            pos[topoSort[i]] = i;\\n        }\\n        \\n        for(int i=0; i<V; i++) {\\n            for(int v : adj[i]) {\\n                if(pos[v] < pos[i]) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        /* Making a directed graph adjacency list */\\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getTopologicalSort(adj, nC));\\n        if(checkCycleExist(adj, nC, topo)) return {};\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Checking if the cycle exist or not simultanously while finding topological sort */\\n/* Approach : Have used the general way to find cycle in directed graph i.e. by tracing the nodes in current DFS call */\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> adj[], int node, vector<bool> &visited, vector<bool> &currDFS, stack<int> &s) {\\n        visited[node] = true;\\n        currDFS[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v]) {\\n                if(!dfs(adj, v, visited, currDFS, s)) return false;   \\n            } else if(currDFS[v]) return false;\\n        }\\n        \\n        currDFS[node] = false;\\n        s.push(node);\\n        return true;\\n    }\\n    \\n    vector<int> getCourseOrder(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        vector<bool> currDFS(nC, false);\\n        \\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i]) {\\n                if(!dfs(adj, i, visited, currDFS, s)) return {};\\n            }\\n        }\\n        \\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getCourseOrder(adj, nC));\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Approach: Kahn\\'s Algorithm */\\n/* TC: O(E + V+E) { for creatin adj list, traversing over all vector and edges }, \\n  SC: O(V+E + V + V + V) { Adjacency List, indegree-vector, queue, order } */\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> indegree(numCourses);\\n        vector<int> adj[numCourses];\\n        \\n        for(int i=0; i<prerequisites.size(); i++) {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            \\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        int doneCnt = 0;    // to keep track of number of nodes completed\\n        queue<int> q;\\n        \\n        /* Push all courses or nodes with indegree 0, means this course has no other prerequisite course */\\n        for(int i=0; i<indegree.size(); i++) {\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        vector<int> order;\\n        while(!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n\\n            doneCnt++; // incremenet complete count\\n            order.push_back(v); \\n            \\n            /* Decrease indegree for all adjacent node of v */\\n            for(int u : adj[v]) {\\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0) q.push(u);\\n            }\\n        }\\n        \\n        /* If all the nodes are traversed then order is correct otherwise graph has a cycle */\\n        return doneCnt == numCourses ? order : vector<int> {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/* LeetCode Question: https://leetcode.com/problems/course-schedule-ii/ */\\n/* We have n courses numbered from 0 to n-1. We also have a prerequisite array, each element is of the form [a, b] which\\nindicates that to take the course a the pre-requisite is the course b. So, basically we have to finish the course b before\\nwe can start the course a. If there is a way to complete all the courses then we have to return the order otherwise empty \\nvector */\\n\\n/* Intution: The graph would have edge like a-> b, means to go and do the course b we first have to complete or visit the course a.\\nSo, here we have to find the ordering of the nodes such that all the further nodes or child nodes will come after the parent node\\nwhich can be done using topological sort  */\\n\\n/* Time Complexity: O((E + V) + V) {one for topo sort and order for cycle detection} */\\n/* Space Complexity: O(E + E + V) { for storing adjacency list, recursion stack and topo sort } */\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<bool> &visited, stack<int> &s) {\\n        visited[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v])\\n                dfs(adj, v, visited, s);\\n        }\\n        \\n        /* After we have finished visiting all further nodes, now all the further nodes are in stack. Hence, we can push \\n        this node into the stack */\\n        s.push(node);\\n    }\\n    \\n    vector<int> getTopologicalSort(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        \\n        /* Normal DFS call for all the nodes */\\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i])\\n                dfs(adj, i, visited, s);\\n        }\\n        \\n        /* Pop all elements from stack to get topo sort */\\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    bool checkCycleExist(vector<int> adj[], int V, vector<int> &topoSort) {\\n        unordered_map<int, int> pos;\\n        \\n        for(int i=0; i<topoSort.size(); i++) {\\n            pos[topoSort[i]] = i;\\n        }\\n        \\n        for(int i=0; i<V; i++) {\\n            for(int v : adj[i]) {\\n                if(pos[v] < pos[i]) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        /* Making a directed graph adjacency list */\\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getTopologicalSort(adj, nC));\\n        if(checkCycleExist(adj, nC, topo)) return {};\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Checking if the cycle exist or not simultanously while finding topological sort */\\n/* Approach : Have used the general way to find cycle in directed graph i.e. by tracing the nodes in current DFS call */\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> adj[], int node, vector<bool> &visited, vector<bool> &currDFS, stack<int> &s) {\\n        visited[node] = true;\\n        currDFS[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v]) {\\n                if(!dfs(adj, v, visited, currDFS, s)) return false;   \\n            } else if(currDFS[v]) return false;\\n        }\\n        \\n        currDFS[node] = false;\\n        s.push(node);\\n        return true;\\n    }\\n    \\n    vector<int> getCourseOrder(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        vector<bool> currDFS(nC, false);\\n        \\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i]) {\\n                if(!dfs(adj, i, visited, currDFS, s)) return {};\\n            }\\n        }\\n        \\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getCourseOrder(adj, nC));\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Approach: Kahn\\'s Algorithm */\\n/* TC: O(E + V+E) { for creatin adj list, traversing over all vector and edges }, \\n  SC: O(V+E + V + V + V) { Adjacency List, indegree-vector, queue, order } */\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> indegree(numCourses);\\n        vector<int> adj[numCourses];\\n        \\n        for(int i=0; i<prerequisites.size(); i++) {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            \\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        int doneCnt = 0;    // to keep track of number of nodes completed\\n        queue<int> q;\\n        \\n        /* Push all courses or nodes with indegree 0, means this course has no other prerequisite course */\\n        for(int i=0; i<indegree.size(); i++) {\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        vector<int> order;\\n        while(!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n\\n            doneCnt++; // incremenet complete count\\n            order.push_back(v); \\n            \\n            /* Decrease indegree for all adjacent node of v */\\n            for(int u : adj[v]) {\\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0) q.push(u);\\n            }\\n        }\\n        \\n        /* If all the nodes are traversed then order is correct otherwise graph has a cycle */\\n        return doneCnt == numCourses ? order : vector<int> {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327646,
                "title": "elegant-python-dfs",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # Handle edge case.\\n        if not prerequisites: return [course for course in range(numCourses)]\\n        \\n        # \\'parents\\' maps each course to a list of its pre\\n\\t\\t# -requisites.\\n        parents = {course: [] for course in range(numCourses)}\\n        for course, prerequisite in prerequisites:\\n            parents[course].append(prerequisite)\\n            \\n        topological_order = []\\n        visited, current_path = [False]*numCourses, [False]*numCourses\\n        \\n        # Returns False if the digraph rooted at \\'course\\'\\n\\t\\t# is acyclic, else, appends courses to \\'topological\\n        # _order\\' in topological order and returns True.\\n        def dfs(course):\\n            if current_path[course]: return False\\n            if visited[course]: return True\\n            visited[course], current_path[course] = True, True\\n            if parents[course]:\\n                for parent in parents[course]:\\n                    if not dfs(parent): return False\\n            topological_order.append(course)\\n            current_path[course] = False\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course): return []\\n            \\n        return topological_order\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # Handle edge case.\\n        if not prerequisites: return [course for course in range(numCourses)]\\n        \\n        # \\'parents\\' maps each course to a list of its pre\\n\\t\\t# -requisites.\\n        parents = {course: [] for course in range(numCourses)}\\n        for course, prerequisite in prerequisites:\\n            parents[course].append(prerequisite)\\n            \\n        topological_order = []\\n        visited, current_path = [False]*numCourses, [False]*numCourses\\n        \\n        # Returns False if the digraph rooted at \\'course\\'\\n\\t\\t# is acyclic, else, appends courses to \\'topological\\n        # _order\\' in topological order and returns True.\\n        def dfs(course):\\n            if current_path[course]: return False\\n            if visited[course]: return True\\n            visited[course], current_path[course] = True, True\\n            if parents[course]:\\n                for parent in parents[course]:\\n                    if not dfs(parent): return False\\n            topological_order.append(course)\\n            current_path[course] = False\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course): return []\\n            \\n        return topological_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317570,
                "title": "java-using-indegree-and-bfs-faster-than-94",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<Integer>[] graph = new ArrayList[numCourses];\\n        for(int i = 0; i < numCourses; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[numCourses];\\n        for(int[] pre : prerequisites) {\\n            int u = pre[0];\\n            int v = pre[1];\\n            graph[u].add(v);\\n            indegree[v]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i = 0; i < indegree.length; i++) {\\n            if(indegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        int i = numCourses - 1;\\n        int[] ans = new int[numCourses];\\n        while(!queue.isEmpty()) {\\n            int vtx = queue.poll();\\n            ans[i--] = vtx;\\n            \\n            for(int v : graph[vtx]){\\n                if(--indegree[v] == 0){\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n        \\n        if(i == -1)\\n            return ans;\\n       return new int[0];\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<Integer>[] graph = new ArrayList[numCourses];\\n        for(int i = 0; i < numCourses; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[numCourses];\\n        for(int[] pre : prerequisites) {\\n            int u = pre[0];\\n            int v = pre[1];\\n            graph[u].add(v);\\n            indegree[v]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i = 0; i < indegree.length; i++) {\\n            if(indegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        int i = numCourses - 1;\\n        int[] ans = new int[numCourses];\\n        while(!queue.isEmpty()) {\\n            int vtx = queue.poll();\\n            ans[i--] = vtx;\\n            \\n            for(int v : graph[vtx]){\\n                if(--indegree[v] == 0){\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n        \\n        if(i == -1)\\n            return ans;\\n       return new int[0];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096569,
                "title": "graph-class-implementation-adjacency-list-dfs-java",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        if(numCourses==1){\\n            return new int[] {0};\\n        }\\n        Graph g = new Graph(numCourses);\\n        for(int i=0; i<pre.length; i++){\\n            g.addEdge(pre[i][1], pre[i][0]);\\n        }\\n        return g.topSort();\\n    }\\n\\n    class Graph {\\n        class Node {\\n            int id;\\n            LinkedList<Node> adjacents = new LinkedList<>();\\n\\n            Node(int id) {\\n                this.id = id;\\n            }\\n        }\\n        \\n        int V;\\n\\n        Graph(int v) {\\n            this.V = v;\\n            for(int i=0; i<V; i++){\\n                nodeLookup.put(i, new Node(i));\\n            }\\n        }\\n\\n        HashMap<Integer, Node> nodeLookup = new HashMap<>();\\n\\n        Node getNode(int id) {\\n            if (nodeLookup.containsKey(id))\\n                return nodeLookup.get(id);\\n            else {\\n                Node newNode = new Node(id);\\n                nodeLookup.put(id, newNode);\\n                return newNode;\\n            }\\n        }\\n\\n        void addEdge(int source, int dest) {\\n            Node s = getNode(source);\\n            Node d = getNode(dest);\\n\\n            s.adjacents.add(d);\\n        }\\n\\n        boolean checkCycle() {\\n            boolean visited[] = new boolean[V];\\n            boolean tracker[] = new boolean[V];\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                boolean loop = DFS(visited, tracker, entry.getKey());\\n                if (loop) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        boolean DFS(boolean[] visited, boolean[] tracker, int current) {\\n            if (tracker[current]) {\\n                return true;\\n            }\\n            visited[current] = true;\\n            tracker[current] = true;\\n\\n            Node node = getNode(current);\\n            for (Node neighbor : node.adjacents) {\\n                boolean res = DFS(visited, tracker, neighbor.id);\\n                if (res) {\\n                    return true;\\n                }\\n            }\\n            tracker[current] = false;\\n\\n            return false;\\n        }\\n\\n        int[] topSort() {\\n            if (checkCycle()) {\\n                return new int[] {};\\n            }\\n            Stack<Integer> result = new Stack<>();\\n            HashSet<Integer> visited = new HashSet<>();\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                topSortHelper(entry.getKey(), visited, result);\\n            }\\n            int res[] = new int[result.size()];\\n            for (int i = 0; i < res.length; i++) {\\n                res[i] = result.pop();\\n            }\\n            return res;\\n        }\\n\\n        void topSortHelper(int id, HashSet<Integer> visited, Stack<Integer> result) {\\n            if (visited.contains(id)) {\\n                return;\\n            }\\n            visited.add(id);\\n            for (Node adjacent : getNode(id).adjacents) {\\n                topSortHelper(adjacent.id, visited, result);\\n            }\\n            result.push(id);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        if(numCourses==1){\\n            return new int[] {0};\\n        }\\n        Graph g = new Graph(numCourses);\\n        for(int i=0; i<pre.length; i++){\\n            g.addEdge(pre[i][1], pre[i][0]);\\n        }\\n        return g.topSort();\\n    }\\n\\n    class Graph {\\n        class Node {\\n            int id;\\n            LinkedList<Node> adjacents = new LinkedList<>();\\n\\n            Node(int id) {\\n                this.id = id;\\n            }\\n        }\\n        \\n        int V;\\n\\n        Graph(int v) {\\n            this.V = v;\\n            for(int i=0; i<V; i++){\\n                nodeLookup.put(i, new Node(i));\\n            }\\n        }\\n\\n        HashMap<Integer, Node> nodeLookup = new HashMap<>();\\n\\n        Node getNode(int id) {\\n            if (nodeLookup.containsKey(id))\\n                return nodeLookup.get(id);\\n            else {\\n                Node newNode = new Node(id);\\n                nodeLookup.put(id, newNode);\\n                return newNode;\\n            }\\n        }\\n\\n        void addEdge(int source, int dest) {\\n            Node s = getNode(source);\\n            Node d = getNode(dest);\\n\\n            s.adjacents.add(d);\\n        }\\n\\n        boolean checkCycle() {\\n            boolean visited[] = new boolean[V];\\n            boolean tracker[] = new boolean[V];\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                boolean loop = DFS(visited, tracker, entry.getKey());\\n                if (loop) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        boolean DFS(boolean[] visited, boolean[] tracker, int current) {\\n            if (tracker[current]) {\\n                return true;\\n            }\\n            visited[current] = true;\\n            tracker[current] = true;\\n\\n            Node node = getNode(current);\\n            for (Node neighbor : node.adjacents) {\\n                boolean res = DFS(visited, tracker, neighbor.id);\\n                if (res) {\\n                    return true;\\n                }\\n            }\\n            tracker[current] = false;\\n\\n            return false;\\n        }\\n\\n        int[] topSort() {\\n            if (checkCycle()) {\\n                return new int[] {};\\n            }\\n            Stack<Integer> result = new Stack<>();\\n            HashSet<Integer> visited = new HashSet<>();\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                topSortHelper(entry.getKey(), visited, result);\\n            }\\n            int res[] = new int[result.size()];\\n            for (int i = 0; i < res.length; i++) {\\n                res[i] = result.pop();\\n            }\\n            return res;\\n        }\\n\\n        void topSortHelper(int id, HashSet<Integer> visited, Stack<Integer> result) {\\n            if (visited.contains(id)) {\\n                return;\\n            }\\n            visited.add(id);\\n            for (Node adjacent : getNode(id).adjacents) {\\n                topSortHelper(adjacent.id, visited, result);\\n            }\\n            result.push(id);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998853,
                "title": "c-bfs-queue-easy-to-understand-explannation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> pre_req_count(numCourses,0);\\n        unordered_map<int,vector<int>> before_after;\\n        vector<int> res;\\n        \\n        for (int i=0; i<prerequisites.size(); ++i) {\\n            // \\n            before_after[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            //increase pre-req count of this course needed by 1 \\n            pre_req_count[prerequisites[i][0]]++;\\n        }\\n        \\n        int total = 0, curr;\\n        queue<int> q;\\n        //find all courses that don\\'t have any prerequisites and add to queue\\n        for (int i=0; i<pre_req_count.size(); ++i) {\\n            if (pre_req_count[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            curr = q.front(); q.pop();\\n            res.push_back(curr);\\n            //find all courses that has this course as pre-req\\n            for (auto &i : before_after[curr]) {\\n                //this course now has one less pre-req\\n                pre_req_count[i]--;\\n                //if now this course is pre-req free, add to q\\n                if (pre_req_count[i] == 0)\\n                    q.push(i);\\n            } \\n            ++total;\\n        }\\n        if (total != numCourses)\\n            return {};\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> pre_req_count(numCourses,0);\\n        unordered_map<int,vector<int>> before_after;\\n        vector<int> res;\\n        \\n        for (int i=0; i<prerequisites.size(); ++i) {\\n            // \\n            before_after[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            //increase pre-req count of this course needed by 1 \\n            pre_req_count[prerequisites[i][0]]++;\\n        }\\n        \\n        int total = 0, curr;\\n        queue<int> q;\\n        //find all courses that don\\'t have any prerequisites and add to queue\\n        for (int i=0; i<pre_req_count.size(); ++i) {\\n            if (pre_req_count[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            curr = q.front(); q.pop();\\n            res.push_back(curr);\\n            //find all courses that has this course as pre-req\\n            for (auto &i : before_after[curr]) {\\n                //this course now has one less pre-req\\n                pre_req_count[i]--;\\n                //if now this course is pre-req free, add to q\\n                if (pre_req_count[i] == 0)\\n                    q.push(i);\\n            } \\n            ++total;\\n        }\\n        if (total != numCourses)\\n            return {};\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942920,
                "title": "dfs-topological-sort-js-solution",
                "content": "```\\n// DFS\\nvar findOrder = function(numCourses, prerequisites) {\\n    let adjList = new Array(numCourses).fill(0).map(() => []);\\n    let visited = new Array(numCourses).fill(false);\\n    let inDegree = new Array(numCourses).fill(0);\\n    for (let [course, preCourse] of prerequisites) {\\n        adjList[preCourse].push(course);\\n        inDegree[course]++;\\n    }\\n    // We can take courses that have no prerequisite or whose pre-requisites have already been taken\\n    let res = [];\\n    for (let i = 0; i < numCourses; i++) {\\n        if (inDegree[i] == 0 && !visited[i]) {\\n            dfs(i);\\n        }\\n    }\\n\\n    return res.length === numCourses ? res : [];\\n    \\n    function dfs(node) {\\n        res.push(node);\\n        visited[node] = true;\\n        for (let next of adjList[node]) {\\n            inDegree[next]--;\\n            if (inDegree[next] == 0 && !visited[next]) {\\n                dfs(next);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(V + E), if there is a valid answer, we visit every node and all of its neighbours (those that current node is pointing to)\\n    // Space Complexity: O(V + E), for adjacency list  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// DFS\\nvar findOrder = function(numCourses, prerequisites) {\\n    let adjList = new Array(numCourses).fill(0).map(() => []);\\n    let visited = new Array(numCourses).fill(false);\\n    let inDegree = new Array(numCourses).fill(0);\\n    for (let [course, preCourse] of prerequisites) {\\n        adjList[preCourse].push(course);\\n        inDegree[course]++;\\n    }\\n    // We can take courses that have no prerequisite or whose pre-requisites have already been taken\\n    let res = [];\\n    for (let i = 0; i < numCourses; i++) {\\n        if (inDegree[i] == 0 && !visited[i]) {\\n            dfs(i);\\n        }\\n    }\\n\\n    return res.length === numCourses ? res : [];\\n    \\n    function dfs(node) {\\n        res.push(node);\\n        visited[node] = true;\\n        for (let next of adjList[node]) {\\n            inDegree[next]--;\\n            if (inDegree[next] == 0 && !visited[next]) {\\n                dfs(next);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(V + E), if there is a valid answer, we visit every node and all of its neighbours (those that current node is pointing to)\\n    // Space Complexity: O(V + E), for adjacency list  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807757,
                "title": "java-dfs-solution-detecting-cycle",
                "content": "1. Here its similar to the cycle detection problem.\\n2. We check for the cycle using the dfs recursion function and if cycle is encountered we just return empty array.\\n3. If we do not encounter the cycle, then we just add it into arraylist and return it as an integer array.\\n\\nGeneral Concept is:\\nJust check for the cycle, if cycle return empty array, else add the vertex to array and finally just return the array.\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int v = numCourses;\\n        List<List<Integer>> adjacent = new ArrayList<>(v);\\n        for (int i=0; i<numCourses; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int i=0; i<prerequisites.length; i++)\\n            adjacent.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        List<Integer> list = new ArrayList<>();\\n        boolean [] visited = new boolean[numCourses];\\n        boolean [] recursionStack = new boolean[numCourses];\\n        for (int i=0; i<numCourses; i++) {\\n            if (isCycle(i, visited, recursionStack, numCourses, adjacent, list))\\n                return new int[0];\\n            }\\n        int [] result = new int[list.size()];  \\n        for (int i=0; !list.isEmpty(); i++)\\n            result[i] = list.remove(0);\\n        return result;\\n    }\\n    public boolean isCycle(int v, boolean [] visited, boolean [] recursionStack, int numCourses, List<List<Integer>> adjacent,List<Integer> list){\\n        if (recursionStack[v])\\n            return true;\\n        if (visited[v])\\n            return false;\\n        visited[v]= true;\\n        recursionStack[v] = true;\\n        for (int child: adjacent.get(v)) {\\n            if (isCycle(child, visited, recursionStack, numCourses, adjacent, list))\\n                return true;\\n        }\\n        recursionStack[v] = false;\\n        list.add(v);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int v = numCourses;\\n        List<List<Integer>> adjacent = new ArrayList<>(v);\\n        for (int i=0; i<numCourses; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int i=0; i<prerequisites.length; i++)\\n            adjacent.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        List<Integer> list = new ArrayList<>();\\n        boolean [] visited = new boolean[numCourses];\\n        boolean [] recursionStack = new boolean[numCourses];\\n        for (int i=0; i<numCourses; i++) {\\n            if (isCycle(i, visited, recursionStack, numCourses, adjacent, list))\\n                return new int[0];\\n            }\\n        int [] result = new int[list.size()];  \\n        for (int i=0; !list.isEmpty(); i++)\\n            result[i] = list.remove(0);\\n        return result;\\n    }\\n    public boolean isCycle(int v, boolean [] visited, boolean [] recursionStack, int numCourses, List<List<Integer>> adjacent,List<Integer> list){\\n        if (recursionStack[v])\\n            return true;\\n        if (visited[v])\\n            return false;\\n        visited[v]= true;\\n        recursionStack[v] = true;\\n        for (int child: adjacent.get(v)) {\\n            if (isCycle(child, visited, recursionStack, numCourses, adjacent, list))\\n                return true;\\n        }\\n        recursionStack[v] = false;\\n        list.add(v);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775519,
                "title": "c-toposort-using-dfs-solution",
                "content": "Applying Topological Sort using DFS approach.\\nWe will use a state vector which will denote the state of any node at a given time.\\nStates:\\n-1: Node is unprocessed\\n0: Node is being processed\\n1: Node is processed\\n\\nChecking for cycle:\\nWhile traversing through DFS if we encounter a node which is at state 1 i.e. being processed, it means there is a cycle in the graph so we instantly break the program and retrun an empty array.\\n\\nIf there is no cycle, we coninue with dfs and then using backtracking add the nodes in the orderings vector, which is the resulting answer.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i, vector<int> &state, vector<int> &orderings, map<int, vector<int>> &adjList) {\\n        state[i] = 0;\\n        bool res = true;\\n        \\n        for(auto nextNode : adjList[i]) {\\n            if(state[nextNode] == -1)\\n                res = res & dfs(nextNode, state, orderings, adjList);\\n            if(state[nextNode] == 0)\\n                return false;\\n        }\\n        state[i] = 1;\\n        orderings.push_back(i);\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = numCourses;\\n        if(n==0)\\n            return {};\\n        \\n        //Making adjacency list\\n        map<int, vector<int>> adjList;\\n        for(int i=0;i<prerequisites.size();i++)\\n            adjList[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0; i<adjList.size();i++){\\n            cout<<i<<\":\";\\n            for(int j=0;j<adjList[i].size();j++)\\n                cout<<adjList[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        vector<int> state(n,-1);\\n        vector<int> orderings;\\n        \\n        for(int i=0;i<n;i++){\\n            if(state[i] == -1) {\\n                bool res = dfs(i, state, orderings, adjList);\\n                if(res == false)\\n                    return {};\\n            }\\n        }\\n        \\n        return orderings;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i, vector<int> &state, vector<int> &orderings, map<int, vector<int>> &adjList) {\\n        state[i] = 0;\\n        bool res = true;\\n        \\n        for(auto nextNode : adjList[i]) {\\n            if(state[nextNode] == -1)\\n                res = res & dfs(nextNode, state, orderings, adjList);\\n            if(state[nextNode] == 0)\\n                return false;\\n        }\\n        state[i] = 1;\\n        orderings.push_back(i);\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = numCourses;\\n        if(n==0)\\n            return {};\\n        \\n        //Making adjacency list\\n        map<int, vector<int>> adjList;\\n        for(int i=0;i<prerequisites.size();i++)\\n            adjList[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0; i<adjList.size();i++){\\n            cout<<i<<\":\";\\n            for(int j=0;j<adjList[i].size();j++)\\n                cout<<adjList[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        vector<int> state(n,-1);\\n        vector<int> orderings;\\n        \\n        for(int i=0;i<n;i++){\\n            if(state[i] == -1) {\\n                bool res = dfs(i, state, orderings, adjList);\\n                if(res == false)\\n                    return {};\\n            }\\n        }\\n        \\n        return orderings;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 746030,
                "title": "topological-sort-neater-than-official-solution",
                "content": "I found the official solution to be a bit of a confusing implementation of topological sort, so I wanted to share my implementation in case it helped anyone:\\n\\n```\\nclass Solution:\\n    def findOrder(self, numVertices, edges):\\n        visited = set()\\n        sortedList = []\\n        depsDict = {vertex: set() for vertex in range(numVertices)}\\n        for node, dep in edges: \\n\\t\\t\\tdepsDict[node].add(dep)\\n            \\n        noDeps = [vertex for vertex, deps in depsDict.items() if len(deps) == 0 and vertex not in visited]\\n        while noDeps:\\n            vertex = noDeps.pop()\\n            visited.add(vertex)\\n            sortedList.append(vertex)\\n            \\n            for node, dep in depsDict.items():\\n                if vertex in depsDict[node]:\\n                    depsDict[node].remove(vertex)\\n            \\n            noDeps = [vertex for vertex, deps in depsDict.items() if len(deps) == 0 and vertex not in visited]\\n            \\n        return sortedList if len(sortedList) == numVertices else []\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n    def findOrder(self, numVertices, edges):\\n        visited = set()\\n        sortedList = []\\n        depsDict = {vertex: set() for vertex in range(numVertices)}",
                "codeTag": "Java"
            },
            {
                "id": 741815,
                "title": "python-by-dfs-and-deadlock-detection-w-comment",
                "content": "Python by DFS and dead lock detection\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n\\n        NOT_CHECKED, CHECKING, COMPLETED = 0, 1, 2\\n        \\n        # -------------------------------\\n        \\n        def has_deadlock( course )->bool:\\n            \\n            if course_state[course] == CHECKING:\\n                # There is a cycle(i.e., deadlock ) in prerequisites\\n                return True\\n            \\n            elif course_state[course] == COMPLETED:\\n                # current course has been checked and marked as completed\\n                return False\\n            \\n            \\n            \\n            # update current course as checking\\n            course_state[course] = CHECKING\\n            \\n            # check pre_course in DFS and detect whether there is deadlock\\n            for pre_course in requirement[course]:\\n                \\n                if has_deadlock( pre_course ):\\n                    # deadlock is found, impossible to finish all courses\\n                    return True\\n                \\n                \\n                \\n            # update current course as completed\\n            course_state[course] = COMPLETED\\n            \\n            # add current completed course into taking order\\n            course_taking_order.append( course )\\n            \\n            return False\\n        \\n        # -------------------------------\\n        \\n        # each course maintain a list of its own prerequisites\\n        requirement = collections.defaultdict( list )\\n        \\n        for course, pre_course in prerequisites:\\n            requirement[course].append( pre_course )\\n        \\n        \\n        # each course maintain a state among {NOT_CHECKED, CHECKING, COMPLETED}\\n        course_state = [ NOT_CHECKED for _ in range(numCourses) ]\\n           \\n        \\n        course_taking_order = []\\n        \\n\\n        for course_idx in range(0, numCourses):\\n            \\n            if has_deadlock(course_idx):\\n                # deadlock is found, impossible to finish all courses\\n                return []\\n        \\n        \\n        return course_taking_order\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n\\n        NOT_CHECKED, CHECKING, COMPLETED = 0, 1, 2\\n        \\n        # -------------------------------\\n        \\n        def has_deadlock( course )->bool:\\n            \\n            if course_state[course] == CHECKING:\\n                # There is a cycle(i.e., deadlock ) in prerequisites\\n                return True\\n            \\n            elif course_state[course] == COMPLETED:\\n                # current course has been checked and marked as completed\\n                return False\\n            \\n            \\n            \\n            # update current course as checking\\n            course_state[course] = CHECKING\\n            \\n            # check pre_course in DFS and detect whether there is deadlock\\n            for pre_course in requirement[course]:\\n                \\n                if has_deadlock( pre_course ):\\n                    # deadlock is found, impossible to finish all courses\\n                    return True\\n                \\n                \\n                \\n            # update current course as completed\\n            course_state[course] = COMPLETED\\n            \\n            # add current completed course into taking order\\n            course_taking_order.append( course )\\n            \\n            return False\\n        \\n        # -------------------------------\\n        \\n        # each course maintain a list of its own prerequisites\\n        requirement = collections.defaultdict( list )\\n        \\n        for course, pre_course in prerequisites:\\n            requirement[course].append( pre_course )\\n        \\n        \\n        # each course maintain a state among {NOT_CHECKED, CHECKING, COMPLETED}\\n        course_state = [ NOT_CHECKED for _ in range(numCourses) ]\\n           \\n        \\n        course_taking_order = []\\n        \\n\\n        for course_idx in range(0, numCourses):\\n            \\n            if has_deadlock(course_idx):\\n                # deadlock is found, impossible to finish all courses\\n                return []\\n        \\n        \\n        return course_taking_order\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741765,
                "title": "c-solution-topological-order",
                "content": "```\\nclass Solution {\\npublic:\\n    //here topological order represents the topological order of the DAG\\n    //If it is not a DAG ,let us say A directed graph with cycles then \\n    //there topological ordering is not possible and topological_order here \\n    //contains the nodes leaving the nodes present in cycle .\\n    //This topological ordering represents a path through which each node is visited once.\\n    bool cycle_detect(int n, vector<int> &topological_order, vector<vector<int> > &adj) {\\n        vector<int> degree(n, 0);\\n        for (vector<int> p: adj)\\n            for(int node: p)\\n                degree[node]++;\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) q.push(i);\\n        while (!q.empty()) \\n        {\\n            int curr = q.front(); q.pop(); n--;\\n            topological_order.push_back(curr);\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) q.push(next);\\n        }\\n        return n == 0;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int> >& prerequisites) {\\n        vector<int> topologicalOrder;\\n        vector<vector<int> > adj(numCourses);\\n        for(vector<int> v: prerequisites){\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        if(!cycle_detect(numCourses, topologicalOrder, adj))\\n            return vector<int>(0);\\n        return topologicalOrder;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //here topological order represents the topological order of the DAG\\n    //If it is not a DAG ,let us say A directed graph with cycles then \\n    //there topological ordering is not possible and topological_order here \\n    //contains the nodes leaving the nodes present in cycle .\\n    //This topological ordering represents a path through which each node is visited once.\\n    bool cycle_detect(int n, vector<int> &topological_order, vector<vector<int> > &adj) {\\n        vector<int> degree(n, 0);\\n        for (vector<int> p: adj)\\n            for(int node: p)\\n                degree[node]++;\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) q.push(i);\\n        while (!q.empty()) \\n        {\\n            int curr = q.front(); q.pop(); n--;\\n            topological_order.push_back(curr);\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) q.push(next);\\n        }\\n        return n == 0;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int> >& prerequisites) {\\n        vector<int> topologicalOrder;\\n        vector<vector<int> > adj(numCourses);\\n        for(vector<int> v: prerequisites){\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        if(!cycle_detect(numCourses, topologicalOrder, adj))\\n            return vector<int>(0);\\n        return topologicalOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730056,
                "title": "c-topological-sort-using-3-markings-types",
                "content": "```csharp\\npublic class Solution \\n{\\n    enum Marking\\n    {\\n        Unvisited = 0,        \\n        Temporary = 1,\\n        Visited = 2\\n    };\\n    \\n    public int[] FindOrder(int numCourses, int[][] pre) \\n    {\\n        Marking[] visited = new Marking[numCourses];\\n        List<int> result = new List<int>();\\n        \\n        Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < numCourses; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        for(int i = 0; i < pre.Length; i++)\\n        {            \\n            graph[pre[i][1]].Add(pre[i][0]);\\n        }        \\n        \\n        for(int i = 0; i < graph.Count; i++)\\n        {           \\n            if(!visit(i, graph, visited, result))\\n            {\\n                return Array.Empty<int>();\\n            }            \\n        }\\n        \\n        result.Reverse();\\n        return result.ToArray();\\n    }\\n    \\n    private bool visit(int node, Dictionary<int, List<int>> graph, Marking[] visited, List<int> result)\\n    {\\n        if(visited[node] == Marking.Temporary)\\n        {\\n            return false;\\n        }\\n        \\n        if(visited[node] == Marking.Visited)\\n        {\\n            return true;\\n        }\\n                \\n        visited[node] = Marking.Temporary;\\n\\n        foreach(var neighbour in graph[node])\\n        {\\n            if(!visit(neighbour, graph, visited, result))\\n            {\\n                return false;    \\n            }  \\n        }        \\n\\n        visited[node] = Marking.Visited;\\n        result.Add(node);                \\n        return true;\\n    }\\n}\\n```\\n\\nAlso, In-Degree based solution:\\n\\n```csharp\\npublic int[] FindOrder(int numCourses, int[][] pre) \\n{\\n\\tList<int> result = new List<int>(numCourses);\\n\\tint[] inDegree = new int[numCourses];\\n\\tQueue<int> zeroInDegreeQueue = new Queue<int>();\\n\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<int>();\\n\\t}\\n\\n\\tfor(int i = 0; i < pre.Length; i++)\\n\\t{            \\n\\t\\tgraph[pre[i][1]].Add(pre[i][0]);\\n\\t\\tinDegree[pre[i][0]]++;\\n\\t} \\n\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tif(inDegree[i] == 0)\\n\\t\\t{                \\n\\t\\t\\tzeroInDegreeQueue.Enqueue(i);\\n\\t\\t}\\n\\t}\\n\\n\\twhile(zeroInDegreeQueue.Count > 0)\\n\\t{\\n\\t\\tint node = zeroInDegreeQueue.Dequeue();\\n\\t\\tresult.Add(node);\\n\\n\\t\\tforeach(var neighbour in graph[node])\\n\\t\\t{\\n\\t\\t\\tinDegree[neighbour]--;\\n\\t\\t\\tif(inDegree[neighbour] == 0)\\n\\t\\t\\t{             \\n\\t\\t\\t\\tzeroInDegreeQueue.Enqueue(neighbour);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(result.Count == numCourses)\\n\\t{            \\n\\t\\treturn result.ToArray();\\n\\t}\\n\\n\\treturn Array.Empty<int>();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    enum Marking\\n    {\\n        Unvisited = 0,        \\n        Temporary = 1,\\n        Visited = 2\\n    };\\n    \\n    public int[] FindOrder(int numCourses, int[][] pre) \\n    {\\n        Marking[] visited = new Marking[numCourses];\\n        List<int> result = new List<int>();\\n        \\n        Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < numCourses; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        for(int i = 0; i < pre.Length; i++)\\n        {            \\n            graph[pre[i][1]].Add(pre[i][0]);\\n        }        \\n        \\n        for(int i = 0; i < graph.Count; i++)\\n        {           \\n            if(!visit(i, graph, visited, result))\\n            {\\n                return Array.Empty<int>();\\n            }            \\n        }\\n        \\n        result.Reverse();\\n        return result.ToArray();\\n    }\\n    \\n    private bool visit(int node, Dictionary<int, List<int>> graph, Marking[] visited, List<int> result)\\n    {\\n        if(visited[node] == Marking.Temporary)\\n        {\\n            return false;\\n        }\\n        \\n        if(visited[node] == Marking.Visited)\\n        {\\n            return true;\\n        }\\n                \\n        visited[node] = Marking.Temporary;\\n\\n        foreach(var neighbour in graph[node])\\n        {\\n            if(!visit(neighbour, graph, visited, result))\\n            {\\n                return false;    \\n            }  \\n        }        \\n\\n        visited[node] = Marking.Visited;\\n        result.Add(node);                \\n        return true;\\n    }\\n}\\n```\n```csharp\\npublic int[] FindOrder(int numCourses, int[][] pre) \\n{\\n\\tList<int> result = new List<int>(numCourses);\\n\\tint[] inDegree = new int[numCourses];\\n\\tQueue<int> zeroInDegreeQueue = new Queue<int>();\\n\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<int>();\\n\\t}\\n\\n\\tfor(int i = 0; i < pre.Length; i++)\\n\\t{            \\n\\t\\tgraph[pre[i][1]].Add(pre[i][0]);\\n\\t\\tinDegree[pre[i][0]]++;\\n\\t} \\n\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tif(inDegree[i] == 0)\\n\\t\\t{                \\n\\t\\t\\tzeroInDegreeQueue.Enqueue(i);\\n\\t\\t}\\n\\t}\\n\\n\\twhile(zeroInDegreeQueue.Count > 0)\\n\\t{\\n\\t\\tint node = zeroInDegreeQueue.Dequeue();\\n\\t\\tresult.Add(node);\\n\\n\\t\\tforeach(var neighbour in graph[node])\\n\\t\\t{\\n\\t\\t\\tinDegree[neighbour]--;\\n\\t\\t\\tif(inDegree[neighbour] == 0)\\n\\t\\t\\t{             \\n\\t\\t\\t\\tzeroInDegreeQueue.Enqueue(neighbour);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(result.Count == numCourses)\\n\\t{            \\n\\t\\treturn result.ToArray();\\n\\t}\\n\\n\\treturn Array.Empty<int>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723374,
                "title": "neat-python3-iterative-postorder-dfs",
                "content": "```Python\\nNOT_VISITED = 0\\nDISCOVERING = 1\\nVISITED = 2\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # construct graph\\n        graph_neighbor = collections.defaultdict(list)\\n        for course, pre in prerequisites:\\n            graph_neighbor[pre].append(course)\\n        \\n        # iterative postorder DFS for topological sort\\n        tsort_rev = []\\n        status = [NOT_VISITED] * numCourses\\n        \\n        for course in range(numCourses):\\n            if status[course] == NOT_VISITED:\\n                dfs = [course]\\n                status[course] = DISCOVERING\\n                \\n                while dfs:\\n                    if graph_neighbor[dfs[-1]]:\\n                        n = graph_neighbor[dfs[-1]].pop()\\n                        if status[n] == DISCOVERING:\\n                            return []\\n                        if status[n] == NOT_VISITED:\\n                            dfs.append(n)\\n                            status[n] = DISCOVERING\\n                    else:\\n                        tsort_rev.append(dfs.pop())\\n                        status[tsort_rev[-1]] = VISITED\\n        \\n        return tsort_rev[::-1]\\n```",
                "solutionTags": [],
                "code": "```Python\\nNOT_VISITED = 0\\nDISCOVERING = 1\\nVISITED = 2\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # construct graph\\n        graph_neighbor = collections.defaultdict(list)\\n        for course, pre in prerequisites:\\n            graph_neighbor[pre].append(course)\\n        \\n        # iterative postorder DFS for topological sort\\n        tsort_rev = []\\n        status = [NOT_VISITED] * numCourses\\n        \\n        for course in range(numCourses):\\n            if status[course] == NOT_VISITED:\\n                dfs = [course]\\n                status[course] = DISCOVERING\\n                \\n                while dfs:\\n                    if graph_neighbor[dfs[-1]]:\\n                        n = graph_neighbor[dfs[-1]].pop()\\n                        if status[n] == DISCOVERING:\\n                            return []\\n                        if status[n] == NOT_VISITED:\\n                            dfs.append(n)\\n                            status[n] = DISCOVERING\\n                    else:\\n                        tsort_rev.append(dfs.pop())\\n                        status[tsort_rev[-1]] = VISITED\\n        \\n        return tsort_rev[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663036,
                "title": "c",
                "content": "topological sort again\\n```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        List<int>[] g = new List<int>[numCourses];\\n        int[] indegree = new int[numCourses];\\n        Queue<int> q = new Queue<int>();\\n        Stack<int> s = new Stack<int>();\\n        int[] res = new int[numCourses];\\n        \\n        foreach (var item in prerequisites)\\n        {\\n            if (g[item[0]] == null)\\n                g[item[0]] = new List<int>();\\n            \\n            g[item[0]].Add(item[1]);\\n            indegree[item[1]] += 1;\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++)\\n            if (indegree[i] == 0)\\n                q.Enqueue(i);\\n        \\n        while (q.Count > 0)\\n        {\\n            int cur = q.Dequeue();\\n            \\n            if (g[cur] != null)            \\n                foreach (var item in g[cur])\\n                    if (--indegree[item] == 0)\\n                        q.Enqueue(item);\\n            \\n            s.Push(cur);\\n        }\\n        \\n        if (s.Count != numCourses)\\n            return new int[] { };\\n        \\n        for (int i = 0; i < numCourses; i++)\\n            res[i] = s.Pop();\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        List<int>[] g = new List<int>[numCourses];\\n        int[] indegree = new int[numCourses];\\n        Queue<int> q = new Queue<int>();\\n        Stack<int> s = new Stack<int>();\\n        int[] res = new int[numCourses];\\n        \\n        foreach (var item in prerequisites)\\n        {\\n            if (g[item[0]] == null)\\n                g[item[0]] = new List<int>();\\n            \\n            g[item[0]].Add(item[1]);\\n            indegree[item[1]] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 294815,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    // do not need backtracking because we only need one solution.\\n    private int[] _result;\\n    private int resultIndex = 0;\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        _result = new int[numCourses];\\n\\n        var adjacencyMatrix = new HashSet<int>[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyMatrix[i] = new HashSet<int>();\\n        }\\n\\n        foreach (var fromTo in prerequisites) {\\n            var from = fromTo[0];\\n            var to = fromTo[1];\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        var isVisited = new bool[numCourses];\\n        var isAdded = new bool[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            if (isAdded[i]) continue;\\n            var noCyclic = DFS(i, adjacencyMatrix, isVisited, isAdded);\\n            if (!noCyclic) return new int[0];\\n        }\\n\\n        return _result;\\n    }\\n\\n    private bool DFS(int cur, HashSet<int>[] adjacencyMatrix, bool[] isVisited, bool[] isAdded) {\\n        if (isVisited[cur]) return false;\\n\\n        isVisited[cur] = true;\\n        var nextCourses = adjacencyMatrix[cur];\\n\\n        foreach (var next in nextCourses) {\\n            var oneResult = DFS(next, adjacencyMatrix, isVisited, isAdded);\\n            if (!oneResult) return false;\\n        }\\n\\n        if (!isAdded[cur]) {\\n            _result[resultIndex] = cur;\\n            resultIndex++;\\n            isAdded[cur] = true;\\n        }\\n\\n        isVisited[cur] = false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // do not need backtracking because we only need one solution.\\n    private int[] _result;\\n    private int resultIndex = 0;\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        _result = new int[numCourses];\\n\\n        var adjacencyMatrix = new HashSet<int>[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyMatrix[i] = new HashSet<int>();\\n        }\\n\\n        foreach (var fromTo in prerequisites) {\\n            var from = fromTo[0];\\n            var to = fromTo[1];\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        var isVisited = new bool[numCourses];\\n        var isAdded = new bool[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            if (isAdded[i]) continue;\\n            var noCyclic = DFS(i, adjacencyMatrix, isVisited, isAdded);\\n            if (!noCyclic) return new int[0];\\n        }\\n\\n        return _result;\\n    }\\n\\n    private bool DFS(int cur, HashSet<int>[] adjacencyMatrix, bool[] isVisited, bool[] isAdded) {\\n        if (isVisited[cur]) return false;\\n\\n        isVisited[cur] = true;\\n        var nextCourses = adjacencyMatrix[cur];\\n\\n        foreach (var next in nextCourses) {\\n            var oneResult = DFS(next, adjacencyMatrix, isVisited, isAdded);\\n            if (!oneResult) return false;\\n        }\\n\\n        if (!isAdded[cur]) {\\n            _result[resultIndex] = cur;\\n            resultIndex++;\\n            isAdded[cur] = true;\\n        }\\n\\n        isVisited[cur] = false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251095,
                "title": "java-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] inDegrees = new int[numCourses];\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        \\n        for (int[] edge : prerequisites) {\\n            int start = edge[1], end = edge[0];\\n            inDegrees[end]++;\\n            if (!graph.containsKey(start))  graph.put(start, new ArrayList());\\n            graph.get(start).add(end);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList();\\n        int[] res = new int[numCourses];\\n        int idx = 0, count = 0;\\n        \\n        for (int i = 0; i < numCourses; ++i) {\\n            if (inDegrees[i] == 0)  queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            int course = queue.poll();\\n            if(graph.containsKey(course)) {\\n                for (int neigh : graph.get(course)) {\\n                    if (--inDegrees[neigh] == 0) {\\n                        queue.offer(neigh);\\n                    }\\n                }\\n            }\\n            res[idx++] = course;\\n            count++;\\n        }\\n        return count == numCourses ? res : new int[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] inDegrees = new int[numCourses];\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        \\n        for (int[] edge : prerequisites) {\\n            int start = edge[1], end = edge[0];\\n            inDegrees[end]++;\\n            if (!graph.containsKey(start))  graph.put(start, new ArrayList());\\n            graph.get(start).add(end);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList();\\n        int[] res = new int[numCourses];\\n        int idx = 0, count = 0;\\n        \\n        for (int i = 0; i < numCourses; ++i) {\\n            if (inDegrees[i] == 0)  queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            int course = queue.poll();\\n            if(graph.containsKey(course)) {\\n                for (int neigh : graph.get(course)) {\\n                    if (--inDegrees[neigh] == 0) {\\n                        queue.offer(neigh);\\n                    }\\n                }\\n            }\\n            res[idx++] = course;\\n            count++;\\n        }\\n        return count == numCourses ? res : new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248415,
                "title": "simple-java-solutions-kahn-dfs-5ms",
                "content": "Kahn approach :\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tint[] inDegrees = new int[numCourses];\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t\\t++inDegrees[prerequisite[0]];\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < inDegrees.length; i++) {\\n\\t\\tif (inDegrees[i] == 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[numCourses];\\n\\tint pos = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint course = queue.remove();\\n\\t\\tfor (int vertex : adjLists.get(course)) {\\n\\t\\t\\tif (--inDegrees[vertex] == 0) {\\n\\t\\t\\t\\tqueue.add(vertex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[pos++] = course;\\n\\t}\\n\\n\\treturn pos == numCourses ? res : new int[] {};\\n}\\n```\\n\\nDFS approach:\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t}\\n\\n\\tboolean[] visited = new boolean[numCourses];\\n\\tboolean[] onVisitingPath = new boolean[numCourses];\\n\\tLinkedList<Integer> stack = new LinkedList<>();\\n\\n\\tfor (int i = 0; i < numCourses; i++) {\\n\\t\\tif (!visited[i]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, i);\\n\\t\\t}\\n\\t}\\n\\n\\tif (stack.size() != numCourses) {\\n\\t\\treturn new int[] {};\\n\\t} else {\\n\\t\\tint[] res = new int[numCourses];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\nprivate void dfs(List<List<Integer>> adjLists, LinkedList<Integer> stack, boolean[] visited,\\n\\t\\tboolean[] onVisitingPath, int curr) {\\n\\n\\tvisited[curr] = true;\\n\\tonVisitingPath[curr] = true;\\n\\tfor (int vertex : adjLists.get(curr)) {\\n\\t\\tif (onVisitingPath[vertex]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visited[vertex]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, vertex);\\n\\t\\t}\\n\\t}\\n\\tonVisitingPath[curr] = false;\\n\\tstack.push(curr);\\n}\\n```\\n\\nHope this helps ! :D",
                "solutionTags": [],
                "code": "```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tint[] inDegrees = new int[numCourses];\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t\\t++inDegrees[prerequisite[0]];\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < inDegrees.length; i++) {\\n\\t\\tif (inDegrees[i] == 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[numCourses];\\n\\tint pos = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint course = queue.remove();\\n\\t\\tfor (int vertex : adjLists.get(course)) {\\n\\t\\t\\tif (--inDegrees[vertex] == 0) {\\n\\t\\t\\t\\tqueue.add(vertex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[pos++] = course;\\n\\t}\\n\\n\\treturn pos == numCourses ? res : new int[] {};\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t}\\n\\n\\tboolean[] visited = new boolean[numCourses];\\n\\tboolean[] onVisitingPath = new boolean[numCourses];\\n\\tLinkedList<Integer> stack = new LinkedList<>();\\n\\n\\tfor (int i = 0; i < numCourses; i++) {\\n\\t\\tif (!visited[i]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, i);\\n\\t\\t}\\n\\t}\\n\\n\\tif (stack.size() != numCourses) {\\n\\t\\treturn new int[] {};\\n\\t} else {\\n\\t\\tint[] res = new int[numCourses];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\nprivate void dfs(List<List<Integer>> adjLists, LinkedList<Integer> stack, boolean[] visited,\\n\\t\\tboolean[] onVisitingPath, int curr) {\\n\\n\\tvisited[curr] = true;\\n\\tonVisitingPath[curr] = true;\\n\\tfor (int vertex : adjLists.get(curr)) {\\n\\t\\tif (onVisitingPath[vertex]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visited[vertex]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, vertex);\\n\\t\\t}\\n\\t}\\n\\tonVisitingPath[curr] = false;\\n\\tstack.push(curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59365,
                "title": "easily-understand-9ms-java-solution-using-bfs-with-topological-sorting",
                "content": "This solution is based on BFS and topological sorting algorithm.\\nI was inspired a solution in Course Schedule, here is the problem: [link text](https://leetcode.com/problems/course-schedule/?tab=Description). But I can't find the solution now. I will add the link later. ^^\\nWe need an **adjacent table** to record the relationship between prerequisite course and current course. \\nAlso, we need an **indegree table** to record the number of courses we need to taken in order to take this current course.\\n**queue** is to record the course with indegree 0, which means we can take this course immediately without limitation.\\nOnce we take the course with indegree 0, we can look up other courses which require this course as prerequisite and subtract their indegree by 1. \\nOnce the indegree is 0, add this course to the queue.\\nbefore return, we need to check if there's a circle.\\n```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n// initialize an adjacent table\\n      List<Integer>[] adj = new List[numCourses];\\n      for(int i = 0; i < numCourses; i++){\\n          adj[i] = new ArrayList<Integer>();\\n      }\\n// define an indegree table recording the number of prerequisite courses should be taken in order to take this current course\\n      int[] indegree = new int[numCourses];\\n      int[] result = new int[numCourses];\\n      for(int i = 0; i < prerequisites.length; i++){\\n          int preCourses = prerequisites[i][1];\\n          int curCourses = prerequisites[i][0];\\n          adj[preCourses].add(curCourses);\\n          indegree[curCourses]++;\\n      }\\n// to find the course with indegree 0 (which we can take immediately)\\n      Queue<Integer> readyCourses = new LinkedList<Integer>();\\n      for(int i = 0; i < numCourses; i++){\\n          if(indegree[i] == 0){\\n              readyCourses.offer(i);\\n          }\\n      }\\n      int count = 0;\\n// if we take the course with indegree 0, we look up for the courses needing this course as prerequisite and subtract their indegree value by 1\\n      while(!readyCourses.isEmpty()){\\n          int ready = readyCourses.poll();\\n          result[count++] = ready;\\n          for(int nextCourse : adj[ready]){\\n              indegree[nextCourse]--;\\n              if(indegree[nextCourse] == 0){\\n                  readyCourses.offer(nextCourse);\\n              }\\n          }\\n      }\\n// to check if there's a circle-like requirements before return\\n      return count == numCourses ? result : new int[0];\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n// initialize an adjacent table\\n      List<Integer>[] adj = new List[numCourses];\\n      for(int i = 0; i < numCourses; i++){\\n          adj[i] = new ArrayList<Integer>();\\n      }\\n// define an indegree table recording the number of prerequisite courses should be taken in order to take this current course\\n      int[] indegree = new int[numCourses];\\n      int[] result = new int[numCourses];\\n      for(int i = 0; i < prerequisites.length; i++){\\n          int preCourses = prerequisites[i][1];\\n          int curCourses = prerequisites[i][0];\\n          adj[preCourses].add(curCourses);\\n          indegree[curCourses]++;\\n      }\\n// to find the course with indegree 0 (which we can take immediately)\\n      Queue<Integer> readyCourses = new LinkedList<Integer>();\\n      for(int i = 0; i < numCourses; i++){\\n          if(indegree[i] == 0){\\n              readyCourses.offer(i);\\n          }\\n      }\\n      int count = 0;\\n// if we take the course with indegree 0, we look up for the courses needing this course as prerequisite and subtract their indegree value by 1\\n      while(!readyCourses.isEmpty()){\\n          int ready = readyCourses.poll();\\n          result[count++] = ready;\\n          for(int nextCourse : adj[ready]){\\n              indegree[nextCourse]--;\\n              if(indegree[nextCourse] == 0){\\n                  readyCourses.offer(nextCourse);\\n              }\\n          }\\n      }\\n// to check if there's a circle-like requirements before return\\n      return count == numCourses ? result : new int[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59423,
                "title": "pure-c-recursive-solution-8ms-beats-100",
                "content": "1. choose a course as start point, DFS.\\n2. if there is a circle, return;\\n3. else record all the points from bottom to up. and set all the points with a `visited` flag.\\n4. when you encounter any of these visited points, just ignoring it, because all the points and their prerequisites have already been recorded.\\n         \\n```\\nbool helper(int **list, int *len, int start, char *flag, char *visited, int *res, int *returnSize) {\\n        flag[start] = 1; \\n\\tint i;\\n\\tfor (i = 0; i < len[start]; i++) {\\n\\t\\tint key = list[start][i];\\n\\t\\tif (visited[key]) continue;\\n\\t\\tif (flag[key]) return false;\\n\\t\\tif (!len[key]) {\\n\\t\\t\\tres[(*returnSize)++] = key;\\n\\t\\t\\tvisited[key] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, key, flag, visited, res, returnSize)) return false;\\n\\t}\\n\\tflag[start] = 0;  // backtracing\\n\\tvisited[start] = 1;\\n\\tres[(*returnSize)++] = start;\\n\\treturn true;\\n}\\n\\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesRowSize, int prerequisitesColSize, int* returnSize) {\\n\\tif (numCourses < 1) return 0;\\n\\tint *res = malloc(numCourses * sizeof(int));\\n\\t*returnSize = 0;\\n\\tint **list = calloc(numCourses, sizeof(int *));\\n\\tint *len = calloc(numCourses, sizeof(int));\\n\\tint i;\\n\\tfor (i = 0; i < prerequisitesRowSize; i++) {\\n\\t\\tint left = prerequisites[i][0];\\n\\t\\tint right = prerequisites[i][1];\\n\\t\\tlen[left]++;\\n\\t\\tlist[left] = realloc(list[left], len[left] * sizeof(int));\\n\\t\\tlist[left][len[left] - 1] = right;\\n\\t}\\n\\n\\tchar *flag = calloc(numCourses, 1);  //for single traversal from a start point.\\n\\tchar *visited = calloc(numCourses, 1); //for all traversal.\\n\\tfor (i = 0; i < numCourses; i++) {\\n\\t\\tif (visited[i]) continue; \\n\\t\\tif (!len[i]) {\\n\\t\\t\\tres[(*returnSize)++] = i;\\n\\t\\t\\tvisited[i] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, i, flag, visited, res, returnSize)) {\\n\\t\\t\\t*returnSize = 0;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool helper(int **list, int *len, int start, char *flag, char *visited, int *res, int *returnSize) {\\n        flag[start] = 1; \\n\\tint i;\\n\\tfor (i = 0; i < len[start]; i++) {\\n\\t\\tint key = list[start][i];\\n\\t\\tif (visited[key]) continue;\\n\\t\\tif (flag[key]) return false;\\n\\t\\tif (!len[key]) {\\n\\t\\t\\tres[(*returnSize)++] = key;\\n\\t\\t\\tvisited[key] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, key, flag, visited, res, returnSize)) return false;\\n\\t}\\n\\tflag[start] = 0;  // backtracing\\n\\tvisited[start] = 1;\\n\\tres[(*returnSize)++] = start;\\n\\treturn true;\\n}\\n\\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesRowSize, int prerequisitesColSize, int* returnSize) {\\n\\tif (numCourses < 1) return 0;\\n\\tint *res = malloc(numCourses * sizeof(int));\\n\\t*returnSize = 0;\\n\\tint **list = calloc(numCourses, sizeof(int *));\\n\\tint *len = calloc(numCourses, sizeof(int));\\n\\tint i;\\n\\tfor (i = 0; i < prerequisitesRowSize; i++) {\\n\\t\\tint left = prerequisites[i][0];\\n\\t\\tint right = prerequisites[i][1];\\n\\t\\tlen[left]++;\\n\\t\\tlist[left] = realloc(list[left], len[left] * sizeof(int));\\n\\t\\tlist[left][len[left] - 1] = right;\\n\\t}\\n\\n\\tchar *flag = calloc(numCourses, 1);  //for single traversal from a start point.\\n\\tchar *visited = calloc(numCourses, 1); //for all traversal.\\n\\tfor (i = 0; i < numCourses; i++) {\\n\\t\\tif (visited[i]) continue; \\n\\t\\tif (!len[i]) {\\n\\t\\t\\tres[(*returnSize)++] = i;\\n\\t\\t\\tvisited[i] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, i, flag, visited, res, returnSize)) {\\n\\t\\t\\t*returnSize = 0;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704398,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto it:prerequisites){\\n            adj[it[1]].push_back(it[0]);\\n            indegree[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        vector<int> topo;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            topo.push_back(it);\\n            for(auto node:adj[it]){\\n                indegree[node]--;\\n                if(indegree[node] == 0)\\n                    q.push(node);\\n            }\\n        }\\n        if(topo.size() == n)\\n            return topo;\\n        return {};\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto it:prerequisites){\\n            adj[it[1]].push_back(it[0]);\\n            indegree[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        vector<int> topo;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            topo.push_back(it);\\n            for(auto node:adj[it]){\\n                indegree[node]--;\\n                if(indegree[node] == 0)\\n                    q.push(node);\\n            }\\n        }\\n        if(topo.size() == n)\\n            return topo;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589844,
                "title": "i-had-provided-you-the-easiest-solution-using-topology-sort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> adj(numCourses);\\n        for (auto it : prerequisites) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> indegree(numCourses, 0);\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int it : adj[i]) {\\n                indegree[it]++;\\n            }\\n        }\\n        \\n        queue<int> pq;\\n        for (int i = 0; i < numCourses; i++) {\\n            if (indegree[i] == 0) {\\n                pq.push(i);\\n            }\\n        }\\n        \\n        vector<int> topo;\\n        while (!pq.empty()) {\\n            int curr = pq.front();\\n            topo.push_back(curr);\\n            pq.pop();\\n            \\n            for (int it : adj[curr]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0) {\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        \\n        if (topo.size() != numCourses) {\\n            return {}; // Return empty array if there is a cycle\\n        }\\n        \\n        return topo; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> adj(numCourses);\\n        for (auto it : prerequisites) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> indegree(numCourses, 0);\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int it : adj[i]) {\\n                indegree[it]++;\\n            }\\n        }\\n        \\n        queue<int> pq;\\n        for (int i = 0; i < numCourses; i++) {\\n            if (indegree[i] == 0) {\\n                pq.push(i);\\n            }\\n        }\\n        \\n        vector<int> topo;\\n        while (!pq.empty()) {\\n            int curr = pq.front();\\n            topo.push_back(curr);\\n            pq.pop();\\n            \\n            for (int it : adj[curr]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0) {\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        \\n        if (topo.size() != numCourses) {\\n            return {}; // Return empty array if there is a cycle\\n        }\\n        \\n        return topo; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542870,
                "title": "python-simple-and-clean-beats-90-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem of finding the order of courses to finish all courses can be modeled as a graph problem. Each course can be represented as a node in the graph, and the prerequisites can be represented as directed edges between the nodes. The problem then becomes one of finding a topological ordering of the nodes in the graph.\\n\\n# Approach\\n1. Initialize an empty list `toposort` to store the topological ordering of the nodes.\\n2. Create an adjacency list `AList` to represent the graph and a dictionary `indegree` to keep track of the indegree of each node.\\n3. For each edge in the prerequisites, add an edge from `bi` to `ai` in the adjacency list and increment the indegree of node `ai`.\\n4. Initialize a queue and add all nodes with indegree 0 to it.\\n5. While the queue is not empty, remove the first node from the queue and add it to `toposort`.\\n6. For each neighbor of the removed node, decrement its indegree by 1. If its indegree becomes 0, add it to the queue.\\n7. If the length of `toposort` is equal to `numCourses`, return `toposort`. Otherwise, return an empty array because it is impossible to finish all courses.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$ where $$n$$ is the number of courses and $$e$$ is the number of prerequisites.\\n- Space complexity: $$O(n + e)$$ where $$n$$ is the number of courses and $$e$$ is the number of prerequisites.\\n\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, p: List[List[int]]) -> List[int]:\\n        toposort = []\\n        queue = deque()\\n        AList = defaultdict(list)\\n        indegree = defaultdict(lambda:0)\\n        for edge in p:\\n            indegree[edge[0]]+=1\\n            AList[edge[1]].append(edge[0])\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n        while len(queue)>0:\\n            curr = queue.popleft()\\n            toposort.append(curr)\\n            for nodes in AList[curr]:\\n                indegree[nodes]-=1\\n                if indegree[nodes]==0:\\n                    queue.append(nodes)\\n        return toposort if len(toposort)==numCourses else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, p: List[List[int]]) -> List[int]:\\n        toposort = []\\n        queue = deque()\\n        AList = defaultdict(list)\\n        indegree = defaultdict(lambda:0)\\n        for edge in p:\\n            indegree[edge[0]]+=1\\n            AList[edge[1]].append(edge[0])\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n        while len(queue)>0:\\n            curr = queue.popleft()\\n            toposort.append(curr)\\n            for nodes in AList[curr]:\\n                indegree[nodes]-=1\\n                if indegree[nodes]==0:\\n                    queue.append(nodes)\\n        return toposort if len(toposort)==numCourses else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469846,
                "title": "topological-sorting-python",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        dic={i:[] for i in range(numCourses)}\\n        for crs,pre in prerequisites:\\n            dic[crs].append(pre)\\n        output=[]\\n        visit,cycle=set(),set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            cycle.add(crs)\\n            for pre in dic[crs]:\\n                if dfs(pre)==False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for c in range(numCourses):\\n            if dfs(c)==False:\\n                return []\\n        return output\\n   ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        dic={i:[] for i in range(numCourses)}\\n        for crs,pre in prerequisites:\\n            dic[crs].append(pre)\\n        output=[]\\n        visit,cycle=set(),set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            cycle.add(crs)\\n            for pre in dic[crs]:\\n                if dfs(pre)==False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for c in range(numCourses):\\n            if dfs(c)==False:\\n                return []\\n        return output\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3468058,
                "title": "swift-solution-topological-sort-beats-92-9",
                "content": "```\\nfunc findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n      var inDegreesArr = Array(repeating: 0, count: numCourses)\\n      var adjDict = [Int: [Int]]()\\n      \\n      for prereqPair in prerequisites {\\n          inDegreesArr[prereqPair[0]] += 1\\n          adjDict[prereqPair[1], default: []].append(prereqPair[0])\\n      }\\n      \\n      var zeroIndegreeQueue = [Int]()\\n      for courseNumber in 0..<numCourses {\\n          if inDegreesArr[courseNumber] == 0 {\\n              zeroIndegreeQueue.append(courseNumber)\\n          }\\n      }\\n      \\n      var topologicallySortedCourses = [Int]()\\n      while !zeroIndegreeQueue.isEmpty {\\n          let prereqCourse = zeroIndegreeQueue.removeFirst()\\n          topologicallySortedCourses.append(prereqCourse)\\n          \\n          for course in adjDict[prereqCourse] ?? [] {\\n              inDegreesArr[course] -= 1\\n              if inDegreesArr[course] == 0 {\\n                  zeroIndegreeQueue.append(course)\\n              }\\n          }\\n      }\\n      return (topologicallySortedCourses.count == numCourses) ? topologicallySortedCourses : []\\n  }\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n      var inDegreesArr = Array(repeating: 0, count: numCourses)\\n      var adjDict = [Int: [Int]]()\\n      \\n      for prereqPair in prerequisites {\\n          inDegreesArr[prereqPair[0]] += 1\\n          adjDict[prereqPair[1], default: []].append(prereqPair[0])\\n      }\\n      \\n      var zeroIndegreeQueue = [Int]()\\n      for courseNumber in 0..<numCourses {\\n          if inDegreesArr[courseNumber] == 0 {\\n              zeroIndegreeQueue.append(courseNumber)\\n          }\\n      }\\n      \\n      var topologicallySortedCourses = [Int]()\\n      while !zeroIndegreeQueue.isEmpty {\\n          let prereqCourse = zeroIndegreeQueue.removeFirst()\\n          topologicallySortedCourses.append(prereqCourse)\\n          \\n          for course in adjDict[prereqCourse] ?? [] {\\n              inDegreesArr[course] -= 1\\n              if inDegreesArr[course] == 0 {\\n                  zeroIndegreeQueue.append(course)\\n              }\\n          }\\n      }\\n      return (topologicallySortedCourses.count == numCourses) ? topologicallySortedCourses : []\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333839,
                "title": "python-solution-using-topological-sort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        prereq = {c:[] for c in range(numCourses)}\\n        for crs, pre in prerequisites:\\n            prereq[crs].append(pre)\\n        \\n        output = []\\n        visit, cycle = set(), set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            \\n            cycle.add(crs)\\n            for pre in prereq[crs]:\\n                if dfs(pre)== False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for i in range(numCourses):\\n            if dfs(i) == False:\\n                return []\\n        return output\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        prereq = {c:[] for c in range(numCourses)}\\n        for crs, pre in prerequisites:\\n            prereq[crs].append(pre)\\n        \\n        output = []\\n        visit, cycle = set(), set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            \\n            cycle.add(crs)\\n            for pre in prereq[crs]:\\n                if dfs(pre)== False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for i in range(numCourses):\\n            if dfs(i) == False:\\n                return []\\n        return output\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136324,
                "title": "java-kahn-s-algorithm-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList < ArrayList < Integer >>adj=new ArrayList<>();\\n\\n        for(int i=0;i<=numCourses;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<prerequisites.length;i++){\\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n        }\\n\\n\\n        Queue<Integer>q=new LinkedList<>();\\n        int indegree[]=new int[numCourses];\\n        \\n        for(int i=0;i<numCourses;i++){\\n            for(int e:adj.get(i)){\\n                indegree[e]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans[]=new int[numCourses];\\n        int i=0;\\n        \\n        while(!q.isEmpty()){\\n            int node=q.peek();\\n            q.poll();\\n            ans[i++]=node;\\n            \\n            for(int e:adj.get(node)){\\n                indegree[e]--;\\n                if(indegree[e]==0) q.add(e);\\n            }\\n        }\\n        if(i==numCourses) return ans;\\n        int arr[]={};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList < ArrayList < Integer >>adj=new ArrayList<>();\\n\\n        for(int i=0;i<=numCourses;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<prerequisites.length;i++){\\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n        }\\n\\n\\n        Queue<Integer>q=new LinkedList<>();\\n        int indegree[]=new int[numCourses];\\n        \\n        for(int i=0;i<numCourses;i++){\\n            for(int e:adj.get(i)){\\n                indegree[e]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans[]=new int[numCourses];\\n        int i=0;\\n        \\n        while(!q.isEmpty()){\\n            int node=q.peek();\\n            q.poll();\\n            ans[i++]=node;\\n            \\n            for(int e:adj.get(node)){\\n                indegree[e]--;\\n                if(indegree[e]==0) q.add(e);\\n            }\\n        }\\n        if(i==numCourses) return ans;\\n        int arr[]={};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136253,
                "title": "c-striver-toposort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> findOrder(int V, vector<vector<int>> prerequisites)\\n\\t{\\n\\t\\tvector<int> adj[V];\\n\\t\\tfor (auto it : prerequisites) {\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tvector<int> indegree(V , 0);\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tfor (auto it : adj[i]) {\\n\\t\\t\\t\\tindegree[it]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue<int> q;\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tif (indegree[i] == 0) {\\n\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> topo;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint node = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t// node is in your topo sort\\n\\t\\t\\t// so please remove it from the indegree\\n\\n\\t\\t\\tfor (auto it : adj[node]) {\\n\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\tif (indegree[it] == 0) q.push(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topo.size() == V) return topo;\\n\\t\\treturn {};\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> findOrder(int V, vector<vector<int>> prerequisites)\\n\\t{\\n\\t\\tvector<int> adj[V];\\n\\t\\tfor (auto it : prerequisites) {\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tvector<int> indegree(V , 0);\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tfor (auto it : adj[i]) {\\n\\t\\t\\t\\tindegree[it]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue<int> q;\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tif (indegree[i] == 0) {\\n\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> topo;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint node = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t// node is in your topo sort\\n\\t\\t\\t// so please remove it from the indegree\\n\\n\\t\\t\\tfor (auto it : adj[node]) {\\n\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\tif (indegree[it] == 0) q.push(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topo.size() == V) return topo;\\n\\t\\treturn {};\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967250,
                "title": "c-striver-s-easy-approach-easy-clean",
                "content": "![image](https://assets.leetcode.com/users/images/b7e0daab-d4eb-404e-84a0-c8b8eaa9cccd_1672318597.4229276.png)\\n\\n***Logic-> No logic! Very basic question of Topological sorting.Just apply it!***\\n\\n**T->O(n+e) [For directed graph, same as BFS Traversal] && S->O(n)**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findOrder(int n,vector<vector<int>>& pre) {\\n\\t\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\t\\tfor(auto i:pre) adj[i[1]].push_back(i[0]);\\n\\t\\t\\t\\tvector<int> topo;\\n\\t\\t\\t\\tvector<int> in(n,0);\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tfor(auto j:adj[node]) in[j]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tif(!in[node]) q.push(node);  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t\\t\\tfor(auto i:adj[node]){\\n\\t\\t\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\t\\t\\tif(!in[i]) q.push(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(topo.size()!=n) return {};\\n\\t\\t\\t\\treturn topo;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findOrder(int n,vector<vector<int>>& pre) {\\n\\t\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\t\\tfor(auto i:pre) adj[i[1]].push_back(i[0]);\\n\\t\\t\\t\\tvector<int> topo;\\n\\t\\t\\t\\tvector<int> in(n,0);\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tfor(auto j:adj[node]) in[j]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2509569,
                "title": "leetcode-the-hard-way-bfs-topological-sort-with-template-explained",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\nAlso exact same solution as [207. Course Schedule](https://leetcode.com/problems/course-schedule/discuss/2509551/LeetCode-The-Hard-Way-BFS-Topological-Sort-with-Template-Explained).\\n\\n---\\n\\n```cpp\\n// for topological sorting tutorial,\\n// see https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/topological-sorting\\nstruct TopologicalSort {\\n    int n;\\n    vector<int> indegree;\\n    vector<int> orders;\\n    vector<vector<int>> G;\\n    bool isTopologicalSorted = false;\\n\\n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\\n        G = g;\\n        n = (int) G.size();\\n        indegree = in;\\n\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            auto u = q.front(); q.pop();\\n            orders.push_back(u);\\n            for(auto v : G[u]) {\\n                if(--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n            res++;\\n        }\\n        isTopologicalSorted = res == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        // define the graph\\n        vector<vector<int>> g(n);\\n        // define indegree\\n        vector<int> indegree(n);\\n        // build the graph\\n        for(auto p : prerequisites) {\\n            // we have to take p[1] in order to take p[0]\\n            g[p[1]].push_back(p[0]);\\n            // increase indegree by 1 for p[0]\\n            indegree[p[0]]++;\\n        }\\n        // init topological sort\\n        TopologicalSort ts(g, indegree);\\n        // we can finish all courses only if we can topologically sort\\n        // hence, return an empty array if it cannot be sorted\\n        if (!ts.isTopologicalSorted) return {};\\n        // else return the order\\n        return ts.orders;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```cpp\\n// for topological sorting tutorial,\\n// see https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/topological-sorting\\nstruct TopologicalSort {\\n    int n;\\n    vector<int> indegree;\\n    vector<int> orders;\\n    vector<vector<int>> G;\\n    bool isTopologicalSorted = false;\\n\\n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\\n        G = g;\\n        n = (int) G.size();\\n        indegree = in;\\n\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            auto u = q.front(); q.pop();\\n            orders.push_back(u);\\n            for(auto v : G[u]) {\\n                if(--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n            res++;\\n        }\\n        isTopologicalSorted = res == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        // define the graph\\n        vector<vector<int>> g(n);\\n        // define indegree\\n        vector<int> indegree(n);\\n        // build the graph\\n        for(auto p : prerequisites) {\\n            // we have to take p[1] in order to take p[0]\\n            g[p[1]].push_back(p[0]);\\n            // increase indegree by 1 for p[0]\\n            indegree[p[0]]++;\\n        }\\n        // init topological sort\\n        TopologicalSort ts(g, indegree);\\n        // we can finish all courses only if we can topologically sort\\n        // hence, return an empty array if it cannot be sorted\\n        if (!ts.isTopologicalSorted) return {};\\n        // else return the order\\n        return ts.orders;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467417,
                "title": "python-solution-using-topological-sort-bfs-approach",
                "content": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # build the graph\\n        visited = [0] * numCourses\\n        graph = defaultdict(list)\\n        for courses in prerequisites:\\n            graph[courses[1]].append(courses[0])\\n            visited[courses[0]] += 1\\n            \\n        # add courses that doesn\\'t have any prerequisite to the queue\\n        queue = deque()\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                queue.append(i)\\n        \\n        # topological sort algorithm using bfs approach\\n        course_order = []\\n        while queue:\\n            course = queue.popleft()\\n            course_order.append(course)\\n            for prerequisite in graph[course]:\\n                visited[prerequisite] -= 1\\n                if visited[prerequisite] == 0:\\n                    queue.append(prerequisite)\\n                    \\n        return course_order if len(course_order) == numCourses else []",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # build the graph\\n        visited = [0] * numCourses\\n        graph = defaultdict(list)\\n        for courses in prerequisites:\\n            graph[courses[1]].append(courses[0])\\n            visited[courses[0]] += 1\\n            \\n        # add courses that doesn\\'t have any prerequisite to the queue\\n        queue = deque()\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                queue.append(i)\\n        \\n        # topological sort algorithm using bfs approach\\n        course_order = []\\n        while queue:\\n            course = queue.popleft()\\n            course_order.append(course)\\n            for prerequisite in graph[course]:\\n                visited[prerequisite] -= 1\\n                if visited[prerequisite] == 0:\\n                    queue.append(prerequisite)\\n                    \\n        return course_order if len(course_order) == numCourses else []",
                "codeTag": "Python3"
            },
            {
                "id": 2335321,
                "title": "c-topological-sort-dfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void topologicalSort(vector<int>adj[],vector<bool>& visited, stack<int>& st, int node){\\n        visited[node]=true;\\n        for(auto it: adj[node]){ //dfs \\n            if(!visited[it]) topologicalSort(adj,visited,st,it); \\n        }\\n        st.push(node); //push node into stack after its dfs call is over\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++){ //creating adjacency list\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n        }\\n        vector<bool>visited(numCourses, false);\\n        stack<int> st;\\n        unordered_map<int,int> position;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]) topologicalSort(adj,visited,st,i); \\n        }\\n        vector<int> ans;\\n        int idx=0;\\n        while(!st.empty()){\\n            ans.push_back(st.top()); //storing ordering in ans vector\\n            position[st.top()]=idx; //indexing all nodes in map to check if ordering is possible\\n            idx++;\\n            st.pop();\\n        }\\n        for(int i=0;i<numCourses;i++){\\n            for(auto it: adj[i]){\\n                if(position[i]>position[it]) return {}; //if ordering not possible\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you find this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void topologicalSort(vector<int>adj[],vector<bool>& visited, stack<int>& st, int node){\\n        visited[node]=true;\\n        for(auto it: adj[node]){ //dfs \\n            if(!visited[it]) topologicalSort(adj,visited,st,it); \\n        }\\n        st.push(node); //push node into stack after its dfs call is over\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++){ //creating adjacency list\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n        }\\n        vector<bool>visited(numCourses, false);\\n        stack<int> st;\\n        unordered_map<int,int> position;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]) topologicalSort(adj,visited,st,i); \\n        }\\n        vector<int> ans;\\n        int idx=0;\\n        while(!st.empty()){\\n            ans.push_back(st.top()); //storing ordering in ans vector\\n            position[st.top()]=idx; //indexing all nodes in map to check if ordering is possible\\n            idx++;\\n            st.pop();\\n        }\\n        for(int i=0;i<numCourses;i++){\\n            for(auto it: adj[i]){\\n                if(position[i]>position[it]) return {}; //if ordering not possible\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207652,
                "title": "c-dfs-topological-sort-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&pre,vector<bool>&visi,vector<bool>& proc,int val){\\n        if(proc[val])\\n            return false;\\n        if(visi[val])\\n            return true;\\n        \\n        visi[val]=true;\\n        \\n        for(int j=0;j<pre[val].size();j++){\\n            if(dfs(pre,visi,proc,pre[val][j]))\\n                return true;\\n        }\\n        visi[val]=false;\\n        return false;\\n    }\\n    \\n    bool cycleDetect(vector<vector<int>>&pre,vector<bool>&visi,int V){\\n        vector<bool> proc(V,false);\\n        for(int i=0;i<V;i++){       \\n            if(dfs(pre,visi,proc,i))\\n                return true;\\n            proc[i]=true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void toposort(vector<vector<int>> &temp,int val,stack<int>&st,vector<bool>&visited){\\n        for(int i=0;i<temp[val].size();i++){\\n            if(!visited[temp[val][i]])\\n                toposort(temp,temp[val][i],st,visited);\\n        }\\n        visited[val]=true;\\n        st.push(val);\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<bool> visited(numCourses,false);\\n        vector<vector<int>> temp(numCourses);\\n        vector<int> ans;\\n        for(int i=0;i<prerequisites.size();i++){\\n            temp[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //if the course are related in cyclic then there will be no sequence of course picking as they all depened on each other.\\n        if(cycleDetect(temp,visited,numCourses))\\n            return ans;\\n        \\n        \\n        // Here we use topological sort as it give most independent course first and so on........\\n        stack<int> st;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]){\\n                toposort(temp,i,st,visited);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&pre,vector<bool>&visi,vector<bool>& proc,int val){\\n        if(proc[val])\\n            return false;\\n        if(visi[val])\\n            return true;\\n        \\n        visi[val]=true;\\n        \\n        for(int j=0;j<pre[val].size();j++){\\n            if(dfs(pre,visi,proc,pre[val][j]))\\n                return true;\\n        }\\n        visi[val]=false;\\n        return false;\\n    }\\n    \\n    bool cycleDetect(vector<vector<int>>&pre,vector<bool>&visi,int V){\\n        vector<bool> proc(V,false);\\n        for(int i=0;i<V;i++){       \\n            if(dfs(pre,visi,proc,i))\\n                return true;\\n            proc[i]=true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void toposort(vector<vector<int>> &temp,int val,stack<int>&st,vector<bool>&visited){\\n        for(int i=0;i<temp[val].size();i++){\\n            if(!visited[temp[val][i]])\\n                toposort(temp,temp[val][i],st,visited);\\n        }\\n        visited[val]=true;\\n        st.push(val);\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<bool> visited(numCourses,false);\\n        vector<vector<int>> temp(numCourses);\\n        vector<int> ans;\\n        for(int i=0;i<prerequisites.size();i++){\\n            temp[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //if the course are related in cyclic then there will be no sequence of course picking as they all depened on each other.\\n        if(cycleDetect(temp,visited,numCourses))\\n            return ans;\\n        \\n        \\n        // Here we use topological sort as it give most independent course first and so on........\\n        stack<int> st;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]){\\n                toposort(temp,i,st,visited);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755757,
                "title": "getting-tle-using-kahn-s-algorithm-can-anyone-help",
                "content": "I have solved this problem using Kahn\\'s algorithm but getting TLE on test case 42/44. My solution is mostly similar to the the provided solution no. 2 by LeetCode (again it is Kahn\\'s algo). Can you please tell me how can I optimise this solution.\\n```\\nclass Solution {\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int N, graph &prerequisites){\\n        graph g(N);\\n        for(int i=0; i<N; i++){\\n            for(auto edge : prerequisites)\\n                g[edge[1]].push_back(edge[0]);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeInDegree(int N, graph &g){\\n        vector<int>inDegree(N, 0);\\n        for(int u=0; u<N; u++){\\n            for(auto v : g[u]){\\n                inDegree[v]++;\\n            }\\n        }\\n        return inDegree;\\n    }\\n    \\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<int>inDegree, topoOrder;\\n        \\n        graph g = buildGraph(numCourses, prerequisites);\\n        inDegree = computeInDegree(numCourses, g);\\n        \\n        queue<int>q;\\n        for(int i=0; i<numCourses; i++){\\n            if(inDegree[i]==0) q.push(i);\\n        }\\n        \\n        int cntNodes = 0;\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            cntNodes++;\\n            if(cntNodes > numCourses) return {};\\n            topoOrder.push_back(curNode);\\n            \\n            for(auto to : g[curNode]){\\n                inDegree[to]--;\\n                if(inDegree[to]==0) \\n                    q.push(to);\\n            }\\n        }\\n        \\n        if(cntNodes==numCourses)\\n            return topoOrder;\\n        return {};\\n    }\\n};\\n```\\nthank you in advance!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int N, graph &prerequisites){\\n        graph g(N);\\n        for(int i=0; i<N; i++){\\n            for(auto edge : prerequisites)\\n                g[edge[1]].push_back(edge[0]);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeInDegree(int N, graph &g){\\n        vector<int>inDegree(N, 0);\\n        for(int u=0; u<N; u++){\\n            for(auto v : g[u]){\\n                inDegree[v]++;\\n            }\\n        }\\n        return inDegree;\\n    }\\n    \\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<int>inDegree, topoOrder;\\n        \\n        graph g = buildGraph(numCourses, prerequisites);\\n        inDegree = computeInDegree(numCourses, g);\\n        \\n        queue<int>q;\\n        for(int i=0; i<numCourses; i++){\\n            if(inDegree[i]==0) q.push(i);\\n        }\\n        \\n        int cntNodes = 0;\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            cntNodes++;\\n            if(cntNodes > numCourses) return {};\\n            topoOrder.push_back(curNode);\\n            \\n            for(auto to : g[curNode]){\\n                inDegree[to]--;\\n                if(inDegree[to]==0) \\n                    q.push(to);\\n            }\\n        }\\n        \\n        if(cntNodes==numCourses)\\n            return topoOrder;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642812,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642387,
                "title": "python3-iterative-toposort-explained",
                "content": "Approach this problem in three steps:\\n\\n1. Build an adjacency list\\n2. Do Topological Sort of the courses (iterative)\\n3. Check for cycles. While building the result out of the stack from the TopoSort, we create a dictionary that maps each node to its position in the toposort. Then iterate over the adjacency list to verify whether all parent nodes are located before children. Notice that checking for cycles also can be done during the topological sort which simplifies the algorithm (check the solution).\\n\\nTime: **O(n)** - linear for all scans\\nSpace: **O(n)** - linear for all sets and stacks\\n\\nRuntime: 92 ms, faster than **94.59%** of Python3 online submissions for Course Schedule II.\\nMemory Usage: 15.9 MB, less than **46.39%** of Python3 online submissions for Course Schedule II.\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, pr: List[List[int]]) -> List[int]:\\n\\t\\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for a, b in prerequisites:\\n            adj[b].append(a)\\n            \\n        # TopoSort\\n        topo = list()\\n        vis = set()\\n        processed = set()\\n        for node in range(numCourses):\\n            if node in vis:\\n                continue\\n                \\n            st = [node]\\n            while st:\\n                cur = st[-1]\\n                vis.add(cur)\\n                \\n                if cur in processed:\\n                    st.pop()\\n                    continue\\n                \\n\\t\\t\\t\\tfor ch in adj[cur]:\\n\\t\\t\\t\\t\\tif not ch in vis:\\n\\t\\t\\t\\t\\t\\tst.append(ch)\\n                    \\n                if cur == st[-1]:\\n                    topo.append(st.pop())\\n                    processed.add(cur)\\n\\n        # Result\\n        res = []\\n        i = 0\\n        pos = dict()\\n        while topo:\\n            node = topo.pop()\\n            pos[node] = i\\n            i += 1\\n            res.append(node)\\n        \\n        # Check for cycles\\n        for parent, children in adj.items():\\n            for child in children:\\n                if pos[parent] > pos[child]:\\n                    return []\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, pr: List[List[int]]) -> List[int]:\\n\\t\\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for a, b in prerequisites:\\n            adj[b].append(a)\\n            \\n        # TopoSort\\n        topo = list()\\n        vis = set()\\n        processed = set()\\n        for node in range(numCourses):\\n            if node in vis:\\n                continue\\n                \\n            st = [node]\\n            while st:\\n                cur = st[-1]\\n                vis.add(cur)\\n                \\n                if cur in processed:\\n                    st.pop()\\n                    continue\\n                \\n\\t\\t\\t\\tfor ch in adj[cur]:\\n\\t\\t\\t\\t\\tif not ch in vis:\\n\\t\\t\\t\\t\\t\\tst.append(ch)\\n                    \\n                if cur == st[-1]:\\n                    topo.append(st.pop())\\n                    processed.add(cur)\\n\\n        # Result\\n        res = []\\n        i = 0\\n        pos = dict()\\n        while topo:\\n            node = topo.pop()\\n            pos[node] = i\\n            i += 1\\n            res.append(node)\\n        \\n        # Check for cycles\\n        for parent, children in adj.items():\\n            for child in children:\\n                if pos[parent] > pos[child]:\\n                    return []\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466187,
                "title": "python-bfs-topological-sort-solution-time-o-v-e-space-o-v-e",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        map, inDegrees = [set() for i in range(numCourses)], [0]*numCourses\\n        for pre in prerequisites:\\n            map[pre[1]].add(pre[0])\\n            inDegrees[pre[0]] += 1\\n        result, queue = [], deque()\\n        for i in range(numCourses):\\n            if inDegrees[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            current = queue.popleft()\\n            result.append(current)\\n            for i in map[current]:\\n                inDegrees[i] -= 1\\n                if inDegrees[i] == 0:\\n                    queue.append(i)\\n        \\n        for i in range(numCourses):\\n            if inDegrees[i] != 0:\\n                return []\\n        return result;\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        map, inDegrees = [set() for i in range(numCourses)], [0]*numCourses\\n        for pre in prerequisites:\\n            map[pre[1]].add(pre[0])\\n            inDegrees[pre[0]] += 1\\n        result, queue = [], deque()\\n        for i in range(numCourses):\\n            if inDegrees[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            current = queue.popleft()\\n            result.append(current)\\n            for i in map[current]:\\n                inDegrees[i] -= 1\\n                if inDegrees[i] == 0:\\n                    queue.append(i)\\n        \\n        for i in range(numCourses):\\n            if inDegrees[i] != 0:\\n                return []\\n        return result;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367215,
                "title": "c-simple-bfs",
                "content": "Use return array as the queue :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector <int> cnt(n, 0), ret;\\n        vector <vector <int>> edge(n); // prerequisite edges\\n        for (auto &z : p) {\\n            int x = z[0], y = z[1];\\n            edge[y].push_back(x); // after taking course \\'y\\' we might want to take course \\'x\\'\\n            cnt[x]++; // indegree up, means there are cnt[x] courses we need to take before taking course \\'x\\'\\n        }\\n        for (int i = 0; i < n; i++)\\n            if (cnt[i] == 0) // every course that doesn\\'t have prerequisites we can add to the queue and take these courses\\n                ret.push_back(i); // put courses we can take into our return array\\n        for (int i = 0; i < ret.size(); i++) // go by the courses we can take\\n            for (auto &x : edge[ret[i]]) // check every other course we might want to take from the current course\\n                if (--cnt[x] == 0) // reduce prerequisite count\\n                    ret.push_back(x);  // add courses to the queue if they don\\'t have any more prerequisites\\n        return ret.size() == n ? ret : vector <int> (); // if \\'ret\\' has \\'n\\' elements means we were able to take all courses, otherwise we couldn\\'t.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector <int> cnt(n, 0), ret;\\n        vector <vector <int>> edge(n); // prerequisite edges\\n        for (auto &z : p) {\\n            int x = z[0], y = z[1];\\n            edge[y].push_back(x); // after taking course \\'y\\' we might want to take course \\'x\\'\\n            cnt[x]++; // indegree up, means there are cnt[x] courses we need to take before taking course \\'x\\'\\n        }\\n        for (int i = 0; i < n; i++)\\n            if (cnt[i] == 0) // every course that doesn\\'t have prerequisites we can add to the queue and take these courses\\n                ret.push_back(i); // put courses we can take into our return array\\n        for (int i = 0; i < ret.size(); i++) // go by the courses we can take\\n            for (auto &x : edge[ret[i]]) // check every other course we might want to take from the current course\\n                if (--cnt[x] == 0) // reduce prerequisite count\\n                    ret.push_back(x);  // add courses to the queue if they don\\'t have any more prerequisites\\n        return ret.size() == n ? ret : vector <int> (); // if \\'ret\\' has \\'n\\' elements means we were able to take all courses, otherwise we couldn\\'t.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302468,
                "title": "c-simple-solution-using-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    //using topological sort\\n    vector<int> findOrder(int n, vector<vector<int>>& preq) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n);    \\n        vector<int> ans;\\n        \\n        for(auto i : preq) {\\n            adj[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;              \\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i<n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int node= q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto v : adj[node]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) q.push(v);\\n            }\\n        }\\n        \\n        return ans.size() == n ? ans : vector<int> {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using topological sort\\n    vector<int> findOrder(int n, vector<vector<int>>& preq) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n);    \\n        vector<int> ans;\\n        \\n        for(auto i : preq) {\\n            adj[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;              \\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i<n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int node= q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto v : adj[node]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) q.push(v);\\n            }\\n        }\\n        \\n        return ans.size() == n ? ans : vector<int> {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270578,
                "title": "js-kahn-s-topological-sort-algorithm",
                "content": "```javascript\\nfunction findOrder(numCourses, prerequisites) {\\n    const adjacencyList = Array(numCourses).fill().map(x => []);\\n    const node2inDegree = new Uint8Array(numCourses);\\n    prerequisites.forEach(([course, prereq]) => {\\n        adjacencyList[prereq].push(course);\\n        node2inDegree[course]++;\\n    });\\n\\n    const order = new Set();\\n    const courses = Object.entries(node2inDegree).reduce((acc, [node, inDegree]) => {\\n        if (inDegree === 0)\\n            acc.push(node);\\n        return acc;\\n    }, []);\\n\\n    while (courses.length) {\\n        const top = courses.pop();\\n        for (const neighbour of adjacencyList[top]) {\\n            if (order.has(neighbour))\\n                return [];\\n            if (--node2inDegree[neighbour] === 0)\\n                courses.push(neighbour);\\n        }\\n        order.add(Number(top));\\n    }\\n\\n    return order.size === numCourses ? Array.from(order) : [];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```javascript\\nfunction findOrder(numCourses, prerequisites) {\\n    const adjacencyList = Array(numCourses).fill().map(x => []);\\n    const node2inDegree = new Uint8Array(numCourses);\\n    prerequisites.forEach(([course, prereq]) => {\\n        adjacencyList[prereq].push(course);\\n        node2inDegree[course]++;\\n    });\\n\\n    const order = new Set();\\n    const courses = Object.entries(node2inDegree).reduce((acc, [node, inDegree]) => {\\n        if (inDegree === 0)\\n            acc.push(node);\\n        return acc;\\n    }, []);\\n\\n    while (courses.length) {\\n        const top = courses.pop();\\n        for (const neighbour of adjacencyList[top]) {\\n            if (order.has(neighbour))\\n                return [];\\n            if (--node2inDegree[neighbour] === 0)\\n                courses.push(neighbour);\\n        }\\n        order.add(Number(top));\\n    }\\n\\n    return order.size === numCourses ? Array.from(order) : [];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247385,
                "title": "java-easy-solution-using-kahn-s-algorithm-bfs",
                "content": "**Please Upvote if you liked this post**\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0;i<numCourses;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        int [] indegree = new int[numCourses];\\n        \\n        for(int i = 0;i<prerequisites.length;i++){\\n            map.get(prerequisites[i][1]).add(prerequisites[i][0]);  //for ex in [0,1] to make edge 1->0\\n            indegree[prerequisites[i][0]]++; //indegree of node 0 will be incremented\\n        }\\n        \\n        int topo[] = new int[numCourses];\\n        int count = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        \\n        for(int i = 0;i<indegree.length;i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int idx = 0;\\n        while(q.size() > 0){\\n            int rem = q.poll();\\n\\t\\t\\tcount++                                    //count will be used to test whether graph is DAG or not\\n            topo[idx++] = rem;\\n            for(int nbr : map.get(rem)){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    q.add(nbr);\\n                }\\n            }\\n        }\\n        \\n        return count == numCourses ? topo : new int[]{};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0;i<numCourses;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        int [] indegree = new int[numCourses];\\n        \\n        for(int i = 0;i<prerequisites.length;i++){\\n            map.get(prerequisites[i][1]).add(prerequisites[i][0]);  //for ex in [0,1] to make edge 1->0\\n            indegree[prerequisites[i][0]]++; //indegree of node 0 will be incremented\\n        }\\n        \\n        int topo[] = new int[numCourses];\\n        int count = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        \\n        for(int i = 0;i<indegree.length;i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int idx = 0;\\n        while(q.size() > 0){\\n            int rem = q.poll();\\n\\t\\t\\tcount++                                    //count will be used to test whether graph is DAG or not\\n            topo[idx++] = rem;\\n            for(int nbr : map.get(rem)){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    q.add(nbr);\\n                }\\n            }\\n        }\\n        \\n        return count == numCourses ? topo : new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214268,
                "title": "c-easy-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> degree(n, 0);\\n        for (auto &p: pre) {\\n            adj[p[1]].push_back(p[0]);\\n            degree[p[0]]++;\\n        }\\n        queue<int> q;\\n        vector<int> res;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        while (!q.empty()) {\\n            int curr = q.front(); q.pop(); n--;\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) \\n                {\\n                    q.push(next);\\n                    res.push_back(next);   \\n                }\\n        }\\n        if(n==0)\\n            return res;\\n        else\\n            return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> degree(n, 0);\\n        for (auto &p: pre) {\\n            adj[p[1]].push_back(p[0]);\\n            degree[p[0]]++;\\n        }\\n        queue<int> q;\\n        vector<int> res;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        while (!q.empty()) {\\n            int curr = q.front(); q.pop(); n--;\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) \\n                {\\n                    q.push(next);\\n                    res.push_back(next);   \\n                }\\n        }\\n        if(n==0)\\n            return res;\\n        else\\n            return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961954,
                "title": "topological-sort-easy-java-solution",
                "content": "Here we are using Topological Sorting approach.\\nStep 1 : Calculate indegree for each of the nodes.\\nStep 2: The nodes with indegree 0 are added to queue for processing. After a node with 0 degree(say y) is processed it its added to an ans arrays and also  we reduce the degree of the nodes (to which y was the incoming edge) by 1\\nStep 3: In the end we\\'ll check if the total courses is equal to the nodes that we have processed, if they are equal so return the array that we have created by popping the queue elements else return null array.\\n\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int ans[] = new int[numCourses];\\n        int indegree[] = new int[numCourses];\\n        \\n        for(int i=0;i<prerequisites.length;i++)\\n        {\\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        Queue<Integer> bfs = new LinkedList<>();\\n        \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(indegree[i] == 0)\\n                bfs.add(i);\\n        }\\n    \\n        int count = bfs.size();\\n        \\n        int j=0;\\n       \\n        while(!bfs.isEmpty())\\n        {\\n             int comp=bfs.poll();\\n            ans[j++]=comp;\\n            for(int i=0;i<prerequisites.length;i++)\\n            {\\n                if(prerequisites[i][1] == comp)\\n                {\\n                    int dependent=prerequisites[i][0];\\n                    indegree[dependent]--;\\n                    \\n                    if(indegree[dependent] == 0)\\n                    {  bfs.add(dependent);\\n                     count++;\\n                    }\\n                }\\n            }\\n        }\\n        return (count == numCourses) ? ans : new int[0];\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int ans[] = new int[numCourses];\\n        int indegree[] = new int[numCourses];\\n        \\n        for(int i=0;i<prerequisites.length;i++)\\n        {\\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        Queue<Integer> bfs = new LinkedList<>();\\n        \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(indegree[i] == 0)\\n                bfs.add(i);\\n        }\\n    \\n        int count = bfs.size();\\n        \\n        int j=0;\\n       \\n        while(!bfs.isEmpty())\\n        {\\n             int comp=bfs.poll();\\n            ans[j++]=comp;\\n            for(int i=0;i<prerequisites.length;i++)\\n            {\\n                if(prerequisites[i][1] == comp)\\n                {\\n                    int dependent=prerequisites[i][0];\\n                    indegree[dependent]--;\\n                    \\n                    if(indegree[dependent] == 0)\\n                    {  bfs.add(dependent);\\n                     count++;\\n                    }\\n                }\\n            }\\n        }\\n        return (count == numCourses) ? ans : new int[0];\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805495,
                "title": "faster-than-95-less-space-that-80-python-topological-sort-indegree-queue",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        indegree = [0 for i in range(numCourses)]\\n        adj = [[] for i in range(numCourses)]\\n        ans = []\\n        for [a,b] in prerequisites:\\n            adj[a].append(b)\\n            indegree[b] += 1\\n        queue = []\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n                ans.append(i)\\n        if queue==[]:\\n            return []\\n        while queue:\\n            j = queue.pop()\\n            for i in adj[j]:\\n                indegree[i] -= 1\\n                if indegree[i]==0:\\n                    queue.append(i)\\n                    ans.append(i)\\n        if indegree==[0 for i in range(numCourses)]:\\n            return ans[::-1]\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        indegree = [0 for i in range(numCourses)]\\n        adj = [[] for i in range(numCourses)]\\n        ans = []\\n        for [a,b] in prerequisites:\\n            adj[a].append(b)\\n            indegree[b] += 1\\n        queue = []\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n                ans.append(i)\\n        if queue==[]:\\n            return []\\n        while queue:\\n            j = queue.pop()\\n            for i in adj[j]:\\n                indegree[i] -= 1\\n                if indegree[i]==0:\\n                    queue.append(i)\\n                    ans.append(i)\\n        if indegree==[0 for i in range(numCourses)]:\\n            return ans[::-1]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743319,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 8 ms, faster than 98.89% of Go online submissions for Course Schedule II.\\nMemory Usage: 5.9 MB, less than 82.67% of Go online submissions for Course Schedule II.\\n\\n```go\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    edges, indegree := make([][]int, numCourses), make([]int, numCourses)\\n    for _, v := range prerequisites {\\n        edges[v[1]] = append(edges[v[1]], v[0])\\n        indegree[v[0]]++\\n    }\\n    queue, res := []int{}, []int{}\\n    for i, v := range indegree { if v == 0 { queue = append(queue, i) } }\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        numCourses--\\n        res = append(res, cur)\\n        for _, v := range edges[cur] {\\n            indegree[v]--\\n            if indegree[v] == 0 { queue = append(queue, v) }\\n        }\\n    }\\n    if numCourses != 0 { return []int{} }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    edges, indegree := make([][]int, numCourses), make([]int, numCourses)\\n    for _, v := range prerequisites {\\n        edges[v[1]] = append(edges[v[1]], v[0])\\n        indegree[v[0]]++\\n    }\\n    queue, res := []int{}, []int{}\\n    for i, v := range indegree { if v == 0 { queue = append(queue, i) } }\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        numCourses--\\n        res = append(res, cur)\\n        for _, v := range edges[cur] {\\n            indegree[v]--\\n            if indegree[v] == 0 { queue = append(queue, v) }\\n        }\\n    }\\n    if numCourses != 0 { return []int{} }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742790,
                "title": "c-bfs-based-solution-explained",
                "content": "Okay, let\\'s go with my longest (and not even so efficient, but still pretty readable) solution to date.\\n\\nFirst of all I need to parse my input into 2 maps: one (`paths`) that I will use to navigate my graph directly and one (`reqs`) that I am going to use to check what are the requirements to unlock a given course.\\n\\nKnowing that I also have `n` courses from `0` to `n-1)`, I will build a boolean vector `cells` (not the best naming, I know) to keep track of which starting points are available to me: initially all the values of `cells` are `true`, but when I find that a course as a prereq, I set it to `false`.\\n\\nOnce I am done populating my `paths`, `reqs` and `cells` container with data, I am going to populate `layer` with the viable starting points I found through `cells` (and then I reset them all to `false`, while at it).\\n\\nWith `layer` I can start grinding my own BFS logic, updating it as I proceed with my running through it: as in any ordinary BFS approach, I store its current length and I go through the queue merrily as I pop nodes from there and had them to my result vector `res` - that is, unless I either alredy added that course to `res` (in which case I will just move on) or the current course (`currCourse`, of course) I am parsing is not blocked by other missing requirements, that I check calling `checkReq` on it - using its own overall `reqs` and checking if they all match against the current state of `cells` (in which case I will just push it back to end of `layer`).\\n\\nThe logic behind using the `progressed` boolean is to make sure I do not run a single cycle of my `while` loop without adding at least one course to `res` - if that happens, it just means I am stuck and I need to move forward.\\n\\nOnce I am out of the loop, I just return `res` if its lenght is the same as the expected number of courses, empty vector otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkReq(vector<int>& reqs, vector<bool>& cells) {\\n        for (auto n: reqs) if (!cells[n]) return false;\\n        return true;\\n    }\\n    vector<int> findOrder(int nc, vector<vector<int>>& ps) {\\n        vector<int> res;\\n        unordered_map<int, vector<int>> paths;\\n        unordered_map<int, vector<int>> reqs;\\n        queue<int> layer;\\n        vector<bool> cells(nc, true);\\n        for (auto p: ps) {\\n            paths[p[1]].push_back(p[0]);\\n            reqs[p[0]].push_back(p[1]);\\n            cells[p[0]] = false;\\n        }\\n        for (int i = 0; i < cells.size(); i++) {\\n            if (cells[i]) {\\n                layer.push(i);\\n                cells[i] = false;\\n            }\\n        }\\n        int len = layer.size(), currCourse;\\n        bool progressed = true;\\n        while (progressed && layer.size()) {\\n            progressed = false;\\n            for (int i = 0; i < len; i++) {\\n                currCourse = layer.front();\\n                layer.pop();\\n                if (!cells[currCourse]) {\\n                    if (checkReq(reqs[currCourse], cells)) {\\n                        progressed = true;\\n                        res.push_back(currCourse);\\n                        cells[currCourse] = true;\\n                        for (auto path: paths[currCourse]) layer.push(path);\\n                    } else {\\n                        layer.push(currCourse);\\n                    }\\n                }\\n            }\\n            len = layer.size();\\n        }\\n        return res.size() == nc ? res : vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkReq(vector<int>& reqs, vector<bool>& cells) {\\n        for (auto n: reqs) if (!cells[n]) return false;\\n        return true;\\n    }\\n    vector<int> findOrder(int nc, vector<vector<int>>& ps) {\\n        vector<int> res;\\n        unordered_map<int, vector<int>> paths;\\n        unordered_map<int, vector<int>> reqs;\\n        queue<int> layer;\\n        vector<bool> cells(nc, true);\\n        for (auto p: ps) {\\n            paths[p[1]].push_back(p[0]);\\n            reqs[p[0]].push_back(p[1]);\\n            cells[p[0]] = false;\\n        }\\n        for (int i = 0; i < cells.size(); i++) {\\n            if (cells[i]) {\\n                layer.push(i);\\n                cells[i] = false;\\n            }\\n        }\\n        int len = layer.size(), currCourse;\\n        bool progressed = true;\\n        while (progressed && layer.size()) {\\n            progressed = false;\\n            for (int i = 0; i < len; i++) {\\n                currCourse = layer.front();\\n                layer.pop();\\n                if (!cells[currCourse]) {\\n                    if (checkReq(reqs[currCourse], cells)) {\\n                        progressed = true;\\n                        res.push_back(currCourse);\\n                        cells[currCourse] = true;\\n                        for (auto path: paths[currCourse]) layer.push(path);\\n                    } else {\\n                        layer.push(currCourse);\\n                    }\\n                }\\n            }\\n            len = layer.size();\\n        }\\n        return res.size() == nc ? res : vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741847,
                "title": "c-solution-topological-sort-cycle-detection",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int i, vector<bool> &visited, vector<bool> &restack, vector<vector<int>> &g)\\n    {\\n        if(!visited[i])\\n        {\\n            visited[i] =1;\\n            restack[i] = 1;\\n            for(int j=0;j<g[i].size();j++)\\n            {\\n                if(!visited[g[i][j]] and isCycle(g[i][j], visited, restack, g))\\n                    return true;\\n                else if(restack[g[i][j]])\\n                    return 1;\\n            }\\n        }\\n        restack[i] = false;\\n        return false;\\n    }\\n    void topo(int i, vector<bool> &visited, vector<int> &ans, vector<vector<int>> & g)\\n    {\\n        visited[i] = 1;\\n        for(int j=0;j<g[i].size();j++)\\n            if(!visited[g[i][j]])\\n                topo(g[i][j], visited, ans, g);\\n        ans.push_back(i);\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) { \\n        vector<vector<int>> g(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n            g[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<bool> visited(numCourses, 0);\\n        vector<bool> restack(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n            if(isCycle(i, visited, restack, g))\\n                return {};\\n        for(int i=0;i<numCourses;i++)\\n            visited[i] = 0;\\n        vector<int> ans;\\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                topo(i, visited, ans, g);\\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int i, vector<bool> &visited, vector<bool> &restack, vector<vector<int>> &g)\\n    {\\n        if(!visited[i])\\n        {\\n            visited[i] =1;\\n            restack[i] = 1;\\n            for(int j=0;j<g[i].size();j++)\\n            {\\n                if(!visited[g[i][j]] and isCycle(g[i][j], visited, restack, g))\\n                    return true;\\n                else if(restack[g[i][j]])\\n                    return 1;\\n            }\\n        }\\n        restack[i] = false;\\n        return false;\\n    }\\n    void topo(int i, vector<bool> &visited, vector<int> &ans, vector<vector<int>> & g)\\n    {\\n        visited[i] = 1;\\n        for(int j=0;j<g[i].size();j++)\\n            if(!visited[g[i][j]])\\n                topo(g[i][j], visited, ans, g);\\n        ans.push_back(i);\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) { \\n        vector<vector<int>> g(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n            g[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<bool> visited(numCourses, 0);\\n        vector<bool> restack(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n            if(isCycle(i, visited, restack, g))\\n                return {};\\n        for(int i=0;i<numCourses;i++)\\n            visited[i] = 0;\\n        vector<int> ans;\\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                topo(i, visited, ans, g);\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571094,
                "title": "c-topological-sort-solution-using-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tbool dfs(vector<int>& ans, int cur,vector<vector<int>>& graph, vector<int>& cnt)\\n\\t\\t{\\n\\n\\t\\t  //  cout<<cur<<endl;\\n\\t\\t\\tif(cnt[cur]==1) return true;\\n\\t\\t\\tif(cnt[cur]==2) return false;\\n\\n\\t\\t\\tcnt[cur]=1;\\n\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,x,graph,cnt)) return true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcnt[cur]=2;\\n\\t\\t\\tans.push_back(cur);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\t\\t\\tvector<int> cnt(numCourses);\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tvector<vector<int>> graph(numCourses);\\n\\t\\t\\tfor(auto& x:prerequisites)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgraph[x[1]].push_back(x[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<numCourses;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,i,graph,cnt)) return {};\\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(ans.begin(),ans.end());\\n\\t\\t\\treturn ans;\\n\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tbool dfs(vector<int>& ans, int cur,vector<vector<int>>& graph, vector<int>& cnt)\\n\\t\\t{\\n\\n\\t\\t  //  cout<<cur<<endl;\\n\\t\\t\\tif(cnt[cur]==1) return true;\\n\\t\\t\\tif(cnt[cur]==2) return false;\\n\\n\\t\\t\\tcnt[cur]=1;\\n\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,x,graph,cnt)) return true;\\n\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 429350,
                "title": "java-course-schedule-i-ii-dfs-bfs",
                "content": "Reference: [Problem I](https://leetcode.com/problems/course-schedule/), [Problem II](https://leetcode.com/problems/course-schedule-ii/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem I\\n\\n> There are a total of `n` courses you have to take, labeled from `0` to `n-1`.\\n\\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\\n\\n> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\\n\\n**Note:** \\n\\n- The input is represented by a **list of edges**, not adjacency matrices or list.\\n- You may assume that there are no duplicate edges in the input prerequisites.\\n\\n**Example:** \\n\\n```java\\nInput: 2, [[1,0]] \\nOutput: true\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0. So it is possible.\\n\\nInput: 2, [[1,0],[0,1]]\\nOutput: false\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0, and to take course 0 you should\\n             also have finished course 1. So it is impossible.\\n```\\n\\n\\n### DFS (Cycle Detection)\\n\\nThis problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\\n\\n**My mistake:** Using only true/false `marked` array does not solve the problem. We need more information because we are not dealing with a problem like finding a cycle in a path.\\n\\nReference: [Python 20 lines DFS solution sharing with explanation](https://leetcode.com/problems/course-schedule/discuss/58586/Python-20-lines-DFS-solution-sharing-with-explanation)\\n\\n`marked` array has three states:\\n\\n1. If node `v` has not been visited, then mark it as `0`.\\n2. If node `v` is being visited, then mark it as `-1`. If we find a vertex marked as `-1` in DFS, then there is a ring.\\n3. If node `v` has been visited, then mark it as `+1`. If a vertex was marked as `-1`, then no ring contains `v` or its successors.\\n\\n**Note:** First, we convert the input to a graph represented by an adjacency list (gain efficiency).\\n\\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list O(E)\\n  List<List<Integer>> graph = new ArrayList<>();\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) { // O(V)\\n    if (dfs(v, graph, marked)) return false; // O(E) in total\\n  }\\n  return true; // no cycle -> can finish\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, List<List<Integer>> graph, int[] marked) {\\n  // not visited: 0 | being visited: -1 | visited: +1\\n  marked[v] = -1; // visit\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) return true; // cycle exists\\n    if (marked[w] == 0) { // not visited\\n      if (dfs(w, graph, marked)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  return false; // no cycle is detected\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n### BFS (Topological Sort)\\n\\nThe problem can be reduced to the one that finds if there is a topological sort in the graph (also equivalent to the one that finds if the graph is acyclic).\\n\\nThere are two ways of finding a topological sort: `Reversed DFS` and `BFS`. We pick `BFS` at this time.\\n\\nThe basic idea is that we add all nodes with `0` degrees into a queue, and do `BFS` from these nodes. They are the starting nodes in a graphs. \\n\\nEach time we poll a node from the queue, we decrease all its neighbors\\' in-degree by one. This is like deleting the node from the graph and removing all its outgoing edges. **If a topological sort exists, we can remove the whole graph!**\\n\\nThe whole process takes `O(V)` steps in total if there is a topological sort.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/g660d.jpg \"Two Cases\")\\n\\nSo we need a `count` variable to check how many steps we have along this process. If it finally reduces to `0`, then there is a topological sort.\\n\\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]); // edge[1] is the prerequisite of edge[0]\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  Queue<Integer> queue = new LinkedList<>();\\n  int count = numCourses;\\n  // push all 0-degree nodes\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) { // starting nodes\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    // for each neighbor w\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n    --count;\\n  }\\n  \\n  return count == 0;\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n## Problem II\\n\\n\\n### DFS (Reversed Post-Order Traversal)\\n\\nReference: [CS 61B | Part 11 | Topological Sort, DAG-LPT, DAG-SPT, DP, LIS / LLIS](https://www.junhaow.com/studynotes/cs61b/cs61b%20p11.html)\\n\\nBased on the version of cycle detection, we can update it to construct a topological ordering.\\n\\n1. Perform a DFS traversal from every vertex (any order) in the graph, **not clearing** markings between traversals (means not traversing marked vertices).\\n2. Record DFS post-order along the way (add to list when backtracking).\\n3. Topological ordering is the reverse of the post-order.\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  List<Integer> result = new ArrayList<>();\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (marked[v] == 0) {\\n      if (dfs(v, marked, graph, result)) { // returns true if a cycle is detected\\n        return new int[0]; // no topological sort\\n      }\\n    }\\n  }\\n  // convert to array\\n  int[] output = new int[result.size()];\\n  for (int i = 0; i < result.size(); ++i) {\\n    output[i] = result.get(result.size() - i - 1);\\n  }\\n  return output;\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, int[] marked, List<List<Integer>> graph, List<Integer> result) {\\n  marked[v] = -1; // being visited\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) { // cycle detected!\\n      return true;\\n    }\\n    if (marked[w] == 0) {\\n      if (dfs(w, marked, graph, result)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  result.add(v); // post-order dfs\\n  return false;\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n### BFS (Simpler)\\n\\nReturn a node list in topological ordering. Use `BFS`. Add to the list when a node is polled from the queue.\\n\\n**Note:** \\n\\n- Base case! When there is no prerequisite, return a list of all nodes.\\n- When there is no topological sort, return an empty array.\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  int[] result = new int[numCourses];\\n  int count = 0;\\n  Queue<Integer> queue = new LinkedList<>();\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) {\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    result[count++] = v;\\n    // for each of its neighbors\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n  }\\n  \\n  // check if there is topologial sort\\n  if (count == numCourses) {\\n    return result;\\n  } else {\\n    return new int[0];\\n  }\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```java\\nInput: 2, [[1,0]] \\nOutput: true\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0. So it is possible.\\n\\nInput: 2, [[1,0],[0,1]]\\nOutput: false\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0, and to take course 0 you should\\n             also have finished course 1. So it is impossible.\\n```\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list O(E)\\n  List<List<Integer>> graph = new ArrayList<>();\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) { // O(V)\\n    if (dfs(v, graph, marked)) return false; // O(E) in total\\n  }\\n  return true; // no cycle -> can finish\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, List<List<Integer>> graph, int[] marked) {\\n  // not visited: 0 | being visited: -1 | visited: +1\\n  marked[v] = -1; // visit\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) return true; // cycle exists\\n    if (marked[w] == 0) { // not visited\\n      if (dfs(w, graph, marked)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  return false; // no cycle is detected\\n}\\n```\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]); // edge[1] is the prerequisite of edge[0]\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  Queue<Integer> queue = new LinkedList<>();\\n  int count = numCourses;\\n  // push all 0-degree nodes\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) { // starting nodes\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    // for each neighbor w\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n    --count;\\n  }\\n  \\n  return count == 0;\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  List<Integer> result = new ArrayList<>();\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (marked[v] == 0) {\\n      if (dfs(v, marked, graph, result)) { // returns true if a cycle is detected\\n        return new int[0]; // no topological sort\\n      }\\n    }\\n  }\\n  // convert to array\\n  int[] output = new int[result.size()];\\n  for (int i = 0; i < result.size(); ++i) {\\n    output[i] = result.get(result.size() - i - 1);\\n  }\\n  return output;\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, int[] marked, List<List<Integer>> graph, List<Integer> result) {\\n  marked[v] = -1; // being visited\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) { // cycle detected!\\n      return true;\\n    }\\n    if (marked[w] == 0) {\\n      if (dfs(w, marked, graph, result)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  result.add(v); // post-order dfs\\n  return false;\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  int[] result = new int[numCourses];\\n  int count = 0;\\n  Queue<Integer> queue = new LinkedList<>();\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) {\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    result[count++] = v;\\n    // for each of its neighbors\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n  }\\n  \\n  // check if there is topologial sort\\n  if (count == numCourses) {\\n    return result;\\n  } else {\\n    return new int[0];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427037,
                "title": "adjacency-list-bfs",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        //1.Create graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < prerequisites.length; i++) {\\n            int pre = prerequisites[i][1];\\n            int pos = prerequisites[i][0];\\n            map.get(pre).add(pos);\\n            inDegree[pos]++;\\n        }\\n        \\n        //2.BFS Topological Sorting\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] res = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int index = 0;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            res[index++] = curr;\\n            List<Integer> list = map.get(curr);\\n            for (int i : list) {\\n                if (--inDegree[i] == 0) {\\n                    queue.offer(i);\\n                }\\n            }\\n        }\\n        \\n        //3.return res\\n        for (int i : inDegree) {\\n            if (i != 0) {\\n                return new int[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        //1.Create graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < prerequisites.length; i++) {\\n            int pre = prerequisites[i][1];\\n            int pos = prerequisites[i][0];\\n            map.get(pre).add(pos);\\n            inDegree[pos]++;\\n        }\\n        \\n        //2.BFS Topological Sorting\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] res = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int index = 0;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            res[index++] = curr;\\n            List<Integer> list = map.get(curr);\\n            for (int i : list) {\\n                if (--inDegree[i] == 0) {\\n                    queue.offer(i);\\n                }\\n            }\\n        }\\n        \\n        //3.return res\\n        for (int i : inDegree) {\\n            if (i != 0) {\\n                return new int[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322701,
                "title": "python-topology-sort-bfs-with-detailed-comments-beats-99-53",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        edges = {i:[] for i in range(numCourses)} # initialization. i->be relied on, list []->courses that rely on i.\\n        \\n        indeg = [0 for i in range(numCourses)]   # initialization. Indegree for elements that reply on the others\\n        \\n        for x,y in prerequisites:           # initialization.\\n            edges[y].append(x)\\n            indeg[x]+=1\\n            \\n        que = collections.deque()\\n     \\n        for i in range(len(indeg)):\\n            if indeg[i] == 0:       #store courses with no reliance on other course(indegree = 0)\\n                que.append(i)\\n        res = []\\n                                    #Begin BFS search\\n        while que:\\n            x = que.popleft()       #Pop out the course that has indegree = 0, which means\\n            res.append(x)           #that courses now is \"clear\", not relying on other courses now. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t#Also means this course is free to take, append it in res.\\n            \\n            for n in edges[x]:      #Loop every element that depend on x, and minus their indegree by 1\\n                indeg[n] -= 1       #(since x now has been poped out and \"cleared\"\\n                if indeg[n] == 0:\\n                    que.append(n)\\n                \\n        if len(res) == numCourses:\\n            return res\\n        else:return []\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        edges = {i:[] for i in range(numCourses)} # initialization. i->be relied on, list []->courses that rely on i.\\n        \\n        indeg = [0 for i in range(numCourses)]   # initialization. Indegree for elements that reply on the others\\n        \\n        for x,y in prerequisites:           # initialization.\\n            edges[y].append(x)\\n            indeg[x]+=1\\n            \\n        que = collections.deque()\\n     \\n        for i in range(len(indeg)):\\n            if indeg[i] == 0:       #store courses with no reliance on other course(indegree = 0)\\n                que.append(i)\\n        res = []\\n                                    #Begin BFS search\\n        while que:\\n            x = que.popleft()       #Pop out the course that has indegree = 0, which means\\n            res.append(x)           #that courses now is \"clear\", not relying on other courses now. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t#Also means this course is free to take, append it in res.\\n            \\n            for n in edges[x]:      #Loop every element that depend on x, and minus their indegree by 1\\n                indeg[n] -= 1       #(since x now has been poped out and \"cleared\"\\n                if indeg[n] == 0:\\n                    que.append(n)\\n                \\n        if len(res) == numCourses:\\n            return res\\n        else:return []\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59367,
                "title": "c-iterative-bfs-using-prereq-counting-clear-explanation",
                "content": "Do BFS and each prereq that leads to a course will decrements the course's prereq count.  When that course gets to zero it can now be \"taken\" and it can enqueue to decrement it's children.  If the prereq counter for course is already zero there is a cycle.  If not all courses were reached this is also indicative of a cycle because the prereq count never reached zero and that course could never be \"taken\".  \\n\\n```\\n    public int[] FindOrder(int numCourses, int[,] prerequisites) \\n    {\\n        // map :: key=course; value=list of courses that have the key as a pre-req\\n        List<int>[] map = new List<int>[numCourses];\\n        for (int i = 0; i < numCourses; i++) map[i] = new List<int>();\\n        \\n        // count number of pre-reqs for each course\\n        int[] cnts = new int[numCourses];\\n        \\n        // build graph and counts\\n        for (int i = 0; i < prerequisites.GetLength(0); i++)\\n        {\\n            int course = prerequisites[i,0];\\n            int pre = prerequisites[i,1];\\n            map[pre].Add(course);        \\n            cnts[course]++;\\n        }\\n        \\n        // enqueue all course which have no pre-reqs\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 0; i < numCourses; i++) if (cnts[i] == 0) queue.Enqueue(i);\\n        \\n        // no starting point - cycle(s)\\n        if (queue.Count == 0) return new int[0];\\n        \\n        // track visited - only visit once\\n        bool[] visited = new bool[numCourses];\\n        \\n        // add to list on each first visit\\n        int[] order = new int[numCourses];\\n        int orderIndex = 0;\\n        \\n        // when unvisited decriment each child's count\\n        // if that child already has zero count -> cycle\\n        // if that child has zero count after deduction then enque this node\\n        while(queue.Count > 0)\\n        {\\n            int i = queue.Dequeue(); \\n            if (!visited[i])\\n            {\\n                visited[i] = true;\\n                order[orderIndex++] = i;\\n                foreach (int x in map[i])\\n                {\\n                    if (cnts[x] == 0) return new int[0]; // cycle\\n                    cnts[x]--;\\n                    if (cnts[x] == 0) queue.Enqueue(x);\\n                }\\n            }\\n        }\\n        \\n        // if not all courses were added there were pre-reqs that could not be removed (cycle)\\n        return orderIndex < numCourses ? new int[0] : order;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] FindOrder(int numCourses, int[,] prerequisites) \\n    {\\n        // map :: key=course; value=list of courses that have the key as a pre-req\\n        List<int>[] map = new List<int>[numCourses];\\n        for (int i = 0; i < numCourses; i++) map[i] = new List<int>();\\n        \\n        // count number of pre-reqs for each course\\n        int[] cnts = new int[numCourses];\\n        \\n        // build graph and counts\\n        for (int i = 0; i < prerequisites.GetLength(0); i++)\\n        {\\n            int course = prerequisites[i,0];\\n            int pre = prerequisites[i,1];\\n            map[pre].Add(course);        \\n            cnts[course]++;\\n        }\\n        \\n        // enqueue all course which have no pre-reqs\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 0; i < numCourses; i++) if (cnts[i] == 0) queue.Enqueue(i);\\n        \\n        // no starting point - cycle(s)\\n        if (queue.Count == 0) return new int[0];\\n        \\n        // track visited - only visit once\\n        bool[] visited = new bool[numCourses];\\n        \\n        // add to list on each first visit\\n        int[] order = new int[numCourses];\\n        int orderIndex = 0;\\n        \\n        // when unvisited decriment each child's count\\n        // if that child already has zero count -> cycle\\n        // if that child has zero count after deduction then enque this node\\n        while(queue.Count > 0)\\n        {\\n            int i = queue.Dequeue(); \\n            if (!visited[i])\\n            {\\n                visited[i] = true;\\n                order[orderIndex++] = i;\\n                foreach (int x in map[i])\\n                {\\n                    if (cnts[x] == 0) return new int[0]; // cycle\\n                    cnts[x]--;\\n                    if (cnts[x] == 0) queue.Enqueue(x);\\n                }\\n            }\\n        }\\n        \\n        // if not all courses were added there were pre-reqs that could not be removed (cycle)\\n        return orderIndex < numCourses ? new int[0] : order;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59418,
                "title": "simple-java",
                "content": "```\\n  public int[] findOrder(int numCourses,int[][] prerequisites){\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        int[] degree=new int[numCourses];\\n        for(int i=0;i<prerequisites.length;i++){\\n            int to=prerequisites[i][0];\\n            int from=prerequisites[i][1];\\n            degree[to]++;\\n            list.get(from).add(to);\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(degree[i]==0){\\n                queue.add(i);\\n                res.add(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            List<Integer> toList=list.get(node);\\n            for(int to : toList){\\n                degree[to]--;\\n                if(degree[to]==0){\\n                    queue.offer(to);\\n                    res.add(to);\\n                }\\n            }\\n        }\\n        if(res.size()<numCourses){\\n            return new int[0];\\n        }else{\\n            int[] array=new int[numCourses];\\n            for(int i=0;i<array.length;i++){\\n                array[i]=res.get(i);\\n            }\\n            return array;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] findOrder(int numCourses,int[][] prerequisites){\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        int[] degree=new int[numCourses];\\n        for(int i=0;i<prerequisites.length;i++){\\n            int to=prerequisites[i][0];\\n            int from=prerequisites[i][1];\\n            degree[to]++;\\n            list.get(from).add(to);\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(degree[i]==0){\\n                queue.add(i);\\n                res.add(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            List<Integer> toList=list.get(node);\\n            for(int to : toList){\\n                degree[to]--;\\n                if(degree[to]==0){\\n                    queue.offer(to);\\n                    res.add(to);\\n                }\\n            }\\n        }\\n        if(res.size()<numCourses){\\n            return new int[0];\\n        }else{\\n            int[] array=new int[numCourses];\\n            for(int i=0;i<array.length;i++){\\n                array[i]=res.get(i);\\n            }\\n            return array;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59454,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "JUST THE SAME AS THE previous question.\\nWe just can use extra vector-array to record the result.\\n\\n    class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<int> result;\\n            vector<unordered_set<int>> graph(numCourses, unordered_set<int>());\\n            for(int i=0; i<prerequisites.size(); i++)\\n                graph[prerequisites[i].second].insert(prerequisites[i].first);\\n            vector<int> in_degree(numCourses, 0);\\n            for(int i=0; i<graph.size(); i++)\\n                for(auto it:graph[i])\\n                    in_degree[it]++;\\n                    \\n            int count=0;\\n            for(int i=0; i<numCourses; i++){\\n                int j;\\n                for(j=0; j<numCourses; j++) if(in_degree[j]==0)  break;\\n                /*** return {} means return null vector ***/\\n                if(j==numCourses)   return {};\\n                in_degree[j]=-1;\\n                for(auto it : graph[j])   in_degree[it]--;\\n                result.push_back(j);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<int> result;\\n            vector<unordered_set<int>> graph(numCourses, unordered_set<int>());\\n            for(int i=0; i<prerequisites.size(); i++)\\n                graph[prerequisites[i].second].insert(prerequisites[i].first);\\n            vector<int> in_degree(numCourses, 0);\\n            for(int i=0; i<graph.size(); i++)\\n                for(auto it:graph[i])\\n                    in_degree[it]++;\\n                    \\n            int count=0;\\n            for(int i=0; i<numCourses; i++){\\n                int j;\\n                for(j=0; j<numCourses; j++) if(in_degree[j]==0)  break;\\n                /*** return {}",
                "codeTag": "Java"
            },
            {
                "id": 59428,
                "title": "46ms-java-bfs-toposort-with-kahn-s-algorithm",
                "content": "Note: it is a vanilla toposort with Kahn's BFS algorithm. The conversion of the final result from list to array is a bit ugly.\\n\\n    public class Solution {\\n    \\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t// BFS toposort with Kahn's algorithm\\n    \\t\\tint[] indegree = new int[numCourses];\\n    \\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\tindegree[p[0]]++;\\n    \\t\\t}\\n    \\t\\t// enqueue vertices with indegree == 0, no prerequisite is needed\\n    \\t\\tLinkedList<Integer> queue = new LinkedList<Integer>();\\n    \\t\\tfor (int i = 0; i < indegree.length; i++) {\\n    \\t\\t\\tif (indegree[i] == 0) {\\n    \\t\\t\\t\\tqueue.offer(i);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\twhile (queue.size() != 0) {\\n    \\t\\t\\tInteger curr = queue.poll();\\n    \\t\\t\\tresult.add(curr);\\n    \\t\\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\t\\tif (p[1] == curr) {\\n    \\t\\t\\t\\t\\tindegree[p[0]]--;\\n    \\t\\t\\t\\t\\tif (indegree[p[0]] == 0) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(p[0]);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (result.size() != numCourses) {\\n    \\t\\t\\treturn new int[0];\\n    \\t\\t}\\n    \\t\\tint[] finalResult = new int[result.size()];\\n    \\t\\tfor (int i = 0; i < result.size(); i++) {\\n    \\t\\t\\tfinalResult[i] = result.get(i);\\n    \\t\\t}\\n    \\t\\treturn finalResult;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t// BFS toposort with Kahn's algorithm\\n    \\t\\tint[] indegree = new int[numCourses];\\n    \\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\tindegree[p[0]]++;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 59477,
                "title": "simple-python-solution-using-dfs",
                "content": "    def findOrder(numCourses, prerequisites):\\n        def dfs(i, visited, graph, ret):\\n            #Stop visiting checked nodes\\n            if visited[i] == 1:\\n                return True\\n            #If cycle is detected, return False\\n            if visited[i] == -1:\\n                return False\\n                \\n            visited[i] = -1\\n            for n in graph[i]:\\n                if not dfs(n, visited, graph, ret):\\n                    return False\\n            #collecting results\\n            ret.append(i)\\n                    \\n            visited[i] = 1\\n            return True\\n            \\n        #Initializing graph data\\n        visited = [0] * numCourses\\n        graph = {x:[] for x in xrange(numCourses)}\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n            \\n        #collecting topological order\\n        ret = []\\n        for i in xrange(numCourses):\\n            if not dfs(i, visited, graph, ret):\\n                return []\\n                \\n        return ret[::-1]",
                "solutionTags": [],
                "code": "    def findOrder(numCourses, prerequisites):\\n        def dfs(i, visited, graph, ret):\\n            #Stop visiting checked nodes\\n            if visited[i] == 1:\\n                return True\\n            #If cycle is detected, return False\\n            if visited[i] == -1:\\n                return False\\n                \\n            visited[i] = -1\\n            for n in graph[i]:\\n                if not dfs(n, visited, graph, ret):\\n                    return False\\n            #collecting results\\n            ret.append(i)\\n                    \\n            visited[i] = 1\\n            return True\\n            \\n        #Initializing graph data\\n        visited = [0] * numCourses\\n        graph = {x:[] for x in xrange(numCourses)}\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n            \\n        #collecting topological order\\n        ret = []\\n        for i in xrange(numCourses):\\n            if not dfs(i, visited, graph, ret):\\n                return []\\n                \\n        return ret[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 59522,
                "title": "java-dfs-solution",
                "content": "Using hashset to detect if the course has shown before. If it does, it must be true, so continue.\\n\\n    public static class Solution {\\n    \\t\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t\\tArrayList[] graph = new ArrayList[numCourses];\\n    \\t\\t\\tint[] res = new int[numCourses];\\n    \\t\\t\\tSet hs = new HashSet();\\n                int index = 0;\\n                \\n                for(int i=0;i<numCourses;i++)\\n                    graph[i] = new ArrayList();\\n                    \\n                boolean[] visited = new boolean[numCourses];\\n                for(int i=0; i<prerequisites.length;i++){\\n                    graph[prerequisites[i][0]].add(prerequisites[i][1]);\\n                }\\n    \\n                for(int i=0; i<numCourses; i++){\\n                    if(hs.contains(i))\\n                        continue;\\n                \\tStack stack = new Stack();\\n                    if(!dfs(graph,visited,i,stack,hs))\\n                        return (new int[0]);\\n                    while(stack.size()!=0){\\n                        int temp = (int)stack.pop();\\n                        if(!hs.contains(temp)){\\n                            res[index++] = temp;\\n                            hs.add(temp);\\n                        }\\n                    }\\n                }\\n                return res;\\n            }\\n    \\n            private boolean dfs(ArrayList[] graph, boolean[] visited, int course,Stack stack,Set hs){\\n                if(visited[course])\\n                    return false;\\n                else{\\n                \\tif(hs.contains(course))\\n                        return true;\\n                \\telse{\\n                        stack.add(course);\\n                \\t\\tvisited[course] = true;\\n                \\t}\\n                }\\n    \\n                for(int i=0; i<graph[course].size();i++){\\n                    if(!dfs(graph,visited,(int)graph[course].get(i),stack,hs))\\n                        return false;\\n                }\\n                visited[course] = false;\\n                return true;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\t\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t\\tArrayList[] graph = new ArrayList[numCourses];\\n    \\t\\t\\tint[] res = new int[numCourses];\\n    \\t\\t\\tSet hs = new HashSet();\\n                int index = 0;\\n                \\n                for(int i=0;i<numCourses;i++)\\n                    graph[i] = new ArrayList();\\n                    \\n                boolean[] visited = new boolean[numCourses];\\n                for(int i=0; i<prerequisites.length;i++){\\n                    graph[prerequisites[i][0]].add(prerequisites[i][1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4101762,
                "title": "topological-sort-bfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for (auto prerequisite : prerequisites) {\\n        int course = prerequisite[1]; \\n        int prereq = prerequisite[0];\\n        adj[course].push_back(prereq); \\n    }\\n        vector<int> indegree(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if( indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>tobo;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            tobo.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if( indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        vector<int>empty;\\n        if(tobo.size()!=numCourses)\\n        {\\n            return empty;\\n        }\\n        return tobo; \\n        \\n    }\\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/ac3905a0-5aab-41e9-8798-4520ad00a684_1695920413.222806.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for (auto prerequisite : prerequisites) {\\n        int course = prerequisite[1]; \\n        int prereq = prerequisite[0];\\n        adj[course].push_back(prereq); \\n    }\\n        vector<int> indegree(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if( indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>tobo;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            tobo.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if( indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        vector<int>empty;\\n        if(tobo.size()!=numCourses)\\n        {\\n            return empty;\\n        }\\n        return tobo; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065652,
                "title": "beats-90-in-speed-88-in-memory-very-short-sol-topological-sort-kahn-s-algorithm",
                "content": "# Approach\\nThe algorithm is designed to find a valid ordering of courses given a number of courses (`n`) and a list of prerequisites (`edges`). It utilizes a breadth-first search (BFS) approach and employs several data structures:\\n\\n- `adj`: An adjacency list representing the directed edges between courses.\\n- `visited`: A boolean array to track visited nodes.\\n- `indegree`: An array keeping track of the indegree of each node.\\n- `ans`: A vector to store the final result.\\n\\nHere\\'s a summarized outline of the algorithm:\\n\\n1. **Initialize Data Structures**:\\n   - Initialize a queue (`q`) for BFS.\\n   - Create an adjacency list (`adj`), visited array (`visited`), and indegree array (`indegree`).\\n   - Initialize an empty vector (`ans`) to store the final ordering.\\n\\n2. **Build the Graph and Calculate Indegrees**:\\n   - Iterate through the list of prerequisites (`edges`).\\n   - For each pair `(x[1], x[0])`, add an edge from `x[1]` to `x[0]` in the adjacency list (`adj`).\\n   - Here we have created the adjancey list in reverese to get the answer vector already reversed. \\n   - Increment the indegree of `x[0]`.\\n\\n3. **Enqueue Nodes with Indegree Zero**:\\n   - Iterate through all nodes.\\n   - If the indegree of a node is zero, enqueue it in the queue (`q`).\\n\\n4. **Perform Breadth-First Search (BFS)**:\\n   - While the queue is not empty:\\n     - Dequeue the front element.\\n     - Add it to the result (`ans`).\\n     - For each adjacent node `x` of the front element:\\n       - Decrement its indegree.\\n       - If the indegree becomes zero, enqueue `x`.\\n\\n5. **Check for Valid Ordering**:\\n   - If the size of the result (`ans`) is not equal to the total number of courses (`n`), return an empty vector (indicating no valid ordering).\\n   - Otherwise, return the result vector.\\n\\n**Summary**:\\nThe algorithm constructs a directed graph based on course prerequisites, performs a topological sort using BFS, and ensures the resulting ordering covers all courses. It returns a valid ordering if one exists, or an empty vector if not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& edges) {\\n        queue<int> q;\\n        vector<int> adj[n], visited(n,false), indegree(n,0), ans;   \\n        for(auto& x : edges) {\\n            adj[x[1]].emplace_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) q.emplace(i);\\n        }\\n        while(!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n            ans.emplace_back(front);\\n            for(auto& x : adj[front]) {\\n                indegree[x]--;\\n                if(indegree[x] == 0) q.emplace(x);\\n            }\\n        }\\n        return ans.size() != n ? vector<int>{} : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& edges) {\\n        queue<int> q;\\n        vector<int> adj[n], visited(n,false), indegree(n,0), ans;   \\n        for(auto& x : edges) {\\n            adj[x[1]].emplace_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) q.emplace(i);\\n        }\\n        while(!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n            ans.emplace_back(front);\\n            for(auto& x : adj[front]) {\\n                indegree[x]--;\\n                if(indegree[x] == 0) q.emplace(x);\\n            }\\n        }\\n        return ans.size() != n ? vector<int>{} : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997895,
                "title": "basic-c-solution-topological-sort-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is possible to finish all courses only when there is no cycle present in the graph i.e nothing but what we do in Topological Sort. \\nSo the solution is same as the Topological Sorting Algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[V];\\n        for(auto it : prerequisites){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> indegree(V, 0);\\n          for(int i=0; i<V; i++){\\n              for(auto it: adj[i]){\\n                  indegree[it]++;\\n              }\\n          }\\n         \\n          queue<int>q;\\n          for(int i=0; i<V; i++){\\n              if(indegree[i] == 0) q.push(i);\\n          }\\n         \\n          vector<int> topo;\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              topo.push_back(node);\\n             \\n              for(auto it: adj[node]){\\n                  indegree[it]--;\\n                  if(indegree[it] == 0) q.push(it);\\n              }\\n          }\\n          \\n          reverse(topo.begin(), topo.end());\\n          if(topo.size() == V) return topo;\\n          return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[V];\\n        for(auto it : prerequisites){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> indegree(V, 0);\\n          for(int i=0; i<V; i++){\\n              for(auto it: adj[i]){\\n                  indegree[it]++;\\n              }\\n          }\\n         \\n          queue<int>q;\\n          for(int i=0; i<V; i++){\\n              if(indegree[i] == 0) q.push(i);\\n          }\\n         \\n          vector<int> topo;\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              topo.push_back(node);\\n             \\n              for(auto it: adj[node]){\\n                  indegree[it]--;\\n                  if(indegree[it] == 0) q.push(it);\\n              }\\n          }\\n          \\n          reverse(topo.begin(), topo.end());\\n          if(topo.size() == V) return topo;\\n          return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921588,
                "title": "easy-c-solution-beat-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topoSortBFS(int n,unordered_map<int,list<int>>& adj){\\n        vector<int> ans;\\n        unordered_map<int,int> indegree;\\n        queue<int> q;\\n        //calculating indegree\\n        for(auto i:adj){\\n            for(auto nbr:i.second)\\n                indegree[nbr]++;\\n        }\\n        //put all node inside q with in degree 0 \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int fnode=q.front();\\n            q.pop();\\n            ans.push_back(fnode);\\n            for(auto nbr : adj[fnode]){\\n                indegree[nbr]--;\\n                    //check for zero again\\n                    if(indegree[nbr] == 0) {\\n                        q.push(nbr);\\n                    }\\n            }\\n        }\\n        if(ans.size()==n)\\n            return ans;\\n        else\\n            return {};\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        unordered_map<int,list<int>> adj;\\n        for(auto task:prerequisites){\\n            int u=task[0];\\n            int v=task[1];\\n            adj[u].push_back(v);\\n        }\\n        vector<int> ans= topoSortBFS(numCourses,adj);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSortBFS(int n,unordered_map<int,list<int>>& adj){\\n        vector<int> ans;\\n        unordered_map<int,int> indegree;\\n        queue<int> q;\\n        //calculating indegree\\n        for(auto i:adj){\\n            for(auto nbr:i.second)\\n                indegree[nbr]++;\\n        }\\n        //put all node inside q with in degree 0 \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int fnode=q.front();\\n            q.pop();\\n            ans.push_back(fnode);\\n            for(auto nbr : adj[fnode]){\\n                indegree[nbr]--;\\n                    //check for zero again\\n                    if(indegree[nbr] == 0) {\\n                        q.push(nbr);\\n                    }\\n            }\\n        }\\n        if(ans.size()==n)\\n            return ans;\\n        else\\n            return {};\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        unordered_map<int,list<int>> adj;\\n        for(auto task:prerequisites){\\n            int u=task[0];\\n            int v=task[1];\\n            adj[u].push_back(v);\\n        }\\n        vector<int> ans= topoSortBFS(numCourses,adj);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844142,
                "title": "c-dfs-kahn-s-algorithm-topological-sort",
                "content": "# Intuition\\nTopological sort\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v];\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        vector<bool> visited(v, false), pathVisited(v, false);\\n        vector<int> result;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (!visited[node] && dfs(adj, visited, pathVisited, result, node))\\n                return {};\\n        }\\n\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n\\nprivate:\\n    bool dfs(vector<int> adj[], vector<bool>& visited, vector<bool>& pathVisited, \\n                vector<int>& result, int node)\\n    {\\n        if (pathVisited[node])\\n            return true;    \\n        if (visited[node])\\n            return false;\\n\\n        visited[node] = pathVisited[node] = true;\\n\\n        for (auto& adjNode : adj[node]) {\\n            if (dfs(adj, visited, pathVisited, result, adjNode))\\n                return true;\\n        }\\n\\n        pathVisited[node] = false;\\n        result.emplace_back(node);\\n        return false;\\n    }\\n};\\n```\\n\\n# Kahn\\'s Algorithm\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v], result(v), indegree(v);\\n        int topoLen = 0;\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        for (int node = 0; node < v; node++) {\\n            for (auto& adjNode : adj[node])\\n                indegree[adjNode]++;\\n        }\\n\\n        queue<int> Q;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (indegree[node] == 0)\\n                Q.emplace(node);\\n        }\\n\\n        int i = 0;\\n        while (!Q.empty()) {\\n            int node = Q.front(); Q.pop();\\n            result[i++] = node;\\n            topoLen++;\\n\\n            for (auto& adjNode : adj[node]) {\\n                if (--indegree[adjNode] == 0)\\n                    Q.emplace(adjNode);\\n            }\\n        }\\n\\n        if (topoLen != v) return {};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v];\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        vector<bool> visited(v, false), pathVisited(v, false);\\n        vector<int> result;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (!visited[node] && dfs(adj, visited, pathVisited, result, node))\\n                return {};\\n        }\\n\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n\\nprivate:\\n    bool dfs(vector<int> adj[], vector<bool>& visited, vector<bool>& pathVisited, \\n                vector<int>& result, int node)\\n    {\\n        if (pathVisited[node])\\n            return true;    \\n        if (visited[node])\\n            return false;\\n\\n        visited[node] = pathVisited[node] = true;\\n\\n        for (auto& adjNode : adj[node]) {\\n            if (dfs(adj, visited, pathVisited, result, adjNode))\\n                return true;\\n        }\\n\\n        pathVisited[node] = false;\\n        result.emplace_back(node);\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v], result(v), indegree(v);\\n        int topoLen = 0;\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        for (int node = 0; node < v; node++) {\\n            for (auto& adjNode : adj[node])\\n                indegree[adjNode]++;\\n        }\\n\\n        queue<int> Q;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (indegree[node] == 0)\\n                Q.emplace(node);\\n        }\\n\\n        int i = 0;\\n        while (!Q.empty()) {\\n            int node = Q.front(); Q.pop();\\n            result[i++] = node;\\n            topoLen++;\\n\\n            for (auto& adjNode : adj[node]) {\\n                if (--indegree[adjNode] == 0)\\n                    Q.emplace(adjNode);\\n            }\\n        }\\n\\n        if (topoLen != v) return {};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759649,
                "title": "python3-topological-sort-solution-intuition-and-imagination-of-solution-96-9-faster",
                "content": "# Intuition\\nHow to proceed with the Question is to think for yourself, where do I start with my first course?\\n \\nAnalogy will come in imagination to a graph problem itself as direct the node starting from which course needs to be completed first to get to the other course.\\n\\nFor example: prerequisites = [[1,0],[2,0],[3,1],[3,2]] numCourses=4\\n\\nTo complete course 0 I have to complete the course 1 first \\n and to complete the course 2 I have to complete the course 0 first again. \\n\\n How the graph will look like at the end, and you can imagine how the adjacancy list will be made. \\n\\n**{ 0 : *[1,2] from 0 we can either complete 1 or 2 so basically        for both the next courses 0 is necessary*\\n  1 : [3]\\n  2 : [3]\\n}**\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/cf20945d-9d07-4674-abd2-47d6ad84f994_1689255624.9738972.png)\\n\\n\\n\\n\\n\\n# Approach\\n\\n**We have to eliminate the node that can be completed without going to any node, meaning we have to complete the course that doesn\\'t have any prerequist and can be completed immediately**. That means all the courses with 0 indegree.\\n\\nWill put them in queue and start traversing in BFS. \\n\\nNow once that particular node(course) is completed, put that course in result as that will be compelted first and already is.\\nNow we will check all the courses that can be now completed or atleast have one less dependancy of a courses due to the completion of our current course (i.e.) Its neighbour or directs in the adjacency list.\\n\\nSo basically, the next (neighbour) course is one less dependency, which means one less indegree. Therefore, indegree[neigh] -= 1. If the indegree becomes 0 (meaning there are no dependencies left), that course (node) is good to go in the queue to be completed.\\n\\n**At last we will check if we were able to complete all the courses that means all the courses were popped from the queue atleast once and no course is left with any dependancy now. That means we have completed all the courses and give the result in order we poped the courses out of the bfs queue.**\\n\\n# Complexity\\n- Time complexity:\\n**O(V+E) BFS Traversal complexity** \\n\\n- Space complexity:\\n**O(V) to contain indegree and adjacency list**\\n\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ## Dependancy of each node/course\\n        indegree= [0]*numCourses\\n\\n        result = []\\n        ##Adjacency list\\n        mapper = defaultdict(list)\\n\\n        ##Putting all the courses that doesn\\'t have any dependancy in queue\\n        for ai, bi in prerequisites:\\n            mapper[bi].append(ai)\\n            indegree[ai]+=1\\n        # print(mapper,indegree)\\n\\n        q = deque()\\n\\n        for i in range(len(indegree)):\\n            if indegree[i]==0:\\n                q.append(i)\\n        while(q):\\n            node = q.popleft()\\n            result.append(node)\\n            for neigh in mapper[node]:\\n            # One less dependancy\\n                indegree[neigh]-=1\\n                if indegree[neigh]==0:\\n                    q.append(neigh)\\n        if len(result) == numCourses:\\n            return result\\n        return []        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ## Dependancy of each node/course\\n        indegree= [0]*numCourses\\n\\n        result = []\\n        ##Adjacency list\\n        mapper = defaultdict(list)\\n\\n        ##Putting all the courses that doesn\\'t have any dependancy in queue\\n        for ai, bi in prerequisites:\\n            mapper[bi].append(ai)\\n            indegree[ai]+=1\\n        # print(mapper,indegree)\\n\\n        q = deque()\\n\\n        for i in range(len(indegree)):\\n            if indegree[i]==0:\\n                q.append(i)\\n        while(q):\\n            node = q.popleft()\\n            result.append(node)\\n            for neigh in mapper[node]:\\n            # One less dependancy\\n                indegree[neigh]-=1\\n                if indegree[neigh]==0:\\n                    q.append(neigh)\\n        if len(result) == numCourses:\\n            return result\\n        return []        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758475,
                "title": "easy-c-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[V];\\n        for(auto it:prerequisites)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<V;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()==V)\\n        {\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[V];\\n        for(auto it:prerequisites)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<V;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()==V)\\n        {\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647087,
                "title": "golang",
                "content": "\\n\\n```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    //build the graph\\n    graph := make([][]int,numCourses)\\n    in_degree := make([]int,numCourses)\\n    for _,v := range prerequisites{\\n        graph[v[1]] = append(graph[v[1]], v[0])\\n        in_degree[v[0]]++\\n    }\\n\\n    frontier := []int{}\\n    for i,v := range in_degree{\\n        if v==0{\\n            frontier = append(frontier,i)\\n        }\\n    }\\n\\n    result := []int{}\\n    for len(frontier)!=0{\\n        cur := frontier[0]\\n        frontier = frontier[1:]\\n        result = append(result,cur)\\n        for _,v := range graph[cur]{\\n            in_degree[v]--\\n            if in_degree[v]==0{\\n                frontier = append(frontier,v)\\n            }\\n        }\\n    }\\n\\n    if len(result)==numCourses{\\n        return result\\n    }\\n    return []int{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    //build the graph\\n    graph := make([][]int,numCourses)\\n    in_degree := make([]int,numCourses)\\n    for _,v := range prerequisites{\\n        graph[v[1]] = append(graph[v[1]], v[0])\\n        in_degree[v[0]]++\\n    }\\n\\n    frontier := []int{}\\n    for i,v := range in_degree{\\n        if v==0{\\n            frontier = append(frontier,i)\\n        }\\n    }\\n\\n    result := []int{}\\n    for len(frontier)!=0{\\n        cur := frontier[0]\\n        frontier = frontier[1:]\\n        result = append(result,cur)\\n        for _,v := range graph[cur]{\\n            in_degree[v]--\\n            if in_degree[v]==0{\\n                frontier = append(frontier,v)\\n            }\\n        }\\n    }\\n\\n    if len(result)==numCourses{\\n        return result\\n    }\\n    return []int{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504656,
                "title": "c-topological-sort",
                "content": "# Complexity\\n- Time complexity: $$O(n+e)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        for (int i=0; i<prerequisites.size(); i++){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        vector<int> topo;\\n        queue<int> q;\\n        vector<int> indegree(n,0);\\n        for (int i=0; i<n; i++){\\n            for (auto val: adj[i]){\\n                indegree[val]++;\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            if (indegree[i]==0)q.push(i);\\n        }\\n        while (!q.empty()){\\n            int fr= q.front();\\n            q.pop();\\n            topo.push_back(fr);\\n            for (auto val: adj[fr]){\\n                indegree[val]--;\\n                if (indegree[val]==0)q.push(val);\\n            }\\n        }\\n        cout<<topo.size()<<endl;\\n        if (topo.size()==n)return topo;\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        for (int i=0; i<prerequisites.size(); i++){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        vector<int> topo;\\n        queue<int> q;\\n        vector<int> indegree(n,0);\\n        for (int i=0; i<n; i++){\\n            for (auto val: adj[i]){\\n                indegree[val]++;\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            if (indegree[i]==0)q.push(i);\\n        }\\n        while (!q.empty()){\\n            int fr= q.front();\\n            q.pop();\\n            topo.push_back(fr);\\n            for (auto val: adj[fr]){\\n                indegree[val]--;\\n                if (indegree[val]==0)q.push(val);\\n            }\\n        }\\n        cout<<topo.size()<<endl;\\n        if (topo.size()==n)return topo;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3177608,
                "title": "c-concise-topological-sort-142ms-97",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        var degree = new int [numCourses];\\n\\n        var parentToChildren = prerequisites.ToLookup(\\n                p => p[1], \\n                c => { degree[c[0]]++; return c[0]; });\\n\\n        var bfs = new List<int>(numCourses);\\n\\n        for (int i = 0; i < numCourses; ++i) \\n            if (degree[i] == 0) bfs.Add(i);\\n\\n        for (int i = 0; i < bfs.Count; ++i)\\n        {\\n            foreach (var j in parentToChildren[bfs[i]])\\n            {\\n                if (--degree[j] == 0) \\n                    bfs.Add(j);\\n            }\\n        }\\n\\n        return bfs.Count == numCourses ? bfs.ToArray() : new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        var degree = new int [numCourses];\\n\\n        var parentToChildren = prerequisites.ToLookup(\\n                p => p[1], \\n                c => { degree[c[0]]++; return c[0]; });\\n\\n        var bfs = new List<int>(numCourses);\\n\\n        for (int i = 0; i < numCourses; ++i) \\n            if (degree[i] == 0) bfs.Add(i);\\n\\n        for (int i = 0; i < bfs.Count; ++i)\\n        {\\n            foreach (var j in parentToChildren[bfs[i]])\\n            {\\n                if (--degree[j] == 0) \\n                    bfs.Add(j);\\n            }\\n        }\\n\\n        return bfs.Count == numCourses ? bfs.ToArray() : new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162718,
                "title": "explained-code-c",
                "content": "# Intuition\\nCheck if the directed graph has a cycle using any topo sort algo.\\nbecause if there is a cycle we will not be able to represent the graph in a linear fashion\\nIf there is no cycle return ant tppo sort.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<int>ind(n,0);\\n        vector<int>v[n];\\n        for(auto it:pre){\\n            v[it[1]].push_back(it[0]);\\n        }\\n        vector<int>o;\\n        for(int i=0;i<n;i++){\\n            for(auto it:v[i]){\\n                ind[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n        if(ind[i]==0){\\n            q.push(i);\\n        }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            o.push_back(node);\\n            for(auto it:v[node]){\\n                ind[it]--;\\n                if(ind[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n) return o;\\n        else return {};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<int>ind(n,0);\\n        vector<int>v[n];\\n        for(auto it:pre){\\n            v[it[1]].push_back(it[0]);\\n        }\\n        vector<int>o;\\n        for(int i=0;i<n;i++){\\n            for(auto it:v[i]){\\n                ind[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n        if(ind[i]==0){\\n            q.push(i);\\n        }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            o.push_back(node);\\n            for(auto it:v[node]){\\n                ind[it]--;\\n                if(ind[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n) return o;\\n        else return {};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034506,
                "title": "c-very-short-and-easy-understanding-5-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& preq, int i = 0) {\\n        vector<vector<int>> graph(n); vector<int> indgr(n,0), ans,emptyVector;\\n        for(auto it: preq) graph[it[1]].push_back(it[0]),indgr[it[0]]++;\\n        for(int i = 0;i<n;i++) if(!indgr[i]) ans.push_back(i);\\n        while(ans.size()<n and i<ans.size())  for(auto it: graph[ans[i++]]) if(--indgr[it]==0) ans.push_back(it);\\n        return ans.size()==n ? ans : emptyVector;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& preq, int i = 0) {\\n        vector<vector<int>> graph(n); vector<int> indgr(n,0), ans,emptyVector;\\n        for(auto it: preq) graph[it[1]].push_back(it[0]),indgr[it[0]]++;\\n        for(int i = 0;i<n;i++) if(!indgr[i]) ans.push_back(i);\\n        while(ans.size()<n and i<ans.size())  for(auto it: graph[ans[i++]]) if(--indgr[it]==0) ans.push_back(it);\\n        return ans.size()==n ? ans : emptyVector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966913,
                "title": "topological-sort-solution",
                "content": "\\n\\n# Code\\n```\\nfunction findOrder(numCourses: number, prerequisites: number[][]): number[] {\\n    const adjList:number[][] = new Array(numCourses)\\n\\n    for(let i=0; i<numCourses; i++) adjList[i] = []\\n\\n    //creating adjacency list\\n    for(let i=0; i<prerequisites.length; i++){\\n        const ver = prerequisites[i][0]\\n        const edge = prerequisites[i][1]\\n        adjList[ver].push(edge)\\n    }\\n\\n    return topoSort(numCourses, adjList)\\n};\\n\\nconst topoSort = (V:number, adj:number[][]):number[] => {\\n    const indegreeEdge = new Array(V).fill(0);\\n    const queue = [];\\n    const topoSort = [];\\n\\n    // indegree\\n    for(let i=0; i<V;i++){\\n        for(let it of adj[i]){\\n            indegreeEdge[it]++\\n        }\\n    }\\n    // zero incoming edge vertex;\\n    for(let i=0;i<V;i++){\\n        if(indegreeEdge[i] === 0){\\n            queue.push(i)\\n        }\\n    }\\n\\n    //topoSort\\n    while(queue.length){\\n        const node = queue.shift()\\n        topoSort.push(node)\\n\\n        //disconnet node;\\n        for(let it of adj[node]){\\n            indegreeEdge[it]--\\n            if(indegreeEdge[it] === 0) queue.push(it)\\n        }\\n    }\\n\\n    return topoSort.length === V ? topoSort.reverse() : []\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nfunction findOrder(numCourses: number, prerequisites: number[][]): number[] {\\n    const adjList:number[][] = new Array(numCourses)\\n\\n    for(let i=0; i<numCourses; i++) adjList[i] = []\\n\\n    //creating adjacency list\\n    for(let i=0; i<prerequisites.length; i++){\\n        const ver = prerequisites[i][0]\\n        const edge = prerequisites[i][1]\\n        adjList[ver].push(edge)\\n    }\\n\\n    return topoSort(numCourses, adjList)\\n};\\n\\nconst topoSort = (V:number, adj:number[][]):number[] => {\\n    const indegreeEdge = new Array(V).fill(0);\\n    const queue = [];\\n    const topoSort = [];\\n\\n    // indegree\\n    for(let i=0; i<V;i++){\\n        for(let it of adj[i]){\\n            indegreeEdge[it]++\\n        }\\n    }\\n    // zero incoming edge vertex;\\n    for(let i=0;i<V;i++){\\n        if(indegreeEdge[i] === 0){\\n            queue.push(i)\\n        }\\n    }\\n\\n    //topoSort\\n    while(queue.length){\\n        const node = queue.shift()\\n        topoSort.push(node)\\n\\n        //disconnet node;\\n        for(let it of adj[node]){\\n            indegreeEdge[it]--\\n            if(indegreeEdge[it] === 0) queue.push(it)\\n        }\\n    }\\n\\n    return topoSort.length === V ? topoSort.reverse() : []\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2953835,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2938936,
                "title": "kotlin-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    private val stack = Stack<Int>()\\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\\n        val preReq = MutableList(numCourses) { mutableListOf<Int>() }\\n        prerequisites.forEach { (course, preq) -> preReq[course].add(preq) }\\n       \\n        val visited = mutableSetOf<Int>()    \\n        val cycle = mutableSetOf<Int>()        \\n        val ans = mutableListOf<Int>()\\n\\n        fun dfs(course: Int): Boolean {\\n            if (course in cycle) return false\\n            if (course in visited) return true\\n            \\n            cycle += course\\n            preReq[course]!!.forEach { if (!dfs(it)) return false }\\n            cycle -= course\\n            \\n            visited += course\\n            ans += course\\n            return true\\n        }\\n\\n        repeat(numCourses) { if (!dfs(it)) return intArrayOf() }\\n\\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private val stack = Stack<Int>()\\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\\n        val preReq = MutableList(numCourses) { mutableListOf<Int>() }\\n        prerequisites.forEach { (course, preq) -> preReq[course].add(preq) }\\n       \\n        val visited = mutableSetOf<Int>()    \\n        val cycle = mutableSetOf<Int>()        \\n        val ans = mutableListOf<Int>()\\n\\n        fun dfs(course: Int): Boolean {\\n            if (course in cycle) return false\\n            if (course in visited) return true\\n            \\n            cycle += course\\n            preReq[course]!!.forEach { if (!dfs(it)) return false }\\n            cycle -= course\\n            \\n            visited += course\\n            ans += course\\n            return true\\n        }\\n\\n        repeat(numCourses) { if (!dfs(it)) return intArrayOf() }\\n\\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742966,
                "title": "java-topological-sort-using-kahn-s-algo-is-93-82-faster-a-solution-you-will-love",
                "content": "**this post contains 3 section\\n1.why kahn\\'s algo work\\n2.applying kahn\\'s algo to this solution\\n3.code**\\njump to section 2 if you know what is topological sort, kahn\\'s algo and why kahn\\'s algo works.\\n**section 1:**\\nin **topological sort** parent comes before the child and this condition is valid for each node in the sequence ,works only for direct acyclic graph.\\nkahn\\'s algorithm is modified bfs algorithm which favours topological sort,when we talk of normal bfs every adjacent unvisited node to this node is added to the queue,so that we can propogate further deep from that node,quiet convenient for it\\'s functionality.\\nbut in kahn\\'s algo the goal is to create a sequence in which all the parents lie before sequence,so one may argue that ,this is what bfs do,yeah but bfs only takes local adjacent parent into consideration\\n![image](https://assets.leetcode.com/users/images/acc89b8b-1025-4d17-a760-1fe0b22a364a_1666703676.6675522.png)\\nbfs manages to put 1 before 2 but fails to put 5 before 2,hence it is modifed to form kahn\\'s algo\\n so we first count how many parent to each node exist,now these parents must be added into the sequence first before this node to be added into the sequence.we start with all the root nodes to which there is no incoming edge and start expending from them(here it is 1) now since 2 has 2 parents we won\\'t add it into the sequence until 5 is added into the sequence.we can simply check this by asking if all of it\\'s parent are traversed or not.and honestly speaking we can simply reduce the incoming edge count each time a parent is found and as soon as incoming edge count turns 0 we add it into the sequence.\\n **section 2**\\n having courses which form a dependency on each other such that both of them wait for each other\\'s completion is the only condition when we won\\'t be able to complete all the courses,which in other terms means that if the graph contains cycle we can\\'t complete all the courses,so how can we detect cycle,we can use kahn\\'s algo.as we know kahn\\'s algo is good in keeping track of parents traversed yet and only allow childs of a node to be traversed only if all of it\\'s parents are traversed(added to sequence),if a loop is encountered the node at which acyclic and cyclic portion of graph meets will wait for itself to be added into the queue so that it can traverse further but won\\'t be able to have the chance as one of it parent is reachable through it and since we are not traversing the node itself how can we traverse the parent,condition of all parents traversed not satisfied hence never added into the queue.the code it commented itself.\\n **section 3-the code**\\n ```\\n class Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        int[] ingress=new int[numCourses];//array to keep track of incoming edges\\n        //create graph from given array\\n        ArrayList<ArrayList<Integer>> graph=graph_creator(numCourses,pre);\\n        Arrays.fill(ingress,0);\\n        for(int i=0;i<numCourses;i++){\\n            for(int j:graph.get(i)){\\n            ingress[j]++;//increase if incoming edge to this node found\\n            }\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(ingress[i]==0) q.add(i);//add all the root nodes to the queue as the starting points of traversal cause there is nothing which lie before them.\\n        }\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            ans.add(node);//here is why traversal means addition to answer.\\n            for(int i:graph.get(node)){\\n                ingress[i]--;//decrease the incoming edge count it won\\'t drop below 0.\\n                if(ingress[i]==0) q.add(i);//only add those whose parents have been added.\\n            }\\n        }\\n        if(ans.size()!=numCourses) return new int[0];//if we failed to add all node into answer there existed a cycle\\n        int[] output=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++){\\n            output[i]=ans.get(i);\\n        }\\n        return output;\\n    }\\n    ArrayList<ArrayList<Integer>> graph_creator(int n,int[][]pre){\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>(n);\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] temp:pre) graph.get(temp[1]).add(temp[0]);\\n        return graph;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n class Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        int[] ingress=new int[numCourses];//array to keep track of incoming edges\\n        //create graph from given array\\n        ArrayList<ArrayList<Integer>> graph=graph_creator(numCourses,pre);\\n        Arrays.fill(ingress,0);\\n        for(int i=0;i<numCourses;i++){\\n            for(int j:graph.get(i)){\\n            ingress[j]++;//increase if incoming edge to this node found\\n            }\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(ingress[i]==0) q.add(i);//add all the root nodes to the queue as the starting points of traversal cause there is nothing which lie before them.\\n        }\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            ans.add(node);//here is why traversal means addition to answer.\\n            for(int i:graph.get(node)){\\n                ingress[i]--;//decrease the incoming edge count it won\\'t drop below 0.\\n                if(ingress[i]==0) q.add(i);//only add those whose parents have been added.\\n            }\\n        }\\n        if(ans.size()!=numCourses) return new int[0];//if we failed to add all node into answer there existed a cycle\\n        int[] output=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++){\\n            output[i]=ans.get(i);\\n        }\\n        return output;\\n    }\\n    ArrayList<ArrayList<Integer>> graph_creator(int n,int[][]pre){\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>(n);\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] temp:pre) graph.get(temp[1]).add(temp[0]);\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715938,
                "title": "c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> res;\\n        vector<vector<int>> adj(numCourses, vector<int>());\\n        vector<int> degree(numCourses, 0);\\n        queue<int> q;\\n        for (const auto& pre : prerequisites) {\\n            // e.g, [2,4], then we store 4->2 \\n            // and [4]==1\\n            adj[pre[1]].push_back(pre[0]);\\n            degree[pre[0]]++;\\n        }\\n        for (int i = 0; i < numCourses; ++i) {\\n            // push cources without any pre into a queue.\\n            if (degree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int pre = q.front(); \\n            q.pop();\\n            numCourses --;\\n            // Found the result and store it. \\n            res.push_back(pre);\\n            for (auto c : adj[pre]) {\\n                degree[c]--;\\n                if (degree[c] == 0) {\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        return (numCourses == 0) ? res : vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> res;\\n        vector<vector<int>> adj(numCourses, vector<int>());\\n        vector<int> degree(numCourses, 0);\\n        queue<int> q;\\n        for (const auto& pre : prerequisites) {\\n            // e.g, [2,4], then we store 4->2 \\n            // and [4]==1\\n            adj[pre[1]].push_back(pre[0]);\\n            degree[pre[0]]++;\\n        }\\n        for (int i = 0; i < numCourses; ++i) {\\n            // push cources without any pre into a queue.\\n            if (degree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int pre = q.front(); \\n            q.pop();\\n            numCourses --;\\n            // Found the result and store it. \\n            res.push_back(pre);\\n            for (auto c : adj[pre]) {\\n                degree[c]--;\\n                if (degree[c] == 0) {\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        return (numCourses == 0) ? res : vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565666,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1566541,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567463,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565916,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567915,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1723612,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569167,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1571430,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1662439,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569024,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565666,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1566541,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567463,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565916,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567915,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1723612,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569167,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1571430,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1662439,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569024,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1862133,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1576579,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1574533,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1572176,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571877,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571431,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571432,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571434,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1570613,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571433,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 2065995,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2064455,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2054966,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2035653,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2020158,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1957673,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1942184,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1940929,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1898180,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1897212,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Redundant Connection II",
        "question_content": "<p>In this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>\n\n<p>The given input is a directed graph that started as a rooted tree with <code>n</code> nodes (with distinct values from <code>1</code> to <code>n</code>), with one additional directed edge added. The added edge has two different vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed.</p>\n\n<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u<sub>i</sub>, v<sub>i</sub>]</code> that represents a <b>directed</b> edge connecting nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, where <code>u<sub>i</sub></code> is a parent of child <code>v<sub>i</sub></code>.</p>\n\n<p>Return <em>an edge that can be removed so that the resulting graph is a rooted tree of</em> <code>n</code> <em>nodes</em>. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\" style=\"width: 222px; height: 382px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n<strong>Output:</strong> [4,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 108045,
                "title": "c-java-union-find-with-explanation-o-n",
                "content": "This problem is very similar to \"Redundant Connection\". But the description on the parent/child relationships is much better clarified. \\n```\\nThere are two cases for the tree structure to be invalid.\\n1) A node having two parents;\\n   including corner case: e.g. [[4,2],[1,5],[5,2],[5,3],[2,4]]\\n2) A circle exists\\n```\\nIf we can remove exactly 1 edge to achieve the tree structure, a single node can have at most two parents. So my solution works in two steps.\\n```\\n1) Check whether there is a node having two parents. \\n    If so, store them as candidates A and B, and set the second edge invalid. \\n2) Perform normal union find. \\n    If the tree is now valid \\n           simply return candidate B\\n    else if candidates not existing \\n           we find a circle, return current edge; \\n    else \\n           remove candidate A instead of B.\\n```\\nIf you like this solution, please help upvote so more people can see.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1, 0), candA, candB;\\n        // step 1, check whether there is a node with two parents\\n        for (auto &edge:edges) {\\n            if (parent[edge[1]] == 0)\\n                parent[edge[1]] = edge[0]; \\n            else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        } \\n        // step 2, union find\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        for (auto &edge:edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = root(parent, u);\\n            // Now every node only has 1 parent, so root of v is implicitly v\\n            if (pu == v) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[v] = pu;\\n        }\\n        return candB;\\n    }\\nprivate:\\n    int root(vector<int>& parent, int k) {\\n        if (parent[k] != k) \\n            parent[k] = root(parent, parent[k]);\\n        return parent[k];\\n    }\\n};\\n```\\nJava version by MichaelLeo \\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] can1 = {-1, -1};\\n        int[] can2 = {-1, -1};\\n        int[] parent = new int[edges.length + 1];\\n        for (int i = 0; i < edges.length; i++) {\\n            if (parent[edges[i][1]] == 0) {\\n                parent[edges[i][1]] = edges[i][0];\\n            } else {\\n                can2 = new int[] {edges[i][0], edges[i][1]};\\n                can1 = new int[] {parent[edges[i][1]], edges[i][1]};\\n                edges[i][1] = 0;\\n            }\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            if (edges[i][1] == 0) {\\n                continue;\\n            }\\n            int child = edges[i][1], father = edges[i][0];\\n            if (root(parent, father) == child) {\\n                if (can1[0] == -1) {\\n                    return edges[i];\\n                }\\n                return can1;\\n            }\\n            parent[child] = father;\\n        }\\n        return can2;\\n    }\\n    \\n    int root(int[] parent, int i) {\\n        while (i != parent[i]) {\\n            parent[i] = parent[parent[i]];\\n            i = parent[i];\\n        }   \\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThere are two cases for the tree structure to be invalid.\\n1) A node having two parents;\\n   including corner case: e.g. [[4,2],[1,5],[5,2],[5,3],[2,4]]\\n2) A circle exists\\n```\n```\\n1) Check whether there is a node having two parents. \\n    If so, store them as candidates A and B, and set the second edge invalid. \\n2) Perform normal union find. \\n    If the tree is now valid \\n           simply return candidate B\\n    else if candidates not existing \\n           we find a circle, return current edge; \\n    else \\n           remove candidate A instead of B.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1, 0), candA, candB;\\n        // step 1, check whether there is a node with two parents\\n        for (auto &edge:edges) {\\n            if (parent[edge[1]] == 0)\\n                parent[edge[1]] = edge[0]; \\n            else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        } \\n        // step 2, union find\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        for (auto &edge:edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = root(parent, u);\\n            // Now every node only has 1 parent, so root of v is implicitly v\\n            if (pu == v) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[v] = pu;\\n        }\\n        return candB;\\n    }\\nprivate:\\n    int root(vector<int>& parent, int k) {\\n        if (parent[k] != k) \\n            parent[k] = root(parent, parent[k]);\\n        return parent[k];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] can1 = {-1, -1};\\n        int[] can2 = {-1, -1};\\n        int[] parent = new int[edges.length + 1];\\n        for (int i = 0; i < edges.length; i++) {\\n            if (parent[edges[i][1]] == 0) {\\n                parent[edges[i][1]] = edges[i][0];\\n            } else {\\n                can2 = new int[] {edges[i][0], edges[i][1]};\\n                can1 = new int[] {parent[edges[i][1]], edges[i][1]};\\n                edges[i][1] = 0;\\n            }\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            if (edges[i][1] == 0) {\\n                continue;\\n            }\\n            int child = edges[i][1], father = edges[i][0];\\n            if (root(parent, father) == child) {\\n                if (can1[0] == -1) {\\n                    return edges[i];\\n                }\\n                return can1;\\n            }\\n            parent[child] = father;\\n        }\\n        return can2;\\n    }\\n    \\n    int root(int[] parent, int i) {\\n        while (i != parent[i]) {\\n            parent[i] = parent[parent[i]];\\n            i = parent[i];\\n        }   \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108058,
                "title": "one-pass-disjoint-set-solution-with-explain",
                "content": "This problem is tricky and interesting. It took me quite a few hours to figure it out. My first working solution was based on DFS, but I feel there might be better solutions. By spending whole night thinking deeply, I finally cracked it using Disjoint Set (also known as Union Find?). I want to share what I got here.\\n\\nAssumption before we start: input \"**edges**\" contains a directed tree with one and only one extra edge. If we remove the extra edge, the remaining graph should make a directed tree - a tree which has one root and from the root you can visit all other nodes by following directed edges. It has features:\\n1. one and only one root, and root does not have parent;\\n2. each non-root node has exactly one parent;\\n3. there is no cycle, which means any path will reach the end by moving at most (n-1) steps along the path.\\n\\nBy adding one edge ***(parent->child)*** to the tree:\\n1. every node including root has exactly one parent, if ***child*** is root;\\n2. root does not have parent, one node (***child***) has 2 parents, and all other nodes have exactly 1 parent, if ***child*** is not root.\\n\\nLet's check cycles. By adding one edge ***(a->b)*** to the tree, the tree will have:\\n1. a cycle, if there exists a path from ***(b->...->a)***; in particularly, if ***b == root***, (in other word, add an edge from a node to root) it will make a cycle since there must be a path ***(root->...->a)***.\\n2. no cycle, if there is no such a path ***(b->...->a)***.\\n\\nAfter adding the extra edge, the graph can be generalized in 3 different cases:\\n![0_1507232871672_Screen Shot 2017-10-05 at 2.25.34 PM.png](/assets/uploads/files/1507232873325-screen-shot-2017-10-05-at-2.25.34-pm-resized.png) \\n\\n```Case 1```: \"c\" is the only node which has 2 parents and there is not path (c->...->b) which means no cycle. In this case, removing either \"e1\" or \"e2\" will make the tree valid. According to the description of the problem, whichever edge added later is the answer.\\n\\n```Case 2```: \"c\" is the only node which has 2 parents and there is a path(c->...->b) which means there is a cycle. In this case, \"e2\" is the only edge that should be removed. Removing \"e1\" will make the tree in 2 separated groups. Note, in input `edges`, \"e1\" may come after \"e2\".\\n\\n```Case 3```: this is how it looks like if edge ***(a->root)*** is added to the tree. Removing any of the edges along the cycle will make the tree valid. But according to the description of the problem, the last edge added to complete the cycle is the answer. Note: edge \"e2\" (an edge pointing from a node outside of the cycle to a node on the cycle) can never happen in this case, because every node including root has exactly one parent. If \"e2\" happens, that make a node on cycle have 2 parents. That is impossible.\\n\\nAs we can see from the pictures, the answer must be:\\n1. one of the 2 edges that pointing to the same node in ``case 1`` and ``case 2``; there is one and only one such node which has 2 parents.\\n2. the last edge added to complete the cycle in ``case 3``.\\n\\nNote: both ``case 2`` and ``case 3`` have cycle, but in ``case 2``, \"e2\" may not be the last edge added to complete the cycle.\\n\\nNow, we can apply Disjoint Set (DS) to build the tree in the order the edges are given. We define ``ds[i]`` as the parent or ancestor of node ``i``. It will become the root of the whole tree eventually if `edges` does not have extra edge. When given an edge (a->b), we find node ``a``'s ancestor and assign it to `ds[b]`. Note, in typical DS, we also need to find node `b`'s ancestor and assign `a`'s ancestor as the ancestor of `b`'s ancestor. But in this case, we don't have to, since we skip the second parent edge (see below), it is guaranteed `a` is the only parent of `b`.\\n\\nIf we find an edge pointing to a node that already has a parent, we simply skip it. The edge skipped can be \"e1\" or \"e2\" in ``case 1`` and ``case 2``. In ``case 1``, removing either \"e1\" or \"e2\" will make the tree valid. In ``case 3``, removing \"e2\" will make the tree valid, but removing \"e1\" will make the tree in 2 separated groups and one of the groups has a cycle. In ```case 3```, none of the edges will be skipped because there is no 2 edges pointing to the same node. The result is a graph with cycle and \"n\" edges.\\n\\n**How to detect cycle by using Disjoint Set (Union Find)?**\\nWhen we join 2 nodes by edge (a->b), we check `a`'s ancestor, if it is b, we find a cycle! When we find a cycle, we don't assign `a`'s ancestor as `b`'s ancestor. That will trap our code in endless loop. We need to save the edge though since it might be the answer in `case 3`.\\n\\nNow the code. We define two variables (`first` and `second`) to store the 2 edges that point to the same node if there is any (there may not be such edges, see `case 3`). We skip adding `second` to tree. `first` and `second` hold the values of the original index in input `edges` of the 2 edges respectively. Variable `last` is the edge added to complete a cycle if there is any (there may not be a cycle, see `case 1` and removing \"e2\" in `case 2`). And it too hold the original index in input `edges`.\\n\\nAfter adding all except at most one edges to the tree, we end up with 4 different scenario:\\n1. `case 1` with either \"e1\" or \"e2\" removed. Either way, the result tree is valid. The answer is the edge being removed or skipped (a.k.a. `second`)\\n2. `case 2` with \"e2\" removed. The result tree is valid. The answer is the edge being removed or skipped (a.k.a. `second`)\\n3. `case 2` with \"e1\" removed. The result tree is invalid with a cycle in one of the groups. The answer is the other edge (`first`) that points to the same node as `second`. \\n4. `case 3` with no edge removed. The result tree is invalid with a cycle. The answer is the `last` edge added to complete the cycle.\\n\\nIn the following code,\\n`last == -1` means \"no cycle found\" which is scenario 1 or 2\\n`second != -1 && last != -1` means \"one edge removed and the result tree has cycle\" which is scenario 3\\n`second == -1` means \"no edge skipped or removed\" which is scenario 4\\n\\n``` \\n   public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent, -1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++) {\\n            int p = edges[i][0], c = edges[i][1];\\n            if (parent[c] != -1) {\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }\\n            parent[c] = i;\\n            \\n            int p1 = find(ds, p);\\n            if (p1 == c) last = i;\\n            else ds[c] = p1;\\n        }\\n\\n        if (last == -1) return edges[second]; // no cycle found by removing second\\n        if (second == -1) return edges[last]; // no edge removed\\n        return edges[first];\\n    }\\n    \\n    private int find(int[] ds, int i) {\\n        return ds[i] == 0 ? i : (ds[i] = find(ds, ds[i]));\\n    }\\n```\\nThis solution past all these test cases and ACed.\\nTest case:\\n[[1,2],[1,3],[2,3]]\\n[[1,2], [2,3], [3,4], [4,1], [1,5]]\\n[[4,2],[1,5],[5,2],[5,3],[2,4]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[4,1],[1,2],[1,3],[4,5],[5,6],[6,5]]\\n[[2,3], [3,4], [4,1], [1,5], [1,2]]\\n[[3,1],[1,4],[3,5],[1,2],[1,5]]\\n[[1,2],[2,3],[3,1]]\\n\\nexpected output:\\n[2,3]\\n[4,1]\\n[4,2]\\n[2,1]\\n[6,5]\\n[1,2]\\n[1,5]\\n[3,1]",
                "solutionTags": [],
                "code": "```Case 1```\n```Case 2```\n```Case 3```\n```case 3```\n``` \\n   public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent, -1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++) {\\n            int p = edges[i][0], c = edges[i][1];\\n            if (parent[c] != -1) {\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }\\n            parent[c] = i;\\n            \\n            int p1 = find(ds, p);\\n            if (p1 == c) last = i;\\n            else ds[c] = p1;\\n        }\\n\\n        if (last == -1) return edges[second]; // no cycle found by removing second\\n        if (second == -1) return edges[last]; // no edge removed\\n        return edges[first];\\n    }\\n    \\n    private int find(int[] ds, int i) {\\n        return ds[i] == 0 ? i : (ds[i] = find(ds, ds[i]));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141897,
                "title": "3ms-union-find-with-explanations",
                "content": "**Thought**\\n* There are **3 cases** for Redundant Connection:\\n\\ncase 1: two-parent problem such that an error node is with two parents\\n```\\n 1\\n / \\\\\\nv   v\\n2-->3     remove the second parentEdge of the node with two parents\\n```\\ncase 2: cyclic problem such that there is a cycle in the graph\\n```\\n 1\\n / ^\\nv   \\\\\\n2-->3     remove the edge that forms the cycle\\n```\\ncase 3: two-parent and cyclic problem\\n```\\n 1\\n / ^\\nv   \\\\\\n2-->3 <- 4     remove [2, 3] (to explain)\\n```\\nExplanation for case 3:\\nWe do union only if it is not the second parentEdge. Why?\\nWe assume we always remove the second parentEdge. If there is still cycle remained - that means we made the wrong choice, that is, we should remove the first parentEdge instead. \\n\\nIf `[[1, 2], [2, 3], [4, 3], [3, 1]]`, [2, 3] comes before [4, 3], we remove [4,3], then we union [1, 2], [2, 3], [3, 1], there is still cycle -- so we should remove [2, 3].\\nIf `[[1, 2], [4, 3], [2, 3], [3, 1]]`, [4, 3] comes before [2, 3], we remove [2, 3], then we union [1, 2], [4, 3], [3, 1], there is not cycle -- so we should remove [2, 3].\\n\\nThe usage of Disjoint Sets is the same as [Solution for 684. Redundant Connection](https://leetcode.com/problems/redundant-connection/discuss/123819/Beats-97.96-Union-Find-Java-with-Explanations)\\n\\n**Code**\\n```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int numNodes = edges.length, edgeRemoved = -1, edgeMakesCycle = -1;\\n        int[] parent = new int[numNodes + 1];      \\n        \\n        for (int i = 0; i < numNodes; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if (parent[v] != 0) {\\n                \\n                /* Assume we removed the second edge. */\\n                edgeRemoved = i; \\n                break;\\n            }\\n            else\\n                parent[v] = u;          \\n        }\\n        \\n        UnionFind uf = new UnionFind(numNodes);\\n        for (int i = 0; i < numNodes; i++) {\\n            if (i == edgeRemoved)\\n                continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if (!uf.union(u, v)) {\\n                edgeMakesCycle = i;\\n                break;\\n            }\\n        } \\n        \\n        /* Handle with the cyclic problem only. */\\n        if (edgeRemoved == -1) {\\n            return edges[edgeMakesCycle];\\n        }\\n        \\n        /* Handle with the cyclic problem when we remove the wrong edge. */\\n        if (edgeMakesCycle != -1) { \\n            int v = edges[edgeRemoved][1];\\n            int u = parent[v];\\n            return new int[]{u, v};\\n        } \\n        \\n        /* CHandle with the cyclic problem when we remove the right edge. */\\n        return edges[edgeRemoved];\\n    }\\n    \\n    static class UnionFind {\\n        private int[] parent; \\n        private int[] rank;\\n        \\n        public UnionFind(int n) {\\n            parent = new int[n + 1];\\n            rank = new int[n + 1];\\n            for (int i = 1; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        private int find(int x) {\\n            if (parent[x] == x)\\n                return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        private boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY)\\n                return false;\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            } else {\\n                parent[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n            }\\n            return true;\\n        }\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\n 1\\n / \\\\\\nv   v\\n2-->3     remove the second parentEdge of the node with two parents\\n```\n```\\n 1\\n / ^\\nv   \\\\\\n2-->3     remove the edge that forms the cycle\\n```\n```\\n 1\\n / ^\\nv   \\\\\\n2-->3 <- 4     remove [2, 3] (to explain)\\n```\n```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int numNodes = edges.length, edgeRemoved = -1, edgeMakesCycle = -1;\\n        int[] parent = new int[numNodes + 1];      \\n        \\n        for (int i = 0; i < numNodes; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if (parent[v] != 0) {\\n                \\n                /* Assume we removed the second edge. */\\n                edgeRemoved = i; \\n                break;\\n            }\\n            else\\n                parent[v] = u;          \\n        }\\n        \\n        UnionFind uf = new UnionFind(numNodes);\\n        for (int i = 0; i < numNodes; i++) {\\n            if (i == edgeRemoved)\\n                continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if (!uf.union(u, v)) {\\n                edgeMakesCycle = i;\\n                break;\\n            }\\n        } \\n        \\n        /* Handle with the cyclic problem only. */\\n        if (edgeRemoved == -1) {\\n            return edges[edgeMakesCycle];\\n        }\\n        \\n        /* Handle with the cyclic problem when we remove the wrong edge. */\\n        if (edgeMakesCycle != -1) { \\n            int v = edges[edgeRemoved][1];\\n            int u = parent[v];\\n            return new int[]{u, v};\\n        } \\n        \\n        /* CHandle with the cyclic problem when we remove the right edge. */\\n        return edges[edgeRemoved];\\n    }\\n    \\n    static class UnionFind {\\n        private int[] parent; \\n        private int[] rank;\\n        \\n        public UnionFind(int n) {\\n            parent = new int[n + 1];\\n            rank = new int[n + 1];\\n            for (int i = 1; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        private int find(int x) {\\n            if (parent[x] == x)\\n                return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        private boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY)\\n                return false;\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            } else {\\n                parent[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n            }\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108070,
                "title": "python-o-n-concise-solution-with-detailed-explanation-passed-updated-testcases",
                "content": "In this problem, you need to deal with 3 cases:\\n1. There is a loop in the graph, and no vertex has more than 1 parent.\\nExample:\\nInput: [[1,2], [2,3], [3,4], [4,1], [1,5]]\\nOutput: [4,1]\\n![0_1506493498612_drawing2.jpg](/assets/uploads/files/1506493500257-drawing2.jpg) \\nIn this case, you can simply output the edge in the loop that occurs last.\\nUnion-find can be used to check whether an directed graph contains a cycle or not. At first, every vertex is an independent subset. For each edge, join the subsets that are on both sides of the edge. If both the vertices are in the same subset, a cycle is found.\\n\\n2. A vertex has more than 1 parent, but there isn't a loop in the graph.\\nExample:\\nInput: [[1,2], [1,3], [2,3]]\\nOutput: [2,3]\\n![0_1506493289378_drawing 1.jpg](/assets/uploads/files/1506493291084-drawing-1.jpg) \\nThis case is also easy. You can just return the last edge that changes the tree into a graph. You can use an array of booleans to indicate whether a vertex has already got a parent.\\n\\n3. A vertex has more than 1 parent, and is part of a loop.\\nExample:\\nInput: [[2,1], [3,1], [4,2], [1,4]]\\nOutput: [2,1]\\n![0_1506494193813_drawing3.jpg](/assets/uploads/files/1506494195441-drawing3.jpg) \\nCase 3 is a mixture of case 1 and case 2. If you detect both cases, do the following:\\na. Find the vertex that has multiple parents. It is obvious that this vertex is also in the loop. In the example above, node 1 is what we are looking for.\\nb. Starting from this vertex, use DFS to find the last edge that forms the cycle.\\nc. Return this edge. In the example above, it is (2, 1).\\n\\n```\\nclass Solution(object):\\n    def union(self, a, b):\\n        self.uf[self.find(b)] = self.find(a)\\n\\n    def find(self, a):\\n        while self.uf[a] != a:\\n            a = self.uf[a]\\n        return a\\n    \\n    def detectCycle(self, V):\\n        self.visited[V] = True\\n        for i in range(len(self.adjList[V])):\\n            nextV = self.adjList[V][i]\\n            if self.visited[nextV]:\\n                return (V, nextV)\\n            ret = self.detectCycle(nextV)\\n            if ret[0]:\\n                return ret\\n        return (None, None)\\n    \\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        self.uf = [0] + [i + 1 for i in range(len(edges))]\\n        self.adjList = [[] for i in range(len(edges) + 1)]      # Adjancency List\\n        hasFather = [False] * (len(edges) + 1)                  # Whether a vertex has already got a parent\\n        criticalEdge = None\\n\\n        for i, edge in enumerate(edges):\\n            w, v = edge[0], edge[1]\\n            self.adjList[w].append(v)\\n            if hasFather[v]:\\n                criticalEdge = (w, v)                           # If a vertex has more than one parent, record the last edge\\n            hasFather[v] = True\\n            if self.find(w) == self.find(v):                    # If a loop is found, record the edge that occurs last\\n                cycleEdge = (w, v)\\n            self.union(w, v)\\n\\n        if not criticalEdge:                                    # Case 1\\n            return cycleEdge\\n        self.visited = [False] * (len(edges) + 1)\\n        (w, v) = self.detectCycle(criticalEdge[1])\\n        return (w, v) if w else criticalEdge                    # Case 2 and 3\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def union(self, a, b):\\n        self.uf[self.find(b)] = self.find(a)\\n\\n    def find(self, a):\\n        while self.uf[a] != a:\\n            a = self.uf[a]\\n        return a\\n    \\n    def detectCycle(self, V):\\n        self.visited[V] = True\\n        for i in range(len(self.adjList[V])):\\n            nextV = self.adjList[V][i]\\n            if self.visited[nextV]:\\n                return (V, nextV)\\n            ret = self.detectCycle(nextV)\\n            if ret[0]:\\n                return ret\\n        return (None, None)\\n    \\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        self.uf = [0] + [i + 1 for i in range(len(edges))]\\n        self.adjList = [[] for i in range(len(edges) + 1)]      # Adjancency List\\n        hasFather = [False] * (len(edges) + 1)                  # Whether a vertex has already got a parent\\n        criticalEdge = None\\n\\n        for i, edge in enumerate(edges):\\n            w, v = edge[0], edge[1]\\n            self.adjList[w].append(v)\\n            if hasFather[v]:\\n                criticalEdge = (w, v)                           # If a vertex has more than one parent, record the last edge\\n            hasFather[v] = True\\n            if self.find(w) == self.find(v):                    # If a loop is found, record the edge that occurs last\\n                cycleEdge = (w, v)\\n            self.union(w, v)\\n\\n        if not criticalEdge:                                    # Case 1\\n            return cycleEdge\\n        self.visited = [False] * (len(edges) + 1)\\n        (w, v) = self.detectCycle(criticalEdge[1])\\n        return (w, v) if w else criticalEdge                    # Case 2 and 3\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112569,
                "title": "easiest-understanding-java-solution-using-union-find-o-n",
                "content": "```\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] roots = new int[edges.length+1];\\n        for (int i = 0; i < roots.length; i++) roots[i] = i;\\n\\n        int[] candidate1 = null, candidate2 = null;\\n        for (int[] e : edges){\\n            int rootx = find(roots, e[0]), rooty = find(roots, e[1]);\\n            if (rooty != e[1]) candidate1 = e; // _Record the last edge which results in \"multiple parents\" issue\\n\\t\\t\\telse if (rootx == rooty) candidate2 = e; // Record last edge which results in \"cycle\" issue, if any.\\n            else roots[rooty] = rootx;\\n        }\\n\\n        // If there is only one issue, return this one.\\n        if (candidate1 == null) return candidate2; \\n        if (candidate2 == null) return candidate1;\\n        \\n        /* If both issues present, then the answer should be the first edge which results in \"multiple parents\" issue\\n        The reason is, when an issue happens, we skip the \"union\" process.\\n\\t\\tTherefore, if both issues happen, it means the incorrent edge which results in \"multiple parents\" was ignored. */\\n        for (int[] e : edges) if (e[1] == candidate1[1]) return e;\\n\\n        return new int[2];\\n    }\\n\\n    private int find(int[] roots, int i){\\n        while (i != roots[i]){\\n            roots[i] = roots[roots[i]];\\n            i = roots[i];\\n        }\\n        return i;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] roots = new int[edges.length+1];\\n        for (int i = 0; i < roots.length; i++) roots[i] = i;\\n\\n        int[] candidate1 = null, candidate2 = null;\\n        for (int[] e : edges){\\n            int rootx = find(roots, e[0]), rooty = find(roots, e[1]);\\n            if (rooty != e[1]) candidate1 = e; // _Record the last edge which results in \"multiple parents\" issue\\n\\t\\t\\telse if (rootx == rooty) candidate2 = e; // Record last edge which results in \"cycle\" issue, if any.\\n            else roots[rooty] = rootx;\\n        }\\n\\n        // If there is only one issue, return this one.\\n        if (candidate1 == null) return candidate2; \\n        if (candidate2 == null) return candidate1;\\n        \\n        /* If both issues present, then the answer should be the first edge which results in \"multiple parents\" issue\\n        The reason is, when an issue happens, we skip the \"union\" process.\\n\\t\\tTherefore, if both issues happen, it means the incorrent edge which results in \"multiple parents\" was ignored. */\\n        for (int[] e : edges) if (e[1] == candidate1[1]) return e;\\n\\n        return new int[2];\\n    }\\n\\n    private int find(int[] roots, int i){\\n        while (i != roots[i]){\\n            roots[i] = roots[roots[i]];\\n            i = roots[i];\\n        }\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254733,
                "title": "python-union-find-clear-logic",
                "content": "I referred to [this post](https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJava-Union-Find-with-explanation-O(n)). Honestly, I dont\\'s think most of the posts explain the logic very well.  **Let me try to explain it.** \\n\\n**General Idea**\\n\\n0. As the problem states, there is one and only one edge that violates the definition of **tree**. Therefore, there are three possible cases:\\n\\ta. There is no cycle in the graph, but there exist two edges pointing to the same node;\\n\\tb. There is a cycle, but there do not exist two edges pointing to the same node;\\n\\tc. There is a cycle, and there exist two edges pointing to the same node.\\n\\tYou may refer to [this post](https://leetcode.com/problems/redundant-connection-ii/discuss/108070/Python-O(N)-concise-solution-with-detailed-explanation-passed-updated-testcases) which has a visualization of the three cases.\\n\\t\\n**Steps**\\n\\n1. First, go through the edges and detect if any node has two parents, i.e., if there exist two edges pointing to the same node. If there exists such two edges, record them as `cand1` and `cand2`, because we know one of them must be the answer. If there do not exist such two edges, then `cand1, cand2` will be `None` and there must be a cycle in the graph. \\n2. Just pretend the edges are undirected. Then go through the edges and do a regular union find, which can detect the existence of a cycle in an undirected graph. (Ignore the existence of `cand2` when going through the edges, i.e., `if [node1, node2] == cand2: continue`)\\n\\ta. If there is no cycle, then we know `cand2` must exist and it is the bad edge we are looking for.\\n\\tb. If there is a cycle and `cand1, cand2` are not found, then the edge that incurs the cycle (the current edge when we go through the edges) is the bad edge.\\n\\tc. If there is a cycle and `cand1, cand2` are found, then `cand1` must be already in the cycle and it is the bad edge.\\n\\t\\n**Some Logic**\\nHere is the reason why `cand2` is ignored in the union find process. When it is ignored, if a cycle is detected in the union find process, we know the cycle has nothing to do with `cand2`. Therefore, the answer must be `cand1` if `cand1` exists, or the edge incuring the cycle if `cand1` does not exist. If no cycle is detected, then either `cand1` or `cand2` is the bad edge. But since `cand2` appears later than `cand1` in the list, we should return `cand2`.\\n\\n```\\nclass DisjointSet: #(UnionFind)\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        if x == y: return False\\n        self.parent[x] = self.parent[y]\\n        return True\\n    \\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        cand1, cand2, point_to = None, None, {}\\n        for node1, node2 in edges:\\n            if node2 in point_to: \\n                cand1, cand2 = point_to[node2], [node1, node2]\\n                break\\n            point_to[node2] = [node1, node2]\\n            \\n        ds = DisjointSet(len(edges))\\n        for node1, node2 in edges:\\n            if [node1, node2] == cand2: continue\\n            if not ds.union(node1 - 1, node2 - 1):\\n                if cand1: return cand1\\n                return [node1, node2]\\n        return cand2\\n```",
                "solutionTags": [],
                "code": "```\\nclass DisjointSet: #(UnionFind)\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        if x == y: return False\\n        self.parent[x] = self.parent[y]\\n        return True\\n    \\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        cand1, cand2, point_to = None, None, {}\\n        for node1, node2 in edges:\\n            if node2 in point_to: \\n                cand1, cand2 = point_to[node2], [node1, node2]\\n                break\\n            point_to[node2] = [node1, node2]\\n            \\n        ds = DisjointSet(len(edges))\\n        for node1, node2 in edges:\\n            if [node1, node2] == cand2: continue\\n            if not ds.union(node1 - 1, node2 - 1):\\n                if cand1: return cand1\\n                return [node1, node2]\\n        return cand2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108073,
                "title": "share-my-solution-c",
                "content": "This problem is limited to a graph with N nodes and N edges. No node is singled out if a edge is removed. For example, [[1,2],[2,4],[3,4]], 4 nodes 3 edges, is not applicable to this problem. You cannot remove [3,4] to single out node 3.\\n\\nThere are 3 cases:\\n  1. No loop, but there is one node who has 2 parents.\\n  2. A loop, and there is one node who has 2 parents, that node must be inside the loop.\\n  3. A loop, and every node has only 1 parent.\\n    \\nCase 1: e.g. ```[[1,2],[1,3],[2,3]]``` ,node 3 has 2 parents ([1,3] and [2,3]). Return the edge that occurs last that is, return [2,3].\\nCase 2: e.g. ```[[1,2],[2,3],[3,1],[4,1]]``` , {1->2->3->1} is a loop, node 1 has 2 parents ([4,1] and  [3,1]). Return the edge that is inside the loop, that is, return [3,1].\\nCase 3: e.g. ```[[1,2],[2,3],[3,1],[1,4]]``` , {1->2->3->1} is a loop, you can remove any edge in a loop, the graph is still valid. Thus, return the one that occurs last, that is, return [3,1].\\n\\n```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        vector<int> from; //parent(s), at most one node has 2 parents in a graph\\n        vector<int> to; //children, can have many children\\n    };\\n    unordered_map<int,Node> getNode;\\n    unordered_map<int,unordered_map<int,int>> edgeOrder;\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        //construct the graph, and record the node which has 2 parents if possible\\n        int N = edges.size();\\n        for(int n=1; n<=N; ++n)\\n            getNode[n] = Node();\\n        int node2parents = -1;\\n        for(int i=0; i<N; ++i){\\n            int p = edges[i][0];\\n            int c = edges[i][1];\\n            edgeOrder[p][c] = i;\\n            getNode[p].to.push_back(c);\\n            getNode[c].from.push_back(p);\\n            if(getNode[c].from.size()==2) //we find a node with 2 parents\\n                node2parents = c;\\n        }\\n        \\n        //doing DFS to find the loop if loop exists\\n        vector<int> status(N+1,0); // status 0,1,2 ==> 0:unvisited, 1:visiting, 2:visited\\n        stack<int> loop;\\n        bool loopfound = false;\\n        for(int i=1; i<=N; ++i){\\n            if(loopfound)   break;\\n            if(status[i] == 0){ //DFS started with node i\\n                status[i] = 1;\\n                stack<int> stk({i});\\n                DFS(stk,status,loopfound,loop);\\n                status[i] = 2;\\n            }\\n        }\\n        \\n        if(!loopfound){ // Case 1\\n            int parent1 = getNode[node2parents].from[0];\\n            int parent2 = getNode[node2parents].from[1];\\n            return (edgeOrder[parent1][node2parents] > edgeOrder[parent2][node2parents]) ?\\n                    vector<int>({parent1,node2parents}) : vector<int>({parent2,node2parents});\\n        }\\n        \\n        int last_occur_order = 0;\\n        vector<int> last_occur_edge;\\n        int begin = loop.top();\\n        while(!loop.empty()){\\n            int child = loop.top();\\n            loop.pop();\\n            int parent = loop.top();\\n            if(node2parents != -1 && child == node2parents) // Case 2\\n                return vector<int>({parent,child});\\n            int order = edgeOrder[parent][child];\\n            if(order > last_occur_order){\\n                last_occur_order = order;\\n                last_occur_edge = vector<int>({parent,child});\\n            }\\n            if(parent == begin)\\n                break; //loop ends\\n        }\\n        \\n        return last_occur_edge; // Case 3\\n    }\\n    \\n    void DFS(stack<int>& stk, vector<int>& status, bool& flag, stack<int>& loop){\\n        for(int c : getNode[stk.top()].to){\\n            if(flag)   return;\\n            if(status[c] == 1){\\n                stk.push(c);\\n                loop = stk;\\n                flag = true;\\n                return;\\n            }\\n            else if(status[c] == 0){\\n                stk.push(c);\\n                status[c] = 1;\\n                DFS(stk,status,flag,loop);\\n                status[c] = 2;\\n                stk.pop();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```[[1,2],[1,3],[2,3]]```\n```[[1,2],[2,3],[3,1],[4,1]]```\n```[[1,2],[2,3],[3,1],[1,4]]```\n```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        vector<int> from; //parent(s), at most one node has 2 parents in a graph\\n        vector<int> to; //children, can have many children\\n    };\\n    unordered_map<int,Node> getNode;\\n    unordered_map<int,unordered_map<int,int>> edgeOrder;\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        //construct the graph, and record the node which has 2 parents if possible\\n        int N = edges.size();\\n        for(int n=1; n<=N; ++n)\\n            getNode[n] = Node();\\n        int node2parents = -1;\\n        for(int i=0; i<N; ++i){\\n            int p = edges[i][0];\\n            int c = edges[i][1];\\n            edgeOrder[p][c] = i;\\n            getNode[p].to.push_back(c);\\n            getNode[c].from.push_back(p);\\n            if(getNode[c].from.size()==2) //we find a node with 2 parents\\n                node2parents = c;\\n        }\\n        \\n        //doing DFS to find the loop if loop exists\\n        vector<int> status(N+1,0); // status 0,1,2 ==> 0:unvisited, 1:visiting, 2:visited\\n        stack<int> loop;\\n        bool loopfound = false;\\n        for(int i=1; i<=N; ++i){\\n            if(loopfound)   break;\\n            if(status[i] == 0){ //DFS started with node i\\n                status[i] = 1;\\n                stack<int> stk({i});\\n                DFS(stk,status,loopfound,loop);\\n                status[i] = 2;\\n            }\\n        }\\n        \\n        if(!loopfound){ // Case 1\\n            int parent1 = getNode[node2parents].from[0];\\n            int parent2 = getNode[node2parents].from[1];\\n            return (edgeOrder[parent1][node2parents] > edgeOrder[parent2][node2parents]) ?\\n                    vector<int>({parent1,node2parents}) : vector<int>({parent2,node2parents});\\n        }\\n        \\n        int last_occur_order = 0;\\n        vector<int> last_occur_edge;\\n        int begin = loop.top();\\n        while(!loop.empty()){\\n            int child = loop.top();\\n            loop.pop();\\n            int parent = loop.top();\\n            if(node2parents != -1 && child == node2parents) // Case 2\\n                return vector<int>({parent,child});\\n            int order = edgeOrder[parent][child];\\n            if(order > last_occur_order){\\n                last_occur_order = order;\\n                last_occur_edge = vector<int>({parent,child});\\n            }\\n            if(parent == begin)\\n                break; //loop ends\\n        }\\n        \\n        return last_occur_edge; // Case 3\\n    }\\n    \\n    void DFS(stack<int>& stk, vector<int>& status, bool& flag, stack<int>& loop){\\n        for(int c : getNode[stk.top()].to){\\n            if(flag)   return;\\n            if(status[c] == 1){\\n                stk.push(c);\\n                loop = stk;\\n                flag = true;\\n                return;\\n            }\\n            else if(status[c] == 0){\\n                stk.push(c);\\n                status[c] = 1;\\n                DFS(stk,status,flag,loop);\\n                status[c] = 2;\\n                stk.pop();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882687,
                "title": "c-indegree-union-find-easy-clean-code-with-explanation",
                "content": "We are given a tree with 1 extra edge i.e. indegree of every node except root was 1 before extra edge . Thus the addition of extra edge can lead to 2 cases -\\n1. indegree of root becomes 1 \\n2. indegree of any other node becomes 2\\n\\nIn first case, it will cause formation of cycle . Thus we return the edge causing cycle .\\n\\nIn second case, it may or may not create a cycle . But we only have to check those 2 edges that leads to increase in indegree. For this we first remove the later edge and check if a cycle is present or not . If cyle is present this is nnot the correct edge else it\\'s the correct edge .\\n\\n```\\n    int find(int u,vector<int> &parent)\\n    {\\n        if(parent[u]<0)\\n            return u;\\n        \\n        parent[u]=find(parent[u],parent);\\n        return parent[u];\\n    }\\n    \\n    bool union_by_weight(int u,int v,vector<int> &parent)\\n    {\\n        int pu=find(u,parent);\\n        int pv=find(v,parent);\\n        \\n        if(pu==pv)\\n            return 0;\\n        \\n        if(parent[pu]<parent[pv])\\n        {\\n            parent[pu]+=parent[pv];\\n            parent[pv]=pu;   \\n        }\\n        else\\n        {\\n            parent[pv]+=parent[pu];\\n            parent[pu]=pv;\\n        }\\n        return 1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        \\n        int i,n=e.size();\\n        vector<int> parent(n+1,-1);\\n        vector<int> in(n+1,-1);\\n        int e1=-1,e2=-1;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(in[e[i][1]]!=-1)         // indegree 2\\n            {\\n                e2=in[e[i][1]];         // first edge causing indegree 2\\n                e1=i;                   // second edge causing indegree 2\\n                break;\\n            }\\n            in[e[i][1]]=i;    \\n        }\\n    \\n        for(i=0;i<n;i++)\\n        {\\n            if(i==e1)                                        //ignore edge causing indegree\\n                continue;\\n            \\n            if(!union_by_weight(e[i][0],e[i][1],parent))     //cycle is present\\n            {\\n                if(e1!=-1)                                   //indegree 2 , wrong edge ignored\\n                    return e[e2];\\n                else                                         //indegree 1 , remove edge causing cycle\\n                    return e[i];\\n            }\\n        }\\n        return e[e1];\\n    }\\n```\\n\\nTime - O( N ) + O( N * LOG N ) = O( N * LOG N )\\nSpace - O( N )\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n    int find(int u,vector<int> &parent)\\n    {\\n        if(parent[u]<0)\\n            return u;\\n        \\n        parent[u]=find(parent[u],parent);\\n        return parent[u];\\n    }\\n    \\n    bool union_by_weight(int u,int v,vector<int> &parent)\\n    {\\n        int pu=find(u,parent);\\n        int pv=find(v,parent);\\n        \\n        if(pu==pv)\\n            return 0;\\n        \\n        if(parent[pu]<parent[pv])\\n        {\\n            parent[pu]+=parent[pv];\\n            parent[pv]=pu;   \\n        }\\n        else\\n        {\\n            parent[pv]+=parent[pu];\\n            parent[pu]=pv;\\n        }\\n        return 1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        \\n        int i,n=e.size();\\n        vector<int> parent(n+1,-1);\\n        vector<int> in(n+1,-1);\\n        int e1=-1,e2=-1;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(in[e[i][1]]!=-1)         // indegree 2\\n            {\\n                e2=in[e[i][1]];         // first edge causing indegree 2\\n                e1=i;                   // second edge causing indegree 2\\n                break;\\n            }\\n            in[e[i][1]]=i;    \\n        }\\n    \\n        for(i=0;i<n;i++)\\n        {\\n            if(i==e1)                                        //ignore edge causing indegree\\n                continue;\\n            \\n            if(!union_by_weight(e[i][0],e[i][1],parent))     //cycle is present\\n            {\\n                if(e1!=-1)                                   //indegree 2 , wrong edge ignored\\n                    return e[e2];\\n                else                                         //indegree 1 , remove edge causing cycle\\n                    return e[i];\\n            }\\n        }\\n        return e[e1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108046,
                "title": "most-posted-answers-are-wrong",
                "content": "We can not simply apply the code from REDUNDANT CONNECTION I, and add codes checking duplicated-parent only. \\nHere are 2 sample failed test cases:\\n```[[4,2],[1,5],[5,2],[5,3],[2,4]]```\\ngot ```[5,2]``` but ```[4,2]``` expected\\nand\\n```[[2,1],[3,1],[4,2],[1,4]]```\\ngot ```[3,1]``` but ```[2,1]``` expected\\n(Thanks @niwota and @wzypangpang )\\nThe problem is we can not consider the two conditions separately, I mean the duplicated-parents and cycle.\\nThis problem should be discussed and solved by checking 3 different situations:\\n1) No-Cycle, but 2 parents pointed to one same child\\n2) No dup parents but with Cycle \\n3) Possessing Cycle and dup-parents\\n\\nThose 2 failed test cases are all in situation 3), where we can not return immediately current edge when we found something  against the tree's requirements.  \\nThe correct solution is detecting and recording the whole cycle, then check edges in that cycle by reverse order to find the one with the same child as the duplicated one we found. \\nA more clear explanation and code have been posted by @niwota \\nhttps://discuss.leetcode.com/topic/105087/share-my-solution-c",
                "solutionTags": [],
                "code": "```[[4,2],[1,5],[5,2],[5,3],[2,4]]```\n```[5,2]```\n```[4,2]```\n```[[2,1],[3,1],[4,2],[1,4]]```\n```[3,1]```\n```[2,1]```",
                "codeTag": "Unknown"
            },
            {
                "id": 277221,
                "title": "java-simple-code-short-and-no-union",
                "content": "We build up the graph ( a rooted tree with N nodes) by adding each edge into it. A just added edge might screw up the graph (or say it diffrently: makes it become not a rooted tree with N nodes) in 2 cases:\\n\\n- A new edge makes a node have 2 parents. `(I)`. We store 2 possible edges that should be removed. `twoParents[0]`, and `twoParents[1]`\\n- A new edge makes a cycle in the graph. `(II)`. We store the possible edge that should be removed. `cycle`\\n\\nThere are 4 possibilities happen:\\n\\n- **`(I)` happens before `(II)`** : we need to remove the edge `twoParents[0]`, because when we remove `twoParents[0]`:\\n\\t+ the graph has no node that has 2 parents\\n\\t+ the graph has no cycle.\\n\\n- **`(II)` happens before `(I))`** : the same as above. We should remove `twoParents[0]`\\n\\n- **Only `(I)`** happens: we should remove one of `twoParents`. Because we must remove the one that occurs last in the given 2D-array. So `twoParents[1]` should be removed.\\n\\n- **Only `(II)`** happens: ofcourse we must remove the edge that makes the graph become cycle: so we remove `cycle`.\\n\\n````\\n\\tpublic int[] findRedundantDirectedConnection(int[][] edges) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] cycle = null, twoParents[] = null;\\n        for (int[] edge : edges) {\\n            if (!map.containsKey(edge[0])) map.put(edge[0], edge[0]);\\n            if (!map.containsKey(edge[1]) || map.get(edge[1]) == edge[1]) map.put(edge[1], edge[0]);\\n            else { // 2 parents\\n                twoParents = new int[][] {new int[] {map.get(edge[1]),edge[1]}, edge};\\n                if (cycle != null) return twoParents[0];\\n            }\\n            if (cycle == null && findRoot(map, edge[0]) == null) { // cycle\\n                cycle = edge;\\n                if (twoParents != null) return twoParents[0];\\n            }\\n        }\\n        if (cycle != null) return cycle;\\n        if (twoParents != null) return twoParents[1];\\n        return new int[2];\\n    }\\n\\n    private Integer findRoot(Map<Integer, Integer> map, int node0) { // return null - cycle, int - root\\n        if (map.get(node0) == node0) return node0;\\n        int node = node0;\\n        while (map.get(node) != node) {\\n            node = map.get(node);\\n            if (node == node0) return null;\\n        }\\n        return node;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int[] findRedundantDirectedConnection(int[][] edges) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] cycle = null, twoParents[] = null;\\n        for (int[] edge : edges) {\\n            if (!map.containsKey(edge[0])) map.put(edge[0], edge[0]);\\n            if (!map.containsKey(edge[1]) || map.get(edge[1]) == edge[1]) map.put(edge[1], edge[0]);\\n            else { // 2 parents\\n                twoParents = new int[][] {new int[] {map.get(edge[1]),edge[1]}, edge};\\n                if (cycle != null) return twoParents[0];\\n            }\\n            if (cycle == null && findRoot(map, edge[0]) == null) { // cycle\\n                cycle = edge;\\n                if (twoParents != null) return twoParents[0];\\n            }\\n        }\\n        if (cycle != null) return cycle;\\n        if (twoParents != null) return twoParents[1];\\n        return new int[2];\\n    }\\n\\n    private Integer findRoot(Map<Integer, Integer> map, int node0) { // return null - cycle, int - root\\n        if (map.get(node0) == node0) return node0;\\n        int node = node0;\\n        while (map.get(node) != node) {\\n            node = map.get(node);\\n            if (node == node0) return null;\\n        }\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749151,
                "title": "explanation-with-intuitive-figures-unionfind-and-python-code",
                "content": "Special thanks to the following Chinese explanation:\\nhttps://leetcode.com/problems/redundant-connection-ii/discuss/278105/topic\\n\\nSome figures are borrowed from this URL and I translated the Chinese into English with some additional Figures as well.\\n\\nBackground knowledge:\\n ![image](https://assets.leetcode.com/users/images/4228bc45-d3b7-4d74-9d77-ae33a6763edf_1595420384.5409684.png)\\n\\nTake into consideration the \\u2018special\\u2019 to be deleted edge:\\nNote that, we pretend that the circle is NOT directed, just for analysis:\\n**Case 1**: The edge starts from an arbitrary node and points to the \\u2018root\\u2019 of the tree: (orange edge)\\n ![image](https://assets.leetcode.com/users/images/a85c5976-6edc-4036-8da5-6cda3fc84d01_1595420407.9547188.png)\\n\\nUnder this situation, the reason of the \\u2018illegal\\u2019tree is that: \\n**No root!**\\nSince every node\\u2019s in-degree is 1 now. (if legal, the root\\u2019s in-degree must be 0)\\nThe solution is that: we can remove any edge in this circle. After deleting, we will obtain a legal tree.\\nThus, based on the question, we only need to delete the edge that is (1) in the cycle and (2) appears the last in the given \\u2018edges\\u2019 array. (i.e., return of lastEdgeCauseCircle, in the code)\\n\\n**Case2:** The edge starts from any node and points to a node which is NOT root: (the following orange edge):\\n ![image](https://assets.leetcode.com/users/images/9aea0149-fc0c-4f2d-8376-d8b92bd7a8f8_1595420446.0902839.png)\\n\\nAt this case, the reason that the tree is illegal is that, there is a node with a in-degree of 2. And, in addition, one in-degree comes from the edge that belongs to a circle (orange edge). To solve this, we can only delete the edge that belongs to the circle (i.e., the orange edge, which is edge1 in the code)\\n\\n**Case 3:**\\nThe edge starts from an arbitrary node x and point to another node y that is not in the path from ROOT to x. As follows:\\n ![image](https://assets.leetcode.com/users/images/63606d42-ba6d-4439-a838-a925c8cff26c_1595420493.5056317.png)\\n\\nUnder this situation, the reason that it is an illegal tree is that, there is a node with an in-degree of 2 (i.e., two direct parents). In addition, these two edges are all in the circle. The solution is that, we can delete any edge that caused this in-degree=2 case. Based on the question\\u2019s requirement, we can delete the edge that appears later in the given edges array. (i.e., edge2 in the code)\\n\\n**So, here comes the algorithm:**\\nBesides the construction of UnionFind class, we additionally introduce a directParent array which stores the direct parent of a node in the graph.\\nFor each edge in the pre-given edges array, we try to use UnionFind to union two node\\u2019s roots. \\n\\nSpecially, for case 2 and case 3, we will face an edge that causes one node\\u2019s in-degree changes from 1 to 2. We record these two in-degree edges to be edge1 and edge2.\\n\\nFor case 1, we will never find a node with in-degree=2, so, edge1 and edge2 will keep to be None. However, in case 1, we will face an edge that causes \\u201Ccircle\\u201D,  we record it (name it \\u201ClastEdgeCauseCircle\\u201Dedge) since it will be the answer.\\nFor case 2 and case 3:\\n\\n## The final question is: when to return edge1 and when to return edge2? ##\\n\\nNote that we skipped taking edge2 into UnionFind in the code, this will cause two different situations finally (after reviewing all the edges):\\n(1)\\tIn case 3, we will keep going and nothing will happen, that is, we skipped edge2 at the coding running period, there will be no circle anymore, Thus, \\u2018lastEdgeCauseCircle\\u2019 will be None. So, edge2 will be our answer!\\n(2)\\tIn case 2, \\n    a.\\tif the edge2 that we skipped is in the cycle, then the whole loop in the code will smoothly continue without facing a circle, and \\u2018lastEdgeCauseCircle\\u2019 is None as well, then edge2 will be our answer. \\n    b.\\tHowever, if edge2 that we skipped is not in the cycle, then we will face a circle even we skipped edge2, so at this time, \\u2018lastEdgeCauseCircle\\u2019 will not be None, this time, we will have to remove another edge1 that caused the in-degree=2 node.\\n \\nFor example:\\n![image](https://assets.leetcode.com/users/images/c7c43a03-647e-4342-9376-97528ddd46ce_1595420360.0145075.png)\\n\\nOrder: \\n2 -> 1\\n3 -> 1  : we face a node \\u20181\\u2019 with an indegree=2, so we record, edge1=[2,1] and edge2=[3,1], so we skip 3->1\\n4 -> 2\\n1 -> 4 : this is the last edge that caused a circle (among 2, 1, and 4), so lastEdgeCauseCircle = [1,4]\\nSince both edge1 and edge2 are not None, and we also have lastEdgeCauseCircle = [1,4]\\nThis means that, even we skiped edge2 (3->1), we still faced circle, so (3->1) is NOT in the circle. And since edge1 together with edge2 caused an in-degree=2 problem, then edge1 is the edge we need to remove actually, to yield:\\n1.\\tNo circle (since we removed edge1 (2->1);\\n2.\\tNo indegree=2 node anymore, since edge1 and edge2 caused the \\u20181\\u2019 node\\u2019s problem and we removed one edge. The problem is solved.\\n\\n[updates] update the python code to be more compact:\\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        #\\u6709\\u5411\\u56FE\\u4E5F\\u53EF\\u4EE5\\u4F7F\\u7528union find \\u65B9\\u6CD5\\uFF01\\n        N = len(edges) + 1\\n        par = {i:i for i in range(N)}\\n        def find(x):\\n            if par[x] != x:\\n                par[x] = find(par[x])\\n            return par[x]\\n        \\n        directpar = [0] * N\\n        edge1 = None\\n        edge2 = None\\n        lastEdgeCauseCycle = None\\n        \\n        for u, v in edges:\\n            # from u to v, i.e., u=parent, v=child\\n            if directpar[v] != 0:\\n                edge1 = [directpar[v], v]\\n                edge2 = [u, v]\\n            else:\\n                directpar[v] = u # do not forget this line!\\n                ru = find(u)\\n                rv = find(v)\\n                if ru != rv:\\n                    par[ru] = rv\\n                else:\\n                    lastEdgeCauseCycle = [u,v]\\n        \\n        if edge1 and edge2:\\n            # edge2 was not added (it is ignored, if still lastEdgeCauseCycle != None, the bad one is edge1)\\n            return edge1 if lastEdgeCauseCycle else edge2\\n        else:\\n            return lastEdgeCauseCycle\\n```\\n\\nPython code:\\n\\n```\\nclass UnionFind:\\n    def __init__(self, N):\\n        self.parent = [-1] * N\\n        self.rank = [0] * N\\n        self.count = 0\\n        for i in range(N):\\n            self.parent[i] = i\\n            self.count += 1\\n    \\n    def findRoot(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.findRoot(self.parent[i]) # path compression\\n        return self.parent[i]\\n    \\n    def union(self, x, y):\\n        rootx, rooty = self.findRoot(x), self.findRoot(y)\\n        if rootx == rooty:\\n            return False\\n        rankx, ranky = self.rank[rootx], self.rank[rooty]\\n        if rankx < ranky:\\n            self.parent[rootx] = rooty\\n        elif rankx > ranky:\\n            self.parent[rooty] = rootx\\n        else:\\n            self.parent[rootx] = rooty\\n            self.rank[rooty] += 1\\n        return True # could successfully combined\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        directParent = [0]*(len(edges) + 1) # since node\\'s NO. starts from 1\\n        uf = UnionFind(len(edges) + 1)\\n        edge1 = None\\n        edge2 = None\\n        lastEdgeCauseCircle = None\\n        for pair in edges:\\n            u = pair[0]\\n            v = pair[1]\\n            if directParent[v] != 0:\\n                # node v already has a father, so we just skip the union of this edge and check if there will be a circle\\n                edge1 = [directParent[v], v]\\n                edge2 = pair # specially note that we skipped edge2 HERE for UnionFind!\\n            else:\\n                directParent[v] = u\\n                rootu = uf.findRoot(u)\\n                rootv = uf.findRoot(v)\\n                if rootu != rootv:\\n                    uf.union(u, v)\\n                else:\\n                    lastEdgeCauseCircle = pair\\n        if edge1 and edge2: # this means that we found in-degree = 2 node \\n            return edge2 if not lastEdgeCauseCircle else edge1\\n\\t\\t\\t# when there is a circle, lastEdgeCauseCircle is not None, and edge1 is the problem;\\n\\t\\t\\t# when no circle, lastEdgeCauseCircle is None, and edge2 was the problem which we intentionally skipped during the loop!\\n        else: # i.e., there is no in-degree=2 node\\n            return lastEdgeCauseCircle # case 1, no in-degree=2 nodes\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        #\\u6709\\u5411\\u56FE\\u4E5F\\u53EF\\u4EE5\\u4F7F\\u7528union find \\u65B9\\u6CD5\\uFF01\\n        N = len(edges) + 1\\n        par = {i:i for i in range(N)}\\n        def find(x):\\n            if par[x] != x:\\n                par[x] = find(par[x])\\n            return par[x]\\n        \\n        directpar = [0] * N\\n        edge1 = None\\n        edge2 = None\\n        lastEdgeCauseCycle = None\\n        \\n        for u, v in edges:\\n            # from u to v, i.e., u=parent, v=child\\n            if directpar[v] != 0:\\n                edge1 = [directpar[v], v]\\n                edge2 = [u, v]\\n            else:\\n                directpar[v] = u # do not forget this line!\\n                ru = find(u)\\n                rv = find(v)\\n                if ru != rv:\\n                    par[ru] = rv\\n                else:\\n                    lastEdgeCauseCycle = [u,v]\\n        \\n        if edge1 and edge2:\\n            # edge2 was not added (it is ignored, if still lastEdgeCauseCycle != None, the bad one is edge1)\\n            return edge1 if lastEdgeCauseCycle else edge2\\n        else:\\n            return lastEdgeCauseCycle\\n```\n```\\nclass UnionFind:\\n    def __init__(self, N):\\n        self.parent = [-1] * N\\n        self.rank = [0] * N\\n        self.count = 0\\n        for i in range(N):\\n            self.parent[i] = i\\n            self.count += 1\\n    \\n    def findRoot(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.findRoot(self.parent[i]) # path compression\\n        return self.parent[i]\\n    \\n    def union(self, x, y):\\n        rootx, rooty = self.findRoot(x), self.findRoot(y)\\n        if rootx == rooty:\\n            return False\\n        rankx, ranky = self.rank[rootx], self.rank[rooty]\\n        if rankx < ranky:\\n            self.parent[rootx] = rooty\\n        elif rankx > ranky:\\n            self.parent[rooty] = rootx\\n        else:\\n            self.parent[rootx] = rooty\\n            self.rank[rooty] += 1\\n        return True # could successfully combined\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        directParent = [0]*(len(edges) + 1) # since node\\'s NO. starts from 1\\n        uf = UnionFind(len(edges) + 1)\\n        edge1 = None\\n        edge2 = None\\n        lastEdgeCauseCircle = None\\n        for pair in edges:\\n            u = pair[0]\\n            v = pair[1]\\n            if directParent[v] != 0:\\n                # node v already has a father, so we just skip the union of this edge and check if there will be a circle\\n                edge1 = [directParent[v], v]\\n                edge2 = pair # specially note that we skipped edge2 HERE for UnionFind!\\n            else:\\n                directParent[v] = u\\n                rootu = uf.findRoot(u)\\n                rootv = uf.findRoot(v)\\n                if rootu != rootv:\\n                    uf.union(u, v)\\n                else:\\n                    lastEdgeCauseCircle = pair\\n        if edge1 and edge2: # this means that we found in-degree = 2 node \\n            return edge2 if not lastEdgeCauseCircle else edge1\\n\\t\\t\\t# when there is a circle, lastEdgeCauseCircle is not None, and edge1 is the problem;\\n\\t\\t\\t# when no circle, lastEdgeCauseCircle is None, and edge2 was the problem which we intentionally skipped during the loop!\\n        else: # i.e., there is no in-degree=2 node\\n            return lastEdgeCauseCircle # case 1, no in-degree=2 nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138593,
                "title": "c-very-straight-forward-solution-either-node-has-two-parents-no-parent",
                "content": "Two cases:\\n1. Each node only has exactly one parent, and there is a cycle.\\n2. One node has two parents, while another node has no parent. There could be one or zero cycle.\\n\\nSolution for the two cases:\\n1. Remove any edge in the cycle is good, so remove the last one appeared in input.\\n2. The one node that has no parent is the root node. For the node that has two parents, we need to remove one edge there.\\n\\t\\t(a) If there is no cycle, then two parents are both from the root, so remove any edge is okay;\\n\\t  (b) If there is a cycle, then remove the cycle-side branch;\\n\\t\\nSo the code is self explanatary:\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<vector<int>> parent(edges.size(), vector<int>());\\n        vector<bool> visited(edges.size(), false);\\n        vector<int> cycle{-1, -1};\\n        int id_two_parents = -1;\\n        for (auto &e : edges) {\\n            if (visited[e[0]] && visited[e[1]]) \\n                cycle = {e[0], e[1]};\\n            visited[e[0]] = true;\\n            visited[e[1]] = true;\\n            parent[e[1]].push_back(e[0]);\\n            if (parent[e[1]].size() > 1)\\n                id_two_parents = e[1];\\n        }\\n        //\\n        if (id_two_parents < 0) {\\n            // no node has two parents, means a single cycle, any node in this cycle can be root\\n            // so return the last cycle edge\\n            return cycle;\\n        } else {\\n            // one node has two parents, must remove one edge from there.\\n            // we recursively find the parent, \\n            // if the last node has no parent, that\\'s the root, we should keep this branch\\n            // otherwise if this branch is cycle, remove this edge.\\n            int branch0 = parent[id_two_parents][0];\\n            int branch1 = parent[id_two_parents][1];\\n            int id = branch0;\\n            while (parent[id].size() != 0 && prarent[id] != id_two_parents) {\\n                // find the root or the cycle\\n                id = parent[id];\\n            }\\n            if (id == id_two_parents) {\\n                // this is the cycle branch, remove this branch\\n                return {branch0, id_two_parents};\\n            } else {\\n                // parent[id].size() == 0, the root branch, remove the other branch\\n                return {branch1, id_two_parents};\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<vector<int>> parent(edges.size(), vector<int>());\\n        vector<bool> visited(edges.size(), false);\\n        vector<int> cycle{-1, -1};\\n        int id_two_parents = -1;\\n        for (auto &e : edges) {\\n            if (visited[e[0]] && visited[e[1]]) \\n                cycle = {e[0], e[1]};\\n            visited[e[0]] = true;\\n            visited[e[1]] = true;\\n            parent[e[1]].push_back(e[0]);\\n            if (parent[e[1]].size() > 1)\\n                id_two_parents = e[1];\\n        }\\n        //\\n        if (id_two_parents < 0) {\\n            // no node has two parents, means a single cycle, any node in this cycle can be root\\n            // so return the last cycle edge\\n            return cycle;\\n        } else {\\n            // one node has two parents, must remove one edge from there.\\n            // we recursively find the parent, \\n            // if the last node has no parent, that\\'s the root, we should keep this branch\\n            // otherwise if this branch is cycle, remove this edge.\\n            int branch0 = parent[id_two_parents][0];\\n            int branch1 = parent[id_two_parents][1];\\n            int id = branch0;\\n            while (parent[id].size() != 0 && prarent[id] != id_two_parents) {\\n                // find the root or the cycle\\n                id = parent[id];\\n            }\\n            if (id == id_two_parents) {\\n                // this is the cycle branch, remove this branch\\n                return {branch0, id_two_parents};\\n            } else {\\n                // parent[id].size() == 0, the root branch, remove the other branch\\n                return {branch1, id_two_parents};\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549772,
                "title": "17-line-clean-python-solution",
                "content": "The idea is same as the ones mentioned in these awesome posts like [here](https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJava-Union-Find-with-explanation-O(n)) and [here](https://leetcode.com/problems/redundant-connection-ii/discuss/254733/Python-Union-Find-Clear-Logic) and a couple more.\\n\\nBasically, there are 2 cases:\\n1. when there exists one node and only one node with 2 parents, one of its 2 incoming edges should be removed.\\n    Like `1->3` or `2->3` in the following figure.\\n```\\nedges = [[1,2], [1,3], [2,3]]\\n  1\\n / \\\\\\nv   v\\n2-->3\\n```\\n2. when every node has exactly one parent, the edge that creates a cycle needes to be removed.\\n    Like `4->1` in the following figure.\\n\\n```\\nedges = [[1,2], [2,3], [3,4], [4,1], [1,5]]\\n5 <- 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\\n\\n### **To address the case 1**\\nhow do we detect a node has 2 parent? We can keep a `dict` or a `list` `parent` to record each node\\'s\\nparent. We still use `edges = [[1,2], [1,3], [2,3]]` as an example. Initially, each node\\'s parent is itself.\\n\\n```\\n parent = dict(zip(range(1,n+1), range(1,n+1)))\\n```\\n\\nFor example, when we have 3 nodes, initially,\\n```\\nparent = {1:1, 2:2, 3:3}\\n```\\n\\nAfter visiting the first 2 edges `[[1,2], [1,3]]`\\n```\\nparent = {1:1, 2:1, 3:1}\\n```\\n\\nThe we visit edge `[2,3]`, since `parent[3] != 3`, we know node `3` has 2 parents. Then both edge `[1,3]` and\\n`[2,3]` are candidates to remove. We will not add edge `[2,3]` to our graph, but record it as `candidate_edge`.\\n\\nSo how to tell whether `[1,3]` or `[2,3]` should be removed? Since we didn\\'t add `[2,3]` to our graph, we will\\ncheck at the end if the graph is still connected. If it\\'s not, it means removing `[2,3]` will make it an invalid\\nrooted tree, then `[1,3]` should be removed. Otherwise `[2,3]` should be removed.\\n\\n### **To address the case 2**\\nhow do we detect adding one edge will create cycle?\\nWe still use `edges = [[1,2], [2,3], [3,4], [4,1], [1,5]]` as an example.\\nAfter visiting the first 3 edges `[[1,2], [2,3], [3,4]]`, the `parent` is like this:\\n\\n```\\nparent = {1:1, 2:1, 3:2, 4:3}\\n```\\n\\nThen we visit the 4th edge `[4, 1]`. We can see if we trace the root of node `4`, i.e. the ancestor, it\\'s node `1`. Since\\n```\\nparent[parent[parent[4]]] = parent[parent[3]] = parent[2] = 1\\n```\\n\\nSo we have the relation `root(4) = 1`. In general, if we see an edge `e = [v, w]` that satisfy `root(v) = w`, we know `e` creates an edge.\\n\\n### **Put it all together**\\n\\nHere is the python code, it\\'s \\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        parent = dict(zip(range(1,n+1), range(1,n+1)))\\n        last_cycle_edge = candidate_edge = candidate = None\\n        def root(v):\\n            while parent[v] != v:\\n                v = parent[v]\\n            return v\\n        for e in edges:\\n            v, w = e\\n            if parent[w] != w: # case 1: w has 2 parents\\n                candidate_edge, candidate = e, w\\n                continue\\n            if root(v) == w: # case 2: [v, w] makes a cycle\\n                last_cycle_edge = e\\n                continue\\n            parent[w], n = v, n-1\\n        return [parent[candidate], candidate] if n > 1 else (candidate_edge or last_cycle_edge)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nedges = [[1,2], [1,3], [2,3]]\\n  1\\n / \\\\\\nv   v\\n2-->3\\n```\n```\\nedges = [[1,2], [2,3], [3,4], [4,1], [1,5]]\\n5 <- 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\n```\\n parent = dict(zip(range(1,n+1), range(1,n+1)))\\n```\n```\\nparent = {1:1, 2:2, 3:3}\\n```\n```\\nparent = {1:1, 2:1, 3:1}\\n```\n```\\nparent = {1:1, 2:1, 3:2, 4:3}\\n```\n```\\nparent[parent[parent[4]]] = parent[parent[3]] = parent[2] = 1\\n```\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        parent = dict(zip(range(1,n+1), range(1,n+1)))\\n        last_cycle_edge = candidate_edge = candidate = None\\n        def root(v):\\n            while parent[v] != v:\\n                v = parent[v]\\n            return v\\n        for e in edges:\\n            v, w = e\\n            if parent[w] != w: # case 1: w has 2 parents\\n                candidate_edge, candidate = e, w\\n                continue\\n            if root(v) == w: # case 2: [v, w] makes a cycle\\n                last_cycle_edge = e\\n                continue\\n            parent[w], n = v, n-1\\n        return [parent[candidate], candidate] if n > 1 else (candidate_edge or last_cycle_edge)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178903,
                "title": "python-fast-two-way-solution",
                "content": "Why a simple union-find fails for some test case? Because mainly union-find deals with **undirected graphs**. For this problem, when all the nodes in the input have exactly one parent, we can use union-find to deal with it. Consider the example 2 in the description: [[1,2], [2,3], [3,4], [4,1], [1,5]].\\n\\nHowever when **some node** has 2 parents, we know one of the edges from its parents to the node must be the result. To find out which one, we write a subroutine `is_cycle` to check if the edge is the result, otherwise returns the other edge.\\n\\n```\\nclass DSU:\\n    def __init__(self, N):\\n        self.ranks = [0] * (N+1)\\n        self.groups = list(range(N+1))\\n        \\n    def find(self, x):\\n        if self.groups[x] == x:\\n            return x\\n        return self.find(self.groups[x])\\n    \\n    def union(self, x, y):\\n        gx = self.find(x)\\n        gy = self.find(y)\\n        if gx == gy: \\n            return False\\n        if self.ranks[gx] > self.ranks[gy]:\\n            self.groups[gy] = gx\\n        elif self.ranks[gx] < self.ranks[gy]:\\n            self.groups[gx] = gy\\n        else:\\n            self.groups[gy] = gx\\n            self.ranks[gy] += 1\\n        return True\\n        \\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def is_cycle(edge):\\n            \"\"\"\\n                return True if from edge=x, y can get back to x\\n            \"\"\"\\n            x, y = edge\\n            while x != y and x in parent:\\n                x = parent[x]\\n            return x == y\\n            \\n        parent = {}\\n        candidates = []\\n        for x, y in edges:\\n            if y not in parent:\\n                parent[y] = x\\n            else:\\n                candidates.append([parent[y], y])\\n                candidates.append([x, y])\\n                \\n        if candidates:\\n            if is_cycle(candidates[0]):\\n                return candidates[0]\\n            return candidates[1]\\n            \\n        else:\\n            N = len(edges)\\n            dsu = DSU(N)\\n            for x, y in edges:\\n                if not dsu.union(x, y):\\n                    return [x, y]\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, N):\\n        self.ranks = [0] * (N+1)\\n        self.groups = list(range(N+1))\\n        \\n    def find(self, x):\\n        if self.groups[x] == x:\\n            return x\\n        return self.find(self.groups[x])\\n    \\n    def union(self, x, y):\\n        gx = self.find(x)\\n        gy = self.find(y)\\n        if gx == gy: \\n            return False\\n        if self.ranks[gx] > self.ranks[gy]:\\n            self.groups[gy] = gx\\n        elif self.ranks[gx] < self.ranks[gy]:\\n            self.groups[gx] = gy\\n        else:\\n            self.groups[gy] = gx\\n            self.ranks[gy] += 1\\n        return True\\n        \\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def is_cycle(edge):\\n            \"\"\"\\n                return True if from edge=x, y can get back to x\\n            \"\"\"\\n            x, y = edge\\n            while x != y and x in parent:\\n                x = parent[x]\\n            return x == y\\n            \\n        parent = {}\\n        candidates = []\\n        for x, y in edges:\\n            if y not in parent:\\n                parent[y] = x\\n            else:\\n                candidates.append([parent[y], y])\\n                candidates.append([x, y])\\n                \\n        if candidates:\\n            if is_cycle(candidates[0]):\\n                return candidates[0]\\n            return candidates[1]\\n            \\n        else:\\n            N = len(edges)\\n            dsu = DSU(N)\\n            for x, y in edges:\\n                if not dsu.union(x, y):\\n                    return [x, y]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272193,
                "title": "java-union-find-that-beats-100-with-detailed-explanation",
                "content": "Credit: Huahua. Thank you for your excellent solution.\\nHis blog link: http://zxi.mytechroad.com/blog/graph/leetcode-685-redundant-connection-ii/\\n```\\nclass Solution {\\n    /**\\n    We still use unionFind to solve this question, but it has two kind of cases\\n    Case 1: No duplicate parents, return the first edge that creates the loop --> Same as 684\\n    Case 2: A node has two parents {u1, u2}\\n        2.1: return the second edge that creates duplicate parents (no loop). Example:[[1,2], [1,3], [2,3]]\\n                      1\\n                     / \\\\\\n                    v   v\\n                    2-->3    Node 3 has two parents: 1 and 2. Remove any one of the edge satisfy the question. But we need to remove the one that occurs the last.\\n        2.2: return edge {u1, v} or edge {u2, v} that creates the loop. Example:[[2,1],[3,1],[4,2],[1,4]]\\n                    2--> 1 <-- 3\\n                    /\\\\   |\\n                     \\\\   v\\n                      \\\\- 4    Node 1 has two parents. We have to remove either {2,1} or {3,1}. {2,1} is the one that creates the loop. So we remove {2,1}\\n   \\n\\tSo our algorithm uses two loops: First loop to detect if there is any duplicate parents.\\n\\t2nd loop to detect if there is any loop in the graph.\\n    */\\n    class UnionFind{\\n        int[] parents;\\n        public UnionFind(int N){\\n            parents = new int[N];\\n            for(int i=0; i<N; i++)\\n                parents[i] = i;\\n        }\\n        public void union(int x, int y){\\n            parents[find(x)] = find(y);\\n        }\\n        public int find(int x){\\n            if(x!=parents[x])\\n                parents[x] = find(parents[x]);\\n            return parents[x];\\n        }\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int [] edge1 = new int [2];\\n        int [] edge2 = new int [2]; /*Possible two edges(Two parents) in cases 2. */\\n        int [] parent = new int [edges.length + 1];\\n        UnionFind uf = new UnionFind(edges.length + 1);\\n        for(int i=0; i<edges.length; i++){ /*First loop to detect if there is duplicate parents*/\\n            int nodeU = edges[i][0];\\n            int nodeV = edges[i][1];\\n            if(parent[nodeV] > 0){  /* there is duplicate parents*/\\n                edge1 = new int[]{parent[nodeV], nodeV}; /*Add previous/first edge*/\\n                edge2 = new int[]{nodeU, nodeV};/*Add 2nd edge*/\\n                edges[i][0] = -1;\\n                edges[i][1] = -1;/*Delete the 2nd edge first*/\\n            }\\n            parent[nodeV] = nodeU; \\n        }\\n        for(int i=0; i<edges.length; i++){\\n            int nodeU = edges[i][0];\\n            int nodeV = edges[i][1];\\n            if(nodeU<0 || nodeV<0)\\n                continue; /*This is for the deleted edge we have done in first loop.*/\\n            int rootU = uf.find(nodeU);\\n            int rootV = uf.find(nodeV);\\n            if(rootU==rootV) /*Since we already deleted the 2nd edge, then it must be edge1. If edge1 is not assigned with any values.*/\\n                return edge1[0]==0? new int[]{nodeU, nodeV} : edge1;/*Then it means there is no duplicate parents. So case1: return current detected edge.*/\\n            uf.union(nodeU, nodeV);\\n        }\\n        return edge2; /*If reached here, it means there is no loop detected, otherwise it would return at 2nd loop in our code. So case 2.1, return 2nd edge.*/\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n    We still use unionFind to solve this question, but it has two kind of cases\\n    Case 1: No duplicate parents, return the first edge that creates the loop --> Same as 684\\n    Case 2: A node has two parents {u1, u2}\\n        2.1: return the second edge that creates duplicate parents (no loop). Example:[[1,2], [1,3], [2,3]]\\n                      1\\n                     / \\\\\\n                    v   v\\n                    2-->3    Node 3 has two parents: 1 and 2. Remove any one of the edge satisfy the question. But we need to remove the one that occurs the last.\\n        2.2: return edge {u1, v} or edge {u2, v} that creates the loop. Example:[[2,1],[3,1],[4,2],[1,4]]\\n                    2--> 1 <-- 3\\n                    /\\\\   |\\n                     \\\\   v\\n                      \\\\- 4    Node 1 has two parents. We have to remove either {2,1} or {3,1}. {2,1} is the one that creates the loop. So we remove {2,1}\\n   \\n\\tSo our algorithm uses two loops: First loop to detect if there is any duplicate parents.\\n\\t2nd loop to detect if there is any loop in the graph.\\n    */\\n    class UnionFind{\\n        int[] parents;\\n        public UnionFind(int N){\\n            parents = new int[N];\\n            for(int i=0; i<N; i++)\\n                parents[i] = i;\\n        }\\n        public void union(int x, int y){\\n            parents[find(x)] = find(y);\\n        }\\n        public int find(int x){\\n            if(x!=parents[x])\\n                parents[x] = find(parents[x]);\\n            return parents[x];\\n        }\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int [] edge1 = new int [2];\\n        int [] edge2 = new int [2]; /*Possible two edges(Two parents) in cases 2. */\\n        int [] parent = new int [edges.length + 1];\\n        UnionFind uf = new UnionFind(edges.length + 1);\\n        for(int i=0; i<edges.length; i++){ /*First loop to detect if there is duplicate parents*/\\n            int nodeU = edges[i][0];\\n            int nodeV = edges[i][1];\\n            if(parent[nodeV] > 0){  /* there is duplicate parents*/\\n                edge1 = new int[]{parent[nodeV], nodeV}; /*Add previous/first edge*/\\n                edge2 = new int[]{nodeU, nodeV};/*Add 2nd edge*/\\n                edges[i][0] = -1;\\n                edges[i][1] = -1;/*Delete the 2nd edge first*/\\n            }\\n            parent[nodeV] = nodeU; \\n        }\\n        for(int i=0; i<edges.length; i++){\\n            int nodeU = edges[i][0];\\n            int nodeV = edges[i][1];\\n            if(nodeU<0 || nodeV<0)\\n                continue; /*This is for the deleted edge we have done in first loop.*/\\n            int rootU = uf.find(nodeU);\\n            int rootV = uf.find(nodeV);\\n            if(rootU==rootV) /*Since we already deleted the 2nd edge, then it must be edge1. If edge1 is not assigned with any values.*/\\n                return edge1[0]==0? new int[]{nodeU, nodeV} : edge1;/*Then it means there is no duplicate parents. So case1: return current detected edge.*/\\n            uf.union(nodeU, nodeV);\\n        }\\n        return edge2; /*If reached here, it means there is no loop detected, otherwise it would return at 2nd loop in our code. So case 2.1, return 2nd edge.*/\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212532,
                "title": "c-dsu",
                "content": "```\\n   int par[1005], sz[1005];\\nclass Solution {\\npublic:\\n    void init(int n) {\\n            for (int i = 0; i < n; i++) {\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n     int find(int v) {\\n            return v == par[v] ? v : par[v] = find(par[v]);\\n        }\\n        void join(int u, int v) {\\n            u = find(u);\\n            v = find(v);\\n            if (u == v) return ;\\n            if (sz[u] < sz[v]) swap(u, v);\\n            par[v] = u;\\n            sz[u] += sz[v];\\n            \\n        }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& g) {\\n        //case 1:after adding a directed edge,there might be two parents for a partiuclar nodere\\n        //case 2:after adding a directed edge there might be a cycle in the directed graph,e.g an edge from leaf node to root node\\n        //case 3:there might be a node with two parents as well as a cycle,this is an edge case\\n        //example for case 3 [2,3],[3,4],[4,5][5,2],[1,2],here node 2 has two parents 1 and 5,but removing 1->2 edge wont help as there would stil be a  cycle left\\n        //so in such cases,remove the edge which is a part of the cycle i.e 5->2(See for yourself)\\n        \\n        //so basically if we have a node with two parents,put the edge which comes later in the graph  in the blacllist1,meaning it must have higher prefernece,because we are required to return the answer that occurs last\\n        //now perform a cycle detection using normal dsu(but remember,directed graph me dsu se cycle detect nahi hota,yaha hame pata hain ki cycle ho sakta hain islie ham kar sakte hain yaha)\\n        //if there is still a cycle,iska matlab woh edge blaclist 1 wala usse remove karke bhi kuch laabh hua nahi,so remove the edge in blacklist 2 and that is the answer\\n        //but what if after removing the node in blacklist 1 there is no cycle,tab toh bhai aram kar,return that edge only and go home\\n        int n=g.size();\\n        vector<int> bl1,bl2;\\n       \\n        vector<int> indeg(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            int x=g[i][0];\\n            int y=g[i][1];\\n            //x->y\\n            if(indeg[y]==-1)\\n               indeg[y]=i;//marking the row number which is increasing y\\'s indegree \\n            else{\\n                bl1.push_back(i);//ye baad me aya hain naa,toh blaclist 1\\n                bl2.push_back(indeg[y]);//pehle wala ko blacklist 2 me daal do\\n                indeg[y]=i;\\n            }\\n        }\\n        if(bl1.size()==0){\\n            //iska matlab kyaa hain\\n            //ksi ka parent two nahi hain\\n            //toh  cycle hi hain graph me for sure,damn sure\\n            //so since we are sure ki cycle hain,toh dsu laga de normally\\n            //waise ham dsu nahi laga sakte to detect cycle in directed graph\\n            //but pata chal gaya na bhai ki hain\\n             init(n+1);\\n            for(int i=0;i<n;i++){\\n                int x=g[i][0];\\n                int y=g[i][1];\\n                if(find(x)==find(y)){\\n                    return g[i];\\n                }\\n                else{\\n                    join(x,y);\\n                }\\n            }\\n        }\\n        //now check cycle if we consider removing bl1\\'s edge,how to do so sir,simple,dsu run karo edge list me without considering bl1 ka edge\\n        int num=bl1[0];\\n        bool cycle=false;\\n        init(n+1);\\n        for(int i=0;i<g.size();i++){ \\n            if(i==num){\\n                continue;\\n            }\\n            int x=g[i][0];\\n            int y=g[i][1];\\n            if(find(x)==find(y)){\\n                cycle=true;\\n                break;\\n            }\\n            else{\\n                 join(x,y);\\n            }\\n         \\n        }  \\n        if(cycle){\\n            return g[bl2[0]];\\n        }\\n        else{\\n            return g[bl1[0]];\\n        }\\n        \\n       \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n   int par[1005], sz[1005];\\nclass Solution {\\npublic:\\n    void init(int n) {\\n            for (int i = 0; i < n; i++) {\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n     int find(int v) {\\n            return v == par[v] ? v : par[v] = find(par[v]);\\n        }\\n        void join(int u, int v) {\\n            u = find(u);\\n            v = find(v);\\n            if (u == v) return ;\\n            if (sz[u] < sz[v]) swap(u, v);\\n            par[v] = u;\\n            sz[u] += sz[v];\\n            \\n        }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& g) {\\n        //case 1:after adding a directed edge,there might be two parents for a partiuclar nodere\\n        //case 2:after adding a directed edge there might be a cycle in the directed graph,e.g an edge from leaf node to root node\\n        //case 3:there might be a node with two parents as well as a cycle,this is an edge case\\n        //example for case 3 [2,3],[3,4],[4,5][5,2],[1,2],here node 2 has two parents 1 and 5,but removing 1->2 edge wont help as there would stil be a  cycle left\\n        //so in such cases,remove the edge which is a part of the cycle i.e 5->2(See for yourself)\\n        \\n        //so basically if we have a node with two parents,put the edge which comes later in the graph  in the blacllist1,meaning it must have higher prefernece,because we are required to return the answer that occurs last\\n        //now perform a cycle detection using normal dsu(but remember,directed graph me dsu se cycle detect nahi hota,yaha hame pata hain ki cycle ho sakta hain islie ham kar sakte hain yaha)\\n        //if there is still a cycle,iska matlab woh edge blaclist 1 wala usse remove karke bhi kuch laabh hua nahi,so remove the edge in blacklist 2 and that is the answer\\n        //but what if after removing the node in blacklist 1 there is no cycle,tab toh bhai aram kar,return that edge only and go home\\n        int n=g.size();\\n        vector<int> bl1,bl2;\\n       \\n        vector<int> indeg(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            int x=g[i][0];\\n            int y=g[i][1];\\n            //x->y\\n            if(indeg[y]==-1)\\n               indeg[y]=i;//marking the row number which is increasing y\\'s indegree \\n            else{\\n                bl1.push_back(i);//ye baad me aya hain naa,toh blaclist 1\\n                bl2.push_back(indeg[y]);//pehle wala ko blacklist 2 me daal do\\n                indeg[y]=i;\\n            }\\n        }\\n        if(bl1.size()==0){\\n            //iska matlab kyaa hain\\n            //ksi ka parent two nahi hain\\n            //toh  cycle hi hain graph me for sure,damn sure\\n            //so since we are sure ki cycle hain,toh dsu laga de normally\\n            //waise ham dsu nahi laga sakte to detect cycle in directed graph\\n            //but pata chal gaya na bhai ki hain\\n             init(n+1);\\n            for(int i=0;i<n;i++){\\n                int x=g[i][0];\\n                int y=g[i][1];\\n                if(find(x)==find(y)){\\n                    return g[i];\\n                }\\n                else{\\n                    join(x,y);\\n                }\\n            }\\n        }\\n        //now check cycle if we consider removing bl1\\'s edge,how to do so sir,simple,dsu run karo edge list me without considering bl1 ka edge\\n        int num=bl1[0];\\n        bool cycle=false;\\n        init(n+1);\\n        for(int i=0;i<g.size();i++){ \\n            if(i==num){\\n                continue;\\n            }\\n            int x=g[i][0];\\n            int y=g[i][1];\\n            if(find(x)==find(y)){\\n                cycle=true;\\n                break;\\n            }\\n            else{\\n                 join(x,y);\\n            }\\n         \\n        }  \\n        if(cycle){\\n            return g[bl2[0]];\\n        }\\n        else{\\n            return g[bl1[0]];\\n        }\\n        \\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190590,
                "title": "explained-why-can-i-apply-dsu-to-a-directional-graph",
                "content": "Firstly, I recommend solving [redundant connection 1](https://leetcode.com/problems/redundant-connection/) on leetcode as the approach would be somewhat similar with slight additions to the code.\\nThe two questions are different in the sense that the former question deals with the detection of edges in an\\nundirected graph which was pretty much a direct application of the DSU algorithm as a cycle would have been\\nsurely present in case of a common parent between any two inter-connected nodes in the graph. But, in this\\nquestion, if we try applying DSU directly, we would encounter an issue wherein two nodes would be having the\\nsame parent and would be connected but still won\\'t be forming a cycle (See Diagram).\\n\\n![image](https://assets.leetcode.com/users/images/1a81d6cb-d8f6-4218-8b0d-31174fec3583_1656057993.7640421.png)\\nNow, In this problem, we would basically be facing three cases:\\n1. When a node has 2 parents\\n2. When an edge leads to a cycle\\n3. When there are both dual parents as well as a cycle in the graph.\\n\\n![image](https://assets.leetcode.com/users/images/04d16bff-cde3-4a9c-8877-307a836fa91b_1656058562.3618014.png)\\nWe can find wether there are 2 parents of a node by counting the inwards-directed arrows for all nodes. If there is more \\nthan one inward arrow for any vertex, it means there is a dual- parent node. Hence, this states either case 1 or 3 is \\npresent.\\nThen, we store both the previous edge and the second edge in different variables and then compare both 1-by-1,\\nremoving one of the parent and checking for a cycle using DSU.\\n\\n### Now the main question: Why can we apply DSU?\\nIn the problem statement, it is clearly stated that the graph is initially a generic tree and a single additional edge is \\ncreated in the tree. Hence, once we have checked and removed either of the dual parent edges (either of which \\nmust be the additional edge), we would no longer have a vertex having 2 parents and hence, cases like case-1 \\nwould not be there anymore. Now, we apply simple DSU, ignoring one dual edge at a time, if it is present and then \\nchecking wether the graph is cyclic anymore.\\n\\nCode: \\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        \\n        int[]inDegree = new int[edges.length+1];        // Case 1: Check for double parents\\n        Arrays.fill(inDegree, -1);\\n        \\n        int bl1 = -1, bl2 = -1;\\n        \\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            if(inDegree[v] == -1){\\n                inDegree[v] = i;\\n            } else {\\n                bl1 = i;                        // If double parents exist, we need to find which one of them is unecessary\\n                bl2 = inDegree[v];              // We store them both in vars and then run DSU on both, ignoring\\n                                                // one edge at a time and check for correct removal\\n                break;\\n            }\\n        }\\n        \\n         // DSU Implementation\\n        \\n        int[]parent = new int[edges.length+1];\\n        int[]rank = new int[edges.length+1];\\n        \\n        for(int i=0; i<parent.length; i++) parent[i] = i;\\n        \\n        for(int i=0; i<edges.length; i++){\\n            if(i == bl1) continue;\\n            \\n            int[]edge = edges[i];\\n            boolean bool = union(edge[0], edge[1], parent, rank);\\n            if(bool){\\n                if(bl1 == -1){                  // Case 3: Double parents dont exist. Cycle exists.\\n                    return edge;\\n                } else{\\n                    return edges[bl2];          // Case 2: Double parents and cycle both exist\\n                }\\n            }\\n        }\\n        \\n        return edges[bl1];\\n    }\\n    \\n    public int find(int x, int[]parent){\\n        if(x == parent[x]) return x;\\n        else return find(parent[x], parent);\\n    }\\n\\t\\n    public boolean union(int s1, int s2, int[]parent, int[]rank){\\n\\t\\tint s1lead = find(s1, parent);        // Finding the parent nodes of both the nodes\\n        int s2lead = find(s2, parent);\\n        \\n        if(s1lead != s2lead){\\n            if(rank[s1lead] > rank[s2lead]){\\n                parent[s2lead] = s1lead;\\n            } else if(rank[s2lead] > rank[s1lead]){\\n                parent[s1lead] = s2lead;\\n            } else{\\n                parent[s2lead] = s1lead;\\n                rank[s1lead]++;\\n            }\\n            return false;       // No cycle due to this edge  \\n        } else return true;     // Indicates that the cycle exists\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        \\n        int[]inDegree = new int[edges.length+1];        // Case 1: Check for double parents\\n        Arrays.fill(inDegree, -1);\\n        \\n        int bl1 = -1, bl2 = -1;\\n        \\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            if(inDegree[v] == -1){\\n                inDegree[v] = i;\\n            } else {\\n                bl1 = i;                        // If double parents exist, we need to find which one of them is unecessary\\n                bl2 = inDegree[v];              // We store them both in vars and then run DSU on both, ignoring\\n                                                // one edge at a time and check for correct removal\\n                break;\\n            }\\n        }\\n        \\n         // DSU Implementation\\n        \\n        int[]parent = new int[edges.length+1];\\n        int[]rank = new int[edges.length+1];\\n        \\n        for(int i=0; i<parent.length; i++) parent[i] = i;\\n        \\n        for(int i=0; i<edges.length; i++){\\n            if(i == bl1) continue;\\n            \\n            int[]edge = edges[i];\\n            boolean bool = union(edge[0], edge[1], parent, rank);\\n            if(bool){\\n                if(bl1 == -1){                  // Case 3: Double parents dont exist. Cycle exists.\\n                    return edge;\\n                } else{\\n                    return edges[bl2];          // Case 2: Double parents and cycle both exist\\n                }\\n            }\\n        }\\n        \\n        return edges[bl1];\\n    }\\n    \\n    public int find(int x, int[]parent){\\n        if(x == parent[x]) return x;\\n        else return find(parent[x], parent);\\n    }\\n\\t\\n    public boolean union(int s1, int s2, int[]parent, int[]rank){\\n\\t\\tint s1lead = find(s1, parent);        // Finding the parent nodes of both the nodes\\n        int s2lead = find(s2, parent);\\n        \\n        if(s1lead != s2lead){\\n            if(rank[s1lead] > rank[s2lead]){\\n                parent[s2lead] = s1lead;\\n            } else if(rank[s2lead] > rank[s1lead]){\\n                parent[s1lead] = s2lead;\\n            } else{\\n                parent[s2lead] = s1lead;\\n                rank[s1lead]++;\\n            }\\n            return false;       // No cycle due to this edge  \\n        } else return true;     // Indicates that the cycle exists\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300019,
                "title": "simple-approach-very-very-easy-solution-using-toposort-algorithm",
                "content": "# Intuition\\nRemove edge one by one  and check whether existing graph after removing edge is having cycle or not.\\nIf existing graph have cycle, then again put that edge in the graph and take away another edge and check the same .\\nBut if existing graph don\\'t have cycle, it means removed edge is our answer.  \\n\\n# Approach\\nUsing map and set I have tried to construct adjacency list.\\n**Why I have used map and set??**\\n**Ans->** I can easily remove a particular edge and easily can put again that edge in graph when required.\\n\\n**Iterate from back of 2D array to satisfy the given condition**:\\nIf there are multiple answers, return the answer that occurs last in the given 2D-array. \\nPick edge and remove it check for rest graph \\n$$Condition 1$$:If cycle don\\'t exists return that particular edge as ans.\\n$$Condition 2:$$ If cycle exists then again put that edge in the adjacency list and continue the same with other edges.\\n\\nHOW TO CHECK CYCLE EXISTS OR NOT ??\\n\\n\\n**1.BFS(KAHN\\'s ALGORITHM)// **\\nI have used BFS, so we need an array indegree to keep the track of indegrees. Then we will try to output all nodes with 0 indegree, and remove the edges coming out of them at the same time. Besides, remember to put the nodes that become 0 indegree in the queue.\\n**It is important to check if indegree[node]>=2, it means it has more than or equal to two parents which is not possible in tree.**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkCycle( unordered_map<int,unordered_set<int>>mp,int n)\\n    {\\n       \\n        vector<int>indegree(n+1,0);\\n        vector<int>ans;\\n       \\n        for(int i=1;i<=n;i++)\\n        {\\n          for(auto it:mp[i])\\n          {\\n              indegree[it]++;\\n          }\\n        }\\n        \\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n            \\n            if(indegree[i]>=2)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!q.empty())\\n            \\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto it:mp[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        if(ans.size()!=n)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) \\n    {\\n        int n=edges.size();\\n        unordered_map<int,unordered_set<int>>mp;\\n        vector<int>res(2,0);\\n        \\n      for(auto it:edges)\\n      {\\n          mp[it[0]].insert(it[1]);\\n      }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[edges[i][0]].erase(edges[i][1]);\\n            \\n            if(checkCycle(mp,n)==true)\\n            {\\n                res[0]=edges[i][0];\\n                res[1]=edges[i][1];\\n                return res;\\n                \\n            }\\n            else\\n            {\\n                 mp[edges[i][0]].insert(edges[i][1]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkCycle( unordered_map<int,unordered_set<int>>mp,int n)\\n    {\\n       \\n        vector<int>indegree(n+1,0);\\n        vector<int>ans;\\n       \\n        for(int i=1;i<=n;i++)\\n        {\\n          for(auto it:mp[i])\\n          {\\n              indegree[it]++;\\n          }\\n        }\\n        \\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n            \\n            if(indegree[i]>=2)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!q.empty())\\n            \\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto it:mp[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        if(ans.size()!=n)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) \\n    {\\n        int n=edges.size();\\n        unordered_map<int,unordered_set<int>>mp;\\n        vector<int>res(2,0);\\n        \\n      for(auto it:edges)\\n      {\\n          mp[it[0]].insert(it[1]);\\n      }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[edges[i][0]].erase(edges[i][1]);\\n            \\n            if(checkCycle(mp,n)==true)\\n            {\\n                res[0]=edges[i][0];\\n                res[1]=edges[i][1];\\n                return res;\\n                \\n            }\\n            else\\n            {\\n                 mp[edges[i][0]].insert(edges[i][1]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872529,
                "title": "python-straight-forward-dfs-with-clear-explanation",
                "content": "\"As the problem states, there is one and only one edge that violates the definition of tree. Therefore, there are three possible cases:\\na. There is no cycle in the graph, but there exist two edges pointing to the same node;\\nb. There is a cycle, but there do not exist two edges pointing to the same node;\\nc. There is a cycle, and there exist two edges pointing to the same node. \"\\n(See for more details in https://leetcode.com/problems/redundant-connection-ii/discuss/254733/Python-Union-Find-Clear-Logic)\\n\\nSo the idea is simple, \\nif we find a node (k) who has two parent i and j (i occurs earlier), we know that one of pair [i,k] or [j,k] needs to be removed. The question is which one should be removed? Note it\\'s not always the latter one. **The earlier pair [i, k] should be removed if and only if there is a cycle from  k to i.** \\nif there is no 2-parent case, then we just need to detect the cycle and remove the last encountered edge in the cycle. \\n\\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        n=len(edges)        \\n        child=collections.defaultdict(list)\\n        parent=collections.defaultdict(list)\\n        def cycle(start, end):\\n            if start==end: return True\\n            self.seen.add(start)\\n            for node in child[start]:\\n                if node not in self.seen:\\n                    if cycle(node, end):\\n                        return True\\n            return False\\n        \\n        K=-1          #to mark the node with 2 parents\\n        for i, j in edges:      \\n            child[i].append(j)\\n            parent[j].append(i)\\n            if len(parent[j])==2:\\n                K=j\\n\\n        if K!=-1:          # if 2-parent case happened\\n            self.seen=set()\\n            if cycle(K, parent[K][0]): \\n                return [parent[K][0], K] \\n            else:\\n                return [parent[K][1], K]\\n                       \\n        for i in range(n-1, -1, -1):     #to find the last edge in the cycle\\n            v, u=edges[i]\\n            self.seen=set()\\n            if cycle(u, v): return [v, u]\\n```\\nRuntime:\\xA040 ms, faster than\\xA091.38%\\xA0of\\xA0Python\\xA0online submissions for\\xA0Redundant Connection II.\\nLet me know if you have any question!\\n",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        n=len(edges)        \\n        child=collections.defaultdict(list)\\n        parent=collections.defaultdict(list)\\n        def cycle(start, end):\\n            if start==end: return True\\n            self.seen.add(start)\\n            for node in child[start]:\\n                if node not in self.seen:\\n                    if cycle(node, end):\\n                        return True\\n            return False\\n        \\n        K=-1          #to mark the node with 2 parents\\n        for i, j in edges:      \\n            child[i].append(j)\\n            parent[j].append(i)\\n            if len(parent[j])==2:\\n                K=j\\n\\n        if K!=-1:          # if 2-parent case happened\\n            self.seen=set()\\n            if cycle(K, parent[K][0]): \\n                return [parent[K][0], K] \\n            else:\\n                return [parent[K][1], K]\\n                       \\n        for i in range(n-1, -1, -1):     #to find the last edge in the cycle\\n            v, u=edges[i]\\n            self.seen=set()\\n            if cycle(u, v): return [v, u]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574742,
                "title": "python-union-find-solution",
                "content": "1. Every tree will have a maximum of one incoming edge and multiple out going edges. Iterate through the edges and check if any node has more than one incoming edge. If so one of the edges is the culprit\\n2. Remove the last edge and check if it does not create cycle using union find , if it does not return that edge or return the other edge\\n3. If there are no nodes which has more than one incoming edge use unionFind to detect the cycle and remove them\\n\\n\\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        incomingEdge = collections.defaultdict(list)\\n        parents = [i for i in range (len(edges)+1)]\\n        #Find algorithm to find the parent of a node\\n        def find(n1):\\n            p = parents[n1]\\n            while p != parents[p]:\\n                parents[p] = parents[parents[p]]\\n                p = parents[p]\\n            return p\\n        \\n        #union algorithm to check if they can be united, if so unite or return False\\n        def union(n1,n2):\\n            p1,p2 = find(n1),find(n2)\\n            if p1 == p2: \\n                return False\\n            parents[p2] = p1\\n            return True\\n        \\n        #unionFind being called to check if there is any cycle in the graph\\n        # return -1 if there are no cycles in the graph\\n        def unionFind(edges):\\n            for n1,n2 in edges:\\n                if union(n1,n2) == False:\\n                    return [n1,n2]\\n            return -1\\n        # Get the incoming edges and check if there is any node with 2 incoming edges\\n        # if so remove the last edge and check if it resolves the cycle if not the other edge is the answer\\n        for n1,n2 in edges:\\n            incomingEdge[n2].append(n1)\\n        for node in incomingEdge:\\n            if len(incomingEdge[node])>1:\\n                edge1 = [incomingEdge[node][0],node]\\n                edge2 = [incomingEdge[node][1],node]\\n                edges.remove(edge2)\\n                if unionFind(edges) == -1:\\n                    return edge2\\n                return edge1\\n        return unionFind(edges)\\n    \\n                \\n     ```\\n\\t \\n\\t",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        incomingEdge = collections.defaultdict(list)\\n        parents = [i for i in range (len(edges)+1)]\\n        #Find algorithm to find the parent of a node\\n        def find(n1):\\n            p = parents[n1]\\n            while p != parents[p]:\\n                parents[p] = parents[parents[p]]\\n                p = parents[p]\\n            return p\\n        \\n        #union algorithm to check if they can be united, if so unite or return False\\n        def union(n1,n2):\\n            p1,p2 = find(n1),find(n2)\\n            if p1 == p2: \\n                return False\\n            parents[p2] = p1\\n            return True\\n        \\n        #unionFind being called to check if there is any cycle in the graph\\n        # return -1 if there are no cycles in the graph\\n        def unionFind(edges):\\n            for n1,n2 in edges:\\n                if union(n1,n2) == False:\\n                    return [n1,n2]\\n            return -1\\n        # Get the incoming edges and check if there is any node with 2 incoming edges\\n        # if so remove the last edge and check if it resolves the cycle if not the other edge is the answer\\n        for n1,n2 in edges:\\n            incomingEdge[n2].append(n1)\\n        for node in incomingEdge:\\n            if len(incomingEdge[node])>1:\\n                edge1 = [incomingEdge[node][0],node]\\n                edge2 = [incomingEdge[node][1],node]\\n                edges.remove(edge2)\\n                if unionFind(edges) == -1:\\n                    return edge2\\n                return edge1\\n        return unionFind(edges)\\n    \\n                \\n     ```",
                "codeTag": "Java"
            },
            {
                "id": 1707750,
                "title": "c-easy-to-understand-solution-union-find",
                "content": "\\n\\tint parent(int i, vector<int> &p)\\n    {\\n        if(p[i]==i)\\n        {\\n            return i;\\n        }\\n        \\n        return parent(p[i], p);\\n    }\\n    \\n    vector<int> unionfind(vector<vector<int>> &edges, vector<int> &ans1, vector<int> &ans2, bool flag)\\n    {\\n        int n=edges.size();\\n        vector<int> p(n+1);\\n        \\n        for(int i=0;i<n+1;i++)\\n        {\\n            p[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i] == ans1)\\n            {\\n                continue;\\n            }\\n            \\n            int pa = parent(edges[i][0], p);\\n            int pb = parent(edges[i][1], p);\\n            \\n            if(pa != pb)\\n            {\\n                p[pa] = pb;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    return ans2;\\n                }\\n                \\n                return {edges[i][0], edges[i][1]};\\n            }\\n        }\\n        \\n        return ans1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        int n = edges.size();\\n        vector<int> ans1;\\n        vector<int> ind(n+1,-1);\\n        vector<int> ans2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[edges[i][1]] != -1)\\n            {\\n                ans1 = edges[i];\\n                ans2 = edges[ind[edges[i][1]]];\\n                \\n                return unionfind(edges, ans1, ans2, true);\\n            }\\n            \\n            ind[edges[i][1]] = i;\\n            \\n            // cout<<edges[i][1]<<endl;\\n        }\\n        \\n        return unionfind(edges, ans1, ans2, false);\\n    }\\n\\t\\n\\t\\n we have to make a tree after removing a single edge, and in a tree indegree of a node can either be 1 or 0 .\\n \\n step 1 calculate the indegree of each node. take a vector of size of n+1(1 based indexing), and store which edge contribute to the indegree of that node in the array.\\n If u find a node whose indree has been already set to an edge means its indegree is 2 i.e that node has two incoming edge and we have to remove one of those incoming edge because since only one edge is extra in a tree , therefore there can be exactly one node with indegree 2.\\n \\n step 2. if no node has indegree 2 , just apply union find algorithm.\\n step 3 if u find a node with indegree two , store both the edges coming to that node .\\n step 4 now remove one of the two edges and apply union find , if cycle is not detected then the edge which we removed is the edge we actually have to remove , and if cycle detected, then that is not the right edge to remove it is the other edge we saved earlier.",
                "solutionTags": [
                    "Graph"
                ],
                "code": "\\n\\tint parent(int i, vector<int> &p)\\n    {\\n        if(p[i]==i)\\n        {\\n            return i;\\n        }\\n        \\n        return parent(p[i], p);\\n    }\\n    \\n    vector<int> unionfind(vector<vector<int>> &edges, vector<int> &ans1, vector<int> &ans2, bool flag)\\n    {\\n        int n=edges.size();\\n        vector<int> p(n+1);\\n        \\n        for(int i=0;i<n+1;i++)\\n        {\\n            p[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i] == ans1)\\n            {\\n                continue;\\n            }\\n            \\n            int pa = parent(edges[i][0], p);\\n            int pb = parent(edges[i][1], p);\\n            \\n            if(pa != pb)\\n            {\\n                p[pa] = pb;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    return ans2;\\n                }\\n                \\n                return {edges[i][0], edges[i][1]};\\n            }\\n        }\\n        \\n        return ans1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        int n = edges.size();\\n        vector<int> ans1;\\n        vector<int> ind(n+1,-1);\\n        vector<int> ans2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[edges[i][1]] != -1)\\n            {\\n                ans1 = edges[i];\\n                ans2 = edges[ind[edges[i][1]]];\\n                \\n                return unionfind(edges, ans1, ans2, true);\\n            }\\n            \\n            ind[edges[i][1]] = i;\\n            \\n            // cout<<edges[i][1]<<endl;\\n        }\\n        \\n        return unionfind(edges, ans1, ans2, false);\\n    }\\n\\t\\n\\t\\n we have to make a tree after removing a single edge, and in a tree indegree of a node can either be 1 or 0 .\\n \\n step 1 calculate the indegree of each node. take a vector of size of n+1(1 based indexing), and store which edge contribute to the indegree of that node in the array.\\n If u find a node whose indree has been already set to an edge means its indegree is 2 i.e that node has two incoming edge and we have to remove one of those incoming edge because since only one edge is extra in a tree , therefore there can be exactly one node with indegree 2.\\n \\n step 2. if no node has indegree 2 , just apply union find algorithm.\\n step 3 if u find a node with indegree two , store both the edges coming to that node .\\n step 4 now remove one of the two edges and apply union find , if cycle is not detected then the edge which we removed is the edge we actually have to remove , and if cycle detected, then that is not the right edge to remove it is the other edge we saved earlier.",
                "codeTag": "C++"
            },
            {
                "id": 1418179,
                "title": "c-union-find-with-good-explanation",
                "content": "Only need to check two cases (when this graph will violate tree property)\\n1) indegree of every node is 1, then return edge which causes the cycle.\\n2) indegree of one node is 2, then we need to check only those two edges,\\n    If removing one edge causes a cycle, then this edge is the wrong edge.\\n\\tIf it does not cause the cycle, then it should satisy tree property.\\nMake sure to return the edge which is closer to the end (and obviously satisfy above conditions)\\n```\\nclass DSU{\\n    public:\\n    vector<int>p;\\n    DSU(int n){\\n        p.resize(n,-1);\\n        for(int i=0;i<n;i++){\\n            make_set(i);\\n        }\\n    }\\n    int find(int a){\\n        if(p[a]==a)return a;\\n        p[a] = find(p[a]);\\n        return p[a];\\n    }\\n    void union_set(int a,int b){\\n        a = find(a);\\n        b = find(b);\\n        if(a==b)return;\\n        p[b] = a;\\n    }\\n    void make_set(int a){\\n        p[a] = a;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> detectCycle(vector<vector<int>>& edges,vector<int>&e){\\n        int n = edges.size();\\n        DSU *dsu = new DSU(n+1);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]==e)continue;\\n            int a = edges[i][0],b = edges[i][1];\\n            if(dsu->find(a)==dsu->find(b))return edges[i];\\n            dsu->union_set(a,b);\\n        }\\n        return {0,0};\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int>indegree(n+1,0);\\n        bool indegtwo = false;\\n        unordered_map<int,int>m;\\n        vector<int>ans1,ans2;\\n        vector<int>f={0,0};\\n        for(auto x:edges){\\n            indegree[x[1]]++;\\n            if(indegree[x[1]]==2){\\n                indegtwo=true;\\n                ans1 = {m[x[1]],x[1]};\\n                ans2 = x;\\n            }\\n            m[x[1]] = x[0];\\n        }\\n        if(!indegtwo)return detectCycle(edges,f);\\n        if(detectCycle(edges,ans2)==f)return ans2;\\n        return ans1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DSU{\\n    public:\\n    vector<int>p;\\n    DSU(int n){\\n        p.resize(n,-1);\\n        for(int i=0;i<n;i++){\\n            make_set(i);\\n        }\\n    }\\n    int find(int a){\\n        if(p[a]==a)return a;\\n        p[a] = find(p[a]);\\n        return p[a];\\n    }\\n    void union_set(int a,int b){\\n        a = find(a);\\n        b = find(b);\\n        if(a==b)return;\\n        p[b] = a;\\n    }\\n    void make_set(int a){\\n        p[a] = a;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> detectCycle(vector<vector<int>>& edges,vector<int>&e){\\n        int n = edges.size();\\n        DSU *dsu = new DSU(n+1);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]==e)continue;\\n            int a = edges[i][0],b = edges[i][1];\\n            if(dsu->find(a)==dsu->find(b))return edges[i];\\n            dsu->union_set(a,b);\\n        }\\n        return {0,0};\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int>indegree(n+1,0);\\n        bool indegtwo = false;\\n        unordered_map<int,int>m;\\n        vector<int>ans1,ans2;\\n        vector<int>f={0,0};\\n        for(auto x:edges){\\n            indegree[x[1]]++;\\n            if(indegree[x[1]]==2){\\n                indegtwo=true;\\n                ans1 = {m[x[1]],x[1]};\\n                ans2 = x;\\n            }\\n            m[x[1]] = x[0];\\n        }\\n        if(!indegtwo)return detectCycle(edges,f);\\n        if(detectCycle(edges,ans2)==f)return ans2;\\n        return ans1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235400,
                "title": "4ms-runtime-faster-than-99-c-submissions-dsu-and-indegree-approach",
                "content": "Upvote if helpful :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> edge;\\n    int find(vector<int>& parent, int x){\\n        if(x==parent[x])\\n            return x;\\n        int temp = find(parent,parent[x]);\\n        parent[x] = temp;\\n        return temp;\\n    }\\n    \\n    void merge(vector<int>& parent,vector<int>& rank, int x, int y){\\n        int parx = find(parent,x);\\n        int pary = find(parent,y);\\n        \\n        if(rank[parx]>rank[pary])\\n            parent[pary] = parx;\\n        else if(rank[parx]<rank[pary])\\n            parent[parx] = pary;\\n        else{\\n            parent[parx] = pary;\\n            rank[parx]++;\\n        }\\n    }\\n    \\n    bool checkDSU(vector<vector<int>>& edges, int n, vector<int>& blacklist){\\n        vector<int> parent(n+1);\\n        for(int i=0;i<n+1;i++){\\n            parent[i] = i;\\n        }\\n        vector<int> rank(n+1,1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(blacklist.size()>0 && edges[i]==blacklist)\\n                continue;\\n            \\n            if(find(parent,edges[i][0]) == find(parent,edges[i][1])){\\n                edge = edges[i];\\n                return true;\\n            }\\n            else\\n                merge(parent,rank,edges[i][0],edges[i][1]);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> indegree(n+1,-1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(indegree[edges[i][1]]!=-1){\\n                vector<int> blacklist = edges[i];\\n                if(checkDSU(edges,n,blacklist))\\n                    return edges[indegree[edges[i][1]]];\\n                else\\n                    return blacklist;\\n            }else{\\n                indegree[edges[i][1]] = i;\\n            }\\n        }\\n        \\n        vector<int> noblacklist;\\n        checkDSU(edges,n,noblacklist);\\n        return edge;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8642e9e6-7e34-4e21-a898-44d4b3d5980e_1622177078.3417857.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> edge;\\n    int find(vector<int>& parent, int x){\\n        if(x==parent[x])\\n            return x;\\n        int temp = find(parent,parent[x]);\\n        parent[x] = temp;\\n        return temp;\\n    }\\n    \\n    void merge(vector<int>& parent,vector<int>& rank, int x, int y){\\n        int parx = find(parent,x);\\n        int pary = find(parent,y);\\n        \\n        if(rank[parx]>rank[pary])\\n            parent[pary] = parx;\\n        else if(rank[parx]<rank[pary])\\n            parent[parx] = pary;\\n        else{\\n            parent[parx] = pary;\\n            rank[parx]++;\\n        }\\n    }\\n    \\n    bool checkDSU(vector<vector<int>>& edges, int n, vector<int>& blacklist){\\n        vector<int> parent(n+1);\\n        for(int i=0;i<n+1;i++){\\n            parent[i] = i;\\n        }\\n        vector<int> rank(n+1,1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(blacklist.size()>0 && edges[i]==blacklist)\\n                continue;\\n            \\n            if(find(parent,edges[i][0]) == find(parent,edges[i][1])){\\n                edge = edges[i];\\n                return true;\\n            }\\n            else\\n                merge(parent,rank,edges[i][0],edges[i][1]);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> indegree(n+1,-1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(indegree[edges[i][1]]!=-1){\\n                vector<int> blacklist = edges[i];\\n                if(checkDSU(edges,n,blacklist))\\n                    return edges[indegree[edges[i][1]]];\\n                else\\n                    return blacklist;\\n            }else{\\n                indegree[edges[i][1]] = i;\\n            }\\n        }\\n        \\n        vector<int> noblacklist;\\n        checkDSU(edges,n,noblacklist);\\n        return edge;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562660,
                "title": "python-solution-with-clearn-explanation-with-graph",
                "content": "There are three situations need to be considered. \\n\\n1. A node has two parent and no loop in graph\\n2. No node has two parent and there is a loop in graph\\n3. A node has two parent and there is a loop in graph\\n\\nAs the image \\n![image](https://assets.leetcode.com/users/jqmhpj/image_1585978745.png)\\n\\nAs the graph we will find\\n\\nsituation 1:\\nFind the node which has tow parents\\nReturn the edge between current node and the second parent\\n\\nsituation 2:\\nThe question become Redundant Connection I,  \\nReturn the edge lead loop\\n\\nsituation 3:\\nAs there is a node has two parents and there is a loop in graph, we need find which edges both in loop and is one of the two parents.\\nrenturn the edge in loop and is the parent of doubleParentNode\\n\\nFor this step,I create a new graph by deleting the second parent and check there is a loop or not. If there is no loop in new graph, we return second edge, else return first edge.\\n\\nCoding:\\nNow we need check is a node has two parents ? \\nusing dictionary\\n\\nIs there is a loop ?\\nA: using union-find to check \\n\\n\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\t\\n        unionList = list(range(len(edges)+1))\\n        \\n        def find(x):\\n            if x == unionList[x]:\\n                return x\\n            return find(unionList[x])\\n        \\n        def union(x,y):\\n            if find(x) != find(y):\\n                unionList[x] = y\\n         \\n\\t\\t#check and saving the last edge in loop\\n        loop = None\\n\\t\\t\\n\\t\\t#check parent\\n        parent = {}\\n        for i,j in edges:\\n            parent.setdefault(j,[]).append(i)\\n            if find(i) == find(j):\\n                loop = [i,j]\\n            union(i,j)\\n\\t\\t\\t\\n\\t\\t\\n\\t\\t#get the node which has more than one parent\\n\\t\\tdoubleParent = [i for i in parent if len(parent[i]) > 1]\\n        hasDoubleParent = len(doubleParent)\\n\\t\\t\\n        #which situation we are? \\n        if not hasDoubleParent and loop:\\n            return loop\\n\\t\\t\\t# simple,return the edge in loop\\n        elif hasDoubleParent and not loop:\\n            return [parent[doubleParent[0]][1],doubleParent[0]]\\n\\t\\t\\t# easy, return the edge between node with second parent\\n\\t\\telse:\\n\\t\\t\\t# get first edge and second edge(one of them should be removed)\\n\\t\\t\\tfirstEdge = [parent[doubleParent[0]][0],doubleParent[0]]\\n            secondEdge = [parent[doubleParent[0]][1],doubleParent[0]]\\n\\t\\t\\t\\n\\t\\t\\t#remove second edge and check there is a loop or not\\n            deleteSecondEdge = edges[:]\\n            deleteSecondEdge.remove(secondEdge)\\n            unionList = list(range(len(edges)+1))\\n            \\n\\t\\t\\t\\n            for i,j in deleteSecondEdge:\\n                if find(i) == find(j):\\n\\t\\t\\t\\t# opps,there is still a loop, we should remove first edge, so return it \\n                    return firstEdge\\n                union(i,j)\\n\\t\\t\\t# seems like remove second edge works.\\n            return secondEdge\\n",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "class Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\t\\n        unionList = list(range(len(edges)+1))\\n        \\n        def find(x):\\n            if x == unionList[x]:\\n                return x\\n            return find(unionList[x])\\n        \\n        def union(x,y):\\n            if find(x) != find(y):\\n                unionList[x] = y\\n         \\n\\t\\t#check and saving the last edge in loop\\n        loop = None\\n\\t\\t\\n\\t\\t#check parent\\n        parent = {}",
                "codeTag": "Java"
            },
            {
                "id": 3152551,
                "title": "disjoint-set-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFor a directed tree(according to the question) every node has indegree 1 (except root has indegree 0).\\n        After adding an extra edge, indegree of a node will increase, and there will be an undirected cycle.\\n\\n    case1: the extra edge falls on root\\n        After this case all nodes will have indegree 1\\n        For any edge <e> in the undirected cycle, if we remove that edge e, then\\n        the remaining edges will still form a directed tree rooted at e.target\\n\\n    case2: the extra edge falls on non-root node\\n        After this case one node(say <u>) will have indegree 2.\\n        Now there are two edges <e1> and <e2> which falls on <u>.       \\n        Atleast  of them must be on the undirected cycle.\\n        If only one edge is on the directed cycle, then that edge is the answer.\\n        Otherwise, if both the edges are on the directed cycle, then removing any of them will \\n        convert the graph to directed tree. so any of them can be answer.      \\n        \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        ====================================================\\n                        Pseudo Algorithm:\\n        ====================================================\\n        1. Count the indegress of all ndoes\\n        2. if no node has indegree 2 (i.e, all nodes have indegree 1)\\n        3.      find an edge, adding which creates cycle --> it is the answer (dynamic connectivity)\\n        4. else\\n        5.      find the 2 edges e1 and e2 for which the \"to\"/\"incident\" node has indegree 2 (e2 is after e1 in the list here)\\n        6.      if e2 is on undirected cycle (determine by dynamically adding edges except e2, then add e2 at last and check\\n                                                                            --> similar to dynamic connectivity using disjoint set)\\n        7.          e2 is the answer here\\n        8.      else //e1 must be in undirected cycle if e2 is not in\\n        9.          e1 is the answer \\n# Complexity\\n- Time complexity:  O(E), E = no of edges,   \\nConsidering union and find operations take almost constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n), n = no of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\n    int *parent;\\n    int *treeSize;\\n    int n;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        this->n = n;\\n        parent = new int[n];\\n        treeSize = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n            treeSize[i] = 1;\\n        }\\n    }\\n\\n    //*returns root of the tree containing x (returns the identifier of the set containing x)\\n    //*Path compression: make the root of the tree parent of all nodes in the path from root to x\\n\\n    int find(int x)\\n    {\\n        // doesnt exist\\n        if (x < 0 || x >= this->n)\\n            return -1;\\n\\n        if (x == parent[x])\\n            return x;\\n\\n        int root = find(parent[x]);\\n\\n        //*for path compression: make the root of the tree parent of x\\n        parent[x] = root;\\n\\n        return root;\\n    }\\n\\n    bool connected(int x, int y)\\n    {\\n        return find(x) == find(y);\\n    }\\n\\n    void doUnion(int x, int y)\\n    {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (this->treeSize[root1] <= this->treeSize[root2])\\n        {\\n            parent[root1] = root2;\\n            this->treeSize[root2] += this->treeSize[root1];\\n        }\\n        else\\n        {\\n            parent[root2] = root1;\\n            this->treeSize[root1] += this->treeSize[root2];\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\n        /*\\n        Intuition: \\n        For a directed tree(according to the question) every node has indegree 1 (except root has indegree 0).\\n        After adding an extra edge, indegree of a node will increase, and there will be an undirected cycle.\\n\\n        case1: the extra edge falls on root\\n            After this case all nodes will have indegree 1\\n            For any edge <e> in the undirected cycle, if we remove that edge e, then\\n            the remaining edges will still form a directed tree rooted at e.target\\n\\n        case2: the extra edge falls on non-root node\\n            After this case one node(say <u>) will have indegree 2\\n            Now there are two edges <e1> and <e2> which falls on <u>. Atleast one of them must be on the undirected cycle.\\n            If only one edge is on the directed cycle, then that edge is the answer.\\n            Otherwise, if both the edges are on the directed cycle, then removing any of them\\n                 will convert the graph to directed tree. so any of them can be answer.      \\n        \\n\\n\\n\\n        ====================================================\\n                        Pseudo Algorithm:\\n        ====================================================\\n        1. Count the indegress of all ndoes\\n        2. if no node has indegree 2 (i.e, all nodes have indegree 1)\\n        3.      find an edge, adding which creates cycle --> it is the answer (dynamic connectivity)\\n        4. else\\n        5.      find the 2 edges e1 and e2 for which the \"to\"/\"incident\" node has indegree 2 (e2 is after e1 in the list here)\\n        6.      if e2 is on undirected cycle (determine by dynamically adding edges except e2, then add e2 at last and check\\n                                                                            --> similar to dynamic connectivity using disjoint set)\\n        7.          e2 is the answer here\\n        8.      else //e1 must be in undirected cycle if e2 is not in\\n        9.          e1 is the answer    \\n\\n        */\\n\\n        int n = 0;\\n        for(const auto &e : edges)\\n        {\\n            n = max(n, e[0]);\\n            n = max(n, e[1]);\\n        }    \\n        DisjointSet ds(n);\\n        \\n        vector<int> indeg(n, 0);\\n        int maxIndeg = 0;\\n        for(const auto &e: edges)\\n        {\\n            int v = e[1] - 1;\\n\\n            indeg[v]++;\\n            maxIndeg = max(maxIndeg, indeg[v]);\\n        }\\n\\n\\n\\n        //CASE1: \\n        if(maxIndeg == 1)\\n        {\\n            vector<int> res = {-1,-1};\\n\\n            //find the last edge in the list that causes bicycle in the dynamically growing graph\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(ds.connected(u, v))\\n                    res = {u+1, v+1};\\n\\n                ds.doUnion(u, v);    \\n            }\\n\\n            return res;\\n        }\\n        //CASE2:\\n        else\\n        {\\n            //let e1 and e2 be the 2 edges which have incident node with indegree == 2\\n            //let e2 be after e1 in the given list\\n            vector<int> e1 = {-1, -1};\\n            vector<int> e2 = {-1, -1};\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(indeg[v] == 2)\\n                {\\n                    if(e1 == vector<int>({-1,-1}) )\\n                        e1 = {u,v};\\n                    else\\n                        e2 = {u,v};    \\n                }\\n            }\\n\\n\\n            \\n            //now check if e2 causes bicycle in the graph\\n\\n            //add all edges in a graph except e2\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(e2 != vector<int>({u,v}) )\\n                    ds.doUnion(u, v);\\n            } \\n\\n            //now check if adding the edge e2 causes bicycle or not\\n            if(ds.connected(e2[0], e2[1]))\\n                return {e2[0] + 1, e2[1] + 1};\\n            else\\n                return {e1[0] + 1, e1[1] + 1};     \\n\\n        }\\n\\n    }\\n};\\n\\n\\n\\n\\n/*\\n[[2,1],[3,1],[4,2],[1,4]]\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet\\n{\\n    int *parent;\\n    int *treeSize;\\n    int n;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        this->n = n;\\n        parent = new int[n];\\n        treeSize = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n            treeSize[i] = 1;\\n        }\\n    }\\n\\n    //*returns root of the tree containing x (returns the identifier of the set containing x)\\n    //*Path compression: make the root of the tree parent of all nodes in the path from root to x\\n\\n    int find(int x)\\n    {\\n        // doesnt exist\\n        if (x < 0 || x >= this->n)\\n            return -1;\\n\\n        if (x == parent[x])\\n            return x;\\n\\n        int root = find(parent[x]);\\n\\n        //*for path compression: make the root of the tree parent of x\\n        parent[x] = root;\\n\\n        return root;\\n    }\\n\\n    bool connected(int x, int y)\\n    {\\n        return find(x) == find(y);\\n    }\\n\\n    void doUnion(int x, int y)\\n    {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (this->treeSize[root1] <= this->treeSize[root2])\\n        {\\n            parent[root1] = root2;\\n            this->treeSize[root2] += this->treeSize[root1];\\n        }\\n        else\\n        {\\n            parent[root2] = root1;\\n            this->treeSize[root1] += this->treeSize[root2];\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\n        /*\\n        Intuition: \\n        For a directed tree(according to the question) every node has indegree 1 (except root has indegree 0).\\n        After adding an extra edge, indegree of a node will increase, and there will be an undirected cycle.\\n\\n        case1: the extra edge falls on root\\n            After this case all nodes will have indegree 1\\n            For any edge <e> in the undirected cycle, if we remove that edge e, then\\n            the remaining edges will still form a directed tree rooted at e.target\\n\\n        case2: the extra edge falls on non-root node\\n            After this case one node(say <u>) will have indegree 2\\n            Now there are two edges <e1> and <e2> which falls on <u>. Atleast one of them must be on the undirected cycle.\\n            If only one edge is on the directed cycle, then that edge is the answer.\\n            Otherwise, if both the edges are on the directed cycle, then removing any of them\\n                 will convert the graph to directed tree. so any of them can be answer.      \\n        \\n\\n\\n\\n        ====================================================\\n                        Pseudo Algorithm:\\n        ====================================================\\n        1. Count the indegress of all ndoes\\n        2. if no node has indegree 2 (i.e, all nodes have indegree 1)\\n        3.      find an edge, adding which creates cycle --> it is the answer (dynamic connectivity)\\n        4. else\\n        5.      find the 2 edges e1 and e2 for which the \"to\"/\"incident\" node has indegree 2 (e2 is after e1 in the list here)\\n        6.      if e2 is on undirected cycle (determine by dynamically adding edges except e2, then add e2 at last and check\\n                                                                            --> similar to dynamic connectivity using disjoint set)\\n        7.          e2 is the answer here\\n        8.      else //e1 must be in undirected cycle if e2 is not in\\n        9.          e1 is the answer    \\n\\n        */\\n\\n        int n = 0;\\n        for(const auto &e : edges)\\n        {\\n            n = max(n, e[0]);\\n            n = max(n, e[1]);\\n        }    \\n        DisjointSet ds(n);\\n        \\n        vector<int> indeg(n, 0);\\n        int maxIndeg = 0;\\n        for(const auto &e: edges)\\n        {\\n            int v = e[1] - 1;\\n\\n            indeg[v]++;\\n            maxIndeg = max(maxIndeg, indeg[v]);\\n        }\\n\\n\\n\\n        //CASE1: \\n        if(maxIndeg == 1)\\n        {\\n            vector<int> res = {-1,-1};\\n\\n            //find the last edge in the list that causes bicycle in the dynamically growing graph\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(ds.connected(u, v))\\n                    res = {u+1, v+1};\\n\\n                ds.doUnion(u, v);    \\n            }\\n\\n            return res;\\n        }\\n        //CASE2:\\n        else\\n        {\\n            //let e1 and e2 be the 2 edges which have incident node with indegree == 2\\n            //let e2 be after e1 in the given list\\n            vector<int> e1 = {-1, -1};\\n            vector<int> e2 = {-1, -1};\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(indeg[v] == 2)\\n                {\\n                    if(e1 == vector<int>({-1,-1}) )\\n                        e1 = {u,v};\\n                    else\\n                        e2 = {u,v};    \\n                }\\n            }\\n\\n\\n            \\n            //now check if e2 causes bicycle in the graph\\n\\n            //add all edges in a graph except e2\\n            for(const auto &e : edges)\\n            {\\n                int u = e[0] - 1;\\n                int v = e[1] - 1;\\n\\n                if(e2 != vector<int>({u,v}) )\\n                    ds.doUnion(u, v);\\n            } \\n\\n            //now check if adding the edge e2 causes bicycle or not\\n            if(ds.connected(e2[0], e2[1]))\\n                return {e2[0] + 1, e2[1] + 1};\\n            else\\n                return {e1[0] + 1, e1[1] + 1};     \\n\\n        }\\n\\n    }\\n};\\n\\n\\n\\n\\n/*\\n[[2,1],[3,1],[4,2],[1,4]]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082732,
                "title": "simple-dfs-c-solution-don-t-have-to-struggle-with-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool fun(int node,int &n,vector<int>&vis,vector<vector<int>>&g, int s, int e){\\n        vis[node]=1;n--;\\n        if(n==0) return 1; // Indicates all nodes are visited\\n        for(auto a:g[node]){\\n            if(node==s&&a==e)continue;         \\n            if(vis[a]==0&&fun(a,n,vis,g,s,e)) return 1;\\n        }    \\n        return 0;\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        int n=e.size();\\n        vector<int>in(n+1);  // Indegree vector is used to find root node\\n\\t\\tvector<vector<int>>g(n+1);\\n       for(auto a:e){\\n           in[a[1]]++; g[a[0]].push_back(a[1]);\\n       }\\n        vector<int>vis(n+1); // used to escape from infinate loops if graph has cycle\\n        for(int k=e.size()-1;k>=0;k--){ // Travel from last edge\\n            in[e[k][1]]--;; // removing  edge\\n            for(int i=1;i<=n;i++){\\n                int p=n; \\n                if(in[i]==0) { // checking for root node which has indegree 0\\n                  int b=fun(i,p,vis,g,e[k][0],e[k][1]);               \\n                    if(b==1) return e[k];\\n                   for(int j=1;j<=n;j++)vis[j]=0;\\n                    break; // breaking because only one root exist\\n                }               \\n            }\\n            in[e[k][1]]++;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fun(int node,int &n,vector<int>&vis,vector<vector<int>>&g, int s, int e){\\n        vis[node]=1;n--;\\n        if(n==0) return 1; // Indicates all nodes are visited\\n        for(auto a:g[node]){\\n            if(node==s&&a==e)continue;         \\n            if(vis[a]==0&&fun(a,n,vis,g,s,e)) return 1;\\n        }    \\n        return 0;\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        int n=e.size();\\n        vector<int>in(n+1);  // Indegree vector is used to find root node\\n\\t\\tvector<vector<int>>g(n+1);\\n       for(auto a:e){\\n           in[a[1]]++; g[a[0]].push_back(a[1]);\\n       }\\n        vector<int>vis(n+1); // used to escape from infinate loops if graph has cycle\\n        for(int k=e.size()-1;k>=0;k--){ // Travel from last edge\\n            in[e[k][1]]--;; // removing  edge\\n            for(int i=1;i<=n;i++){\\n                int p=n; \\n                if(in[i]==0) { // checking for root node which has indegree 0\\n                  int b=fun(i,p,vis,g,e[k][0],e[k][1]);               \\n                    if(b==1) return e[k];\\n                   for(int j=1;j<=n;j++)vis[j]=0;\\n                    break; // breaking because only one root exist\\n                }               \\n            }\\n            in[e[k][1]]++;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042716,
                "title": "easy-c-solution-union-find-method",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> parent, sz;\\n\\n    int find_set(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find_set(parent[x]);\\n    }\\n\\n    bool make_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a == b) return true;\\n        if(sz[a] < sz[b]) swap(a, b);\\n        parent[b] = a;\\n        sz[a] += sz[b];\\n        return false;\\n    }\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>> &edges)\\n    {\\n        int n = edges.size();\\n        parent.resize(n+1);\\n        sz.resize(n+1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n\\n        vector<int> indeg(n+1, -1);\\n        int b1 = -1, b2 = -1;\\n        for(int i = 0; i<edges.size(); i++){\\n            if(indeg[edges[i][1]] == -1){\\n                indeg[edges[i][1]] = i;\\n            }\\n            else{\\n                b1 = i;\\n                b2 = indeg[edges[i][1]]; \\n                break;\\n            }\\n        }\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            if(i == b1) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(make_union(u, v)){\\n                if(b1 == -1) return {u, v};\\n                else return {edges[b2][0], edges[b2][1]};\\n            }\\n        }\\n        return {edges[b1][0], edges[b1][1]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> parent, sz;\\n\\n    int find_set(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find_set(parent[x]);\\n    }\\n\\n    bool make_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a == b) return true;\\n        if(sz[a] < sz[b]) swap(a, b);\\n        parent[b] = a;\\n        sz[a] += sz[b];\\n        return false;\\n    }\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>> &edges)\\n    {\\n        int n = edges.size();\\n        parent.resize(n+1);\\n        sz.resize(n+1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n\\n        vector<int> indeg(n+1, -1);\\n        int b1 = -1, b2 = -1;\\n        for(int i = 0; i<edges.size(); i++){\\n            if(indeg[edges[i][1]] == -1){\\n                indeg[edges[i][1]] = i;\\n            }\\n            else{\\n                b1 = i;\\n                b2 = indeg[edges[i][1]]; \\n                break;\\n            }\\n        }\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            if(i == b1) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(make_union(u, v)){\\n                if(b1 == -1) return {u, v};\\n                else return {edges[b2][0], edges[b2][1]};\\n            }\\n        }\\n        return {edges[b1][0], edges[b1][1]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831901,
                "title": "c-union-find-beats-92",
                "content": "First, count the indegree of each node, there\\'re 2 cases:\\n\\n(1) There exists one `node` whose indegree is 2.\\nIn this case, the deleted edge must be one of the two edges connected to `node` because a tree won\\'t have a node with indegree 2. Try both edges using union find, if `edge[i][0]` and `edge[i][1]` already has the same root, this edge can be deleted.\\n\\n(2) All edges have indegree 1, there exists a circle.\\nIn this case, use union find to find the first edge that leads to a circle. Since the deleted edge must be one of the edges in the circle, this edge is exactly the last edge in the circle, which is the answer.\\n\\n```\\nclass Solution {\\n    vector<int> pre;\\n    int find(int root) { // union find with path compression\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int N = edges.size();\\n        pre.resize(N+1);\\n        for (int i = 0; i < N+1; i++) {\\n            pre[i] = i;\\n        }\\n        vector<int> indegrees(N+1, 0);\\n        int node = -1;\\n        for (int i = 0; i < N; i++) {\\n            indegrees[edges[i][1]] += 1;\\n            if (indegrees[edges[i][1]] == 2) {\\n                node = edges[i][1];\\n                break;\\n            }\\n        }\\n        int a = -1, b = -1;\\n        if (node != -1) { // there is a node with indegree = 2\\n            for (auto e : edges) {\\n                if (e[1] != node) pre[find(e[0])] = find(e[1]);\\n                else if (a == -1) a = e[0];\\n                else b = e[0];\\n            }\\n            if (find(a) == find(node)) return {a, node};\\n            else return {b, node};\\n        }\\n        else { // circle\\n            for (auto e : edges) {\\n                if (find(e[0]) != find(e[1])) pre[find(e[0])] = find(e[1]);\\n                else return {e[0], e[1]};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> pre;\\n    int find(int root) { // union find with path compression\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int N = edges.size();\\n        pre.resize(N+1);\\n        for (int i = 0; i < N+1; i++) {\\n            pre[i] = i;\\n        }\\n        vector<int> indegrees(N+1, 0);\\n        int node = -1;\\n        for (int i = 0; i < N; i++) {\\n            indegrees[edges[i][1]] += 1;\\n            if (indegrees[edges[i][1]] == 2) {\\n                node = edges[i][1];\\n                break;\\n            }\\n        }\\n        int a = -1, b = -1;\\n        if (node != -1) { // there is a node with indegree = 2\\n            for (auto e : edges) {\\n                if (e[1] != node) pre[find(e[0])] = find(e[1]);\\n                else if (a == -1) a = e[0];\\n                else b = e[0];\\n            }\\n            if (find(a) == find(node)) return {a, node};\\n            else return {b, node};\\n        }\\n        else { // circle\\n            for (auto e : edges) {\\n                if (find(e[0]) != find(e[1])) pre[find(e[0])] = find(e[1]);\\n                else return {e[0], e[1]};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540408,
                "title": "java-clean-code-analysis-comments",
                "content": "**Code**\\n\\t\\n```java\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\tint n = edges.length;\\n\\n\\t/* When a node has 2 incoming edges, then one of those \\n\\tedges is redundant */\\n\\tint[] indegree = new int[n + 1];\\n\\tint found = -1;\\n\\tfor (int[] edge : edges) {\\n\\t\\tindegree[edge[1]]++;\\n\\t\\tif (indegree[edge[1]] == 2) {\\n\\t\\t\\tfound = edge[1];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t/**\\n\\t\\tIf no node with multiple parent, then look for cycles\\n\\t**/\\n\\tif (found == -1)\\n\\t\\treturn detectCycle(edges, new int[2]);\\n\\n\\t/**\\n\\t\\tWhen both happens, which means cycle and multiple parents both exist\\n\\t**/\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tif (edges[i][1] == found) {\\n\\t\\t\\tint[] redundant = detectCycle(edges, edges[i]);\\n\\t\\t\\t// No cycle found if I skip the current edge\\n\\t\\t\\tif (redundant == null) \\n\\t\\t\\t\\treturn edges[i];\\n\\t\\t}\\n\\t}\\n\\treturn new int[0];\\n}\\n\\nprivate int[] detectCycle(int[][] edges, int[] skip) {\\n\\tUnionFind uf = new UnionFind(edges.length);\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] == skip[0] && edge[1] == skip[1]) continue;\\n\\t\\tif (!uf.union(edge[0], edge[1])) return edge;\\n\\t}\\n\\treturn null;\\n}\\n\\nclass UnionFind {\\n\\tint[] parent;\\n\\tint[] rank;\\n\\tUnionFind(int n) {\\n\\t\\tparent = new int[n + 1];\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tparent[i] = i;\\n\\t\\trank = new int[n + 1];\\n\\t}\\n\\tint find(int a) {\\n\\t\\tif (parent[a] != a)\\n\\t\\t\\tparent[a] = find(parent[a]);\\n\\t\\treturn parent[a];\\n\\t}\\n\\tboolean union(int a, int b) {\\n\\t\\tint p1 = find(a);\\n\\t\\tint p2 = find(b);\\n\\t\\tif (p1 == p2) return false;\\n\\t\\tif (rank[p1] > rank[p2]) {\\n\\t\\t\\trank[p1]++;\\n\\t\\t\\tparent[p2] = p1;\\n\\t\\t} else {\\n\\t\\t\\trank[p2]++;\\n\\t\\t\\tparent[p1] = p2;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n\\n**Anaylsis**\\nTime complexity : O(n log * n) -> O(n)\\nSpace complexity : O(n)",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```java\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\tint n = edges.length;\\n\\n\\t/* When a node has 2 incoming edges, then one of those \\n\\tedges is redundant */\\n\\tint[] indegree = new int[n + 1];\\n\\tint found = -1;\\n\\tfor (int[] edge : edges) {\\n\\t\\tindegree[edge[1]]++;\\n\\t\\tif (indegree[edge[1]] == 2) {\\n\\t\\t\\tfound = edge[1];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t/**\\n\\t\\tIf no node with multiple parent, then look for cycles\\n\\t**/\\n\\tif (found == -1)\\n\\t\\treturn detectCycle(edges, new int[2]);\\n\\n\\t/**\\n\\t\\tWhen both happens, which means cycle and multiple parents both exist\\n\\t**/\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tif (edges[i][1] == found) {\\n\\t\\t\\tint[] redundant = detectCycle(edges, edges[i]);\\n\\t\\t\\t// No cycle found if I skip the current edge\\n\\t\\t\\tif (redundant == null) \\n\\t\\t\\t\\treturn edges[i];\\n\\t\\t}\\n\\t}\\n\\treturn new int[0];\\n}\\n\\nprivate int[] detectCycle(int[][] edges, int[] skip) {\\n\\tUnionFind uf = new UnionFind(edges.length);\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] == skip[0] && edge[1] == skip[1]) continue;\\n\\t\\tif (!uf.union(edge[0], edge[1])) return edge;\\n\\t}\\n\\treturn null;\\n}\\n\\nclass UnionFind {\\n\\tint[] parent;\\n\\tint[] rank;\\n\\tUnionFind(int n) {\\n\\t\\tparent = new int[n + 1];\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tparent[i] = i;\\n\\t\\trank = new int[n + 1];\\n\\t}\\n\\tint find(int a) {\\n\\t\\tif (parent[a] != a)\\n\\t\\t\\tparent[a] = find(parent[a]);\\n\\t\\treturn parent[a];\\n\\t}\\n\\tboolean union(int a, int b) {\\n\\t\\tint p1 = find(a);\\n\\t\\tint p2 = find(b);\\n\\t\\tif (p1 == p2) return false;\\n\\t\\tif (rank[p1] > rank[p2]) {\\n\\t\\t\\trank[p1]++;\\n\\t\\t\\tparent[p2] = p1;\\n\\t\\t} else {\\n\\t\\t\\trank[p2]++;\\n\\t\\t\\tparent[p1] = p2;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689003,
                "title": "java-disjoint-set-solution-using-indegree",
                "content": "As we cannot directly use dsu to directed graph. \\n![image](https://assets.leetcode.com/users/images/056a4c77-e117-4489-87b4-1f332ab7d883_1642141660.2313592.png)\\nSo there are total three possible ways by which the tree is destroyed.\\n1. When a node has two parent\\n2. When there in cycle present in graph\\n3. When both cycle is present and node has two parent.\\nDsu can not be used for directed graph but if we know that there is definately cycle present in graph so we can detect that edge. In this way we can solve case-2.\\nCase 1 and 3 are similar node has two parent . To know which node has two parent we find indegree of all nodes and when two parent are present we blacklist both edges . We name them bl1 second edge and bl2 first edge. Now we apply dsu and does not consider bl1 and even after that cylce is present then bl2 should be removed(**This is case 3** ) and after removing bl1 if cycle is not present then bl1 should be removed.(**This is case 1** ).\\nWe can do this in one dsu application.\\nFind indegree of all nodes and mark bl1 and bl2 if necessary.\\nNow run dsu and if bl1 is present skip that edge. And even after cycle is present then check if bl1 is present or not . If not then that edge itself is answer. And if bl1 is present then bl2 is answer becasue we did not considered bl1 and after that we found cycle means bl2 is making cycle. And if cycle is not present means after removing bl1 cycle vanishes means bl1 is answer.\\n\\n\\n\\n```\\nclass Solution {\\n    int []par;\\n    int []rank;\\n    public int[] findRedundantDirectedConnection(int[][] arr) {\\n        int n=arr.length;\\n        int []deg=new int[n+1];\\n        par=new int[n+1];\\n        rank=new int[n+1];\\n        Arrays.fill(par,-1);\\n        Arrays.fill(deg,-1);\\n        \\n        int bl1=-1;\\n        int bl2=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(deg[arr[i][1]]==-1)\\n                deg[arr[i][1]]=i;\\n            else{\\n                bl1=i;\\n                bl2=deg[arr[i][1]];\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i==bl1)continue;\\n            \\n            int to=arr[i][0];\\n            int from=arr[i][1];\\n            boolean flag=union(to,from);\\n            if(flag){\\n                if(bl1==-1){\\n                    return arr[i];\\n                }\\n                else{\\n                    return arr[bl2];\\n                }\\n            }\\n        }\\n        return arr[bl1];\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(par[node]==-1)return node;\\n        return par[node]=find(par[node]);\\n    }\\n    public boolean union(int to,int from){\\n        int toP=find(to);\\n        int fromP=find(from);\\n        \\n        if(toP==fromP)return true;\\n        \\n        if(rank[toP]>rank[fromP]){\\n            par[fromP]=toP;\\n        }\\n        else if(rank[toP]<rank[fromP]){\\n            par[toP]=fromP;\\n        }\\n        else{\\n            par[fromP]=toP;\\n            rank[toP]++;\\n        }\\n        return false;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int []par;\\n    int []rank;\\n    public int[] findRedundantDirectedConnection(int[][] arr) {\\n        int n=arr.length;\\n        int []deg=new int[n+1];\\n        par=new int[n+1];\\n        rank=new int[n+1];\\n        Arrays.fill(par,-1);\\n        Arrays.fill(deg,-1);\\n        \\n        int bl1=-1;\\n        int bl2=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(deg[arr[i][1]]==-1)\\n                deg[arr[i][1]]=i;\\n            else{\\n                bl1=i;\\n                bl2=deg[arr[i][1]];\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i==bl1)continue;\\n            \\n            int to=arr[i][0];\\n            int from=arr[i][1];\\n            boolean flag=union(to,from);\\n            if(flag){\\n                if(bl1==-1){\\n                    return arr[i];\\n                }\\n                else{\\n                    return arr[bl2];\\n                }\\n            }\\n        }\\n        return arr[bl1];\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(par[node]==-1)return node;\\n        return par[node]=find(par[node]);\\n    }\\n    public boolean union(int to,int from){\\n        int toP=find(to);\\n        int fromP=find(from);\\n        \\n        if(toP==fromP)return true;\\n        \\n        if(rank[toP]>rank[fromP]){\\n            par[fromP]=toP;\\n        }\\n        else if(rank[toP]<rank[fromP]){\\n            par[toP]=fromP;\\n        }\\n        else{\\n            par[fromP]=toP;\\n            rank[toP]++;\\n        }\\n        return false;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529428,
                "title": "simple-union-find-solution-with-simple-logic-c",
                "content": "Please upvote if u liked it\\n\\n\\n```\\nclass Solution {\\npublic:\\n    class unionfind{\\n        int *parent;\\n        int *size;\\n        public:\\n        unionfind(int n){\\n            parent= new int[n+1];\\n            size= new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n        int find(int a){\\n            if(a!=parent[a]){\\n                parent[a]=find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        bool unionop(int a,int b){\\n            int x=find(a);\\n            int y=find(b);\\n            if(x==y){\\n                return false;\\n            }\\n            if(size[x]>size[y]){\\n                parent[y]=x;\\n                size[x]+=size[y];\\n            }else{\\n                parent[x]=y;\\n                size[y]+=size[x];\\n            }\\n            return true;\\n        }\\n    };\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        unionfind ob(n);\\n        int bl1=-1;\\n        int bl2=-1;\\n        vector<int>indegree(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            if(indegree[v]==-1){\\n                indegree[v]=i;\\n            }else{\\n                bl1=i;\\n                bl2=indegree[v];\\n                break;\\n            }\\n        }\\n        //  Now traversing again to check which case it is\\n        //so we traverse again and we would skip previous potential expected answer\\n        //we check if cycle is still present that means our potential answer is wrong\\n        //so our answer would be second bl2;\\n        //now there may be possibility that indegree found to be -1 that means there is cycle \\n        //only so our answer would be the current indexed row \\n        //otherwise answer would be among the bl1 and bl2\\n        for(int i=0;i<n;i++){\\n            if(i==bl1){\\n                continue;\\n            }\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            bool flag=ob.unionop(u,v);\\n            if(flag==false){\\n\\t\\t\\t//case 2 -> When there is only cycle is present(All nodes have indegree 1 )\\n                if(bl1==-1){\\n                    return edges[i];\\n                }else{\\n\\t\\t\\t\\t\\t// Case 3: like there is cycle and also a single node have more than one parent and thats why its indegree is more than one\\n                    return edges[bl2];\\n                }\\n            }\\n        }\\n\\t\\t//final case that means our potential answer is our answer and after removing that there is no cycle\\n        return edges[bl1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class unionfind{\\n        int *parent;\\n        int *size;\\n        public:\\n        unionfind(int n){\\n            parent= new int[n+1];\\n            size= new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n        int find(int a){\\n            if(a!=parent[a]){\\n                parent[a]=find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        bool unionop(int a,int b){\\n            int x=find(a);\\n            int y=find(b);\\n            if(x==y){\\n                return false;\\n            }\\n            if(size[x]>size[y]){\\n                parent[y]=x;\\n                size[x]+=size[y];\\n            }else{\\n                parent[x]=y;\\n                size[y]+=size[x];\\n            }\\n            return true;\\n        }\\n    };\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        unionfind ob(n);\\n        int bl1=-1;\\n        int bl2=-1;\\n        vector<int>indegree(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            if(indegree[v]==-1){\\n                indegree[v]=i;\\n            }else{\\n                bl1=i;\\n                bl2=indegree[v];\\n                break;\\n            }\\n        }\\n        //  Now traversing again to check which case it is\\n        //so we traverse again and we would skip previous potential expected answer\\n        //we check if cycle is still present that means our potential answer is wrong\\n        //so our answer would be second bl2;\\n        //now there may be possibility that indegree found to be -1 that means there is cycle \\n        //only so our answer would be the current indexed row \\n        //otherwise answer would be among the bl1 and bl2\\n        for(int i=0;i<n;i++){\\n            if(i==bl1){\\n                continue;\\n            }\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            bool flag=ob.unionop(u,v);\\n            if(flag==false){\\n\\t\\t\\t//case 2 -> When there is only cycle is present(All nodes have indegree 1 )\\n                if(bl1==-1){\\n                    return edges[i];\\n                }else{\\n\\t\\t\\t\\t\\t// Case 3: like there is cycle and also a single node have more than one parent and thats why its indegree is more than one\\n                    return edges[bl2];\\n                }\\n            }\\n        }\\n\\t\\t//final case that means our potential answer is our answer and after removing that there is no cycle\\n        return edges[bl1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009763,
                "title": "union-find",
                "content": "Inspired by https://leetcode.com/problems/redundant-connection-ii/discuss/141897/3ms-Union-Find-with-Explanations\\n\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parent = new int[edges.length + 1];\\n                int[] candidate1 = null, candidate2 = null;\\n        for (int[] edge : edges) {\\n            int p1 = find(edge[0], parent);\\n            int p2 = find(edge[1], parent);\\n            //this edge makes a cicle\\n            if (p1 == p2) {\\n                candidate2 = edge;\\n            } else {\\n                // this edge means edge2 has more than one parents\\n                if (p2 != edge[1]) {\\n                    candidate1 = edge;\\n                } \\n                // union\\n                else {\\n                    parent[p2] = p1;\\n                }\\n            }\\n        }\\n        // the tree contains cycle, remove the edge that makes it a cycle\\n        if (candidate1 == null) {\\n            return candidate2;\\n        }\\n        \\n        // the tree has no cycle but one nodes contain two parents, remove that edge\\n        if (candidate2 == null) {\\n            return candidate1;\\n        }\\n        \\n        // the tree contains both cycle and a node that have more than two parents, remove the first edge for that node\\n        for (int[] edge: edges) {\\n            if (edge[1] == candidate1[1]) {\\n                return edge;\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public int find(int node, int[] parent) {\\n        while (parent[node] != 0) {\\n            node = parent[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parent = new int[edges.length + 1];\\n                int[] candidate1 = null, candidate2 = null;\\n        for (int[] edge : edges) {\\n            int p1 = find(edge[0], parent);\\n            int p2 = find(edge[1], parent);\\n            //this edge makes a cicle\\n            if (p1 == p2) {\\n                candidate2 = edge;\\n            } else {\\n                // this edge means edge2 has more than one parents\\n                if (p2 != edge[1]) {\\n                    candidate1 = edge;\\n                } \\n                // union\\n                else {\\n                    parent[p2] = p1;\\n                }\\n            }\\n        }\\n        // the tree contains cycle, remove the edge that makes it a cycle\\n        if (candidate1 == null) {\\n            return candidate2;\\n        }\\n        \\n        // the tree has no cycle but one nodes contain two parents, remove that edge\\n        if (candidate2 == null) {\\n            return candidate1;\\n        }\\n        \\n        // the tree contains both cycle and a node that have more than two parents, remove the first edge for that node\\n        for (int[] edge: edges) {\\n            if (edge[1] == candidate1[1]) {\\n                return edge;\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public int find(int node, int[] parent) {\\n        while (parent[node] != 0) {\\n            node = parent[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649991,
                "title": "bruteforce-dfs-solution-easy-to-understand",
                "content": "Most top answers give the theory and the cases we need to check.,,, \\nSo not repeating that again...\\n\\nHere is a simple code \\n\\n> ideg : Dictionary to keep track of in-degrees (Later realized a boolean array would have been enough)\\n> g : directed graph\\n> \\n\\nBasic idea is to remove an edge\\nFind the root, i.e node with 0 parent\\nCheck if every other node has 1 parent\\nCheck if every other node is reachable from the root, i.e the tree is connected.\\nIf everything is as perfect, return the currently removed edge\\nelse add it back and repeat till you find such an edge.\\n\\n```\\nclass Solution:    \\n    def check(self, g, ideg):\\n\\n        # if I remove this edge...\\n        # Graph should be connected...\\n        # Every edge should have 1 parent, i.e 1 ideg and \\n        # only root should have 0 \\n        # if true, nikaloooo bc (Remove the edge manh...)\\n\\n        root = None\\n        for i in ideg:\\n            if ideg[i] == 0:\\n                root = i\\n            if ideg[i] > 1:\\n                return False #the curr removed choice is wrong..\\n        if root is None:\\n            return False #curr removed choice is wrong...\\n        # dfs to see if graph is connected...\\n        vis = set()\\n        def dfs(root):\\n            vis.add(root)\\n            if root not in g:\\n                return\\n            for nei in g[root]:\\n                if nei not in vis:\\n                    dfs(nei)\\n\\n        dfs(root)\\n        if len(vis) == self.n:\\n            return True\\n        return False\\n        \\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        g = {}\\n        self.n = len(edges)\\n        ideg = {i:0 for i in range(1, self.n + 1)}\\n        for u, v in edges:\\n            g[u] = g.get(u, []) + [v]\\n            ideg[v] = 1 + ideg.get(v, 0)\\n        \\n        for u,v in edges[::-1]:\\n            g[u].remove(v)\\n            ideg[v] -= 1\\n            if self.check(g,ideg):\\n                return [u,v]\\n            g[u].append(v)\\n            ideg[v] += 1\\n        return []\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:    \\n    def check(self, g, ideg):\\n\\n        # if I remove this edge...\\n        # Graph should be connected...\\n        # Every edge should have 1 parent, i.e 1 ideg and \\n        # only root should have 0 \\n        # if true, nikaloooo bc (Remove the edge manh...)\\n\\n        root = None\\n        for i in ideg:\\n            if ideg[i] == 0:\\n                root = i\\n            if ideg[i] > 1:\\n                return False #the curr removed choice is wrong..\\n        if root is None:\\n            return False #curr removed choice is wrong...\\n        # dfs to see if graph is connected...\\n        vis = set()\\n        def dfs(root):\\n            vis.add(root)\\n            if root not in g:\\n                return\\n            for nei in g[root]:\\n                if nei not in vis:\\n                    dfs(nei)\\n\\n        dfs(root)\\n        if len(vis) == self.n:\\n            return True\\n        return False\\n        \\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        g = {}\\n        self.n = len(edges)\\n        ideg = {i:0 for i in range(1, self.n + 1)}\\n        for u, v in edges:\\n            g[u] = g.get(u, []) + [v]\\n            ideg[v] = 1 + ideg.get(v, 0)\\n        \\n        for u,v in edges[::-1]:\\n            g[u].remove(v)\\n            ideg[v] -= 1\\n            if self.check(g,ideg):\\n                return [u,v]\\n            g[u].append(v)\\n            ideg[v] += 1\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629578,
                "title": "python-o-n-clean-code-explain",
                "content": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        \\n        # In order to form a valid tree, we need to ensure that each of the node has only one parent and there are no cycle\\n        \\n        mem = dict()\\n        # find if any node has two parents\\n        A,B = [],[]\\n        for x,y in edges:\\n            if y in mem:\\n                # y has two parent\\n                A,B = [mem[y],y],[x,y] # List of edges\\n                break\\n            mem[y] = x\\n        \\n        \\n        parent = list(range(len(edges)+1))\\n        \\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x,y):\\n            px = find(x)\\n            py = find(y)\\n            parent[px] = py\\n            \\n        \\n        for x,y in edges:\\n            if [x,y] == B: # Ingnpre the edge B\\n                continue\\n            \\n            px = find(x)\\n            py = find(y)\\n            if px!=py:\\n                union(x,y)\\n                \\n            else:\\n                if A: # if A exits remove A\\n                    return A\\n                else:\\n                    return [x,y] # if A doesn\\'t exits remove (x,y)\\n        \\n        return B # If no cycle detected, means B is the faulty edge\\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        \\n        # In order to form a valid tree, we need to ensure that each of the node has only one parent and there are no cycle\\n        \\n        mem = dict()\\n        # find if any node has two parents\\n        A,B = [],[]\\n        for x,y in edges:\\n            if y in mem:\\n                # y has two parent\\n                A,B = [mem[y],y],[x,y] # List of edges\\n                break\\n            mem[y] = x\\n        \\n        \\n        parent = list(range(len(edges)+1))\\n        \\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x,y):\\n            px = find(x)\\n            py = find(y)\\n            parent[px] = py\\n            \\n        \\n        for x,y in edges:\\n            if [x,y] == B: # Ingnpre the edge B\\n                continue\\n            \\n            px = find(x)\\n            py = find(y)\\n            if px!=py:\\n                union(x,y)\\n                \\n            else:\\n                if A: # if A exits remove A\\n                    return A\\n                else:\\n                    return [x,y] # if A doesn\\'t exits remove (x,y)\\n        \\n        return B # If no cycle detected, means B is the faulty edge\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 294428,
                "title": "c-o-n-simple-and-concise-union-find-solution-beats-99",
                "content": "Hi, below are my code and explanation. Hope they are helpful.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> root;\\n    \\n    int trace(int i) {\\n        while (i != root[i]) i = root[i];\\n        return i;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> res, candidate;\\n        int n = edges.size();\\n        root.assign(n + 1, 0);\\n        for (int i = 0; i <= n; i++) root[i] = i;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int v = edges[i][0], u = edges[i][1], ru = trace(u), rv = trace(v);\\n            \\n            if (root[u] != u) { // two nodes point to one node\\n                if (!candidate.empty()) res = {root[u], u};\\n                else { candidate = {root[u], u}; res = {v, u}; }\\n            } else if (ru == rv) { // cycle detected\\n                if (candidate.empty()) candidate = {v, u};\\n                else res = candidate;\\n            }\\n            // update root when no violations occur\\n            if (root[u] == u && ru != rv) root[u] = v;\\n        }\\n        return res.empty() ? candidate : res;\\n    }\\n};\\n```\\n\\nTestcases:\\n[[2,1],[3,1],[4,2],[1,4]] - 43/52\\n[[2,1],[4,2],[1,4],[3,1]]\\n[[3,4],[4,1],[1,2],[2,3],[5,1]] - 48/52\\n\\nNotable points are (i) no more than one node of the graph is pointed by two nodes and all other nodes are pointed by exactly one node or 0 node in case of the root. (ii) There are only two possible violations of the directed graph definition, the first being that one node is pointed by two nodes and the second occurs when a cycle is detected. And these two violations are each edge should be mutually exclusive (if-else). (iii) These two violations may co-exist regarding the graph as a whole (43/52 instance) (iv) We are required to return the lastest edge violating the rule whose removal can restore the graph.\\n\\nTake 43/52 for instance, as we reach [3,1], we know that two nodes (3 & 2) are now pointing both at 1 and therefore, the answer should definitely be either [2,1] or [3,1]. Since we are required to return the lastest edge, we take [1,3] as the temporary res. However, as we are not sure if the existence of [2,1] may incur further violations, we have to store [2,1] as a candidate and if no violations are violated later, we immediately return res which holds [1,3], the lastest violating edge. Notice, to check further possibilities icurred by [1,2] only, we do not update root to bring 3 in. This can be shown by the left chart below. If we update the root of 1 to be 3, then we cannot detect the cycle incurred by 2.\\n\\n3   2  <\\u2014\\u2014\\u2014                   |\\u2014\\u20142<\\u2014\\u2014|\\n \\\\ /                    |                v                  1 <\\u2014 5\\n  v                    |                3                  ^\\n  1 \\u2014\\u2014\\u2014\\u2014> 4                 |\\u2014\\u2014>4\\u2014\\u2014|\\n\\nMoreover, if a cycle is detected as the first violation, the we have multiple choices, either remove the most recent edge which confirmed the cycle or any other edges in the cycle. Like the right figure above, if 5 is not presenting, we simply return the latest edge which is [2,3]. However, when we reach [1,5], we are faced agian with a two-pointer vilation with 1 being pointed by 4 and 5. Now, we should either return [4,1] or [5,1]. Since [5,1] is the most recent edge, if no previous violations present (candidate empty), we return [5,1]. As we have detected a cycle previously which do not involve [5,1], it can thus be ascertained that [4,1] can incur other violations apart from sharing the target with 5 and thus should be removed.\\n\\nNote we store the root of each node as its immediate root rather than any profound roots. This is to ensure that when we detect a two-pointer violation, we can trace the other node also pointing to the common target.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> root;\\n    \\n    int trace(int i) {\\n        while (i != root[i]) i = root[i];\\n        return i;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> res, candidate;\\n        int n = edges.size();\\n        root.assign(n + 1, 0);\\n        for (int i = 0; i <= n; i++) root[i] = i;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int v = edges[i][0], u = edges[i][1], ru = trace(u), rv = trace(v);\\n            \\n            if (root[u] != u) { // two nodes point to one node\\n                if (!candidate.empty()) res = {root[u], u};\\n                else { candidate = {root[u], u}; res = {v, u}; }\\n            } else if (ru == rv) { // cycle detected\\n                if (candidate.empty()) candidate = {v, u};\\n                else res = candidate;\\n            }\\n            // update root when no violations occur\\n            if (root[u] == u && ru != rv) root[u] = v;\\n        }\\n        return res.empty() ? candidate : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270795,
                "title": "python-either-two-parents-or-has-cycle-uf",
                "content": "The given directed graph has exactly one redundant edges in this problem. So there are only 3 occasions:\\n```\\n# 1 One node with two parents and graph has no cycle:\\n  1\\n / \\\\\\nv   v\\n2-->3\\n```\\nTarget node is 3 which has two parents (1 & 2). And redundant edge can be either of the edges (```1->3``` or ```2->3```) that points to 3. We should pick the edge occurs last in the given edges.\\n```\\n# 2 One node with two parents and it\\'s in a cycle:\\n5 -> 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\\nTarget node is 1 which has two parents (5 & 1). And target edge is the edge ```4->1``` that points to 1 and consists of the cycle.\\n```\\n# 3 No node has two parents and graph has a cycle:\\n5 <- 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\\nRedundant edge can be either of the edges in the cycle. We should pick the edge occurs last in the given edges.\\n\\nGiven that, we can first identify the node with two parents, then identify the cycle edge.\\n\\n1. If there is a node with two parent, we have two candidates by saying ```p1->c```, ```p2->c```. We delete the later one ```p2->c``` and then check if there is a cycle. \\n-- If there is a cycle, it\\'s case #2 and we delete the wrong edge. The target edge would be the other edge ```p1-->c```.\\n-- If there isn\\'t, it\\'s case #1 and we have deleted the correct edge ```p2->c``` as the later edge points to the node with two parents.\\n2. If there is no such node with two parents (```p1 is None```), it\\'s case #3. We delete the last edge of a cycle. I used Union Find to detect the cycle. If two nodes are already unioned, then we find the last edge of the cycle (```if find(u)==find(v): return [u, v]```) and we just return it.\\n\\nTo detect two parents, I used a parent array ```p``` to record each node\\'s parent node. Once a node ```edges[i][1]``` already has a parent (```p[edges[i][1]] != 0```), this node has two parents (```p1=p[edges[i][1]], p2=edges[i][0]```). To delete an ```edge[i]```, I just mark ```edges[i][0]``` as 0 since all nodes are range from 1 to n. Later in Union Find, I only search the edge that ```edges[i][0] != 0```.\\n```\\ndef findRedundantDirectedConnection(edges):\\n\\tn, p1, p2, c = len(edges), None, None, None\\n\\tp = [0] * (n+1)\\n\\tfor i, (u,v) in enumerate(edges):\\n\\t\\tif p[v]: p1, p2, c, edges[i][0] = p[v], u, v, 0\\n\\t\\telse: p[v] = u\\n\\tp = list(range(n+1))\\n\\tdef find(x):\\n\\t\\tif p[x] != x: p[x] = find(p[x])\\n\\t\\treturn p[x]\\n\\tfor u, v in edges:\\n\\t\\tif u:\\n\\t\\t\\tpu, pv = find(u), find(v)\\n\\t\\t\\tif pu == pv: return p1 and [p1, c] or [u, v]\\n\\t\\t\\telse: p[pv] = pu\\n\\treturn [p2, c]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 1 One node with two parents and graph has no cycle:\\n  1\\n / \\\\\\nv   v\\n2-->3\\n```\n```1->3```\n```2->3```\n```\\n# 2 One node with two parents and it\\'s in a cycle:\\n5 -> 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\n```4->1```\n```\\n# 3 No node has two parents and graph has a cycle:\\n5 <- 1 -> 2\\n     ^    |\\n     |    v\\n     4 <- 3\\n```\n```p1->c```\n```p2->c```\n```p2->c```\n```p1-->c```\n```p2->c```\n```p1 is None```\n```if find(u)==find(v): return [u, v]```\n```p```\n```edges[i][1]```\n```p[edges[i][1]] != 0```\n```p1=p[edges[i][1]], p2=edges[i][0]```\n```edge[i]```\n```edges[i][0]```\n```edges[i][0] != 0```\n```\\ndef findRedundantDirectedConnection(edges):\\n\\tn, p1, p2, c = len(edges), None, None, None\\n\\tp = [0] * (n+1)\\n\\tfor i, (u,v) in enumerate(edges):\\n\\t\\tif p[v]: p1, p2, c, edges[i][0] = p[v], u, v, 0\\n\\t\\telse: p[v] = u\\n\\tp = list(range(n+1))\\n\\tdef find(x):\\n\\t\\tif p[x] != x: p[x] = find(p[x])\\n\\t\\treturn p[x]\\n\\tfor u, v in edges:\\n\\t\\tif u:\\n\\t\\t\\tpu, pv = find(u), find(v)\\n\\t\\t\\tif pu == pv: return p1 and [p1, c] or [u, v]\\n\\t\\t\\telse: p[pv] = pu\\n\\treturn [p2, c]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141743,
                "title": "javascript-version-using-union-find-and-circle",
                "content": "```\\n/**\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\n\\n// condition 1: one node 2 parents, we will try to remove one node. If we remove wrong node, a circle will be created\\n// condition 2: a perfect circle without any node having 2 parents, in that case we just remove the last edge that creates circle\\n\\nvar findParent = function(parent, i) {\\n  if (parent[i] !== i) {\\n    parent[i] = findParent(parent, parent[i]);\\n  }\\n  return parent[i];\\n};\\n\\nvar findRedundantDirectedConnection = function(edges) {\\n  var parent = [];\\n  //detect circle\\n  for (let i = 1; i <= edges.length; i++) {\\n    parent[i] = i;\\n  }\\n  let circleEdge, removedEdge, candidateEdge;\\n  for (let i = 0; i < edges.length; i++) {\\n    let [u, v] = edges[i];\\n    let pu = findParent(parent, u);\\n    let pv = findParent(parent, v);\\n    if (pv !== v) {\\n      removedEdge = [u, v]; // node with 2 parents\\n    } else {\\n      if (pv == pu) {\\n        circleEdge = [u, v]; // circle edge\\n      }\\n      parent[v] = pu;\\n    }\\n  }\\n  if (!removedEdge) {\\n    return circleEdge;\\n  }\\n  if (circleEdge) {\\n    return edges.find(d => d[1] == removedEdge[1] && d[0] !== removedEdge[0]);\\n  } else {\\n    return removedEdge;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\n\\n// condition 1: one node 2 parents, we will try to remove one node. If we remove wrong node, a circle will be created\\n// condition 2: a perfect circle without any node having 2 parents, in that case we just remove the last edge that creates circle\\n\\nvar findParent = function(parent, i) {\\n  if (parent[i] !== i) {\\n    parent[i] = findParent(parent, parent[i]);\\n  }\\n  return parent[i];\\n};\\n\\nvar findRedundantDirectedConnection = function(edges) {\\n  var parent = [];\\n  //detect circle\\n  for (let i = 1; i <= edges.length; i++) {\\n    parent[i] = i;\\n  }\\n  let circleEdge, removedEdge, candidateEdge;\\n  for (let i = 0; i < edges.length; i++) {\\n    let [u, v] = edges[i];\\n    let pu = findParent(parent, u);\\n    let pv = findParent(parent, v);\\n    if (pv !== v) {\\n      removedEdge = [u, v]; // node with 2 parents\\n    } else {\\n      if (pv == pu) {\\n        circleEdge = [u, v]; // circle edge\\n      }\\n      parent[v] = pu;\\n    }\\n  }\\n  if (!removedEdge) {\\n    return circleEdge;\\n  }\\n  if (circleEdge) {\\n    return edges.find(d => d[1] == removedEdge[1] && d[0] !== removedEdge[0]);\\n  } else {\\n    return removedEdge;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3318946,
                "title": "685-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a UnionFind object with a size equal to the number of edges in the input graph plus one.\\n\\nCreate a parent list of size n+1, initialized to all zeros.\\n\\nInitialize two variables candidate1 and candidate2 to None.\\n\\nLoop through the edges in the input list, and for each edge (u, v), if the parent[v] is not zero, then we have found a node with two parents. In this case, set candidate1 to the first parent of v (i.e. parent[v]) and candidate2 to the current edge (i.e. [u, v]). Break out of the loop.\\n\\nLoop through the edges in the input list again, and for each edge (u, v), if it is equal to candidate2, skip to the next iteration. Otherwise, call the union() method of the UnionFind object with u and v as arguments. If the union() method returns False, then we have found a cycle in the graph, and we can return candidate1 if it is not None, otherwise we return the current edge (i.e. [u, v]).\\n\\nIf we have not found a cycle by the end of the loop, then the graph must be a tree with a node with two parents. In this case, we can return candidate2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n  def __init__(self, n: int):\\n    self.parent = list(range(n))\\n    self.rank = [0] * n\\n\\n  def find(self, u: int) -> int:\\n    if self.parent[u] != u:\\n      self.parent[u] = self.find(self.parent[u])\\n    return self.parent[u]\\n\\n  def union(self, u: int, v: int) -> bool:\\n    pu, pv = self.find(u), self.find(v)\\n    if pu == pv:\\n      return False\\n    if self.rank[pu] < self.rank[pv]:\\n      self.parent[pu] = pv\\n    elif self.rank[pv] < self.rank[pu]:\\n      self.parent[pv] = pu\\n    else:\\n      self.parent[pu] = pv\\n      self.rank[pv] += 1\\n    return True\\n\\n\\nclass Solution:\\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n    uf = UnionFind(len(edges) + 1)\\n    parent = [0] * (len(edges) + 1)\\n    candidate1 = candidate2 = None\\n    \\n    for u, v in edges:\\n      if parent[v]:\\n        candidate1 = [parent[v], v]\\n        candidate2 = [u, v]\\n        break\\n      parent[v] = u\\n\\n    for u, v in edges:\\n      if [u, v] == candidate2:\\n        continue\\n      if not uf.union(u, v):\\n        return candidate1 if candidate1 else [u, v]\\n\\n    return candidate2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n  def __init__(self, n: int):\\n    self.parent = list(range(n))\\n    self.rank = [0] * n\\n\\n  def find(self, u: int) -> int:\\n    if self.parent[u] != u:\\n      self.parent[u] = self.find(self.parent[u])\\n    return self.parent[u]\\n\\n  def union(self, u: int, v: int) -> bool:\\n    pu, pv = self.find(u), self.find(v)\\n    if pu == pv:\\n      return False\\n    if self.rank[pu] < self.rank[pv]:\\n      self.parent[pu] = pv\\n    elif self.rank[pv] < self.rank[pu]:\\n      self.parent[pv] = pu\\n    else:\\n      self.parent[pu] = pv\\n      self.rank[pv] += 1\\n    return True\\n\\n\\nclass Solution:\\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n    uf = UnionFind(len(edges) + 1)\\n    parent = [0] * (len(edges) + 1)\\n    candidate1 = candidate2 = None\\n    \\n    for u, v in edges:\\n      if parent[v]:\\n        candidate1 = [parent[v], v]\\n        candidate2 = [u, v]\\n        break\\n      parent[v] = u\\n\\n    for u, v in edges:\\n      if [u, v] == candidate2:\\n        continue\\n      if not uf.union(u, v):\\n        return candidate1 if candidate1 else [u, v]\\n\\n    return candidate2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373872,
                "title": "easy-solution-faster",
                "content": "Just consider cases;\\nLike is there any node on which two nodes are pointing -- 3cases \\n           no node on which two nodes are pointing = (ans== edge making the cycle)\\n```\\nclass Solution {\\n    int[] dsu;\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n=edges.length;\\n        int[] parent=new int[n+1];\\n        Arrays.fill(parent,-1);\\n        \\n        int[] e2=null;\\n        int[] e1=null;\\n        boolean twopt=false;\\n        \\n        for(int[] edge: edges){\\n            \\n            int from=edge[0];\\n            int to=edge[1];\\n            \\n            if(parent[to]==-1){\\n                parent[to]=from;\\n            }else{\\n                twopt=true;\\n                e2=edge;\\n                e1=new int[]{parent[to],to};\\n                break;\\n            }\\n        }\\n        \\n        dsu=new int[edges.length+1];\\n        for(int i=0;i<=edges.length;i++){\\n            dsu[i]=i;\\n        }\\n        if(twopt==false){\\n            int[] res=null;\\n            \\n            for(int[] edge: edges){\\n                int from=edge[0];\\n                int to=edge[1];\\n                \\n                int fromlead=find(from);\\n                if(fromlead==to){\\n                    res=edge;\\n                    break;\\n                }else{\\n                    dsu[to]=fromlead;\\n                }\\n            }\\n            return res;\\n        }else{\\n            boolean iscycle=false;\\n            for(int[] edge: edges){\\n                if(edge==e2) continue;\\n                int from =edge[0];\\n                int to=edge[1];\\n                \\n                int fromlead=find(from);\\n                \\n                if(fromlead==to){\\n                    iscycle=true;\\n                    break;\\n                }else{\\n                    dsu[to]=fromlead;\\n                }\\n            }\\n            if(iscycle==true){\\n                return e1;\\n            }else{\\n                return e2; \\n            }\\n        }\\n        \\n        \\n    }\\n    public int find(int x){\\n        if(dsu[x]==x) return x;\\n        return dsu[x]=find(dsu[x]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] dsu;\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n=edges.length;\\n        int[] parent=new int[n+1];\\n        Arrays.fill(parent,-1);\\n        \\n        int[] e2=null;\\n        int[] e1=null;\\n        boolean twopt=false;\\n        \\n        for(int[] edge: edges){\\n            \\n            int from=edge[0];\\n            int to=edge[1];\\n            \\n            if(parent[to]==-1){\\n                parent[to]=from;\\n            }else{\\n                twopt=true;\\n                e2=edge;\\n                e1=new int[]{parent[to],to};\\n                break;\\n            }\\n        }\\n        \\n        dsu=new int[edges.length+1];\\n        for(int i=0;i<=edges.length;i++){\\n            dsu[i]=i;\\n        }\\n        if(twopt==false){\\n            int[] res=null;\\n            \\n            for(int[] edge: edges){\\n                int from=edge[0];\\n                int to=edge[1];\\n                \\n                int fromlead=find(from);\\n                if(fromlead==to){\\n                    res=edge;\\n                    break;\\n                }else{\\n                    dsu[to]=fromlead;\\n                }\\n            }\\n            return res;\\n        }else{\\n            boolean iscycle=false;\\n            for(int[] edge: edges){\\n                if(edge==e2) continue;\\n                int from =edge[0];\\n                int to=edge[1];\\n                \\n                int fromlead=find(from);\\n                \\n                if(fromlead==to){\\n                    iscycle=true;\\n                    break;\\n                }else{\\n                    dsu[to]=fromlead;\\n                }\\n            }\\n            if(iscycle==true){\\n                return e1;\\n            }else{\\n                return e2; \\n            }\\n        }\\n        \\n        \\n    }\\n    public int find(int x){\\n        if(dsu[x]==x) return x;\\n        return dsu[x]=find(dsu[x]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179926,
                "title": "c-easy-to-understand-simple-dfs-based-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<set<int>> &adj,vector<bool> &vis,int node)\\n    {\\n        vis[node]=true;\\n        for(auto &x:adj[node])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(adj,vis,x);\\n            }\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<set<int>> adj(n+1);\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            adj[edges[i][0]].erase(edges[i][1]);\\n            indegree[edges[i][1]]--;\\n            \\n            int startNode=-1;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(indegree[j]==0)\\n                {\\n                    startNode=j;\\n                    break;\\n                }\\n            }\\n            if(startNode==-1)\\n            {\\n                continue;\\n            }\\n            vector<bool> vis(n+1,false);\\n            dfs(adj,vis,startNode);\\n            bool ok=true;\\n            for(int i=1;i<=n;i++)\\n            {\\n                if(vis[i]==false)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                return {edges[i][0],edges[i][1]};\\n            }\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        return {};\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<set<int>> &adj,vector<bool> &vis,int node)\\n    {\\n        vis[node]=true;\\n        for(auto &x:adj[node])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(adj,vis,x);\\n            }\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<set<int>> adj(n+1);\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            adj[edges[i][0]].erase(edges[i][1]);\\n            indegree[edges[i][1]]--;\\n            \\n            int startNode=-1;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(indegree[j]==0)\\n                {\\n                    startNode=j;\\n                    break;\\n                }\\n            }\\n            if(startNode==-1)\\n            {\\n                continue;\\n            }\\n            vector<bool> vis(n+1,false);\\n            dfs(adj,vis,startNode);\\n            bool ok=true;\\n            for(int i=1;i<=n;i++)\\n            {\\n                if(vis[i]==false)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                return {edges[i][0],edges[i][1]};\\n            }\\n            adj[edges[i][0]].insert(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170833,
                "title": "c-clean-and-concise-solution-union-find-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/redundant-connection-ii/\\n    \\n    TC: O(nlogn)\\n    SC: O(n)\\n    \\n    There can be 3 cases:\\n    \\n    case 1: 2 Parents for one node, No cycle\\n            Either edge [1, 3] or [4, 3] can be removed, but since last needs to be removed, remove [4, 3]\\n            Solution: remove the 2nd seen edge that contributes to 2 parents\\n        1\\n       / \\\\\\n      v   v\\n      2   3\\n     /    ^\\n    v     |\\n    4-----|\\n    \\n    case 2: 2 Parents for one node, cycle present\\n            Edges [1, 2] or [4, 2] contribute to 2 parents. Only [4, 2] can be removed since removing [1,2] will make it disconnected.\\n            Solution: remove the edge that contributes to 2 parents and on the cyclic path\\n            edge [1, 2] might come after [4, 2] and this will result in candidate1 = [4, 2], candidate2 = [1, 2].\\n            Once we set the candidates, we disable the candidate2 edge.\\n            So we need to check post setting the candidates, whether the cycle still exists or not. If we chose \\n            [4, 2] as the 2nd candidate, then the cycle would be absent otherwise if candidate2 = [1,2], then cycle \\n            will still be present.\\n         1\\n       /    \\\\\\n      v      v\\n      2<--|   3\\n     /    | \\n    v     |\\n    4-----|\\n    \\n    case 3: Only cycle\\n            Either edge [1, 2], [2, 4], [4, 1] can be removed, but since last needs to be removed, remove [4, 1]\\n            Solution: remove the last seen edge that contributes to cycle\\n         1\\n       / ^ \\\\\\n      v  |  v\\n      2  |  3\\n     /   | \\n    v    |\\n    4----|\\n    \\n    1. We use a parent vector to keep track of parent node for each node\\n    2. Find the candidate edges that contribute to 2 parents situation. Then disable the last seen candidate edge.\\n    3. using union find check if cycle is present:\\n        If cycle is present: track the edge causing cycle\\n    4. Deal with the individual scenario cases\\n*/\\nclass Solution {\\nprivate:\\n    class UnionFind {\\n    public:\\n        vector<int> root, size;\\n        UnionFind(int n) {\\n            root.resize(n);\\n            size.resize(n, 1);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                a = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_b]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n    };\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        UnionFind uf(n + 1);\\n        // Candidate1: First edge seen that is part of 2 parents node\\n        // Candidate2: Second edge seen that is part of 2 parents node\\n        vector<int> candidate1, candidate2, disabled_edge;\\n        // parent[i] = Parent of ith node\\n        vector<int> parent(n + 1, -1);\\n        \\n        // Check if there is an edge that leads to 2 parents\\n        for(auto edge: edges) {\\n            int src = edge[0], dst = edge[1];\\n            // if current destination node already has a parent\\n            // Track the two candidates\\n            if(parent[dst] != -1) {\\n                candidate1 = {parent[dst], dst};\\n                candidate2 = edge;\\n                // disable the 2nd seen edge\\n                disabled_edge = edge;\\n                break;\\n            }\\n            else\\n                parent[dst] = src;\\n        }\\n        \\n        // Check if there is a cycle\\n        vector<int> cyclic_edge; \\n        for(auto edge: edges) {\\n            // skip the disabled edge\\n            if(edge == disabled_edge)\\n                continue;\\n            \\n            int src = edge[0], dst = edge[1];\\n            // cycle present\\n            if(uf.Union(src, dst) == false) { \\n                cyclic_edge = edge;\\n                break;\\n            }\\n        }\\n        \\n        // case1: Only cylic case\\n        if(candidate1.empty()) \\n            return cyclic_edge;\\n        \\n        // case2: Cyclic + 2 parents\\n        // If the candidates were picked correctly, then won\\'t see \\n        // a cycle. If we are seeing a cycle, that means we classified candidate 2 wrongly\\n        if(!cyclic_edge.empty())\\n            return candidate1;\\n        \\n        // case3: Only 2 parents\\n        return candidate2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/redundant-connection-ii/\\n    \\n    TC: O(nlogn)\\n    SC: O(n)\\n    \\n    There can be 3 cases:\\n    \\n    case 1: 2 Parents for one node, No cycle\\n            Either edge [1, 3] or [4, 3] can be removed, but since last needs to be removed, remove [4, 3]\\n            Solution: remove the 2nd seen edge that contributes to 2 parents\\n        1\\n       / \\\\\\n      v   v\\n      2   3\\n     /    ^\\n    v     |\\n    4-----|\\n    \\n    case 2: 2 Parents for one node, cycle present\\n            Edges [1, 2] or [4, 2] contribute to 2 parents. Only [4, 2] can be removed since removing [1,2] will make it disconnected.\\n            Solution: remove the edge that contributes to 2 parents and on the cyclic path\\n            edge [1, 2] might come after [4, 2] and this will result in candidate1 = [4, 2], candidate2 = [1, 2].\\n            Once we set the candidates, we disable the candidate2 edge.\\n            So we need to check post setting the candidates, whether the cycle still exists or not. If we chose \\n            [4, 2] as the 2nd candidate, then the cycle would be absent otherwise if candidate2 = [1,2], then cycle \\n            will still be present.\\n         1\\n       /    \\\\\\n      v      v\\n      2<--|   3\\n     /    | \\n    v     |\\n    4-----|\\n    \\n    case 3: Only cycle\\n            Either edge [1, 2], [2, 4], [4, 1] can be removed, but since last needs to be removed, remove [4, 1]\\n            Solution: remove the last seen edge that contributes to cycle\\n         1\\n       / ^ \\\\\\n      v  |  v\\n      2  |  3\\n     /   | \\n    v    |\\n    4----|\\n    \\n    1. We use a parent vector to keep track of parent node for each node\\n    2. Find the candidate edges that contribute to 2 parents situation. Then disable the last seen candidate edge.\\n    3. using union find check if cycle is present:\\n        If cycle is present: track the edge causing cycle\\n    4. Deal with the individual scenario cases\\n*/\\nclass Solution {\\nprivate:\\n    class UnionFind {\\n    public:\\n        vector<int> root, size;\\n        UnionFind(int n) {\\n            root.resize(n);\\n            size.resize(n, 1);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                a = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_b]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n    };\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        UnionFind uf(n + 1);\\n        // Candidate1: First edge seen that is part of 2 parents node\\n        // Candidate2: Second edge seen that is part of 2 parents node\\n        vector<int> candidate1, candidate2, disabled_edge;\\n        // parent[i] = Parent of ith node\\n        vector<int> parent(n + 1, -1);\\n        \\n        // Check if there is an edge that leads to 2 parents\\n        for(auto edge: edges) {\\n            int src = edge[0], dst = edge[1];\\n            // if current destination node already has a parent\\n            // Track the two candidates\\n            if(parent[dst] != -1) {\\n                candidate1 = {parent[dst], dst};\\n                candidate2 = edge;\\n                // disable the 2nd seen edge\\n                disabled_edge = edge;\\n                break;\\n            }\\n            else\\n                parent[dst] = src;\\n        }\\n        \\n        // Check if there is a cycle\\n        vector<int> cyclic_edge; \\n        for(auto edge: edges) {\\n            // skip the disabled edge\\n            if(edge == disabled_edge)\\n                continue;\\n            \\n            int src = edge[0], dst = edge[1];\\n            // cycle present\\n            if(uf.Union(src, dst) == false) { \\n                cyclic_edge = edge;\\n                break;\\n            }\\n        }\\n        \\n        // case1: Only cylic case\\n        if(candidate1.empty()) \\n            return cyclic_edge;\\n        \\n        // case2: Cyclic + 2 parents\\n        // If the candidates were picked correctly, then won\\'t see \\n        // a cycle. If we are seeing a cycle, that means we classified candidate 2 wrongly\\n        if(!cyclic_edge.empty())\\n            return candidate1;\\n        \\n        // case3: Only 2 parents\\n        return candidate2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012203,
                "title": "java-straightforward-check-from-end-to-start",
                "content": "### Algorithm\\n+ Try from last to first, if valid, return edge.\\n\\n\\n\\n### Code\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n\\n        // O(n = 1000) from last to first, check if remove valid\\n        // Nested: check O(V + E = 2000)\\n        // So total is O(2e6)\\n        // 1. build Graph with whole\\n        Map<Integer, Set<Integer>> graph = buildGraph(edges);\\n        int[] indegree = buildIndegree(edges);\\n        \\n        // 2. remove current edge and check\\n        int n = edges.length;\\n        for(int i = n - 1; i >= 0; i--){\\n            // remove current one\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            graph.get(u).remove(v);\\n            indegree[v]--;\\n            \\n            if(ok(graph, indegree)) return edges[i];\\n            \\n            indegree[v]++;\\n            graph.get(u).add(v);\\n        }\\n        \\n        return new int[]{-1, -1};\\n    }\\n    \\n    // build the graph by input edges\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges){\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph.putIfAbsent(u, new HashSet<>());\\n            graph.putIfAbsent(v, new HashSet<>());\\n            \\n            graph.get(u).add(v);\\n        }\\n        \\n        return graph;\\n    }\\n    \\n    private int[] buildIndegree(int[][] edges){\\n        int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        indegree[0] = -100;\\n        \\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            indegree[v]++;\\n        }\\n        return indegree;\\n    }\\n    \\n    // check current graph is valid tree of not\\n    private boolean ok(Map<Integer, Set<Integer>> graph, int[] indegree){\\n        // valid tree: one start root and no cycle\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        // indegree is 0\\n        for(int i = 1; i < indegree.length; i++){\\n            if(indegree[i] == 0){\\n                queue.offer(i);\\n                visited.add(i);\\n            }\\n        }\\n        \\n        if(queue.size() != 1) return false;\\n        \\n        while(!queue.isEmpty()){\\n            int u = queue.poll();\\n            \\n            for(int v : graph.get(u)){\\n                if(visited.contains(v)) return false;\\n                \\n                queue.offer(v);\\n                visited.add(v);\\n            }\\n        }\\n        \\n        int n = indegree.length - 1;\\n        \\n        return visited.size() == n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n\\n        // O(n = 1000) from last to first, check if remove valid\\n        // Nested: check O(V + E = 2000)\\n        // So total is O(2e6)\\n        // 1. build Graph with whole\\n        Map<Integer, Set<Integer>> graph = buildGraph(edges);\\n        int[] indegree = buildIndegree(edges);\\n        \\n        // 2. remove current edge and check\\n        int n = edges.length;\\n        for(int i = n - 1; i >= 0; i--){\\n            // remove current one\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            graph.get(u).remove(v);\\n            indegree[v]--;\\n            \\n            if(ok(graph, indegree)) return edges[i];\\n            \\n            indegree[v]++;\\n            graph.get(u).add(v);\\n        }\\n        \\n        return new int[]{-1, -1};\\n    }\\n    \\n    // build the graph by input edges\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges){\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph.putIfAbsent(u, new HashSet<>());\\n            graph.putIfAbsent(v, new HashSet<>());\\n            \\n            graph.get(u).add(v);\\n        }\\n        \\n        return graph;\\n    }\\n    \\n    private int[] buildIndegree(int[][] edges){\\n        int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        indegree[0] = -100;\\n        \\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            indegree[v]++;\\n        }\\n        return indegree;\\n    }\\n    \\n    // check current graph is valid tree of not\\n    private boolean ok(Map<Integer, Set<Integer>> graph, int[] indegree){\\n        // valid tree: one start root and no cycle\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        // indegree is 0\\n        for(int i = 1; i < indegree.length; i++){\\n            if(indegree[i] == 0){\\n                queue.offer(i);\\n                visited.add(i);\\n            }\\n        }\\n        \\n        if(queue.size() != 1) return false;\\n        \\n        while(!queue.isEmpty()){\\n            int u = queue.poll();\\n            \\n            for(int v : graph.get(u)){\\n                if(visited.contains(v)) return false;\\n                \\n                queue.offer(v);\\n                visited.add(v);\\n            }\\n        }\\n        \\n        int n = indegree.length - 1;\\n        \\n        return visited.size() == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618773,
                "title": "intuitive-java-solution-with-explanation",
                "content": "From the problem description we have \"a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.... The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added.\" So, after adding an edge two things could have happened. \\n`Case 1 =>` A child could now have two parents. In which case we will store the two edges to the child. `(candidateA and candidateB)`\\n`Case 2 =>` The root could now have a parent, which would form a cycle since the root is an ancestor of all nodes.\\n\\n```\\n// 1) Check whether there is a node having two parents. If so, store them as candidateA and candidateB. \\n// 2) If there is a cycle, perform union-find and return the edge that creates the cycle.\\n// 3) Else remove candidateA edge and perform union-find. If find of candidateA\\'s parent\\n// and child are equal return candidateA, otherwise return candidateB \\n\\n\\nclass Solution {\\n    int[] parent;\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        parent = new int[n+1];\\n        int[] candidateA = null;\\n        int[] candidateB = null;\\n        \\n        for (int[] edge : edges) {\\n            int parentNode = edge[0];\\n            int childNode = edge[1];\\n            if (parent[childNode] == 0) {\\n                parent[childNode] = parentNode;\\n            } else {\\n                candidateA = new int[]{parentNode, childNode};\\n                candidateB = new int[]{parent[childNode], childNode};\\n            }\\n        }\\n        \\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // there must be a cycle, return edge that creates cycle\\n        if (candidateA == null && candidateB == null) {\\n            for (int[] edge : edges) {\\n                int parentNode = edge[0];\\n                int childNode = edge[1];\\n                if (!union(parentNode, childNode)) {\\n                    return edge;\\n                }\\n            }\\n        } else {\\n            // remove edge candidateA and perform union\\n            // if find of this removed edge\\'s parent and child are equal\\n            // return candidateA\\n            // otherwise return candidateB\\n            for (int[] edge : edges) {\\n                int parentNode = edge[0];\\n                int childNode = edge[1];\\n                if (candidateA[0] == parentNode && candidateA[1] == childNode) {\\n                    continue;\\n                }\\n                union(parentNode, childNode);\\n            }\\n            if (find(candidateA[0]) == find(candidateA[1])) {\\n                return candidateA;\\n            } else {\\n                return candidateB;\\n            }\\n        }\\n        // will never reach here\\n        return edges[0];\\n    }\\n    \\n    public int find(int node) {\\n        int root = node;\\n        while (root != parent[root]) {\\n            root = parent[root];\\n        }\\n        \\n        // path compression\\n        int curr = node;\\n        while (curr != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    public boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\n// 1) Check whether there is a node having two parents. If so, store them as candidateA and candidateB. \\n// 2) If there is a cycle, perform union-find and return the edge that creates the cycle.\\n// 3) Else remove candidateA edge and perform union-find. If find of candidateA\\'s parent\\n// and child are equal return candidateA, otherwise return candidateB \\n\\n\\nclass Solution {\\n    int[] parent;\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        parent = new int[n+1];\\n        int[] candidateA = null;\\n        int[] candidateB = null;\\n        \\n        for (int[] edge : edges) {\\n            int parentNode = edge[0];\\n            int childNode = edge[1];\\n            if (parent[childNode] == 0) {\\n                parent[childNode] = parentNode;\\n            } else {\\n                candidateA = new int[]{parentNode, childNode};\\n                candidateB = new int[]{parent[childNode], childNode};\\n            }\\n        }\\n        \\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // there must be a cycle, return edge that creates cycle\\n        if (candidateA == null && candidateB == null) {\\n            for (int[] edge : edges) {\\n                int parentNode = edge[0];\\n                int childNode = edge[1];\\n                if (!union(parentNode, childNode)) {\\n                    return edge;\\n                }\\n            }\\n        } else {\\n            // remove edge candidateA and perform union\\n            // if find of this removed edge\\'s parent and child are equal\\n            // return candidateA\\n            // otherwise return candidateB\\n            for (int[] edge : edges) {\\n                int parentNode = edge[0];\\n                int childNode = edge[1];\\n                if (candidateA[0] == parentNode && candidateA[1] == childNode) {\\n                    continue;\\n                }\\n                union(parentNode, childNode);\\n            }\\n            if (find(candidateA[0]) == find(candidateA[1])) {\\n                return candidateA;\\n            } else {\\n                return candidateB;\\n            }\\n        }\\n        // will never reach here\\n        return edges[0];\\n    }\\n    \\n    public int find(int node) {\\n        int root = node;\\n        while (root != parent[root]) {\\n            root = parent[root];\\n        }\\n        \\n        // path compression\\n        int curr = node;\\n        while (curr != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    public boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105385,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        p.resize(n + 1);\\n        for (int i = 1; i <= n; i ++) p[i] = i;\\n        vector<int> indegree(n + 1);\\n        for (auto edge : edges) {\\n            indegree[edge[1]] ++;\\n        }\\n        vector<vector<int>> conflicts;\\n        for (auto edge : edges) {\\n            if (indegree[edge[1]] > 1) {\\n                conflicts.push_back(edge);\\n            }\\n        }\\n        \\n        if (conflicts.size() > 0) {\\n            if (isTreeByRemoveEdge(edges, conflicts[1])) {\\n                return conflicts[1];\\n            }\\n            else return conflicts[0];\\n        }\\n        return getTreeByCircle(edges);\\n    }\\n    bool isTreeByRemoveEdge(vector<vector<int>>& edges, vector<int>& x) {\\n        for (auto edge : edges) {\\n            if (edge == x) continue;\\n            int a = find(edge[0]), b = find(edge[1]);\\n            if (a == b) return false;\\n            p[b] = a;\\n        }\\n        return true;\\n    }\\n    vector<int> getTreeByCircle(vector<vector<int>>& edges) {\\n        for (auto edge : edges) {\\n            int a = find(edge[0]), b = find(edge[1]);\\n            if (a == b) return edge;\\n            p[b] = a;\\n        }\\n        return {};\\n    }\\n    int find(int a) {\\n        if (p[a] != a) p[a] = find(p[a]);\\n        return p[a];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        p.resize(n + 1);\\n        for (int i = 1; i <= n; i ++) p[i] = i;\\n        vector<int> indegree(n + 1);\\n        for (auto edge : edges) {\\n            indegree[edge[1]] ++;\\n        }\\n        vector<vector<int>> conflicts;\\n        for (auto edge : edges) {\\n            if (indegree[edge[1]] > 1) {\\n                conflicts.push_back(edge);\\n            }\\n        }\\n        \\n        if (conflicts.size() > 0) {\\n            if (isTreeByRemoveEdge(edges, conflicts[1])) {\\n                return conflicts[1];\\n            }\\n            else return conflicts[0];\\n        }\\n        return getTreeByCircle(edges);\\n    }\\n    bool isTreeByRemoveEdge(vector<vector<int>>& edges, vector<int>& x) {\\n        for (auto edge : edges) {\\n            if (edge == x) continue;\\n            int a = find(edge[0]), b = find(edge[1]);\\n            if (a == b) return false;\\n            p[b] = a;\\n        }\\n        return true;\\n    }\\n    vector<int> getTreeByCircle(vector<vector<int>>& edges) {\\n        for (auto edge : edges) {\\n            int a = find(edge[0]), b = find(edge[1]);\\n            if (a == b) return edge;\\n            p[b] = a;\\n        }\\n        return {};\\n    }\\n    int find(int a) {\\n        if (p[a] != a) p[a] = find(p[a]);\\n        return p[a];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940991,
                "title": "don-t-use-path-compression",
                "content": "The problem is simple if you figure out the different cases. It is already stated in the problem that removing a single edge converts the directed grapsh into a directed tree. So, there may be two cases:\\n1. You have a node with indegree 2 (2 parents).\\n2. You don\\'t have a node with 2 parents. Then you have added a parent to the root.\\n\\nSo first check if there exists a node with 2 parents. If exists then store the edges which make 2 parents for a single node. Now we may or we may not have the edges which nade 2 parents for a node. If we don\\'t have such edges then we have a cycle passing through the root of the directed tree. If we do have 2 edges then also we need to find whcih edge should be removed. So we find if we skip one of these edges. Do we end up finding a normal tree? If so then adding the skipped edge should result in a cycle. If that does not happen then any of the two edges can be removed.\\n\\nCheck code, I\\'ve added the comments for better understanding\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int,int> par;\\n        vector<int> first_edge, second_edge;\\n        for(auto x: edges){\\n            if(!par.count(x[1]))\\n                par[x[1]] = x[0];\\n            else{\\n                first_edge = {par[x[1]], x[1]};\\n                second_edge = x;\\n            }\\n        }\\n        // +2 because in case you have a node with indegree 0 then its parent has \\n        // not been defined yet and has not been counted in par\\n        int p[par.size()+2];\\n        memset(p,-1,sizeof p);\\n        for(auto x:edges){\\n            int a = x[0], b = x[1];\\n            if(p[a] == -1)p[a] = a;\\n            if(p[b] == -1)p[b] = b;\\n            \\n            //skip first_edge then find if cycle exists\\n            if(x==first_edge)continue;\\n            // check if b lies on path from a to its top most parent\\n            while(p[a]!=a){\\n                a = p[a];\\n                // if b found, cycle completes\\n                if(a==b){\\n                    // you can have a cycle without having a node with 2 parents\\n                    // so check if the second_edge is empty or not\\n                    if(second_edge.empty())\\n                        return x;\\n                    return second_edge;\\n                }\\n            }\\n            \\n            // if you\\'ve made it till here then a holds its top most parent\\n            // find the top most parent of b\\n            // while(p[b]!=b)\\n            //     b = p[b];\\n            // if both the top most parents are same, then you are adding an edge to a node\\n            // which already had a parent but this can not happen here because only\\n            // first_edge and second_edge are capable of doing so\\n            // so simply do a union without path compression\\n            p[b] = x[0];\\n        }\\n        int a = first_edge[0], b = first_edge[1];\\n        while(p[a]!=a && a!=b)\\n            a = p[a];\\n        if(a == b)\\n            return first_edge;\\n        return second_edge;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int,int> par;\\n        vector<int> first_edge, second_edge;\\n        for(auto x: edges){\\n            if(!par.count(x[1]))\\n                par[x[1]] = x[0];\\n            else{\\n                first_edge = {par[x[1]], x[1]};\\n                second_edge = x;\\n            }\\n        }\\n        // +2 because in case you have a node with indegree 0 then its parent has \\n        // not been defined yet and has not been counted in par\\n        int p[par.size()+2];\\n        memset(p,-1,sizeof p);\\n        for(auto x:edges){\\n            int a = x[0], b = x[1];\\n            if(p[a] == -1)p[a] = a;\\n            if(p[b] == -1)p[b] = b;\\n            \\n            //skip first_edge then find if cycle exists\\n            if(x==first_edge)continue;\\n            // check if b lies on path from a to its top most parent\\n            while(p[a]!=a){\\n                a = p[a];\\n                // if b found, cycle completes\\n                if(a==b){\\n                    // you can have a cycle without having a node with 2 parents\\n                    // so check if the second_edge is empty or not\\n                    if(second_edge.empty())\\n                        return x;\\n                    return second_edge;\\n                }\\n            }\\n            \\n            // if you\\'ve made it till here then a holds its top most parent\\n            // find the top most parent of b\\n            // while(p[b]!=b)\\n            //     b = p[b];\\n            // if both the top most parents are same, then you are adding an edge to a node\\n            // which already had a parent but this can not happen here because only\\n            // first_edge and second_edge are capable of doing so\\n            // so simply do a union without path compression\\n            p[b] = x[0];\\n        }\\n        int a = first_edge[0], b = first_edge[1];\\n        while(p[a]!=a && a!=b)\\n            a = p[a];\\n        if(a == b)\\n            return first_edge;\\n        return second_edge;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359674,
                "title": "java-0-ms-beats-100-using-union-find",
                "content": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] roots = new int[edges.length + 1];\\n        for (int i = 0; i < roots.length; i++) {\\n            roots[i] = i;\\n        }\\n        int[] circle = null;\\n        int[] doubleParents = null;\\n        for (int[] edge : edges) {\\n            int node1 = find(roots, edge[0]);\\n            int node2 = find(roots, edge[1]);\\n            if (node2 != edge[1]) { //double parents\\n                doubleParents = edge;\\n                continue;\\n            }\\n            if (node1 == node2) { //circle\\n                circle = edge;\\n                continue;\\n            }\\n            roots[node2] = node1;\\n        }\\n        if (doubleParents == null) return circle;  //only have circle then return last edge\\n        if (circle == null) return doubleParents; //only have double parents then return last parent\\n        for (int[] tmp : edges) { //have double parents and circle, then return the parent in circle\\n            if (tmp[1] == doubleParents[1]) return tmp;\\n        }\\n        return edges[edges.length - 1];\\n    }\\n    \\n    public int find(int[] roots, int node) {\\n        while (roots[node] != node) {\\n            roots[node] = roots[roots[node]];\\n            node = roots[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] roots = new int[edges.length + 1];\\n        for (int i = 0; i < roots.length; i++) {\\n            roots[i] = i;\\n        }\\n        int[] circle = null;\\n        int[] doubleParents = null;\\n        for (int[] edge : edges) {\\n            int node1 = find(roots, edge[0]);\\n            int node2 = find(roots, edge[1]);\\n            if (node2 != edge[1]) { //double parents\\n                doubleParents = edge;\\n                continue;\\n            }\\n            if (node1 == node2) { //circle\\n                circle = edge;\\n                continue;\\n            }\\n            roots[node2] = node1;\\n        }\\n        if (doubleParents == null) return circle;  //only have circle then return last edge\\n        if (circle == null) return doubleParents; //only have double parents then return last parent\\n        for (int[] tmp : edges) { //have double parents and circle, then return the parent in circle\\n            if (tmp[1] == doubleParents[1]) return tmp;\\n        }\\n        return edges[edges.length - 1];\\n    }\\n    \\n    public int find(int[] roots, int node) {\\n        while (roots[node] != node) {\\n            roots[node] = roots[roots[node]];\\n            node = roots[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128596,
                "title": "easy-to-understand-java-solution-union-find",
                "content": "The idea behind my solution is very simple:\\n\\n* To determine if an edge is invalid:\\n\\t* if a child node already has a parent other than itself,  ``` roots[child] != child ```\\n\\t* if the parent of the parent node is child - forms a cricle, ```  find(roots, parent) == child```\\n* In the first loop, we keep tracking the number of invalid edge, if there\\'s only one after the loop, we\\'re confident that the only invalid edge is redundent.\\n* If we found more than one invalid edges, reset the ```roots``` and do a reverse check, return the first invalid edge we found. \\n\\n```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length, count = 0; // Use count to track the number of the invalid edge.\\n        \\n        int[] roots = new int[n + 1];\\n        \\n        int[] res = new int[2];\\n        \\n        for (int i = 0; i <= n ; i++) roots[i] = i;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int parent = edges[i][0], child = edges[i][1];\\n            \\n            if (roots[child] != child || find(roots, parent) == child) {res = edges[i]; count++;}\\n            \\n            else roots[child] = parent;\\n        }\\n        \\n        if (count == 1) return res; // If there\\'s only one invalid edge, return this edge.\\n        \\n        // Reset and do it the reverse way.\\n        for (int i = 0; i <= n ; i++) roots[i] = i; \\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            int parent = edges[i][0], child = edges[i][1];\\n            \\n            if (roots[child] != child || find(roots, parent) == child) return edges[i];\\n            \\n            roots[child] = parent;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int find(int[] roots, int x) {\\n        if (roots[x] == x) return x;\\n        \\n        return find(roots, roots[x]);\\n    }\\n```",
                "solutionTags": [],
                "code": "``` roots[child] != child ```\n```  find(roots, parent) == child```\n```roots```\n```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length, count = 0; // Use count to track the number of the invalid edge.\\n        \\n        int[] roots = new int[n + 1];\\n        \\n        int[] res = new int[2];\\n        \\n        for (int i = 0; i <= n ; i++) roots[i] = i;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int parent = edges[i][0], child = edges[i][1];\\n            \\n            if (roots[child] != child || find(roots, parent) == child) {res = edges[i]; count++;}\\n            \\n            else roots[child] = parent;\\n        }\\n        \\n        if (count == 1) return res; // If there\\'s only one invalid edge, return this edge.\\n        \\n        // Reset and do it the reverse way.\\n        for (int i = 0; i <= n ; i++) roots[i] = i; \\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            int parent = edges[i][0], child = edges[i][1];\\n            \\n            if (roots[child] != child || find(roots, parent) == child) return edges[i];\\n            \\n            roots[child] = parent;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int find(int[] roots, int x) {\\n        if (roots[x] == x) return x;\\n        \\n        return find(roots, roots[x]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099044,
                "title": "solve-like-sherlock-hollmes",
                "content": "My dear Watson. Let us approach this problem with keen observation and deduction.\\n\\nWe are presented with a tangled web of connections in the form of directed edges between nodes. Our initial state was a rooted tree, a structure where one node, the root, reigns supreme, and all others are its descendants, connected by parent-child relationships.\\n\\nNow, the mystery is that someone has added an extra connection, throwing our once-ordered tree into chaos. Our task is to identify the suspicious connection, the one we must remove to restore the tree to its original state.\\n\\nSherlock, in his wisdom, begins by examining each connection. He notices that some connections seem to claim the same child node. This is a clear sign of a disturbance in the hierarchy.\\n\\nOur detective keeps a record of two potential culprits, which we\\'ll call Suspect A and Suspect B. These are pairs of connections that seem to compete for the same child. However, to make things more intriguing, he temporarily removes the child node from contention, making it disappear from the graph for the time being.\\n\\nWith this child temporarily out of the picture, he then examines the connections again. His goal is to determine if any of the remaining connections create loops, where a node ends up connecting back to itself. Such loops would be a sign of chaos in the hierarchy.\\n\\nIf he finds a loop and doesn\\'t have a prime suspect (Suspect A), he selects the connection responsible for the loop as the main suspect.\\n\\nBut if he already has a prime suspect (Suspect A), he knows that connection must be the troublemaker. He presents Suspect A as the answer, the one we should remove to restore order. If he didn\\'t find a loop and only has Suspect B, he presents Suspect B as the solution.\\n\\nIn essence, Sherlock Holmes uses a combination of observation, deduction, and a clever strategy to uncover the suspicious connection that disrupts our once-peaceful rooted tree. And with that, the mystery is solved!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n + 1, 0);\\n        vector<int> candidateA, candidateB;\\n\\n        // Step 1: Detect the candidates for removal\\n        for (const auto& edge : edges) {\\n            int parentOfChild = edge[0];\\n            int child = edge[1];\\n\\n            if (parent[child] == 0) {\\n                // If the child node has no parent, assign the current edge as its parent\\n                parent[child] = parentOfChild;\\n            } else {\\n                // If the child already has a parent, it\\'s a candidate for removal\\n                candidateA = {parent[child], child};\\n                candidateB = edge;\\n\\n                // Temporarily remove the current edge by setting the child to 0\\n                edge[1] = 0;\\n            }\\n        }\\n\\n        // Step 2: Reset parent pointers for the union-find operation\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        // Step 3: Detect if there\\'s a loop and return the appropriate candidate\\n        for (const auto& edge : edges) {\\n            if (edge[1] == 0) {\\n                // Skip edges that were temporarily removed\\n                continue;\\n            }\\n\\n            int parentOfSource = edge[0];\\n            int child = edge[1];\\n            int parentOfSourceRoot = findRoot(parent, parentOfSource);\\n\\n            if (parentOfSourceRoot == child) {\\n                // A loop is detected; return the appropriate candidate\\n                if (candidateA.empty()) {\\n                    return edge;\\n                } else {\\n                    return candidateA;\\n                }\\n            }\\n\\n            // Perform the union operation by updating the parent\\n            parent[child] = parentOfSourceRoot;\\n        }\\n\\n        // If no loop was detected, return candidate B\\n        return candidateB;\\n    }\\n\\nprivate:\\n    int findRoot(vector<int>& parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findRoot(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n + 1, 0);\\n        vector<int> candidateA, candidateB;\\n\\n        // Step 1: Detect the candidates for removal\\n        for (const auto& edge : edges) {\\n            int parentOfChild = edge[0];\\n            int child = edge[1];\\n\\n            if (parent[child] == 0) {\\n                // If the child node has no parent, assign the current edge as its parent\\n                parent[child] = parentOfChild;\\n            } else {\\n                // If the child already has a parent, it\\'s a candidate for removal\\n                candidateA = {parent[child], child};\\n                candidateB = edge;\\n\\n                // Temporarily remove the current edge by setting the child to 0\\n                edge[1] = 0;\\n            }\\n        }\\n\\n        // Step 2: Reset parent pointers for the union-find operation\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        // Step 3: Detect if there\\'s a loop and return the appropriate candidate\\n        for (const auto& edge : edges) {\\n            if (edge[1] == 0) {\\n                // Skip edges that were temporarily removed\\n                continue;\\n            }\\n\\n            int parentOfSource = edge[0];\\n            int child = edge[1];\\n            int parentOfSourceRoot = findRoot(parent, parentOfSource);\\n\\n            if (parentOfSourceRoot == child) {\\n                // A loop is detected; return the appropriate candidate\\n                if (candidateA.empty()) {\\n                    return edge;\\n                } else {\\n                    return candidateA;\\n                }\\n            }\\n\\n            // Perform the union operation by updating the parent\\n            parent[child] = parentOfSourceRoot;\\n        }\\n\\n        // If no loop was detected, return candidate B\\n        return candidateB;\\n    }\\n\\nprivate:\\n    int findRoot(vector<int>& parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findRoot(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430968,
                "title": "solution",
                "content": "```C++ []\\nclass DSU{\\n    private:\\n        vector<int>parent,size;\\n    public:\\n        DSU(int n){\\n            parent.resize(n + 1);\\n            size.resize(n + 1, 1);\\n            for(int i = 0; i <= n; i++)\\n                parent[i] = i;\\n        }\\n        int findPar(int a){\\n            if(a == parent[a])\\n                return a;\\n            return parent[a] = findPar(parent[a]);\\n        }\\n        bool join(int a, int b){\\n            int par_a = findPar(a);\\n            int par_b = findPar(b);\\n            if(par_a == par_b)\\n                return false;\\n            parent[par_a] = par_b;\\n            size[par_b] += size[par_a];\\n            return true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        DSU dsu(n);\\n        vector<int>ans;\\n\\n        int ans1 = -1 , ans2 = -1;\\n        vector<int>indegree(n+ 1, -1);\\n        for(int i = 0; i < n; i++){\\n            if(indegree[edges[i][1]] != -1){\\n                ans1 = i;\\n                ans2 = indegree[edges[i][1]];\\n            }\\n            indegree[edges[i][1]] = i; \\n        }\\n        for(int i =0; i < n; i++){\\n            if(i != ans1 && !dsu.join(edges[i][0], edges[i][1])){\\n                if(ans2 != -1)\\n                    return edges[ans2];\\n                return edges[i];\\n            }\\n        }\\n        return ans = edges[ans1];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        l = [*range(len(edges)+1)]\\n        def find(x):\\n            if l[x]!=x:\\n                l[x] = find(l[x])\\n            return l[x]\\n        def union(x1,x2):\\n            r1 = find(x1)\\n            r2 = find(x2)\\n            if r1!=r2:\\n                l[r2] = r1\\n                return False\\n            return True\\n        last = []\\n        p = {}\\n        can = []\\n        for u,v in edges:\\n            if v in p:\\n                can.append([p[v],v])\\n                can.append([u,v])\\n            else:\\n                p[v] = u\\n                if union(u,v): # hasSameRoot?\\n                    last = [u,v]\\n        if not can:\\n            return last\\n        return can[0] if last else can[1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent ,-1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++){\\n            int p = edges[i][0], c = edges[i][1];\\n            if(parent[c] != -1){\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }\\n            parent[c] = i;\\n            int p2 = find(ds, p);\\n            if(p2 == c)\\n                last = i;\\n            else ds[c] = p2;\\n        }\\n        if(last == -1) return edges[second];\\n        if(second == -1)return edges[last];\\n        return edges[first];\\n    }\\n    private int find(int[] ds, int p){\\n        return ds[p] == 0?p:(ds[p] = find(ds,ds[p]));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass DSU{\\n    private:\\n        vector<int>parent,size;\\n    public:\\n        DSU(int n){\\n            parent.resize(n + 1);\\n            size.resize(n + 1, 1);\\n            for(int i = 0; i <= n; i++)\\n                parent[i] = i;\\n        }\\n        int findPar(int a){\\n            if(a == parent[a])\\n                return a;\\n            return parent[a] = findPar(parent[a]);\\n        }\\n        bool join(int a, int b){\\n            int par_a = findPar(a);\\n            int par_b = findPar(b);\\n            if(par_a == par_b)\\n                return false;\\n            parent[par_a] = par_b;\\n            size[par_b] += size[par_a];\\n            return true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        DSU dsu(n);\\n        vector<int>ans;\\n\\n        int ans1 = -1 , ans2 = -1;\\n        vector<int>indegree(n+ 1, -1);\\n        for(int i = 0; i < n; i++){\\n            if(indegree[edges[i][1]] != -1){\\n                ans1 = i;\\n                ans2 = indegree[edges[i][1]];\\n            }\\n            indegree[edges[i][1]] = i; \\n        }\\n        for(int i =0; i < n; i++){\\n            if(i != ans1 && !dsu.join(edges[i][0], edges[i][1])){\\n                if(ans2 != -1)\\n                    return edges[ans2];\\n                return edges[i];\\n            }\\n        }\\n        return ans = edges[ans1];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        l = [*range(len(edges)+1)]\\n        def find(x):\\n            if l[x]!=x:\\n                l[x] = find(l[x])\\n            return l[x]\\n        def union(x1,x2):\\n            r1 = find(x1)\\n            r2 = find(x2)\\n            if r1!=r2:\\n                l[r2] = r1\\n                return False\\n            return True\\n        last = []\\n        p = {}\\n        can = []\\n        for u,v in edges:\\n            if v in p:\\n                can.append([p[v],v])\\n                can.append([u,v])\\n            else:\\n                p[v] = u\\n                if union(u,v): # hasSameRoot?\\n                    last = [u,v]\\n        if not can:\\n            return last\\n        return can[0] if last else can[1]\\n```\n```Java []\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent ,-1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++){\\n            int p = edges[i][0], c = edges[i][1];\\n            if(parent[c] != -1){\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }\\n            parent[c] = i;\\n            int p2 = find(ds, p);\\n            if(p2 == c)\\n                last = i;\\n            else ds[c] = p2;\\n        }\\n        if(last == -1) return edges[second];\\n        if(second == -1)return edges[last];\\n        return edges[first];\\n    }\\n    private int find(int[] ds, int p){\\n        return ds[p] == 0?p:(ds[p] = find(ds,ds[p]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967742,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        if(findp(u)==findp(v)){return;}\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<vector<int>>v;\\n        int n=0;\\n        for(int i=0; i<edges.size(); i++){\\n            n=max(n, edges[i][0]);\\n            n=max(n, edges[i][1]);\\n        }\\n        disjointset d(n);\\n        vector<int>v1(n+1, -1), vec;\\n        for(int i=0; i<edges.size(); i++){\\n            //cout<<edges[i][1]<<\" \"<<v1[edges[i][1]]<<endl;\\n            if(v1[edges[i][1]]==-1){\\n                v1[edges[i][1]]=i;\\n            }\\n            else{\\n                //cout<<i<<endl;\\n                vec.push_back(i);\\n                vec.push_back(v1[edges[i][1]]);\\n                break;\\n            }\\n        }\\n        if(vec.empty()){\\n            for(auto it: edges){\\n                if(d.findp(it[0])==d.findp(it[1])){\\n                    v.push_back({it[0], it[1]});\\n                }\\n                else{\\n                    d.un(it[0], it[1]);\\n                }\\n            }\\n            // for(int i=0; i<v.size(); i++){\\n            //     cout<<v[i][0]<<\" \"<<v[i][1]<<endl;\\n            // }\\n            return v[v.size()-1];\\n        }\\n        else{\\n            for(int i=0; i<vec.size(); i++){cout<<vec[i]<<\" \";}\\n            for(int i=0; i<edges.size(); i++){\\n                if(i!=vec[0] && d.findp(edges[i][0])==d.findp(edges[i][1])){\\n                    return edges[vec[1]];\\n                }\\n                else if(i!=vec[0] && d.findp(edges[i][0])!=d.findp(edges[i][1])){\\n                    d.un(edges[i][0], edges[i][1]);\\n                }\\n            }\\n            return edges[vec[0]];\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        if(findp(u)==findp(v)){return;}\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<vector<int>>v;\\n        int n=0;\\n        for(int i=0; i<edges.size(); i++){\\n            n=max(n, edges[i][0]);\\n            n=max(n, edges[i][1]);\\n        }\\n        disjointset d(n);\\n        vector<int>v1(n+1, -1), vec;\\n        for(int i=0; i<edges.size(); i++){\\n            //cout<<edges[i][1]<<\" \"<<v1[edges[i][1]]<<endl;\\n            if(v1[edges[i][1]]==-1){\\n                v1[edges[i][1]]=i;\\n            }\\n            else{\\n                //cout<<i<<endl;\\n                vec.push_back(i);\\n                vec.push_back(v1[edges[i][1]]);\\n                break;\\n            }\\n        }\\n        if(vec.empty()){\\n            for(auto it: edges){\\n                if(d.findp(it[0])==d.findp(it[1])){\\n                    v.push_back({it[0], it[1]});\\n                }\\n                else{\\n                    d.un(it[0], it[1]);\\n                }\\n            }\\n            // for(int i=0; i<v.size(); i++){\\n            //     cout<<v[i][0]<<\" \"<<v[i][1]<<endl;\\n            // }\\n            return v[v.size()-1];\\n        }\\n        else{\\n            for(int i=0; i<vec.size(); i++){cout<<vec[i]<<\" \";}\\n            for(int i=0; i<edges.size(); i++){\\n                if(i!=vec[0] && d.findp(edges[i][0])==d.findp(edges[i][1])){\\n                    return edges[vec[1]];\\n                }\\n                else if(i!=vec[0] && d.findp(edges[i][0])!=d.findp(edges[i][1])){\\n                    d.un(edges[i][0], edges[i][1]);\\n                }\\n            }\\n            return edges[vec[0]];\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2839500,
                "title": "help-can-someone-find-what-s-wrong",
                "content": "There is something wrong with my solution but it makes sense to me, can someone explain why the logic of return the first occurring connection edge doesn\\'t work?\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int parent;\\n        vector<int> indegrees(edges.size() + 1, 0);\\n        parent = edges[0][0];\\n        for(vector<int> edge : edges) {\\n            \\n            if(edge[1] == parent || ++indegrees[edge[1]] == 2 || edge[0] == edge[1]) {\\n                return edge;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int parent;\\n        vector<int> indegrees(edges.size() + 1, 0);\\n        parent = edges[0][0];\\n        for(vector<int> edge : edges) {\\n            \\n            if(edge[1] == parent || ++indegrees[edge[1]] == 2 || edge[0] == edge[1]) {\\n                return edge;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375708,
                "title": "union-find-solution-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find_parent(int node,vector<int>& parent){\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = find_parent(parent[node],parent);\\n    }\\n    \\n    void union_find(int u,int v,vector<int>& parent,vector<int>& rank){\\n        u = find_parent(u,parent);\\n        v = find_parent(v,parent);\\n        \\n        if(rank[u]>rank[v]){\\n            parent[v] = u;\\n        }else if(rank[v]>rank[u]){\\n            parent[u] = v;\\n        }else{\\n            parent[v] = u;\\n            rank[u]+=1;\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int bl1 = -1;\\n        int bl2 = -1;\\n        int n = edges.size();\\n        vector<int> indegree(n+1,-1);\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(indegree[v] == -1){\\n                indegree[v] = i;\\n            }else{\\n                bl1 = i; // stores the edge which caused an indegree 2\\n                bl2 = indegree[v]; // stores the edge which caused an indegree 2\\n                break;\\n            }\\n        }\\n        vector<int> parent(n+1);\\n        for(int i=1;i<=n;i++)\\n            parent[i] = i;\\n        vector<int> rank(n+1,0);\\n        \\n         for(int i=0;i<edges.size();i++){\\n             if(i == bl1) // for case 2 bl1 = -1 there wont be any indegree 2 as cycle would be from node to root\\n                 continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(find_parent(u,parent) == find_parent(v,parent)){\\n                if(bl1 == -1)\\n                    return edges[i]; // case 2\\n                else\\n                    return edges[bl2]; //  case 3 we thougth of bl1 as an answer but found a cycle therefore bl2 is the answer\\n            }else{\\n                union_find(u,v,parent,rank);\\n            }\\n        }\\n        return edges[bl1]; // if there is no cycle with bl1 removed then bl1 is the answer\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int find_parent(int node,vector<int>& parent){\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = find_parent(parent[node],parent);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2331519,
                "title": "java-unionfind-and-hascycle",
                "content": "```\\nclass UnionFind{\\n    int[] parents;\\n    int[] ranks;\\n    UnionFind(int n){\\n        parents = new int[n];\\n        ranks = new int[n];\\n        Arrays.fill(ranks, 1);\\n        for (int i = 0; i < n; i++)\\n            parents[i]=i;\\n    }\\n    public int find(int v){\\n        if (parents[v]==v)\\n            return v;\\n        return find(parents[v]);\\n    }\\n    public boolean union(int v1, int v2){\\n        int ar1 = find(v1);\\n        int ar2 = find(v2);\\n        if (ar1 == ar2)\\n            return false;\\n        if (ranks[ar1]> ranks[ar2])\\n            parents[ar2]= ar1;\\n        else if (ranks[ar2]>ranks[ar1])\\n            parents[ar1]=ar2;\\n        else{\\n            parents[ar1]=ar2;\\n            ranks[ar2]++;\\n        }\\n        return true;\\n    }\\n}\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        Integer nodeWith2Indegree = getIndegreeTwo(edges);\\n        UnionFind uf = new UnionFind(edges.length+1);\\n        if (nodeWith2Indegree == null){\\n            for (int[] edge:edges){\\n                if (!uf.union(edge[0], edge[1]))\\n                    return edge;\\n            }\\n        }else{\\n            int[][] twoEdges = new int[2][2];\\n            int top = -1;\\n            for (int[] edge:edges){\\n                if (edge[1]== nodeWith2Indegree)\\n                    twoEdges[++top]= edge;\\n                if (top == 1)\\n                    break;\\n            }\\n            if (hasCycle(uf, edges, twoEdges[1]))\\n                return twoEdges[0];\\n            else\\n                return twoEdges[1];\\n        }\\n        return null;\\n    }\\n    private boolean hasCycle(UnionFind uf, int[][] edges, int[] skipEdge){\\n        for (int[] edge: edges){\\n            if (edge!=skipEdge)\\n                if (!uf.union(edge[0], edge[1]))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    private Integer getIndegreeTwo(int[][] edges){\\n        int[] map = new int[edges.length + 1];\\n        for (int[] edge:edges)\\n            if (++map[edge[1]]==2)\\n                return edge[1];\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind{\\n    int[] parents;\\n    int[] ranks;\\n    UnionFind(int n){\\n        parents = new int[n];\\n        ranks = new int[n];\\n        Arrays.fill(ranks, 1);\\n        for (int i = 0; i < n; i++)\\n            parents[i]=i;\\n    }\\n    public int find(int v){\\n        if (parents[v]==v)\\n            return v;\\n        return find(parents[v]);\\n    }\\n    public boolean union(int v1, int v2){\\n        int ar1 = find(v1);\\n        int ar2 = find(v2);\\n        if (ar1 == ar2)\\n            return false;\\n        if (ranks[ar1]> ranks[ar2])\\n            parents[ar2]= ar1;\\n        else if (ranks[ar2]>ranks[ar1])\\n            parents[ar1]=ar2;\\n        else{\\n            parents[ar1]=ar2;\\n            ranks[ar2]++;\\n        }\\n        return true;\\n    }\\n}\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        Integer nodeWith2Indegree = getIndegreeTwo(edges);\\n        UnionFind uf = new UnionFind(edges.length+1);\\n        if (nodeWith2Indegree == null){\\n            for (int[] edge:edges){\\n                if (!uf.union(edge[0], edge[1]))\\n                    return edge;\\n            }\\n        }else{\\n            int[][] twoEdges = new int[2][2];\\n            int top = -1;\\n            for (int[] edge:edges){\\n                if (edge[1]== nodeWith2Indegree)\\n                    twoEdges[++top]= edge;\\n                if (top == 1)\\n                    break;\\n            }\\n            if (hasCycle(uf, edges, twoEdges[1]))\\n                return twoEdges[0];\\n            else\\n                return twoEdges[1];\\n        }\\n        return null;\\n    }\\n    private boolean hasCycle(UnionFind uf, int[][] edges, int[] skipEdge){\\n        for (int[] edge: edges){\\n            if (edge!=skipEdge)\\n                if (!uf.union(edge[0], edge[1]))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    private Integer getIndegreeTwo(int[][] edges){\\n        int[] map = new int[edges.length + 1];\\n        for (int[] edge:edges)\\n            if (++map[edge[1]]==2)\\n                return edge[1];\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172304,
                "title": "c-union-find-two-conditions-multiple-parents-circle",
                "content": "inspired by https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJava-Union-Find-with-explanation-O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    /*\\n    There are two cases for the tree structure to be invalid.\\n    1) A node having two parents;\\n    2) A circle exists\\n    \\n    If there are both invalid conditions, which means there is a node which has 2 parents and there is also a circle even after we invalid edgeB. \\n    In this case, we have to return edgeA. only in this way can we avoid both double parents and circle for the tree.\\n    */        \\n\\t\\n    int find(vector<int>& par, int n){\\n        if(par[n]==n || par[n]<0) return n;\\n        par[n] = find(par, par[n]);\\n        return par[n];\\n    }    \\n    \\n    void findSpecialEdge(vector<vector<int>>& edges, vector<int>& edgeA, vector<int>& edgeB){\\n        int len = edges.size();\\n        vector<int>par(len+1, 0);\\n        for(vector<int> e : edges){\\n            int p =e[0], c=e[1];\\n            if(par[c]){\\n                edgeA = {par[c], c};\\n                edgeB = e;\\n                return;    \\n            }else{\\n                par[c] = p;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int len = edges.size();\\n        vector<int>parent(len+1, 0);\\n        for(int i=0; i<=len; i++) parent[i]=i;\\n        \\n        vector<int>edgeA={}; // 1st candidate\\n        vector<int>edgeB={}; // 2nd candidate\\n        findSpecialEdge(edges, edgeA, edgeB);\\n        \\n        for(vector<int> e : edges){\\n            int n1 = e[0];\\n            int n2 = e[1];\\n            if(edgeB.size()>0 && (edgeB[0]==n1 && edgeB[1]==n2)){  // invalidate edgeB\\n                continue;\\n            }\\n            int p1 = find(parent, n1);\\n            int p2 = find(parent, n2);\\n            if(p1==p2){ // circle found\\n                if(edgeB.size()>0){\\n                    return edgeA;\\n                }else{\\n                    return e;\\n                }\\n            } else{\\n                parent[p2] = p1;\\n            }\\n        }         \\n        return edgeB;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    There are two cases for the tree structure to be invalid.\\n    1) A node having two parents;\\n    2) A circle exists\\n    \\n    If there are both invalid conditions, which means there is a node which has 2 parents and there is also a circle even after we invalid edgeB. \\n    In this case, we have to return edgeA. only in this way can we avoid both double parents and circle for the tree.\\n    */        \\n\\t\\n    int find(vector<int>& par, int n){\\n        if(par[n]==n || par[n]<0) return n;\\n        par[n] = find(par, par[n]);\\n        return par[n];\\n    }    \\n    \\n    void findSpecialEdge(vector<vector<int>>& edges, vector<int>& edgeA, vector<int>& edgeB){\\n        int len = edges.size();\\n        vector<int>par(len+1, 0);\\n        for(vector<int> e : edges){\\n            int p =e[0], c=e[1];\\n            if(par[c]){\\n                edgeA = {par[c], c};\\n                edgeB = e;\\n                return;    \\n            }else{\\n                par[c] = p;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int len = edges.size();\\n        vector<int>parent(len+1, 0);\\n        for(int i=0; i<=len; i++) parent[i]=i;\\n        \\n        vector<int>edgeA={}; // 1st candidate\\n        vector<int>edgeB={}; // 2nd candidate\\n        findSpecialEdge(edges, edgeA, edgeB);\\n        \\n        for(vector<int> e : edges){\\n            int n1 = e[0];\\n            int n2 = e[1];\\n            if(edgeB.size()>0 && (edgeB[0]==n1 && edgeB[1]==n2)){  // invalidate edgeB\\n                continue;\\n            }\\n            int p1 = find(parent, n1);\\n            int p2 = find(parent, n2);\\n            if(p1==p2){ // circle found\\n                if(edgeB.size()>0){\\n                    return edgeA;\\n                }else{\\n                    return e;\\n                }\\n            } else{\\n                parent[p2] = p1;\\n            }\\n        }         \\n        return edgeB;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802863,
                "title": "c-union-find-with-path-compression-and-union-by-rank-easy-understanding",
                "content": "**Key Takeaway from this question:**\\n\\n1. Test cases of this question will invalidate DFS implementation and forces Union Find implementation\\n2. Test Cases doesn\\'t indicate \"Cycles\" in the graph, there are \"Circular\" formations, but not Cycles defined in Graph Theory.\\n\\t* \\t Example: [[1 ,2], [2, 3], [1, 3]] doesn\\'t form Cycle unless it\\'s edge is [3, 1]. If you pefrom DFS for this example, it won\\'t detect cycle as 3 is not directly connected to 1 and 1 -> 2 -> 3 path will never explore 3 -> 1 as this is not bi-directional and no connection between 1 -> 3\\n\\n```\\n//Case 1 : The additional edge caused a Cycle in the Graph. We find this edge and return it.\\n//Case 2 : The additional edge caused a vertex to have two parents (two incoming edges).\\n    //2a : There is a cycle with one of the parents\\n    //2b : If there is no cycle, decide which parent to remove.\\npublic class Solution {\\n    Dictionary<int, int> incoming = new Dictionary<int, int>();\\n\\n    public int[] FindRedundantDirectedConnection(int[][] edges)\\n    {\\n\\n        // count incoming edges for all nodes\\n        int nodeWithTwoIncomingEdges = -1;\\n        foreach(int[] edge in edges)\\n        {\\n            incoming.TryAdd(edge[1], 0);\\n            incoming[edge[1]] += 1;\\n            if (incoming[edge[1]] == 2) \\n                nodeWithTwoIncomingEdges = edge[1];\\n        }\\n\\n        if (nodeWithTwoIncomingEdges == -1)\\n        {\\n            // if there are no nodes with 2 incoming edges -> just find a cycle\\n            return findRedundantConnection(edges, -1);\\n        }\\n        else\\n        {\\n            // if there is a node with 2 incoming edges -> skip them one by one and try to build a graph\\n            // if we manage to build a graph without a cycle - the skipped node is what we\\'re looking for\\n            for (int i = edges.Length- 1; i >= 0; i--)\\n            {\\n                if (edges[i][1] == nodeWithTwoIncomingEdges)\\n                {\\n                    int[] res = findRedundantConnection(edges, i);\\n                    if (res == null) return edges[i];\\n                }\\n            }\\n        }\\n\\n        return null;\\n    }\\n    // \\'Redundant Connection\\' solution is extended to skip a node.\\n    private int[] findRedundantConnection(int[][] a, int skip)\\n    {\\n        UnionFind uf = new UnionFind(a.Length + 1);\\n\\n        for (int i = 0; i < a.Length; i++)\\n        {\\n            if (i == skip) continue;\\n            if (!uf.Union(a[i][0], a[i][1])) return a[i];\\n        }\\n\\n        return null;\\n    }\\n}\\n\\npublic class UnionFind{\\n    public int[] root;\\n    public int[] rank;\\n    int numberOfConnectedComponents;\\n    public UnionFind(int size){\\n        this.root = new int[size];\\n        this.rank = new int[size];\\n        for(int i = 0; i < size; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n        this.numberOfConnectedComponents = size;\\n    }\\n\\n    public int Find(int node){\\n        if(root[node] == node){\\n            return root[node];\\n        }\\n        return root[node] = Find(root[node]);\\n    }\\n\\n    public bool Union(int nodeA, int nodeB){\\n        int rootA = Find(nodeA);\\n        int rootB = Find(nodeB);\\n\\n        if(rootA != rootB){\\n            if(rank[rootA] > rank[rootB]){\\n                root[rootB] = rootA;\\n            }else if(rank[rootB] > rank[rootA]){\\n                root[rootA] = rootB;\\n            }else{\\n                root[rootB] = rootA;\\n                rank[rootA] += 1;\\n            }\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n\\n    public bool isConnected(int nodeA, int nodeB){\\n        return Find(nodeA) == Find(nodeB);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Case 1 : The additional edge caused a Cycle in the Graph. We find this edge and return it.\\n//Case 2 : The additional edge caused a vertex to have two parents (two incoming edges).\\n    //2a : There is a cycle with one of the parents\\n    //2b : If there is no cycle, decide which parent to remove.\\npublic class Solution {\\n    Dictionary<int, int> incoming = new Dictionary<int, int>();\\n\\n    public int[] FindRedundantDirectedConnection(int[][] edges)\\n    {\\n\\n        // count incoming edges for all nodes\\n        int nodeWithTwoIncomingEdges = -1;\\n        foreach(int[] edge in edges)\\n        {\\n            incoming.TryAdd(edge[1], 0);\\n            incoming[edge[1]] += 1;\\n            if (incoming[edge[1]] == 2) \\n                nodeWithTwoIncomingEdges = edge[1];\\n        }\\n\\n        if (nodeWithTwoIncomingEdges == -1)\\n        {\\n            // if there are no nodes with 2 incoming edges -> just find a cycle\\n            return findRedundantConnection(edges, -1);\\n        }\\n        else\\n        {\\n            // if there is a node with 2 incoming edges -> skip them one by one and try to build a graph\\n            // if we manage to build a graph without a cycle - the skipped node is what we\\'re looking for\\n            for (int i = edges.Length- 1; i >= 0; i--)\\n            {\\n                if (edges[i][1] == nodeWithTwoIncomingEdges)\\n                {\\n                    int[] res = findRedundantConnection(edges, i);\\n                    if (res == null) return edges[i];\\n                }\\n            }\\n        }\\n\\n        return null;\\n    }\\n    // \\'Redundant Connection\\' solution is extended to skip a node.\\n    private int[] findRedundantConnection(int[][] a, int skip)\\n    {\\n        UnionFind uf = new UnionFind(a.Length + 1);\\n\\n        for (int i = 0; i < a.Length; i++)\\n        {\\n            if (i == skip) continue;\\n            if (!uf.Union(a[i][0], a[i][1])) return a[i];\\n        }\\n\\n        return null;\\n    }\\n}\\n\\npublic class UnionFind{\\n    public int[] root;\\n    public int[] rank;\\n    int numberOfConnectedComponents;\\n    public UnionFind(int size){\\n        this.root = new int[size];\\n        this.rank = new int[size];\\n        for(int i = 0; i < size; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n        this.numberOfConnectedComponents = size;\\n    }\\n\\n    public int Find(int node){\\n        if(root[node] == node){\\n            return root[node];\\n        }\\n        return root[node] = Find(root[node]);\\n    }\\n\\n    public bool Union(int nodeA, int nodeB){\\n        int rootA = Find(nodeA);\\n        int rootB = Find(nodeB);\\n\\n        if(rootA != rootB){\\n            if(rank[rootA] > rank[rootB]){\\n                root[rootB] = rootA;\\n            }else if(rank[rootB] > rank[rootA]){\\n                root[rootA] = rootB;\\n            }else{\\n                root[rootB] = rootA;\\n                rank[rootA] += 1;\\n            }\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n\\n    public bool isConnected(int nodeA, int nodeB){\\n        return Find(nodeA) == Find(nodeB);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771592,
                "title": "java-solution-with-very-detail-explanations",
                "content": "```\\nclass Solution\\n{\\n    public int[] findRedundantDirectedConnection(int[][] edges)\\n    {\\n    \\t/* two scenario:\\n    \\t * 0\\xBA all nodes with only 1 in-degree except one node with two in-degree (the extra edge causes)\\n    \\t * \\t  for this situation, find the edges who point to this node (two edges)\\n    \\t * \\t  delete one of the two edges and check if the other edges form a good tree\\n    \\t *    GOOD TREE: the edge is the one to delete\\n    \\t *    NOT TREE: the other edge should be deleted.\\n    \\t * \\n    \\t * 1\\xBA all nodes with only one in-degree.\\n    \\t *    then the extra edge will cause a circle\\n    \\t *    we can use union find to search for the extra edge.\\n    \\t */\\n    \\t// 0\\xBA find the in-degree of all nodes.\\n    \\tint[] degreeOfNodes = new int[edges.length + 1];\\n    \\tint nodeWithTwoDegree = -1;\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\tdegreeOfNodes[edges[i][1]]++;\\n    \\t\\tif (degreeOfNodes[edges[i][1]] == 2)\\n    \\t\\t{\\n    \\t\\t\\t// found the node with two-in-Degrees.\\n    \\t\\t\\tnodeWithTwoDegree = edges[i][1];\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\t// for union find use.\\n    \\tint[] parents = new int[edges.length + 1];\\n        for (int i = 0; i < parents.length; i++)\\n            parents[i] = i;\\n    \\t\\n    \\tif (nodeWithTwoDegree != -1)\\n    \\t\\treturn findRedundantWithTwoInDegree(edges, nodeWithTwoDegree, parents);\\n    \\t\\n    \\t// 1\\xBA No 2-in-degree nodes, circular exists. union find to search for extra edge.\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\t// the two nodes in the same set already, not a corret tree, return the other node\\n    \\t\\tint parentOfFrom = findParent(parents, edges[i][0]);\\n    \\t\\tint parentOfTo = findParent(parents, edges[i][1]);\\n    \\t\\tif (parentOfFrom == parentOfTo)\\n    \\t\\t\\treturn edges[i];\\n    \\t\\t\\n    \\t\\tparents[parentOfTo] = parentOfFrom;\\n    \\t}\\n    \\t\\n    \\treturn null;\\n    }\\n    \\n    private int[] findRedundantWithTwoInDegree(int[][] edges, int nodeWithTwoDegree, int[] parents)\\n    {\\n    \\t// 0\\xBA find the two edge that point to nodeWithTwoDegree.\\n    \\tint[] theTwoEdges = new int[2];\\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < edges.length && index < 2; i++)\\n    \\t{\\n    \\t\\tif (edges[i][1] == nodeWithTwoDegree)\\n    \\t\\t\\ttheTwoEdges[index++] = i;\\n    \\t}\\n    \\t\\n    \\t// 1\\xBA check to delete one of the edges to see if left edges can form a tree\\n    \\t//    begin with the later one first.\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\tif (i == theTwoEdges[1])\\n    \\t\\t\\tcontinue;\\n    \\t\\t\\n    \\t\\t// the two nodes in the same set already, not a corret tree, return the other node\\n    \\t\\tint parentOfFrom = findParent(parents, edges[i][0]);\\n    \\t\\tint parentOfTo = findParent(parents, edges[i][1]);\\n    \\t\\tif (parentOfFrom == parentOfTo)\\n    \\t\\t\\treturn edges[theTwoEdges[0]];\\n    \\t\\t\\n    \\t\\tparents[parentOfTo] = parentOfFrom;\\n    \\t}\\n    \\t\\n    \\treturn edges[theTwoEdges[1]];\\n    }\\n    \\n    // find root node of current node.\\n    private int findParent(int[] parents, int child)\\n    {\\n    \\tif (child == parents[child])\\n    \\t\\treturn child;\\n    \\t\\n    \\treturn findParent(parents, parents[child]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] findRedundantDirectedConnection(int[][] edges)\\n    {\\n    \\t/* two scenario:\\n    \\t * 0\\xBA all nodes with only 1 in-degree except one node with two in-degree (the extra edge causes)\\n    \\t * \\t  for this situation, find the edges who point to this node (two edges)\\n    \\t * \\t  delete one of the two edges and check if the other edges form a good tree\\n    \\t *    GOOD TREE: the edge is the one to delete\\n    \\t *    NOT TREE: the other edge should be deleted.\\n    \\t * \\n    \\t * 1\\xBA all nodes with only one in-degree.\\n    \\t *    then the extra edge will cause a circle\\n    \\t *    we can use union find to search for the extra edge.\\n    \\t */\\n    \\t// 0\\xBA find the in-degree of all nodes.\\n    \\tint[] degreeOfNodes = new int[edges.length + 1];\\n    \\tint nodeWithTwoDegree = -1;\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\tdegreeOfNodes[edges[i][1]]++;\\n    \\t\\tif (degreeOfNodes[edges[i][1]] == 2)\\n    \\t\\t{\\n    \\t\\t\\t// found the node with two-in-Degrees.\\n    \\t\\t\\tnodeWithTwoDegree = edges[i][1];\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\t// for union find use.\\n    \\tint[] parents = new int[edges.length + 1];\\n        for (int i = 0; i < parents.length; i++)\\n            parents[i] = i;\\n    \\t\\n    \\tif (nodeWithTwoDegree != -1)\\n    \\t\\treturn findRedundantWithTwoInDegree(edges, nodeWithTwoDegree, parents);\\n    \\t\\n    \\t// 1\\xBA No 2-in-degree nodes, circular exists. union find to search for extra edge.\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\t// the two nodes in the same set already, not a corret tree, return the other node\\n    \\t\\tint parentOfFrom = findParent(parents, edges[i][0]);\\n    \\t\\tint parentOfTo = findParent(parents, edges[i][1]);\\n    \\t\\tif (parentOfFrom == parentOfTo)\\n    \\t\\t\\treturn edges[i];\\n    \\t\\t\\n    \\t\\tparents[parentOfTo] = parentOfFrom;\\n    \\t}\\n    \\t\\n    \\treturn null;\\n    }\\n    \\n    private int[] findRedundantWithTwoInDegree(int[][] edges, int nodeWithTwoDegree, int[] parents)\\n    {\\n    \\t// 0\\xBA find the two edge that point to nodeWithTwoDegree.\\n    \\tint[] theTwoEdges = new int[2];\\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < edges.length && index < 2; i++)\\n    \\t{\\n    \\t\\tif (edges[i][1] == nodeWithTwoDegree)\\n    \\t\\t\\ttheTwoEdges[index++] = i;\\n    \\t}\\n    \\t\\n    \\t// 1\\xBA check to delete one of the edges to see if left edges can form a tree\\n    \\t//    begin with the later one first.\\n    \\tfor (int i = 0; i < edges.length; i++)\\n    \\t{\\n    \\t\\tif (i == theTwoEdges[1])\\n    \\t\\t\\tcontinue;\\n    \\t\\t\\n    \\t\\t// the two nodes in the same set already, not a corret tree, return the other node\\n    \\t\\tint parentOfFrom = findParent(parents, edges[i][0]);\\n    \\t\\tint parentOfTo = findParent(parents, edges[i][1]);\\n    \\t\\tif (parentOfFrom == parentOfTo)\\n    \\t\\t\\treturn edges[theTwoEdges[0]];\\n    \\t\\t\\n    \\t\\tparents[parentOfTo] = parentOfFrom;\\n    \\t}\\n    \\t\\n    \\treturn edges[theTwoEdges[1]];\\n    }\\n    \\n    // find root node of current node.\\n    private int findParent(int[] parents, int child)\\n    {\\n    \\tif (child == parents[child])\\n    \\t\\treturn child;\\n    \\t\\n    \\treturn findParent(parents, parents[child]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769297,
                "title": "python-union-find-3-cases-explained",
                "content": "First case: By adding extra node, we only created a single cycle, and no node has 2 parents.Apply usual union find and return the latest edge returing false.\\n\\nSecond case: This has a node with 2 parents and no cycle.This might be the third case also.So for checking this take those 2 edges creating 2 parents, first remove latest node from edges ,if union find returns True every time it means this is our answer and the case we considered was 2nd case.\\n\\nThird case: This has a node with 2 parents and a cycle. Similar to case 2, remove the latest node and check if union find returns True everytime.If it returns false it means you removed a node not part of the cycle, so return the other node.Else it was either the 2nd case or you removed a node forming part of cycle which was the actual answer.\\n\\nIn in_degree we store the parent of that node, and not the actual degree of that node.\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        def find(x):\\n                if parent[x]!=x:\\n                    parent[x]=find(parent[x])\\n                return parent[x]\\n            \\n        def union(x,y):\\n            x,y=find(x),find(y)\\n            if x!=y:\\n                parent[y]=x\\n                return True\\n            return False\\n        \\n        n=len(edges)\\n        in_degree=[0]*(n+1)\\n        flag=False\\n        for u,v in edges:\\n            if in_degree[v]:\\n                to,a,b=v,in_degree[v],u       #node_with_2_parents,first_parent,second_parent by order of edges\\n                flag=True\\n                break\\n            else: in_degree[v]=u\\n        parent=[i for i in range(n+1)]\\n        #case:1\\n        if not flag:\\n            for u,v in edges:\\n                if not union(u,v):\\n                    return [u,v]\\n\\t\\t#case 2 && 3\\n        else:\\n            remove=b\\n            edges.remove([b,to])\\n            for u,v in edges:\\n                if not union(u,v):\\n                    return [a,to]\\n            return [b,to]\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        def find(x):\\n                if parent[x]!=x:\\n                    parent[x]=find(parent[x])\\n                return parent[x]\\n            \\n        def union(x,y):\\n            x,y=find(x),find(y)\\n            if x!=y:\\n                parent[y]=x\\n                return True\\n            return False\\n        \\n        n=len(edges)\\n        in_degree=[0]*(n+1)\\n        flag=False\\n        for u,v in edges:\\n            if in_degree[v]:\\n                to,a,b=v,in_degree[v],u       #node_with_2_parents,first_parent,second_parent by order of edges\\n                flag=True\\n                break\\n            else: in_degree[v]=u\\n        parent=[i for i in range(n+1)]\\n        #case:1\\n        if not flag:\\n            for u,v in edges:\\n                if not union(u,v):\\n                    return [u,v]\\n\\t\\t#case 2 && 3\\n        else:\\n            remove=b\\n            edges.remove([b,to])\\n            for u,v in edges:\\n                if not union(u,v):\\n                    return [a,to]\\n            return [b,to]\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716442,
                "title": "python3-solution-o-v-e-space-and-time-heavily-commented",
                "content": "\\t\\t\"\"\"\\n        If you feel my approach can be improved, please let me know in the comments, I will be more than happy to know. \\n\\t\\tAlso, if my complexity analysis is incorrect please put it in the comments. I am still in the learning phase and will be glad to polish myself. \\n\\t\\tI have commented this code heavily to make it more readable and \\n\\t\\tif I have to look back at this after a year, I should not be confused with regard to what has been done.\\n        \"\"\"\\n        \\n        \"\"\"\\n        What we have to do in this question???\\n        in the question, they have mentioned the presence of a rooted tree. Rooted trees are of two types- out tree and in tree.\\n        An out tree is a tree where all the edges point away from the root\\n        Now, Looking at the examples presented, I concluded we have to create an out-tree\\n        \\n        Now, remember, tree does not have any cycle. \\n        Thus, we can conclude that we have to create a tree with the following Conditions\\n        1) All tree nodes are connected. Therefore, find the bridges and you MUST NOT remove the bridges\\n        2) If cycle exists, an edge has to be removed to break the cycle\\n        3) Make sure we create an out-tree. If 2 edges point to the same node, remove one of them  to obey the           concept of out-tree\\n        \\n        What are strongly onnected components?\\n        In a directed graph if a circle is formed then all the nodes in the given circle are said to be strongly connected. \\n        When it is an undirected graph, we say connected but since here we have a directed graph, we\\'re saying strongly connected.\\n        \\n        How to approach this question??\\n        Based on the above, we have decided cycles/bridges are to be found. \\n\\t\\tNow there exists an algorithm for  the same called Tarjan\\'s algorithm to find strongly connected components. \\n        Before I start this algorithm, it is necessary to make an adjacency list. I have created the same using a dicitonary.\\n\\t\\t\\n        Step1: create a graph\\n        step2: use tarjans algorithm\\n        step 3: create a neat array (with proper mapping (u,v)) of strongly connected components\\n        step 4: create an array of edges disobeying the out root tree condition\\n        step 5: apply filtering to find the answer\\n        \"\"\"\\n        \\n        #STEP 1\\n        #creation of a graph\\n        graph = {}\\n        for edge in edges:\\n            start = edge[0] -1\\n            end = edge[1] -1\\n            if start not in graph:\\n                graph[start] = [end]\\n            else:\\n                graph[start].append(end)\\n            if end not in graph:\\n                graph[end] = []\\n        \\n        node_count = len(graph)\\n        \\n        #STEP 2A\\n        #Tarjan\\'s algorithm \\n        def tarjan(graph,node_count):\\n            id = [0]\\n\\n            ids = [-1] * node_count\\n            low = [-1] * node_count \\n            onStack = [False] * node_count \\n            stack = []\\n\\n            for i in range(node_count):\\n                if ids[i] == -1:\\n                    dfsTarjan(i,stack,onStack,ids,low,id,graph)\\n            return low\\n        \\n        #STEP 2B\\n        #Tarjan\\'s algorithm\\n        def dfsTarjan(at,stack,onStack,ids,low,id,graph):\\n            stack.append(at)\\n            onStack[at] = True\\n            ids[at] = low[at] = id[0]\\n            id[0]+=1 \\n\\n            for to in graph[at]:\\n                if ids[to] == -1:\\n                    dfsTarjan(to,stack,onStack,ids,low,id,graph)\\n                if onStack[to]: \\n                    low[at] = min(low[at], low[to])\\n\\n            if ids[at] == low[at]:  \\n                while stack:\\n                    node = stack.pop()\\n                    onStack[node] = False\\n                    low[node] = ids[at] \\n                    if node == at: break\\n        \\n        \"\"\"\\n        getting the lowlink array using Tarjan\\'s algorithm. \\n\\t\\tIf 2 indices have the same value in a low lnk array, we can state with certainty that they are connected. \\n        \"\"\"\\n        lowLinkArray = tarjan(graph,node_count)\\n        edgesReversed = edges[::-1]\\n        #STEP3\\n        #We have a lowLink array but we need proper mapping of edges that form strongly connected components/\\n        stronglyConnected = []\\n        for edge in edgesReversed:\\n            start = edge[0]-1\\n            end = edge[1]-1\\n            if lowLinkArray[start] == lowLinkArray[end]:\\n                stronglyConnected.append(edge)\\n        #At this point the list named stronglyConnected has a list of all components that form the cycle\\n        \\n        #STEP 4A\\n        #Finding the edges that do not obey the condition of outrooted tree\\n        \"\"\"   \\n        We have created a dictionary called OutRootedDisobey. The values are the nodes that point towards the key. \\n\\t\\tIf we have more than one value pointing to the same node, clearly there is a problem and we have  found the edge that we want to remove.\\n        \"\"\" \\n        OutRootedDisobey = {}\\n        for edge in edges:\\n            start = edge[1]\\n            end = edge[0]\\n            if start not in OutRootedDisobey:\\n                OutRootedDisobey[start] = [end]\\n            else:\\n                OutRootedDisobey[start].append(end)\\n        \\n        #STEP 4B\\n        #We need a clear mapping in the form of (u,v) for the edges disbobeying the outroot condition\\n        #iterate over the dictionary and if the length of values is greater than 1 then create a mapping         \\n        notOutRoot = []\\n        for key,values in OutRootedDisobey.items():\\n            if len(values)>1:\\n                for value in values:\\n                    notOutRoot.append([value,key])\\n        \\n        #this section ensures we send the proper edge.\\n        \"\"\"\\n        \\n        At this point we know which edges do not obey outRoot (present in notOutRoot)\\n        At this point we also know the edges that are a part of a cycle (present in stronglyConnected)\\n        \\n        we want to start iterating from the last element because the question asks for the one edge that occurs first if we start from the last.\\n\\t\\tWhile iterating check for the following 3 points.\\n        \\n        1) If an edge exists in a cycle and also does not obey the out rooted tree condition, that\\'s the edge to be hunted first!\\n        2) If we are lucky to find all edges obeying the out root tree condition but the edge is a part of some cycle, remove that particular edge. \\n        \\n        (here, there might be more than one edges that can be removed but the question clearly asks you to remove the one that occurs at the last)\\n        3) Lastly, if we are lucky to not find any cycle but we find an edge disobeying the outRoot tree condition, remove it\\n        \"\"\"\\n        \\n        #STEP 5\\n        for edge in edgesReversed:\\n            if edge in stronglyConnected and edge in notOutRoot:\\n                return edge\\n            elif edge in stronglyConnected and len(notOutRoot) == 0:\\n                return edge\\n            elif edge in notOutRoot and len(stronglyConnected) == 0:\\n                return edge\\n            \\n            \\n        \"\"\"\\n        Complexity analysis\\n        V = total vertices\\n        E = Total edges\\n        Time:\\n        \\n        Step 1: O(E)\\n        step 2: O(V+E)\\n        step 3: O(E)\\n        step 4: OutRootedDisobey = O(E)\\n                NotOutRoot = O(E) #not sure about this\\n        step 5: O(E)\\n        Edge reversal: O(E)\\n        \\n        NET time: O(E) + O(V+E) + O(E) + O(E) + O(E) + O(E) + O(E) = O(V+E)\\n        ----------------------------------------------------------\\n        Space:\\n        Step 1: O(E)\\n        step 2: O(V)\\n        step 3: O(E) in worst case the entire graph is connected\\n        step 4: OutRootedDisobey = O(1)\\n                AND for NotOutRoot, at the most one edge wont obey the condition so O(1)\\n        step 5: O(1)\\n        Edge reversal: O(E)\\n        \\n        NET SPACE: (E) + O(V) + O(E) + O(E) = O(V+E)      \\n        \"\"\"",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "\\t\\t\"\"\"\\n        If you feel my approach can be improved, please let me know in the comments, I will be more than happy to know. \\n\\t\\tAlso, if my complexity analysis is incorrect please put it in the comments. I am still in the learning phase and will be glad to polish myself. \\n\\t\\tI have commented this code heavily to make it more readable and \\n\\t\\tif I have to look back at this after a year, I should not be confused with regard to what has been done.\\n        \"\"\"\\n        \\n        \"\"\"\\n        What we have to do in this question???\\n        in the question, they have mentioned the presence of a rooted tree. Rooted trees are of two types- out tree and in tree.\\n        An out tree is a tree where all the edges point away from the root\\n        Now, Looking at the examples presented, I concluded we have to create an out-tree\\n        \\n        Now, remember, tree does not have any cycle. \\n        Thus, we can conclude that we have to create a tree with the following Conditions\\n        1) All tree nodes are connected. Therefore, find the bridges and you MUST NOT remove the bridges\\n        2) If cycle exists, an edge has to be removed to break the cycle\\n        3) Make sure we create an out-tree. If 2 edges point to the same node, remove one of them  to obey the           concept of out-tree\\n        \\n        What are strongly onnected components?\\n        In a directed graph if a circle is formed then all the nodes in the given circle are said to be strongly connected. \\n        When it is an undirected graph, we say connected but since here we have a directed graph, we\\'re saying strongly connected.\\n        \\n        How to approach this question??\\n        Based on the above, we have decided cycles/bridges are to be found. \\n\\t\\tNow there exists an algorithm for  the same called Tarjan\\'s algorithm to find strongly connected components. \\n        Before I start this algorithm, it is necessary to make an adjacency list. I have created the same using a dicitonary.\\n\\t\\t\\n        Step1: create a graph\\n        step2: use tarjans algorithm\\n        step 3: create a neat array (with proper mapping (u,v)) of strongly connected components\\n        step 4: create an array of edges disobeying the out root tree condition\\n        step 5: apply filtering to find the answer\\n        \"\"\"\\n        \\n        #STEP 1\\n        #creation of a graph\\n        graph = {}\\n        for edge in edges:\\n            start = edge[0] -1\\n            end = edge[1] -1\\n            if start not in graph:\\n                graph[start] = [end]\\n            else:\\n                graph[start].append(end)\\n            if end not in graph:\\n                graph[end] = []\\n        \\n        node_count = len(graph)\\n        \\n        #STEP 2A\\n        #Tarjan\\'s algorithm \\n        def tarjan(graph,node_count):\\n            id = [0]\\n\\n            ids = [-1] * node_count\\n            low = [-1] * node_count \\n            onStack = [False] * node_count \\n            stack = []\\n\\n            for i in range(node_count):\\n                if ids[i] == -1:\\n                    dfsTarjan(i,stack,onStack,ids,low,id,graph)\\n            return low\\n        \\n        #STEP 2B\\n        #Tarjan\\'s algorithm\\n        def dfsTarjan(at,stack,onStack,ids,low,id,graph):\\n            stack.append(at)\\n            onStack[at] = True\\n            ids[at] = low[at] = id[0]\\n            id[0]+=1 \\n\\n            for to in graph[at]:\\n                if ids[to] == -1:\\n                    dfsTarjan(to,stack,onStack,ids,low,id,graph)\\n                if onStack[to]: \\n                    low[at] = min(low[at], low[to])\\n\\n            if ids[at] == low[at]:  \\n                while stack:\\n                    node = stack.pop()\\n                    onStack[node] = False\\n                    low[node] = ids[at] \\n                    if node == at: break\\n        \\n        \"\"\"\\n        getting the lowlink array using Tarjan\\'s algorithm. \\n\\t\\tIf 2 indices have the same value in a low lnk array, we can state with certainty that they are connected. \\n        \"\"\"\\n        lowLinkArray = tarjan(graph,node_count)\\n        edgesReversed = edges[::-1]\\n        #STEP3\\n        #We have a lowLink array but we need proper mapping of edges that form strongly connected components/\\n        stronglyConnected = []\\n        for edge in edgesReversed:\\n            start = edge[0]-1\\n            end = edge[1]-1\\n            if lowLinkArray[start] == lowLinkArray[end]:\\n                stronglyConnected.append(edge)\\n        #At this point the list named stronglyConnected has a list of all components that form the cycle\\n        \\n        #STEP 4A\\n        #Finding the edges that do not obey the condition of outrooted tree\\n        \"\"\"   \\n        We have created a dictionary called OutRootedDisobey. The values are the nodes that point towards the key. \\n\\t\\tIf we have more than one value pointing to the same node, clearly there is a problem and we have  found the edge that we want to remove.\\n        \"\"\" \\n        OutRootedDisobey = {}\\n        for edge in edges:\\n            start = edge[1]\\n            end = edge[0]\\n            if start not in OutRootedDisobey:\\n                OutRootedDisobey[start] = [end]\\n            else:\\n                OutRootedDisobey[start].append(end)\\n        \\n        #STEP 4B\\n        #We need a clear mapping in the form of (u,v) for the edges disbobeying the outroot condition\\n        #iterate over the dictionary and if the length of values is greater than 1 then create a mapping         \\n        notOutRoot = []\\n        for key,values in OutRootedDisobey.items():\\n            if len(values)>1:\\n                for value in values:\\n                    notOutRoot.append([value,key])\\n        \\n        #this section ensures we send the proper edge.\\n        \"\"\"\\n        \\n        At this point we know which edges do not obey outRoot (present in notOutRoot)\\n        At this point we also know the edges that are a part of a cycle (present in stronglyConnected)\\n        \\n        we want to start iterating from the last element because the question asks for the one edge that occurs first if we start from the last.\\n\\t\\tWhile iterating check for the following 3 points.\\n        \\n        1) If an edge exists in a cycle and also does not obey the out rooted tree condition, that\\'s the edge to be hunted first!\\n        2) If we are lucky to find all edges obeying the out root tree condition but the edge is a part of some cycle, remove that particular edge. \\n        \\n        (here, there might be more than one edges that can be removed but the question clearly asks you to remove the one that occurs at the last)\\n        3) Lastly, if we are lucky to not find any cycle but we find an edge disobeying the outRoot tree condition, remove it\\n        \"\"\"\\n        \\n        #STEP 5\\n        for edge in edgesReversed:\\n            if edge in stronglyConnected and edge in notOutRoot:\\n                return edge\\n            elif edge in stronglyConnected and len(notOutRoot) == 0:\\n                return edge\\n            elif edge in notOutRoot and len(stronglyConnected) == 0:\\n                return edge\\n            \\n            \\n        \"\"\"\\n        Complexity analysis\\n        V = total vertices\\n        E = Total edges\\n        Time:\\n        \\n        Step 1: O(E)\\n        step 2: O(V+E)\\n        step 3: O(E)\\n        step 4: OutRootedDisobey = O(E)\\n                NotOutRoot = O(E) #not sure about this\\n        step 5: O(E)\\n        Edge reversal: O(E)\\n        \\n        NET time: O(E) + O(V+E) + O(E) + O(E) + O(E) + O(E) + O(E) = O(V+E)\\n        ----------------------------------------------------------\\n        Space:\\n        Step 1: O(E)\\n        step 2: O(V)\\n        step 3: O(E) in worst case the entire graph is connected\\n        step 4: OutRootedDisobey = O(1)\\n                AND for NotOutRoot, at the most one edge wont obey the condition so O(1)\\n        step 5: O(1)\\n        Edge reversal: O(E)\\n        \\n        NET SPACE: (E) + O(V) + O(E) + O(E) = O(V+E)      \\n        \"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1706417,
                "title": "few-test-cases-to-test-your-solution-before-submitting",
                "content": "```\\n[[1,2],[1,3],[2,3]]\\n[[1,3],[2,3],[1,2]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[5,2],[5,1],[3,1],[3,4],[3,5]]\\n[[1,2],[3,1],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n```",
                "solutionTags": [],
                "code": "```\\n[[1,2],[1,3],[2,3]]\\n[[1,3],[2,3],[1,2]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[5,2],[5,1],[3,1],[3,4],[3,5]]\\n[[1,2],[3,1],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1543712,
                "title": "c-concept-explanation-no-union-find",
                "content": "**Idea**\\nUnlike most other solutions posted and even the official attached topic with the problem, I have not used Union Find. The idea is that the original rooted tree had the indegree of all of its nodes as ```1``` except the root which had ```0``` indegree. Then, when an extra edge was added, then there are only two possible ways the tree could have got modified. They are: \\n1) The new edge could be from any non-root edge to the root edge. In this case, the indegree of the root changes to ```1``` from ```0```. \\n2) The new edge could be added from any non-root edge to another non-root edge. In this case, the indegree of the node to which the edge was added will become ```2```.\\n\\nNow, we need to figure out which case does the given tree belong to. In case, it belongs to the first case, then we know that the original root node is now hidden among the nodes having indegree of ```1```. But the root node still possesses the property that every other node can be reached from it. Why? Because the extra edge does not delete any connection from the root to any other node, it rather added a redundant connection. Now, we run bfs from each node having indegree ```1``` and check if every node can be visited from that node. If so, then we have identified the root node of the original tree and can just delete the only edge which connects this node to its only parent (because the root has no parent, this must be the extra edge).\\nIn case, the second category is where out tree falls into, then we just pick the edge which has indegree ```2``` and try deleting each of its 2 edges 1 at a time and run bfs on the resulting tree from the ```0``` indegree vertex (which must be the original root) to check for connected vertices. If connected, then the deleted edge must be the extra edge. \\n\\n**C++ Solution**\\n```\\nint n;\\nset<int> adj[1001] = {};\\nint indeg[1001] = {};\\n\\nbool bfs(int node){\\n\\tqueue<int> q;\\n\\tvector<bool> visited(n+1, false);\\n\\n\\tq.push(node);\\n\\tvisited[node] = true;\\n\\tint countVis = 1;\\n\\n\\twhile(!q.empty()){\\n\\t\\tint poped = q.front();\\n\\t\\tq.pop();\\n\\n\\t\\tfor(int neigh: adj[poped]){\\n\\t\\t\\tif(!visited[neigh]){\\n\\t\\t\\t\\tq.push(neigh);\\n\\t\\t\\t\\tvisited[neigh] = true;\\n\\t\\t\\t\\tcountVis += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn countVis == n;\\n}\\n\\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\tthis->n = edges.size();\\n\\tint res = -1;\\n\\n\\tfor(auto edge: edges){\\n\\t\\tadj[edge[0]].insert(edge[1]);\\n\\t\\tindeg[edge[1]]++;\\n\\t}\\n\\n\\tint zeroIndeg = -1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tif(indeg[i] == 0){\\n\\t\\t\\tzeroIndeg = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tif(zeroIndeg == -1){\\n\\n\\t\\tfor(int i = n-1; i >= 0; i--){\\n\\t\\t\\tauto edge = edges[i];\\n\\n\\t\\t\\tif(indeg[edge[1]] == 1){\\n\\t\\t\\t\\tif(bfs(edge[1])){\\n\\t\\t\\t\\t\\tres = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telse{\\n\\t\\tint twoIndeg = -1;\\n\\t\\tfor(int i = 1; i <= n; i++){\\n\\t\\t\\tif(indeg[i] == 2){\\n\\t\\t\\t\\ttwoIndeg = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor(int i = n-1; i >= 0; i--){\\n\\t\\t\\tauto edge = edges[i];\\n\\n\\t\\t\\tif(edge[1] == twoIndeg){\\n\\t\\t\\t\\tadj[edge[0]].erase(edge[1]);\\n\\t\\t\\t\\tif(bfs(zeroIndeg)){\\n\\t\\t\\t\\t\\tres = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tadj[edge[0]].insert(edge[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn edges[res];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```1```\n```0```\n```1```\n```0```\n```2```\n```1```\n```1```\n```2```\n```0```\n```\\nint n;\\nset<int> adj[1001] = {};\\nint indeg[1001] = {};\\n\\nbool bfs(int node){\\n\\tqueue<int> q;\\n\\tvector<bool> visited(n+1, false);\\n\\n\\tq.push(node);\\n\\tvisited[node] = true;\\n\\tint countVis = 1;\\n\\n\\twhile(!q.empty()){\\n\\t\\tint poped = q.front();\\n\\t\\tq.pop();\\n\\n\\t\\tfor(int neigh: adj[poped]){\\n\\t\\t\\tif(!visited[neigh]){\\n\\t\\t\\t\\tq.push(neigh);\\n\\t\\t\\t\\tvisited[neigh] = true;\\n\\t\\t\\t\\tcountVis += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn countVis == n;\\n}\\n\\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\tthis->n = edges.size();\\n\\tint res = -1;\\n\\n\\tfor(auto edge: edges){\\n\\t\\tadj[edge[0]].insert(edge[1]);\\n\\t\\tindeg[edge[1]]++;\\n\\t}\\n\\n\\tint zeroIndeg = -1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tif(indeg[i] == 0){\\n\\t\\t\\tzeroIndeg = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tif(zeroIndeg == -1){\\n\\n\\t\\tfor(int i = n-1; i >= 0; i--){\\n\\t\\t\\tauto edge = edges[i];\\n\\n\\t\\t\\tif(indeg[edge[1]] == 1){\\n\\t\\t\\t\\tif(bfs(edge[1])){\\n\\t\\t\\t\\t\\tres = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telse{\\n\\t\\tint twoIndeg = -1;\\n\\t\\tfor(int i = 1; i <= n; i++){\\n\\t\\t\\tif(indeg[i] == 2){\\n\\t\\t\\t\\ttwoIndeg = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor(int i = n-1; i >= 0; i--){\\n\\t\\t\\tauto edge = edges[i];\\n\\n\\t\\t\\tif(edge[1] == twoIndeg){\\n\\t\\t\\t\\tadj[edge[0]].erase(edge[1]);\\n\\t\\t\\t\\tif(bfs(zeroIndeg)){\\n\\t\\t\\t\\t\\tres = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tadj[edge[0]].insert(edge[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn edges[res];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459376,
                "title": "java-solution-union-find",
                "content": "```\\nclass Solution {\\n    public class UnionFind{\\n        int[] parent;\\n        int[] rank;\\n        UnionFind(int vtces){\\n            parent=new int[vtces];\\n            rank=new int[vtces];\\n            for(int i=0;i<vtces;i++){\\n                parent[i]=i;\\n            }\\n            Arrays.fill(rank,0);\\n        }\\n        int find(int x){\\n            if(parent[x]==x){\\n                return x;\\n            }\\n            return parent[x]=find(parent[x]);\\n        }\\n        boolean union(int x,int y){\\n            int lx=find(x);\\n            int ly=find(y);\\n            \\n            if(lx!=ly){\\n                int rank1=rank[lx];\\n                int rank2=rank[ly];\\n                \\n                if(rank1>rank2){\\n                    parent[ly]=lx;\\n                }else if(rank2>rank1){\\n                    parent[lx]=ly;\\n                }else{\\n                    parent[ly]=lx;\\n                    rank[lx]++;\\n                }\\n                return false;\\n            }else{\\n                return true;\\n            }\\n        }\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] indegree=new int[edges.length+1];\\n        Arrays.fill(indegree,-1);\\n        int bl1=-1;\\n        int bl2=-1;\\n        for(int i=0;i<edges.length;i++){\\n            int[] edge=edges[i];\\n            int u=edge[0];\\n            int v=edge[1];\\n            if(indegree[v]==-1){\\n                indegree[v]=i;\\n            }else{\\n                bl1=i;\\n                bl2=indegree[v];\\n            }\\n        }\\n        UnionFind uf=new UnionFind(edges.length+1);\\n        for(int i=0;i<edges.length;i++){\\n            if(i==bl1){\\n                continue;\\n            }\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            boolean flag=uf.union(u,v);\\n            \\n            if(flag==true){//cycle case\\n                if(bl1==-1){\\n                    return edges[i]; //only cycle\\n                }else{\\n                    return edges[bl2];//2 parent + cycle\\n                }\\n            }\\n        }\\n        return edges[bl1];// 2 parent\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public class UnionFind{\\n        int[] parent;\\n        int[] rank;\\n        UnionFind(int vtces){\\n            parent=new int[vtces];\\n            rank=new int[vtces];\\n            for(int i=0;i<vtces;i++){\\n                parent[i]=i;\\n            }\\n            Arrays.fill(rank,0);\\n        }\\n        int find(int x){\\n            if(parent[x]==x){\\n                return x;\\n            }\\n            return parent[x]=find(parent[x]);\\n        }\\n        boolean union(int x,int y){\\n            int lx=find(x);\\n            int ly=find(y);\\n            \\n            if(lx!=ly){\\n                int rank1=rank[lx];\\n                int rank2=rank[ly];\\n                \\n                if(rank1>rank2){\\n                    parent[ly]=lx;\\n                }else if(rank2>rank1){\\n                    parent[lx]=ly;\\n                }else{\\n                    parent[ly]=lx;\\n                    rank[lx]++;\\n                }\\n                return false;\\n            }else{\\n                return true;\\n            }\\n        }\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] indegree=new int[edges.length+1];\\n        Arrays.fill(indegree,-1);\\n        int bl1=-1;\\n        int bl2=-1;\\n        for(int i=0;i<edges.length;i++){\\n            int[] edge=edges[i];\\n            int u=edge[0];\\n            int v=edge[1];\\n            if(indegree[v]==-1){\\n                indegree[v]=i;\\n            }else{\\n                bl1=i;\\n                bl2=indegree[v];\\n            }\\n        }\\n        UnionFind uf=new UnionFind(edges.length+1);\\n        for(int i=0;i<edges.length;i++){\\n            if(i==bl1){\\n                continue;\\n            }\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            boolean flag=uf.union(u,v);\\n            \\n            if(flag==true){//cycle case\\n                if(bl1==-1){\\n                    return edges[i]; //only cycle\\n                }else{\\n                    return edges[bl2];//2 parent + cycle\\n                }\\n            }\\n        }\\n        return edges[bl1];// 2 parent\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448181,
                "title": "c-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int x, vector<int>& parent) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x],parent);\\n    }\\n    \\n    void unionVal(int u, int v, vector<int>& parent, vector<int>& rank) {\\n        int lx = find(u,parent);\\n        int ly = find(v,parent);\\n        \\n        if(lx!=ly)\\n        {\\n            if(rank[lx] > rank[ly]) {\\n                parent[ly] = lx;\\n            } else if(rank[ly] > rank[lx]) {\\n                parent[lx] = ly;\\n            } else {\\n                parent[ly] = lx;\\n                rank[lx]++;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1,-1),rank(n+1,1);\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n            parent[i] = i;\\n        \\n        vector<int> adj[n+1];\\n        vector<int> ind(n+1,-1);\\n        int bl1 = -1 , bl2 = -1;\\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            \\n            if(ind[edges[i][1]] != -1)\\n            {\\n                bl1 = i;\\n                bl2 = ind[edges[i][1]];\\n                continue;\\n            }\\n            \\n            ind[edges[i][1]] = i;\\n        }\\n        \\n        if(bl1 == -1)\\n        {\\n            vector<int> ans;\\n            \\n            for(auto it : edges)\\n            {\\n                int u = it[0];\\n                int v = it[1];\\n                \\n                if(find(u,parent) != find(v,parent))\\n                    unionVal(u,v,parent,rank);\\n                else\\n                    ans = it;\\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            bool isCycle = false;\\n            //cout<<bl1<<\" \"<<bl2;\\n            for(int i = 0 ; i < edges.size() ; i++)\\n            {\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                \\n                if(i == bl1) continue;\\n                \\n                if(find(u,parent) != find(v,parent))\\n                    unionVal(u,v,parent,rank);\\n                else\\n                {\\n                    isCycle = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCycle)\\n                return edges[bl2];\\n            else\\n                return edges[bl1];\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int x, vector<int>& parent) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x],parent);\\n    }\\n    \\n    void unionVal(int u, int v, vector<int>& parent, vector<int>& rank) {\\n        int lx = find(u,parent);\\n        int ly = find(v,parent);\\n        \\n        if(lx!=ly)\\n        {\\n            if(rank[lx] > rank[ly]) {\\n                parent[ly] = lx;\\n            } else if(rank[ly] > rank[lx]) {\\n                parent[lx] = ly;\\n            } else {\\n                parent[ly] = lx;\\n                rank[lx]++;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1,-1),rank(n+1,1);\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n            parent[i] = i;\\n        \\n        vector<int> adj[n+1];\\n        vector<int> ind(n+1,-1);\\n        int bl1 = -1 , bl2 = -1;\\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            \\n            if(ind[edges[i][1]] != -1)\\n            {\\n                bl1 = i;\\n                bl2 = ind[edges[i][1]];\\n                continue;\\n            }\\n            \\n            ind[edges[i][1]] = i;\\n        }\\n        \\n        if(bl1 == -1)\\n        {\\n            vector<int> ans;\\n            \\n            for(auto it : edges)\\n            {\\n                int u = it[0];\\n                int v = it[1];\\n                \\n                if(find(u,parent) != find(v,parent))\\n                    unionVal(u,v,parent,rank);\\n                else\\n                    ans = it;\\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            bool isCycle = false;\\n            //cout<<bl1<<\" \"<<bl2;\\n            for(int i = 0 ; i < edges.size() ; i++)\\n            {\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                \\n                if(i == bl1) continue;\\n                \\n                if(find(u,parent) != find(v,parent))\\n                    unionVal(u,v,parent,rank);\\n                else\\n                {\\n                    isCycle = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCycle)\\n                return edges[bl2];\\n            else\\n                return edges[bl1];\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1424201,
                "title": "python3-dsu-with-path-compression-and-union-by-rank-reuse-684",
                "content": "For #684 we can use Union-Find/ Disjoin Set Union optionally with path compression + union by rank to get the reduntant connection. The logic here is basically to see if any two nodes that have an edge have the same parent then that edge is redundant.\\n\\nIn the case of directed graph, the idea is similar, however we can account for directed paths by using in-degrees.\\n\\nA redundant connection is only possible with a node with more than one parent i.e in-degrees > 1.\\n\\nFor all edges with such nodes (indegree > 1) we check if the rest of the edges have a reduntant connection. \\n\\n```\\nfrom typing import *\\nimport collections\\n\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = {i + 1 : i + 1 for i in range(n)}\\n        self.rank = {i + 1: 1 for i in range(n)}\\n\\n    def find(self, x):\\n\\t    # path compression\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n\\t    # union by rank\\n        x = self.find(x)\\n        y = self.find(y)\\n        if self.rank[x] <= self.rank[y]:\\n            self.rank[y] += self.rank[x]\\n            self.rank[x] = 0\\n            self.parent[x] = y\\n        else:\\n            self.rank[x] += self.rank[y]\\n            self.rank[y] = 0\\n            self.parent[y] = x\\n\\nclass Solution:\\n    def findRedundantConnection(self, edges: List[List[int]], n=None) -> List[int]:\\n\\t    # this is AC soln for 684 with small modification -> pass how many nodes are in the tree/graph\\n\\t\\t# to build the correct DSU\\n        if not n:   n = len(edges)\\n        dsu = DSU(n)\\n        res = None\\n        for u, v in edges:\\n            if dsu.find(u) == dsu.find(v):\\n                return [u, v]\\n            else:\\n                dsu.union(u, v)\\n        return res\\n\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        node_with_two_incoming = 0\\n\\n        indegrees = collections.defaultdict(int)\\n        for parent, child in edges:\\n            indegrees[child] += 1\\n            if indegrees[child] == 2:\\n                node_with_two_incoming = child\\n\\t\\t# if there are no nodes with indegrees > 1 the problem reduces to the undirected case\\n        if not node_with_two_incoming:  return self.findRedundantConnection(edges, n)\\n\\t\\t# start removing each edge with the problematic node that has two parents.\\n        for i in range(len(edges) -1, -1, -1):\\n            parent, child = edges[i]\\n            if child == node_with_two_incoming:\\n                temp_edges = edges[:i] + edges[i + 1:]\\n                res = self.findRedundantConnection(temp_edges, n)\\n                if not res: # if there are no redundant connection then the current edge is the redundant one\\n                    return [parent, child]\\n```",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nfrom typing import *\\nimport collections\\n\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = {i + 1 : i + 1 for i in range(n)}\\n        self.rank = {i + 1: 1 for i in range(n)}\\n\\n    def find(self, x):\\n\\t    # path compression\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n\\t    # union by rank\\n        x = self.find(x)\\n        y = self.find(y)\\n        if self.rank[x] <= self.rank[y]:\\n            self.rank[y] += self.rank[x]\\n            self.rank[x] = 0\\n            self.parent[x] = y\\n        else:\\n            self.rank[x] += self.rank[y]\\n            self.rank[y] = 0\\n            self.parent[y] = x\\n\\nclass Solution:\\n    def findRedundantConnection(self, edges: List[List[int]], n=None) -> List[int]:\\n\\t    # this is AC soln for 684 with small modification -> pass how many nodes are in the tree/graph\\n\\t\\t# to build the correct DSU\\n        if not n:   n = len(edges)\\n        dsu = DSU(n)\\n        res = None\\n        for u, v in edges:\\n            if dsu.find(u) == dsu.find(v):\\n                return [u, v]\\n            else:\\n                dsu.union(u, v)\\n        return res\\n\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        node_with_two_incoming = 0\\n\\n        indegrees = collections.defaultdict(int)\\n        for parent, child in edges:\\n            indegrees[child] += 1\\n            if indegrees[child] == 2:\\n                node_with_two_incoming = child\\n\\t\\t# if there are no nodes with indegrees > 1 the problem reduces to the undirected case\\n        if not node_with_two_incoming:  return self.findRedundantConnection(edges, n)\\n\\t\\t# start removing each edge with the problematic node that has two parents.\\n        for i in range(len(edges) -1, -1, -1):\\n            parent, child = edges[i]\\n            if child == node_with_two_incoming:\\n                temp_edges = edges[:i] + edges[i + 1:]\\n                res = self.findRedundantConnection(temp_edges, n)\\n                if not res: # if there are no redundant connection then the current edge is the redundant one\\n                    return [parent, child]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295783,
                "title": "javascript-union-find-72ms-100",
                "content": "```\\nconst findRedundantDirectedConnection = (edges) => {\\n    let n = edges.length;\\n    let parent = Array(n + 1).fill(0);\\n    let first = [];\\n    let second = [];\\n    for (const e of edges) {\\n        if (parent[e[1]] == 0) {\\n            parent[e[1]] = e[0];\\n        } else {\\n            first = [parent[e[1]], e[1]];\\n            second = [...e];\\n            e[1] = 0;\\n        }\\n    }\\n    for (let i = 0; i <= n; ++i) parent[i] = i;\\n    for (const e of edges) {\\n        if (e[1] == 0) continue;\\n        let [x, y] = [find(parent, e[0]), find(parent, e[1])];\\n        if (x == y) return first.length == 0 ? e : first;\\n        parent[x] = y;\\n    }\\n    return second;\\n};\\n\\nconst find = (parent, x) => {\\n    return x == parent[x] ? x : find(parent, parent[x]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findRedundantDirectedConnection = (edges) => {\\n    let n = edges.length;\\n    let parent = Array(n + 1).fill(0);\\n    let first = [];\\n    let second = [];\\n    for (const e of edges) {\\n        if (parent[e[1]] == 0) {\\n            parent[e[1]] = e[0];\\n        } else {\\n            first = [parent[e[1]], e[1]];\\n            second = [...e];\\n            e[1] = 0;\\n        }\\n    }\\n    for (let i = 0; i <= n; ++i) parent[i] = i;\\n    for (const e of edges) {\\n        if (e[1] == 0) continue;\\n        let [x, y] = [find(parent, e[0]), find(parent, e[1])];\\n        if (x == y) return first.length == 0 ? e : first;\\n        parent[x] = y;\\n    }\\n    return second;\\n};\\n\\nconst find = (parent, x) => {\\n    return x == parent[x] ? x : find(parent, parent[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268800,
                "title": "java-union-find-94-solve-two-cases",
                "content": "```\\n// union find\\n\\n// The graph has n nodes and n edges, meaning there must be a cycle\\n// With the extra egde: the graph will have 2 cases\\n// case 1: there is one and only one node with indegree of 2. In this case, it must be one of \\n// the two in edges of this node to be removed\\n// case 2: each node has at most 1 indegree. in this case, iterate all edges, the extra edge will \\n// create a cycle.\\n\\n\\nclass Solution {\\n    int[] parent;\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        \\n        parent = new int[n + 1];\\n        Arrays.fill(parent, -1);\\n\\n        int[] inDegree = new int[n + 1];\\n        \\n        for (int[] e: edges) inDegree[e[1]]++;\\n\\n        int node = -1;\\n        for (int i = 1; i <= n; i++) {\\n            if (inDegree[i] == 2) {\\n                node = i;\\n                break;\\n            }\\n        }\\n        // Case 1: there is one and only one node, n, with indegree of 2, so one of them must be removed.\\n        if (node != -1) {\\n            // union all edges except for the in edges of node n\\n            for (int[] e: edges) {\\n                int u = e[0];\\n                int v = e[1];\\n                if (v == node) continue;\\n                union(u, v);\\n            }\\n            for (int[] e: edges) {\\n                int u = e[0];\\n                int v = e[1];\\n                if (v == node) {\\n                    if (find(u) != find(v)) {\\n                        union(u, v);\\n                    } else {\\n                        return e;\\n                    }\\n                }\\n            } \\n            return null;\\n        }\\n        \\n        // Case 2: there is no nodes with indegree greater than 1\\n        for (int[] e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            if (find(u) == find(v)) return e;\\n            union(u, v);\\n        }\\n        return null;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (parent[r] >= 0) {\\n            r = parent[r];\\n        }\\n        \\n        if (r == x) return r;\\n        int p = parent[x];\\n        while (p >= 0) {\\n            parent[x] = r;\\n            x = p;\\n            p = parent[x];\\n        }\\n        return r;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int px = find(x);\\n        int py = find(y);\\n        if (px == py) return;\\n        \\n        if (parent[px] > parent[py]) {\\n            parent[py] += parent[px];\\n            parent[px] = py;\\n        } else {\\n            parent[px] += parent[py];\\n            parent[py] = px;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// union find\\n\\n// The graph has n nodes and n edges, meaning there must be a cycle\\n// With the extra egde: the graph will have 2 cases\\n// case 1: there is one and only one node with indegree of 2. In this case, it must be one of \\n// the two in edges of this node to be removed\\n// case 2: each node has at most 1 indegree. in this case, iterate all edges, the extra edge will \\n// create a cycle.\\n\\n\\nclass Solution {\\n    int[] parent;\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        \\n        parent = new int[n + 1];\\n        Arrays.fill(parent, -1);\\n\\n        int[] inDegree = new int[n + 1];\\n        \\n        for (int[] e: edges) inDegree[e[1]]++;\\n\\n        int node = -1;\\n        for (int i = 1; i <= n; i++) {\\n            if (inDegree[i] == 2) {\\n                node = i;\\n                break;\\n            }\\n        }\\n        // Case 1: there is one and only one node, n, with indegree of 2, so one of them must be removed.\\n        if (node != -1) {\\n            // union all edges except for the in edges of node n\\n            for (int[] e: edges) {\\n                int u = e[0];\\n                int v = e[1];\\n                if (v == node) continue;\\n                union(u, v);\\n            }\\n            for (int[] e: edges) {\\n                int u = e[0];\\n                int v = e[1];\\n                if (v == node) {\\n                    if (find(u) != find(v)) {\\n                        union(u, v);\\n                    } else {\\n                        return e;\\n                    }\\n                }\\n            } \\n            return null;\\n        }\\n        \\n        // Case 2: there is no nodes with indegree greater than 1\\n        for (int[] e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            if (find(u) == find(v)) return e;\\n            union(u, v);\\n        }\\n        return null;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (parent[r] >= 0) {\\n            r = parent[r];\\n        }\\n        \\n        if (r == x) return r;\\n        int p = parent[x];\\n        while (p >= 0) {\\n            parent[x] = r;\\n            x = p;\\n            p = parent[x];\\n        }\\n        return r;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int px = find(x);\\n        int py = find(y);\\n        if (px == py) return;\\n        \\n        if (parent[px] > parent[py]) {\\n            parent[py] += parent[px];\\n            parent[px] = py;\\n        } else {\\n            parent[px] += parent[py];\\n            parent[py] = px;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220712,
                "title": "an-easy-understand-code",
                "content": "class Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int N = edges.length;\\n        int[] in_degree = new int[N+1];\\n        \\n        //Build the adjacency matrix\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            int start = edge[0];\\n            int end = edge[1];\\n            in_degree[end]++;\\n            if(!map.containsKey(start)) map.put(start, new HashSet<>());\\n            map.get(start).add(end);\\n        }\\n        \\n        //for every edge, delete it and see if there is a loop. if there is no a loop and all the nodes can be traverse, return the edge\\n        for(int i=N-1; i>=0; i--){\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n            in_degree[end]--;\\n            map.get(start).remove(end);\\n            for(int j=1; j<=N; j++){\\n                if(in_degree[j] == 0){\\n                    Set<Integer> visited = new HashSet<>();\\n                    if(dfs(map, j, visited) && visited.size() == N) return edges[i];\\n                    break;\\n                }\\n            }\\n            map.get(start).add(end);\\n            in_degree[end]++;\\n        }\\n        return null;\\n    }\\n    \\n    //if there is a loop\\n    public boolean dfs(Map<Integer, Set<Integer>> map, int start, Set<Integer> visited){\\n        if(visited.contains(start)) return false;\\n        visited.add(start);\\n        Set<Integer> neighbors = map.get(start);\\n        if(neighbors != null){\\n            for(int neighbor : neighbors){\\n                if(!dfs(map, neighbor, visited)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int N = edges.length;\\n        int[] in_degree = new int[N+1];\\n        \\n        //Build the adjacency matrix\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            int start = edge[0];\\n            int end = edge[1];\\n            in_degree[end]++;\\n            if(!map.containsKey(start)) map.put(start, new HashSet<>());\\n            map.get(start).add(end);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1180211,
                "title": "extremely-good-question-of-union-find-java",
                "content": "So there are three cases when connecting a and b:\\n1. connecting a to b causes a cycle where b is the root of the cycle. \\n2. a and b already have a common ancestor and connecting a to b means that b has two incoming edges\\n3. connecting a and b is safe, that is only contributes to building of the tree. \\n\\nNow, if there is case 2, with the ancestor being say, x, then it means that x - b and a -b are two possible answers for removal, so we push them into the candidate edges list. \\nIn case 1, we need to add the last edge of the cycle to the list of cycles. \\n\\nNow, see this test case:\\n[[2,1],[3,1],[4,2],[1,4]]\\n                    3\\n                     |\\n4 --> 2 ---> 1\\n^____________|\\n We see that 2 -1  is always returned. Why is this natural to happen?\\nNow this demonstrates the use of the conditions in the lines of if (hasCycle).\\nIf we add the edge (3 - 1) first, then when we add the edge (4 - 1), parent of 1 is 3, and of 4 is 4. So this falls under case 2. So, 2-1 is returned because 3 - 1 is not cause of the cycle and since we have two candidates the other candidate should be cause of the cycle then. \\nBut if (2 - 1) is added first, then when we add (4 - 1), parent of 1 is 4, and of 4 is 4 as well. So this falls under case 1 and again (2- 1) is returned as 2 is reponsible for root(parent[1]) = 4. \\n\\n\\n```\\nclass Solution {\\n    public void union(int[] parent, int a, int b){\\n        parent[b] = a;\\n    }\\n    public int root(int[] parent, int a){\\n        if (parent[a] != a){return root(parent, parent[a]);}\\n        return a;\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] parent = new int[n + 1];\\n        for (int i = 0; i < n + 1; i++){parent[i] = i;}\\n        ArrayList<int[]> candidate = new ArrayList<>();\\n         ArrayList<int[]> cycle = new ArrayList<>();\\n        boolean hasCycle =false;\\n        for (int i = 0; i < n; i++){\\n            int a = edges[i][0]; int b = edges[i][1];\\n            if (parent[b] == b && root(parent, a) != root(parent, b)){\\n                union(parent, a, b);\\n            }\\n            else if (parent[b] != b){\\n                candidate.add(new int[]{parent[b], b});\\n                candidate.add(edges[i]);\\n            }\\n            else {\\n                hasCycle = true;\\n                cycle.add(edges[i]);\\n            }\\n        }\\n        if (hasCycle){\\n            if (!candidate.isEmpty()) return candidate.get(0);\\n            return cycle.get(0);\\n        }\\n        return candidate.get(candidate.size() - 1);\\n    }\\n  \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void union(int[] parent, int a, int b){\\n        parent[b] = a;\\n    }\\n    public int root(int[] parent, int a){\\n        if (parent[a] != a){return root(parent, parent[a]);}\\n        return a;\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] parent = new int[n + 1];\\n        for (int i = 0; i < n + 1; i++){parent[i] = i;}\\n        ArrayList<int[]> candidate = new ArrayList<>();\\n         ArrayList<int[]> cycle = new ArrayList<>();\\n        boolean hasCycle =false;\\n        for (int i = 0; i < n; i++){\\n            int a = edges[i][0]; int b = edges[i][1];\\n            if (parent[b] == b && root(parent, a) != root(parent, b)){\\n                union(parent, a, b);\\n            }\\n            else if (parent[b] != b){\\n                candidate.add(new int[]{parent[b], b});\\n                candidate.add(edges[i]);\\n            }\\n            else {\\n                hasCycle = true;\\n                cycle.add(edges[i]);\\n            }\\n        }\\n        if (hasCycle){\\n            if (!candidate.isEmpty()) return candidate.get(0);\\n            return cycle.get(0);\\n        }\\n        return candidate.get(candidate.size() - 1);\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167210,
                "title": "c-o-n-union-find-w-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        const int n = edges.size();\\n        \\n        // The parent vector used for the union-find set.\\n        parent.resize(n + 1, 0);\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = i;\\n        }\\n        \\n        // pre[i] = j: there is a directed edge (j, i).\\n        vector<int> pre(n + 1, -1);\\n        \\n        // After the for-loop below, u == -1 if and only if there is no node with indegree 2.\\n        // If there is a node with indegree 2, then (pre_u, u) is its second inbound edge.\\n        // Note:\\n        // - There will be at most 1 node with indegree 2: this is because one extra edge can add only\\n        //   1 indegree to the graph\\n        // - There can be 0 node with indegree 2: this will happen if and only if the extra edge is\\n        //   pointing to the root of the tree\\n        // - When u != -1, its first inbound edge is (pre[u], u).\\n        int u = -1, pre_u;\\n        \\n        // (s, t) is the edge after which the there will be a *undirected* loop (when direction is\\n        // considered, it\\'s not necessarily a cycle). This can be detected with union-find set.\\n        int s = 1, t = 1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (pre[edges[i][1]] == -1) {\\n                pre[edges[i][1]] = edges[i][0];\\n            } else {\\n                u = edges[i][1];\\n                pre_u = edges[i][0];\\n            }\\n            if (!merge(edges[i][0], edges[i][1])) {\\n                s = edges[i][0];\\n                t = edges[i][1];\\n            }\\n        }\\n        \\n        // Detect the whether there is a directed cycle.\\n        int lp = s;\\n        while (pre[lp] != s && pre[lp] != -1) {\\n            lp = pre[lp];\\n        }\\n        \\n        if (pre[lp] == -1) { // no cycle\\n            // When there is no cycle, the second inbound edge to u\\n            // is an \"cross edge\", remove it.\\n            return {pre_u, u};\\n        } else { // there is cycle\\n            if (u == -1) {\\n                // There is no node with indegree as 2, so the last edge added that\\n                // made it a cycle should be removed.\\n                return {s, t};\\n            } else {\\n                // There is a node with indegree as 2, remove its inbound edge that\\'s\\n                // on the cycle.\\n                return {pre[u], u};\\n            }\\n        }\\n        \\n        // This will never be reached.\\n        return {};\\n    }\\n    \\nprivate:\\n    int find(int u) {\\n        if (parent[u] != u) {\\n            parent[u] = find(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    \\n    bool merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        if (u != v) {\\n            parent[u] =v;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> parent;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        const int n = edges.size();\\n        \\n        // The parent vector used for the union-find set.\\n        parent.resize(n + 1, 0);\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = i;\\n        }\\n        \\n        // pre[i] = j: there is a directed edge (j, i).\\n        vector<int> pre(n + 1, -1);\\n        \\n        // After the for-loop below, u == -1 if and only if there is no node with indegree 2.\\n        // If there is a node with indegree 2, then (pre_u, u) is its second inbound edge.\\n        // Note:\\n        // - There will be at most 1 node with indegree 2: this is because one extra edge can add only\\n        //   1 indegree to the graph\\n        // - There can be 0 node with indegree 2: this will happen if and only if the extra edge is\\n        //   pointing to the root of the tree\\n        // - When u != -1, its first inbound edge is (pre[u], u).\\n        int u = -1, pre_u;\\n        \\n        // (s, t) is the edge after which the there will be a *undirected* loop (when direction is\\n        // considered, it\\'s not necessarily a cycle). This can be detected with union-find set.\\n        int s = 1, t = 1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (pre[edges[i][1]] == -1) {\\n                pre[edges[i][1]] = edges[i][0];\\n            } else {\\n                u = edges[i][1];\\n                pre_u = edges[i][0];\\n            }\\n            if (!merge(edges[i][0], edges[i][1])) {\\n                s = edges[i][0];\\n                t = edges[i][1];\\n            }\\n        }\\n        \\n        // Detect the whether there is a directed cycle.\\n        int lp = s;\\n        while (pre[lp] != s && pre[lp] != -1) {\\n            lp = pre[lp];\\n        }\\n        \\n        if (pre[lp] == -1) { // no cycle\\n            // When there is no cycle, the second inbound edge to u\\n            // is an \"cross edge\", remove it.\\n            return {pre_u, u};\\n        } else { // there is cycle\\n            if (u == -1) {\\n                // There is no node with indegree as 2, so the last edge added that\\n                // made it a cycle should be removed.\\n                return {s, t};\\n            } else {\\n                // There is a node with indegree as 2, remove its inbound edge that\\'s\\n                // on the cycle.\\n                return {pre[u], u};\\n            }\\n        }\\n        \\n        // This will never be reached.\\n        return {};\\n    }\\n    \\nprivate:\\n    int find(int u) {\\n        if (parent[u] != u) {\\n            parent[u] = find(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    \\n    bool merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        if (u != v) {\\n            parent[u] =v;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> parent;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061229,
                "title": "c-simple-union-find-solution-one-pass",
                "content": "While connecting an edge to two nodes a->b , we need to check \\ni. if a and b are not connected already\\nii. if a the parent of b is b, ie b has not been connected with any other node yet\\nIf both condition i and ii are true, then we can connect both of these nodes.\\n\\nHowever, if b has already been connected with some other node previously (ie if ii is false), then the two edges\\nparent[b]->b and a->b are candidate edges. By candidate edges, we mean either of these two need to be removed. We will check later which one needs to be removed. For now, we have already connected the edge parent[b]->b. We will not be considering the edge a->b. \\n\\nBut if condition i is false, ie, these two nodes have already been connected previously, it means that we have a cycle in our graph, which means that some edge that we had included previously needed to be eliminated. \\n\\nNow we know from our candidates, that the edge parent[b]->b was included. So if there is a cycle, exclude this one. If there is no cycle, then the edge a->b stored in candidate, needs to be excluded.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void unionn(vector<int>&parent, int a, int b){\\n        int p=a;\\n        int q=b;\\n        parent[q]=p;\\n    }\\n    int root(vector<int>&parent, int a){\\n        int r=a;\\n        while(r!=parent[r]){\\n            r=parent[r];\\n        }\\n        return r;\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<int>parent(n+1);\\n        \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        vector<vector<int> >cand,cycle;\\n        bool hasCycle=false;\\n        for(int i=0;i<n;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            if(root(parent,a)!=root(parent,b) && parent[b]==b){\\n                unionn(parent,a,b);\\n            }else if(parent[b]!=b){\\n                cand.push_back({parent[b],b});\\n                cand.push_back({a,b});\\n            }else{\\n                hasCycle=true;\\n                cycle.push_back(edges[i]);\\n            }\\n        }\\n        if(hasCycle){\\n            if(cand.size()!=0)\\n                return cand[0];\\n            return cycle[0];\\n        }\\n        return cand[cand.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void unionn(vector<int>&parent, int a, int b){\\n        int p=a;\\n        int q=b;\\n        parent[q]=p;\\n    }\\n    int root(vector<int>&parent, int a){\\n        int r=a;\\n        while(r!=parent[r]){\\n            r=parent[r];\\n        }\\n        return r;\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<int>parent(n+1);\\n        \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        vector<vector<int> >cand,cycle;\\n        bool hasCycle=false;\\n        for(int i=0;i<n;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            if(root(parent,a)!=root(parent,b) && parent[b]==b){\\n                unionn(parent,a,b);\\n            }else if(parent[b]!=b){\\n                cand.push_back({parent[b],b});\\n                cand.push_back({a,b});\\n            }else{\\n                hasCycle=true;\\n                cycle.push_back(edges[i]);\\n            }\\n        }\\n        if(hasCycle){\\n            if(cand.size()!=0)\\n                return cand[0];\\n            return cycle[0];\\n        }\\n        return cand[cand.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850448,
                "title": "python-concise-solution-with-union-find",
                "content": "There are two cases in this problem. Based on [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/).\\n1. same as 684, if we find[x]==find[y] before union, this edge is redundant.\\n2. There is only one root means for each node must have only one parent.\\nFor the case `[[2,1],[3,1],[4,2],[1,4]]`\\n```\\n  2 \\u2190 4\\n  \\u2193 \\u2197 \\n  1 \\u2190 3\\n```\\nif 1 has two parents (2, 3), we must delete one. So when wo meet `[1, 3]`, did nothing but record. Finally, If all nodes connected, just delete `[1, 3]`, otherwise, delete`[2, 1]`, use a `pare` record parent of each node, we can find `[2, 1]` by `pare`.\\n```python\\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\n      def union(x, y):\\n          uf[find(x)] = find(y)\\n\\n      def find(x):\\n          if x != uf[x]:\\n              uf[x] = find(uf[x])\\n          return uf[x]\\n        \\n      ans, N, pare = None, len(edges), {}\\n      uf = list(range(N+1))\\n      for u, v in edges:\\n          if v in pare:\\n              ans = (u, v)\\n              continue\\n          if find(u)==find(v) and not ans:\\n              ans = (u, v)\\n          union(u, v)\\n          pare[v] = u\\n      return ans if len(set(map(find, range(1, N+1))))==1 else (pare[ans[1]], ans[1])\\n```",
                "solutionTags": [],
                "code": "```\\n  2 \\u2190 4\\n  \\u2193 \\u2197 \\n  1 \\u2190 3\\n```\n```python\\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\n      def union(x, y):\\n          uf[find(x)] = find(y)\\n\\n      def find(x):\\n          if x != uf[x]:\\n              uf[x] = find(uf[x])\\n          return uf[x]\\n        \\n      ans, N, pare = None, len(edges), {}\\n      uf = list(range(N+1))\\n      for u, v in edges:\\n          if v in pare:\\n              ans = (u, v)\\n              continue\\n          if find(u)==find(v) and not ans:\\n              ans = (u, v)\\n          union(u, v)\\n          pare[v] = u\\n      return ans if len(set(map(find, range(1, N+1))))==1 else (pare[ans[1]], ans[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 729524,
                "title": "c-detect-multiple-parent-and-cycle-with-explanation",
                "content": "We have directed graph as rooted tree (all nodes have single parent, only root has 0 parent) plus one redudant edge as input. That redudant edge might cause one of the nodes to have two parents or lead to cycle in graph.\\n\\nSo, We first check parent of each edge and if we found such edge, we consider it as redudant candidate. However, we need more step to check that after removing that edge there should not be cycle in the graph.\\n\\nConsider example : [[1,2],[2,3],[3,1],[4,3]]\\n```\\n   2 -> 3 <- 4\\n   ^   /\\n    \\\\ v      \\n     1\\n```\\n\\nHere, we find 3 as having multiple parents ([2,3],[4,3]) and we detect [4,3] as last edge so it is our candidate. However, after removing it still there would be cycle in the graph. In that case, we need to consider the first parent [2,3] as answer, since it would always be case it is one causing cycle (check with other examples to prove it).\\n\\nIf there were no cycle after removing candidate with node having multiple parent then we have made the right choice and that is the answer.\\n\\nIf there were no node with multiple parent, there must be the cycle in graph as there is one redudant edge. We can find the first edge causing the cycle and return it as answer.\\n\\nThe cycle detection can be done in many ways - one of it can be using Subsets (also known as Union-Find algorithm).\\n\\n```csharp\\npublic class Solution\\n{\\n    public class Subset\\n    {\\n        public int Representative {get; set;}\\n        public int Rank {get; set;}\\n        \\n        public static void Union(Subset[] subsets, int first, int second)\\n        {\\n            if(subsets[first].Rank < subsets[second].Rank)\\n            {\\n                subsets[first].Representative = subsets[second].Representative;\\n            }\\n            \\n            else if (subsets[second].Rank < subsets[first].Rank)\\n            {\\n                subsets[second].Representative = subsets[first].Representative;\\n            }\\n            \\n            else\\n            {\\n                subsets[second].Representative = first;\\n                subsets[first].Rank++;\\n            }\\n        }\\n                \\n        public static int Find(Subset[] subsets, int val)\\n        {\\n            if(subsets[val].Representative != val)\\n            {\\n                subsets[val].Representative = Find(subsets, subsets[val].Representative);\\n            }\\n            \\n            return subsets[val].Representative;\\n        }\\n        \\n    }\\n    \\n    public int[] FindRedundantDirectedConnection(int[][] edges) \\n    {\\n        int[] parent = new int[edges.Length + 1];        \\n        int edgeWithMultipleParents = -1;\\n        int edgeFormingCycle = -1;\\n        \\n        // Find edge with more than one parent\\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n            \\n            if(parent[end] > 0)\\n            {\\n                edgeWithMultipleParents = i;\\n                break;\\n            }\\n            \\n            parent[end] = start;\\n        }\\n        \\n        // Find cycle\\n        Subset[] subsets = new Subset[edges.Length + 1];\\n        for(int i = 0; i < subsets.Length; i++)\\n        {\\n            subsets[i] = new Subset(){ Representative = i};\\n        }\\n        \\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            if(edgeWithMultipleParents == i)\\n            {\\n                continue;\\n            }\\n            \\n            int first = Subset.Find(subsets, edges[i][0]);\\n            int second = Subset.Find(subsets, edges[i][1]);\\n            \\n            if(first == second)\\n            {\\n                edgeFormingCycle = i;\\n                break;\\n            }\\n            \\n            Subset.Union(subsets, first, second);\\n        }\\n        \\n        if(edgeWithMultipleParents == -1)\\n        {\\n            return edges[edgeFormingCycle];\\n        }\\n            \\n        if(edgeFormingCycle == -1)\\n        {\\n            return edges[edgeWithMultipleParents];            \\n        }\\n        \\n        int v = edges[edgeWithMultipleParents][1];\\n        int u = parent[v];\\n        return new int[] { u, v };        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   2 -> 3 <- 4\\n   ^   /\\n    \\\\ v      \\n     1\\n```\n```csharp\\npublic class Solution\\n{\\n    public class Subset\\n    {\\n        public int Representative {get; set;}\\n        public int Rank {get; set;}\\n        \\n        public static void Union(Subset[] subsets, int first, int second)\\n        {\\n            if(subsets[first].Rank < subsets[second].Rank)\\n            {\\n                subsets[first].Representative = subsets[second].Representative;\\n            }\\n            \\n            else if (subsets[second].Rank < subsets[first].Rank)\\n            {\\n                subsets[second].Representative = subsets[first].Representative;\\n            }\\n            \\n            else\\n            {\\n                subsets[second].Representative = first;\\n                subsets[first].Rank++;\\n            }\\n        }\\n                \\n        public static int Find(Subset[] subsets, int val)\\n        {\\n            if(subsets[val].Representative != val)\\n            {\\n                subsets[val].Representative = Find(subsets, subsets[val].Representative);\\n            }\\n            \\n            return subsets[val].Representative;\\n        }\\n        \\n    }\\n    \\n    public int[] FindRedundantDirectedConnection(int[][] edges) \\n    {\\n        int[] parent = new int[edges.Length + 1];        \\n        int edgeWithMultipleParents = -1;\\n        int edgeFormingCycle = -1;\\n        \\n        // Find edge with more than one parent\\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n            \\n            if(parent[end] > 0)\\n            {\\n                edgeWithMultipleParents = i;\\n                break;\\n            }\\n            \\n            parent[end] = start;\\n        }\\n        \\n        // Find cycle\\n        Subset[] subsets = new Subset[edges.Length + 1];\\n        for(int i = 0; i < subsets.Length; i++)\\n        {\\n            subsets[i] = new Subset(){ Representative = i};\\n        }\\n        \\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            if(edgeWithMultipleParents == i)\\n            {\\n                continue;\\n            }\\n            \\n            int first = Subset.Find(subsets, edges[i][0]);\\n            int second = Subset.Find(subsets, edges[i][1]);\\n            \\n            if(first == second)\\n            {\\n                edgeFormingCycle = i;\\n                break;\\n            }\\n            \\n            Subset.Union(subsets, first, second);\\n        }\\n        \\n        if(edgeWithMultipleParents == -1)\\n        {\\n            return edges[edgeFormingCycle];\\n        }\\n            \\n        if(edgeFormingCycle == -1)\\n        {\\n            return edges[edgeWithMultipleParents];            \\n        }\\n        \\n        int v = edges[edgeWithMultipleParents][1];\\n        int u = parent[v];\\n        return new int[] { u, v };        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689027,
                "title": "simple-c-solution-union-find-indegree",
                "content": "The approach for this problem is: ** no node in a tree can have 2 parents **\\nSo, i calculated the indegrees of all the nodes. if indegree > 1 , that means that this node has more than 1 parent, so one of the edge pointing to this node must be removed.\\nSo, if indegree of node > 1, i push the edge in a queue for later processing, else i connect the 2 nodes together via Union Find. While connecting 2 nodes, if both the nodes have same parent then these nodes are pushed to res vector.\\n\\nAfter we have processed all the edges, and if we have edges in the queue to be processed, we loop over them and as done earlier connect them via Union Find. If 2 nodes have same parent, push the nodes in a vector.\\n\\nAs we are maintaining the order while pushing in the queue, this will return us the last node that can be removed.\\n\\nreturn the resultant vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> res;\\n        vector<int> parent(1001);\\n        \\n        // populate array with incrementing numbers.\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<int> rank(1001, 0);\\n        vector<int> indegree(1001,0);\\n        queue<pair<int,int>> q;\\n        vector<int> newRes;\\n        \\n        // find indegree of nodes\\n        // if indegree > 1, means node has 2 parents\\n        for(vector<int> v: edges) {\\n            indegree[v[1]]++;\\n        }\\n\\n        for(vector<int> v: edges) {\\n            // if we are visiting node which has 2 parents\\n            // we do not consider that edge intially\\n            // just push nodes in a data structure, queue in this case\\n            // for lateral ref\\n            // else connect nodes using Union find\\n            if (indegree[v[1]] > 1) {\\n                q.push(make_pair(v[0], v[1]));\\n            } else if (!Union(v[0], v[1], parent, rank)) {\\n                // we visit node with same parent\\n                // store these edge nodes in res vector\\n                res.push_back(v[0]);\\n                res.push_back(v[1]);\\n            }\\n        }\\n        \\n        // if queue is not empty\\n        // try connecting these nodes now and\\n        // check if they break the tree structure.\\n        while (!q.empty()) {\\n            pair<int,int> qEle = q.front();\\n            q.pop();\\n            \\n            if (!Union(qEle.first, qEle.second, parent, rank)) {\\n                // if same parent store in newRes vector\\n                newRes.push_back(qEle.first);\\n                newRes.push_back(qEle.second);\\n            }\\n        }\\n        \\n        if (newRes.size()) return newRes;\\n        return res;\\n    }\\n    \\n    // find parent of a given node.\\n    int find(int x, vector<int> &parent) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x], parent);\\n        }\\n        return parent[x];\\n    }\\n    \\n    // connect 2 nodes.\\n    bool Union(int x, int y, vector<int> &parent, vector<int> &rank) {\\n        int xr = find(x, parent);\\n        int yr = find(y, parent);\\n        \\n        if (xr == yr) {\\n            return false;\\n        } else if(rank[xr] > rank[yr]){\\n            parent[yr] = xr;\\n        } else if(rank[yr] > rank[xr]) {\\n            parent[xr] = yr;\\n        } else {\\n            parent[yr] = xr;\\n            rank[xr]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> res;\\n        vector<int> parent(1001);\\n        \\n        // populate array with incrementing numbers.\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<int> rank(1001, 0);\\n        vector<int> indegree(1001,0);\\n        queue<pair<int,int>> q;\\n        vector<int> newRes;\\n        \\n        // find indegree of nodes\\n        // if indegree > 1, means node has 2 parents\\n        for(vector<int> v: edges) {\\n            indegree[v[1]]++;\\n        }\\n\\n        for(vector<int> v: edges) {\\n            // if we are visiting node which has 2 parents\\n            // we do not consider that edge intially\\n            // just push nodes in a data structure, queue in this case\\n            // for lateral ref\\n            // else connect nodes using Union find\\n            if (indegree[v[1]] > 1) {\\n                q.push(make_pair(v[0], v[1]));\\n            } else if (!Union(v[0], v[1], parent, rank)) {\\n                // we visit node with same parent\\n                // store these edge nodes in res vector\\n                res.push_back(v[0]);\\n                res.push_back(v[1]);\\n            }\\n        }\\n        \\n        // if queue is not empty\\n        // try connecting these nodes now and\\n        // check if they break the tree structure.\\n        while (!q.empty()) {\\n            pair<int,int> qEle = q.front();\\n            q.pop();\\n            \\n            if (!Union(qEle.first, qEle.second, parent, rank)) {\\n                // if same parent store in newRes vector\\n                newRes.push_back(qEle.first);\\n                newRes.push_back(qEle.second);\\n            }\\n        }\\n        \\n        if (newRes.size()) return newRes;\\n        return res;\\n    }\\n    \\n    // find parent of a given node.\\n    int find(int x, vector<int> &parent) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x], parent);\\n        }\\n        return parent[x];\\n    }\\n    \\n    // connect 2 nodes.\\n    bool Union(int x, int y, vector<int> &parent, vector<int> &rank) {\\n        int xr = find(x, parent);\\n        int yr = find(y, parent);\\n        \\n        if (xr == yr) {\\n            return false;\\n        } else if(rank[xr] > rank[yr]){\\n            parent[yr] = xr;\\n        } else if(rank[yr] > rank[xr]) {\\n            parent[xr] = yr;\\n        } else {\\n            parent[yr] = xr;\\n            rank[xr]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560156,
                "title": "test-case-failing-for-java-solution",
                "content": "I wrote a union find solution to solve the problem but it fails for the test case [[2,1],[3,1],[4,2],[1,4]]. The expected answer is [2,1] but my code gives [1,4]. I can\\'t figure out how the answer will be [2,1]? Can somebody explain?\\n```\\nclass Solution {\\n    public int[] setUnion(int[][] edges){\\n        List<HashSet<Integer>> sets = new ArrayList<HashSet<Integer>>();\\n        int[] result = new int[2];\\n        for(int i=0; i<edges.length; i++){\\n            int first=-1, second=-1;\\n            int index = 0;\\n            for(Set s: sets){\\n                if(s.contains(edges[i][0])) first = index;\\n                if(s.contains(edges[i][1])) second = index;\\n                index++;\\n            }\\n     //       System.out.println(first+\" \"+second);\\n            if(first == -1 && second == -1){\\n                HashSet<Integer> newset = new HashSet<>();\\n                newset.add(edges[i][0]);\\n                newset.add(edges[i][1]);\\n                sets.add(newset);\\n            } else if(first != -1 && second != -1 && first!=second){\\n                sets.get(first).addAll(sets.get(second));\\n                sets.remove(second);\\n            } else if(first != -1 && second != -1 && first==second){\\n                result[0] = edges[i][0];\\n                result[1] = edges[i][1]; \\n                break;\\n            } else if(first == -1){\\n                sets.get(second).add(edges[i][0]);\\n            } else if(second == -1){\\n                sets.get(first).add(edges[i][1]); \\n            }\\n        }\\n        return result;\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n    \\n        return setUnion(edges);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] setUnion(int[][] edges){\\n        List<HashSet<Integer>> sets = new ArrayList<HashSet<Integer>>();\\n        int[] result = new int[2];\\n        for(int i=0; i<edges.length; i++){\\n            int first=-1, second=-1;\\n            int index = 0;\\n            for(Set s: sets){\\n                if(s.contains(edges[i][0])) first = index;\\n                if(s.contains(edges[i][1])) second = index;\\n                index++;\\n            }\\n     //       System.out.println(first+\" \"+second);\\n            if(first == -1 && second == -1){\\n                HashSet<Integer> newset = new HashSet<>();\\n                newset.add(edges[i][0]);\\n                newset.add(edges[i][1]);\\n                sets.add(newset);\\n            } else if(first != -1 && second != -1 && first!=second){\\n                sets.get(first).addAll(sets.get(second));\\n                sets.remove(second);\\n            } else if(first != -1 && second != -1 && first==second){\\n                result[0] = edges[i][0];\\n                result[1] = edges[i][1]; \\n                break;\\n            } else if(first == -1){\\n                sets.get(second).add(edges[i][0]);\\n            } else if(second == -1){\\n                sets.get(first).add(edges[i][1]); \\n            }\\n        }\\n        return result;\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n    \\n        return setUnion(edges);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465372,
                "title": "java-solution-using-broken-circle-method",
                "content": "```\\nclass Solution {\\n    //685. Redundant Connection II\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        if(edges==null||edges.length==0) return null;\\n        //record all edges inside the ring\\n        Set<Integer> s=new HashSet<>();\\n        int[] degree=new int[edges.length+1];\\n        while(true){\\n            boolean flag=false;\\n            for (int[] edge : edges) {\\n                if (!s.contains(edge[0]) && !s.contains(edge[1])) {\\n                    degree[edge[0]] += 1;\\n                    degree[edge[1]] += 1;\\n                }\\n            }\\n            for(int i=1;i<=edges.length;++i){\\n                if(degree[i]==1){\\n                    s.add(i);\\n                    flag=true;\\n                }\\n                degree[i]=0;//clear\\n            }\\n            if(!flag) break;\\n        }\\n\\n        int[] inDegree=new int[edges.length+1];\\n        for (int[] edge : edges) {\\n            inDegree[edge[1]] += 1;//in-degree\\n        }\\n        int[] ans=new int[2];\\n        for(int i=edges.length-1;i>=0;--i){\\n            if(!s.contains(edges[i][0])&&!s.contains(edges[i][1])){//a node has multiple parent\\n                if(inDegree[edges[i][1]]>1){\\n                    ans[0]=edges[i][0];\\n                    ans[1]=edges[i][1];\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        //reach here, it shows that no node has multiple parent in the graph. just delete the first matching edge from back to front.\\n        for(int i=edges.length-1;i>=0;--i){\\n            if(!s.contains(edges[i][0])&&!s.contains(edges[i][1])){\\n                ans[0]=edges[i][0];\\n                ans[1]=edges[i][1];\\n                return ans;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //685. Redundant Connection II\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        if(edges==null||edges.length==0) return null;\\n        //record all edges inside the ring\\n        Set<Integer> s=new HashSet<>();\\n        int[] degree=new int[edges.length+1];\\n        while(true){\\n            boolean flag=false;\\n            for (int[] edge : edges) {\\n                if (!s.contains(edge[0]) && !s.contains(edge[1])) {\\n                    degree[edge[0]] += 1;\\n                    degree[edge[1]] += 1;\\n                }\\n            }\\n            for(int i=1;i<=edges.length;++i){\\n                if(degree[i]==1){\\n                    s.add(i);\\n                    flag=true;\\n                }\\n                degree[i]=0;//clear\\n            }\\n            if(!flag) break;\\n        }\\n\\n        int[] inDegree=new int[edges.length+1];\\n        for (int[] edge : edges) {\\n            inDegree[edge[1]] += 1;//in-degree\\n        }\\n        int[] ans=new int[2];\\n        for(int i=edges.length-1;i>=0;--i){\\n            if(!s.contains(edges[i][0])&&!s.contains(edges[i][1])){//a node has multiple parent\\n                if(inDegree[edges[i][1]]>1){\\n                    ans[0]=edges[i][0];\\n                    ans[1]=edges[i][1];\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        //reach here, it shows that no node has multiple parent in the graph. just delete the first matching edge from back to front.\\n        for(int i=edges.length-1;i>=0;--i){\\n            if(!s.contains(edges[i][0])&&!s.contains(edges[i][1])){\\n                ans[0]=edges[i][0];\\n                ans[1]=edges[i][1];\\n                return ans;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410210,
                "title": "python-union-find-circle-detect",
                "content": "When all nodes has only one parent, then no need to consider map direction. We can use union find to union all nodes without direction, and delete first (or any) connection that already exists union set. Actually, we don\\'t need to even use union find in case of \"all one parent\". We only need to find a circle. But the questions requires returning the last connection when multiple results exists. Union find is suitable for such situation.\\n\\nWhen a node has 2 parents, then the two parents must be the only 2 candidates that can be removed. We detect circle for these 2 paths, and delete the one that forms a circle.\\n\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        def isloop(end):\\n            cur=end\\n            while cur in parents:\\n                cur=parents[cur]\\n                if cur==end:\\n                    return True\\n            return False\\n        uf={}\\n        def find(x):\\n            uf.setdefault(x,x)\\n            if uf[x]!=x:\\n                uf[x]=find(uf[x])\\n            return uf[x]\\n        def union(x,y):\\n            uf[find(x)]=find(y)\\n        parents={}\\n        unionCandidate=[]\\n        candidates=[]\\n        for start,end in edges:\\n            if end not in parents:\\n                parents[end]=start\\n            else:\\n                candidates=[[parents[end],end],[start,end]]\\n            if find(start)==find(end):\\n                unionCandidate=[start,end]\\n            else:\\n                union(start,end)\\n        if candidates:\\n            if isloop(candidates[0][1]):\\n                return candidates[0]\\n            return candidates[1]\\n        else:\\n            return unionCandidate\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        def isloop(end):\\n            cur=end\\n            while cur in parents:\\n                cur=parents[cur]\\n                if cur==end:\\n                    return True\\n            return False\\n        uf={}\\n        def find(x):\\n            uf.setdefault(x,x)\\n            if uf[x]!=x:\\n                uf[x]=find(uf[x])\\n            return uf[x]\\n        def union(x,y):\\n            uf[find(x)]=find(y)\\n        parents={}\\n        unionCandidate=[]\\n        candidates=[]\\n        for start,end in edges:\\n            if end not in parents:\\n                parents[end]=start\\n            else:\\n                candidates=[[parents[end],end],[start,end]]\\n            if find(start)==find(end):\\n                unionCandidate=[start,end]\\n            else:\\n                union(start,end)\\n        if candidates:\\n            if isloop(candidates[0][1]):\\n                return candidates[0]\\n            return candidates[1]\\n        else:\\n            return unionCandidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397996,
                "title": "easy-python-union-find-in-degree-check",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        \\n        indegree = defaultdict(list)\\n        \\n        for edge in edges:\\n            indegree[edge[1]].append(edge[0])\\n         \\n        cand1, cand2 = None, None\\n        \\n        for k, v in indegree.items():\\n            \\n            if len(v) == 2:\\n                cand1 = [v[0], k]\\n                cand2 = [v[1], k]\\n                break\\n        \\n        def union(x, y):\\n            \\n            parent_x = find_parent(x)\\n            parent_y = find_parent(y)\\n            \\n            parent[parent_x] = parent_y\\n                \\n        def find_parent(x):\\n            \\n            if parent[x] == -1 : return x\\n            return find_parent(parent[x])\\n        \\n        parent = [-1]*(len(edges) + 1)\\n        \\n        cycle_edge = None\\n        \\n        for edge in edges:\\n            \\n            if edge == cand2 : continue\\n            \\n            if find_parent(edge[0]) != find_parent(edge[1]) : union(edge[0], edge[1])\\n            else:\\n                cycle_edge = edge\\n                \\n        if not cycle_edge : return cand2\\n        \\n        elif not cand1 and not cand2 : return cycle_edge\\n        \\n        elif cycle_edge == cand1 or cycle_edge == cand2 : return cycle_edge\\n        \\n        else : return cand1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        \\n        indegree = defaultdict(list)\\n        \\n        for edge in edges:\\n            indegree[edge[1]].append(edge[0])\\n         \\n        cand1, cand2 = None, None\\n        \\n        for k, v in indegree.items():\\n            \\n            if len(v) == 2:\\n                cand1 = [v[0], k]\\n                cand2 = [v[1], k]\\n                break\\n        \\n        def union(x, y):\\n            \\n            parent_x = find_parent(x)\\n            parent_y = find_parent(y)\\n            \\n            parent[parent_x] = parent_y\\n                \\n        def find_parent(x):\\n            \\n            if parent[x] == -1 : return x\\n            return find_parent(parent[x])\\n        \\n        parent = [-1]*(len(edges) + 1)\\n        \\n        cycle_edge = None\\n        \\n        for edge in edges:\\n            \\n            if edge == cand2 : continue\\n            \\n            if find_parent(edge[0]) != find_parent(edge[1]) : union(edge[0], edge[1])\\n            else:\\n                cycle_edge = edge\\n                \\n        if not cycle_edge : return cand2\\n        \\n        elif not cand1 and not cand2 : return cycle_edge\\n        \\n        elif cycle_edge == cand1 or cycle_edge == cand2 : return cycle_edge\\n        \\n        else : return cand1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379855,
                "title": "python-union-find-solution",
                "content": "```py\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # idea: \\u5229\\u7528union find\\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\uFF0C\\u5229\\u7528parents\\u6570\\u7EC4\\u5224\\u65AD\\u67D0\\u4E2Anode\\u662F\\u5426\\u6709\\u591A\\u4E2Aparents\\n        uf = UnionFind()\\n        parents = {}\\n\\n        first, second, cycle_edge = None, None, None\\n\\n        for parent, child in edges:\\n            # in case there is two parents associated with this child\\n            if child in parents:\\n                first = [parents[child], child]\\n                second = [parent, child]\\n            else:\\n                parents[child] = parent\\n                # in case there is a cycle\\n                if uf.connected(parent, child):\\n                    cycle_edge = [parent, child]\\n\\n                uf.union(parent, child)\\n\\n        if cycle_edge:\\n            # case 1: there is a cycle and no two parents associated\\n            # with the same child, return cycle_edge\\n            # case 2: there is a cycle and are two parents associated\\n            # with the same child, return first edge that associated with that child\\n            return first or cycle_edge\\n        else:\\n            # case 3: there is no cycle, just two parents associated with the same child\\n            # then return second\\n            return second\\n\\nclass UnionFind(object):\\n    def __init__(self):\\n        self._ids = {}\\n        self._ranks = collections.defaultdict(lambda : 1)\\n\\n    def _find(self, id):\\n        if id not in self._ids:\\n            self._ids[id] = id\\n            return id\\n\\n        while id != self._ids[id]:\\n            self._ids[id] = self._ids[self._ids[id]] # path compression\\n            id = self._ids[id]\\n\\n        return id\\n\\n    def connected(self, p, q):\\n        return self._find(p) == self._find(q)\\n\\n    def union(self, p, q):\\n        root_p, root_q = self._find(p), self._find(q)\\n        if root_p == root_q:\\n            return\\n\\n        rank_p, rank_q = self._ranks[root_p], self._ranks[root_q]\\n\\n        # Union by Rank\\n        if rank_p <= rank_q:\\n            self._ids[root_p] = root_q\\n            self._ranks[root_q] += rank_p\\n        else:\\n            self._ids[root_q] = root_p\\n            self._ranks[root_p] += rank_q\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # idea: \\u5229\\u7528union find\\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\uFF0C\\u5229\\u7528parents\\u6570\\u7EC4\\u5224\\u65AD\\u67D0\\u4E2Anode\\u662F\\u5426\\u6709\\u591A\\u4E2Aparents\\n        uf = UnionFind()\\n        parents = {}\\n\\n        first, second, cycle_edge = None, None, None\\n\\n        for parent, child in edges:\\n            # in case there is two parents associated with this child\\n            if child in parents:\\n                first = [parents[child], child]\\n                second = [parent, child]\\n            else:\\n                parents[child] = parent\\n                # in case there is a cycle\\n                if uf.connected(parent, child):\\n                    cycle_edge = [parent, child]\\n\\n                uf.union(parent, child)\\n\\n        if cycle_edge:\\n            # case 1: there is a cycle and no two parents associated\\n            # with the same child, return cycle_edge\\n            # case 2: there is a cycle and are two parents associated\\n            # with the same child, return first edge that associated with that child\\n            return first or cycle_edge\\n        else:\\n            # case 3: there is no cycle, just two parents associated with the same child\\n            # then return second\\n            return second\\n\\nclass UnionFind(object):\\n    def __init__(self):\\n        self._ids = {}\\n        self._ranks = collections.defaultdict(lambda : 1)\\n\\n    def _find(self, id):\\n        if id not in self._ids:\\n            self._ids[id] = id\\n            return id\\n\\n        while id != self._ids[id]:\\n            self._ids[id] = self._ids[self._ids[id]] # path compression\\n            id = self._ids[id]\\n\\n        return id\\n\\n    def connected(self, p, q):\\n        return self._find(p) == self._find(q)\\n\\n    def union(self, p, q):\\n        root_p, root_q = self._find(p), self._find(q)\\n        if root_p == root_q:\\n            return\\n\\n        rank_p, rank_q = self._ranks[root_p], self._ranks[root_q]\\n\\n        # Union by Rank\\n        if rank_p <= rank_q:\\n            self._ids[root_p] = root_q\\n            self._ranks[root_q] += rank_p\\n        else:\\n            self._ids[root_q] = root_p\\n            self._ranks[root_p] += rank_q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362642,
                "title": "java-union-find",
                "content": "The key point of this problem is that:\\n`there is only one wrong edge to get to the tree structure`\\n\\nThere are only two condition that leads to a wrong edge:\\n```\\n1. one node has two parent\\n2. there is no root (formed a circle)\\n```\\n\\nfor the two condition, there is a data structure that can perfectly detect these two ---- `Union and Find`\\n\\nFor the first key point, there is one gold method to test all two:\\n`discard one of the candidate edges, test the updated graph. If it \\'s correct now, it means the candidate discarded is the target. Otherwise, the other candidate.`\\n\\n\\nSo you can see, the main trick the problem wanna test you is whether you can use union&find to check tree-related problems in graph.\\n\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] cand1=new int[]{-1,-1};\\n        int[] cand2=new int[]{-1,-1};\\n        int[] parent = new int[n+1];\\n        for (int i=0; i<n; i++){\\n            int[] edge = edges[i];\\n            if(parent[edge[1]]!=0){\\n                cand1 = new int[]{parent[edge[1]], edge[1]};\\n                cand2 = new int[]{edge[0], edge[1]};\\n                edges[i][1] = 0;\\n                break;\\n            }\\n            parent[edge[1]] = edge[0];\\n        }\\n        for (int i=1; i<=n; i++) parent[i] = i;\\n        for (int[] edge: edges){\\n            if (root(parent,edge[0]) == root(parent,edge[1])){\\n                if (cand1[0]==-1) return edge;\\n                return cand1;\\n            }\\n            parent[edge[1]] = root(parent,edge[0]);\\n        }\\n        return cand2;\\n    }\\n    \\n    int root(int[] parent, int i){\\n        if (parent[i]!=i) parent[i] = root(parent, parent[i]);\\n        return parent[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. one node has two parent\\n2. there is no root (formed a circle)\\n```\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] cand1=new int[]{-1,-1};\\n        int[] cand2=new int[]{-1,-1};\\n        int[] parent = new int[n+1];\\n        for (int i=0; i<n; i++){\\n            int[] edge = edges[i];\\n            if(parent[edge[1]]!=0){\\n                cand1 = new int[]{parent[edge[1]], edge[1]};\\n                cand2 = new int[]{edge[0], edge[1]};\\n                edges[i][1] = 0;\\n                break;\\n            }\\n            parent[edge[1]] = edge[0];\\n        }\\n        for (int i=1; i<=n; i++) parent[i] = i;\\n        for (int[] edge: edges){\\n            if (root(parent,edge[0]) == root(parent,edge[1])){\\n                if (cand1[0]==-1) return edge;\\n                return cand1;\\n            }\\n            parent[edge[1]] = root(parent,edge[0]);\\n        }\\n        return cand2;\\n    }\\n    \\n    int root(int[] parent, int i){\\n        if (parent[i]!=i) parent[i] = root(parent, parent[i]);\\n        return parent[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179687,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\nvar findRedundantDirectedConnection = function(edges) {\\n    //Broken Graphs\\n    //1. Graph has no loop, a node with 2 parents\\n    //2. Graph with loop, every node has 1 parent\\n    //3. Graph with loop, a node with 2 parents\\n    \\n    var nodes = {};\\n    var parent = {};\\n    var visited = {}; //key current \\'node\\', node visited \\'from\\'\\n    let twoParentNode = null;\\n    //examine every directed edge, try to find a node with 2 parents\\n    //build tree as we go along\\n    for(let i=0; i<edges.length;i++){\\n        let edge = edges[i];\\n        let fromNode = edge[0];\\n        let toNode = edge[1];\\n        \\n        if(!nodes[fromNode]){\\n            nodes[fromNode] = new Node(fromNode);\\n        }\\n        \\n        if(!nodes[toNode]){\\n            nodes[toNode] = new Node(toNode);\\n        }\\n        \\n        if(!visited[toNode]){ //if we are going to a node we have never seen before\\n            visited[toNode] = fromNode; //mark the node as visited from this parent\\n\\n            parent[toNode] = [fromNode];\\n            nodes[fromNode].children.push(toNode);\\n            \\n        }else if(visited[toNode]){ //if we have visited the node we are going to visit before, break\\n            twoParentNode = [];\\n            twoParentNode.push([visited[toNode], toNode])\\n            twoParentNode.push([fromNode, toNode])\\n            parent[toNode].push(fromNode);\\n        }\\n    }\\n    \\n    //find the loop\\n    let loop = null;\\n    for(let i=0; i<edges.length;i++){\\n        visited = {}; //key current \\'node\\', node visited \\'from\\'\\n        let edge = edges[i];\\n        let currNode = edge[0];\\n        let val = null;\\n        if(parent[currNode]){\\n            val = dfs(currNode, parent[currNode][0], visited, nodes, parent);\\n        \\n            if(parent[currNode].length == 2 && val == null){\\n                 val = dfs(currNode, parent[currNode][1], visited, nodes, parent);\\n            }\\n            \\n            if(val != null){\\n                loop = val;\\n            }\\n        }\\n\\n    }\\n    \\n    if(loop == null){\\n        //return the latest second edge\\n        return twoParentNode.pop();\\n    }else{\\n        //there is a loop\\n        if(twoParentNode){ //a node has two parents\\n            let p1 = twoParentNode.pop();\\n            let p2 = twoParentNode.pop();\\n            for(var el of loop){\\n                if(el[0] == p1[0] && el[1] == p1[1]){\\n                    return p1;\\n                }else if(el[0] == p2[0] && el[1] == p2[1]){\\n                    return p2;\\n                }\\n            }\\n        }else{\\n            return loop[0];\\n        }\\n    }\\n        \\n    return null;\\n    \\n    \\n\\n};\\n\\nfunction dfs(curr, from, visited, nodes){\\n    let loop = [];\\n    \\n    if(visited[curr]){\\n        loop.push([from,curr])\\n        return loop;\\n    }\\n\\n    let node = nodes[curr];\\n    visited[curr] = 1;\\n    \\n    let foundLoop = false;\\n\\n    if(node.children.length != 0){ //has children, could be part of a cycle\\n        let val = null;\\n        for(let child of node.children){\\n            let val = dfs(child, curr, visited, nodes);\\n            if(val != null){ //found a path\\n                foundLoop = true;\\n                loop.push([from, curr])\\n                loop = loop.concat(val);\\n                break;\\n            }\\n        }\\n    }\\n   \\n    if(!foundLoop){\\n        loop = null\\n    }\\n    \\n    return loop;\\n    \\n}\\n\\nvar Node = function(_val){\\n    this.val = _val;\\n    this.children = [];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\nvar findRedundantDirectedConnection = function(edges) {\\n    //Broken Graphs\\n    //1. Graph has no loop, a node with 2 parents\\n    //2. Graph with loop, every node has 1 parent\\n    //3. Graph with loop, a node with 2 parents\\n    \\n    var nodes = {};\\n    var parent = {};\\n    var visited = {}; //key current \\'node\\', node visited \\'from\\'\\n    let twoParentNode = null;\\n    //examine every directed edge, try to find a node with 2 parents\\n    //build tree as we go along\\n    for(let i=0; i<edges.length;i++){\\n        let edge = edges[i];\\n        let fromNode = edge[0];\\n        let toNode = edge[1];\\n        \\n        if(!nodes[fromNode]){\\n            nodes[fromNode] = new Node(fromNode);\\n        }\\n        \\n        if(!nodes[toNode]){\\n            nodes[toNode] = new Node(toNode);\\n        }\\n        \\n        if(!visited[toNode]){ //if we are going to a node we have never seen before\\n            visited[toNode] = fromNode; //mark the node as visited from this parent\\n\\n            parent[toNode] = [fromNode];\\n            nodes[fromNode].children.push(toNode);\\n            \\n        }else if(visited[toNode]){ //if we have visited the node we are going to visit before, break\\n            twoParentNode = [];\\n            twoParentNode.push([visited[toNode], toNode])\\n            twoParentNode.push([fromNode, toNode])\\n            parent[toNode].push(fromNode);\\n        }\\n    }\\n    \\n    //find the loop\\n    let loop = null;\\n    for(let i=0; i<edges.length;i++){\\n        visited = {}; //key current \\'node\\', node visited \\'from\\'\\n        let edge = edges[i];\\n        let currNode = edge[0];\\n        let val = null;\\n        if(parent[currNode]){\\n            val = dfs(currNode, parent[currNode][0], visited, nodes, parent);\\n        \\n            if(parent[currNode].length == 2 && val == null){\\n                 val = dfs(currNode, parent[currNode][1], visited, nodes, parent);\\n            }\\n            \\n            if(val != null){\\n                loop = val;\\n            }\\n        }\\n\\n    }\\n    \\n    if(loop == null){\\n        //return the latest second edge\\n        return twoParentNode.pop();\\n    }else{\\n        //there is a loop\\n        if(twoParentNode){ //a node has two parents\\n            let p1 = twoParentNode.pop();\\n            let p2 = twoParentNode.pop();\\n            for(var el of loop){\\n                if(el[0] == p1[0] && el[1] == p1[1]){\\n                    return p1;\\n                }else if(el[0] == p2[0] && el[1] == p2[1]){\\n                    return p2;\\n                }\\n            }\\n        }else{\\n            return loop[0];\\n        }\\n    }\\n        \\n    return null;\\n    \\n    \\n\\n};\\n\\nfunction dfs(curr, from, visited, nodes){\\n    let loop = [];\\n    \\n    if(visited[curr]){\\n        loop.push([from,curr])\\n        return loop;\\n    }\\n\\n    let node = nodes[curr];\\n    visited[curr] = 1;\\n    \\n    let foundLoop = false;\\n\\n    if(node.children.length != 0){ //has children, could be part of a cycle\\n        let val = null;\\n        for(let child of node.children){\\n            let val = dfs(child, curr, visited, nodes);\\n            if(val != null){ //found a path\\n                foundLoop = true;\\n                loop.push([from, curr])\\n                loop = loop.concat(val);\\n                break;\\n            }\\n        }\\n    }\\n   \\n    if(!foundLoop){\\n        loop = null\\n    }\\n    \\n    return loop;\\n    \\n}\\n\\nvar Node = function(_val){\\n    this.val = _val;\\n    this.children = [];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178465,
                "title": "3-ms-easy-to-understand-java-solution-detailed-case-explained",
                "content": "In a tree for a `node i,` how many ways to choose a `node j` in the tree to point to?\\n1. Choose the` node j `that is in the same path from root to any leaf node with `node i`\\n\\t1. `node j` is root\\n**Concequence**: create **a cycle** , **no conflict**\\n**Condiiton**: `findRoot(node j) == findRoot(node i) && parent(node j) = node j`\\n**Solution**: delete either edge in the cycle.\\n\\t2. `node j` bofore it => depth(j) > depth(i)\\n**Concequence**: create **a cycle**, the extra edge will** conflict** with original edge on `node j`.\\n**Condition**: `findRoot(node j) == findRoot(node i) && parent(node j) != node i`\\n**Solution**: find two concliced edge, how to choose which one to delete?\\nIf detach two edges, then add all other edges, check which node is the descendant of` node j`.\\n\\t3. `node j` after it => depth(j) < depth(i)\\n**Concequence**: **no cycle**, **a conflict** occured on` node j`\\n**Condition**: `parent(node j) != node i`\\n**Solution**: delete either one\\n2. OtherWise\\n**Concequnce**: **no cycle**, **an conflict** occured on `node j`\\n**Condition**:` parent(node j) != node i`\\n**Solution**: delete either one\\n\\nwe can conclude case 1.2, 1.3, 2 can use the same method to solve.\\n\\n**Question is the edges is not appeared in order**, so we may encounter an cycle, then a conflict or counterwise.\\nSo we need to **record the status** through the whole process. Then according to the final status, choose the answer we need.\\n\\nMy tricky part is use **3 nodes to record the status and remove and record the unormal edge fisrt, then recover it later if needed.**\\n\\n`node1` : old edge[0] in conflict edges\\n`node2` : new edge[0] in conflict edges or the first edge[0] that create a cycle\\n`node3` : conflict edges[1] (they are same) or first edge[1] that create a cycle  \\n\\n* if node1 == -1:\\nno conflict edge, just return the last edge create cycle which is {node2, node3}\\n* otherwise:\\ntwo conflict edges\\nwe want to determine if the first edge is undetachable.\\n\\t* case: 1.2:  if we remove two conflict node, the node that is descendant of node j is answer\\n if node1 is not in cycle => return {node2, node3}\\nelse return {node1, node3}\\n\\t* case: 1.3, 2:  return {node2, node3}\\n\\n\\nLast Code\\uFF1A\\n```java\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // int root = findRoot(edges);\\n        \\n        int[] parent = new int[edges.length + 1];\\n        int node1 = -1;\\n        int node2 = -1;\\n        int node3 = -1;\\n        \\n        for(int[] edge : edges){\\n            int root1 = find(parent, edge[0]);\\n            int root2 = find(parent, edge[1]);\\n            \\n            if(parent[edge[1]] == edge[1] && root1 != root2){\\n                // normal edge\\n                // add this edge\\n                parent[edge[1]] = edge[0];\\n            }else if(root1 == root2){\\n                // cycle\\n                // record the current edge that create a cycle, and remove the edge\\n\\t\\t\\t\\t\\t\\t\\t\\t// no more cycle\\n                node2 = edge[0];\\n                node3 = edge[1];\\n            }else{\\n                // conflict edge\\n                // if we have already found a cycle, re-add this edge to the graph\\n                if(node2 != -1){\\n                    parent[node3] = node2;\\n                }\\n\\n                // record two conflict edges\\n                node1 = parent[edge[1]];\\n                node2 = edge[0];\\n                node3 = edge[1];\\n\\n                // remove the two edges, then no cycle anymore\\n                parent[node3] = node3;\\n            }\\n        }\\n        \\n        // if no conflict edge or if the first edge is not in cycle.\\n        return node1 == -1 || find(parent, node1) != node3 ? new int[]{node2, node3} : new int[]{node1, node3};    \\n    }\\n    \\n    private int find(int[] parent, int i){\\n        if(parent[i] == 0) parent[i] = i;\\n        \\n        while(parent[i] != i){\\n            i = parent[i];\\n        }\\n        \\n        return i;\\n    }\\n```\\n\\nSorry for my poor English!",
                "solutionTags": [],
                "code": "```java\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // int root = findRoot(edges);\\n        \\n        int[] parent = new int[edges.length + 1];\\n        int node1 = -1;\\n        int node2 = -1;\\n        int node3 = -1;\\n        \\n        for(int[] edge : edges){\\n            int root1 = find(parent, edge[0]);\\n            int root2 = find(parent, edge[1]);\\n            \\n            if(parent[edge[1]] == edge[1] && root1 != root2){\\n                // normal edge\\n                // add this edge\\n                parent[edge[1]] = edge[0];\\n            }else if(root1 == root2){\\n                // cycle\\n                // record the current edge that create a cycle, and remove the edge\\n\\t\\t\\t\\t\\t\\t\\t\\t// no more cycle\\n                node2 = edge[0];\\n                node3 = edge[1];\\n            }else{\\n                // conflict edge\\n                // if we have already found a cycle, re-add this edge to the graph\\n                if(node2 != -1){\\n                    parent[node3] = node2;\\n                }\\n\\n                // record two conflict edges\\n                node1 = parent[edge[1]];\\n                node2 = edge[0];\\n                node3 = edge[1];\\n\\n                // remove the two edges, then no cycle anymore\\n                parent[node3] = node3;\\n            }\\n        }\\n        \\n        // if no conflict edge or if the first edge is not in cycle.\\n        return node1 == -1 || find(parent, node1) != node3 ? new int[]{node2, node3} : new int[]{node1, node3};    \\n    }\\n    \\n    private int find(int[] parent, int i){\\n        if(parent[i] == 0) parent[i] = i;\\n        \\n        while(parent[i] != i){\\n            i = parent[i];\\n        }\\n        \\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160673,
                "title": "modify-solution-for-684-to-solve-685-redundant-connection-union-find",
                "content": "Two senarios:\\n(1) If no node with dual parenets, this problem reduces to LC684. Redundant Connection, just remove the last edge that forms the circle. \\n\\n(2)If there is one node with dual parents:\\n(2.1) there is no cycle, just return the second edge. But you need to traverse the entire graph to make sure there is no circle, NO early return.\\n(2.2) Or there is a cycle, due to nature of directed graph, only one of the dual edges is in the cycle. If you find the cycle with first edge, remove the first edge, early termination. Otherwise, remove the second.\\n\\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n\\t \"\"\"Solution for 685. Redundant Connection II\"\"\"\\n        n = len(edges) \\n        \\n        def union(a,b):\\n            parent[find(b)] = find(a)\\n            \\n        def find(x):\\n            return x if x==parent.setdefault(x,x) else find(parent[x])\\n\\n        parent = {}\\n        numParents = collections.defaultdict(int)           \\n        for p, q in edges: \\n            numParents[q] += 1\\n       \\n        first, second = None, None #two edges pointing to the same node\\n        for p, q in edges:\\n            if numParents[q]> 1: #when q has two parents, find out the two edges\\n                if first:\\n                    second = (p,q) \\n                    continue      #find the second edge, then skip union find\\n                else:\\n                    first = (p,q) #find the first edge then do the union find\\n                    \\n            if find(p) == find(q):  #when there is a circle\\n                return first or (p,q)\\n            \\n            union(p,q)\\n            \\n        return second\\n\\t\\t\\n    def findRedundantConnection(self, edges):\\n\\t  \"\"\"Solution to LC684. Redundant Connection\"\"\"\\n\\tdef union(a,b):\\n            parent[find(b)] = find(a)\\n            \\n        def find(x):\\n            return x if x==parent.setdefault(x,x) else find(parent[x])\\n\\n        self.parent = {}\\n        \\n        for u, v in edges:\\n            if self.find(u)!=self.find(v):\\n                self.union(u,v)\\n            else:\\n                return [u,v]\\n        return\\n    \\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n\\t \"\"\"Solution for 685. Redundant Connection II\"\"\"\\n        n = len(edges) \\n        \\n        def union(a,b):\\n            parent[find(b)] = find(a)\\n            \\n        def find(x):\\n            return x if x==parent.setdefault(x,x) else find(parent[x])\\n\\n        parent = {}\\n        numParents = collections.defaultdict(int)           \\n        for p, q in edges: \\n            numParents[q] += 1\\n       \\n        first, second = None, None #two edges pointing to the same node\\n        for p, q in edges:\\n            if numParents[q]> 1: #when q has two parents, find out the two edges\\n                if first:\\n                    second = (p,q) \\n                    continue      #find the second edge, then skip union find\\n                else:\\n                    first = (p,q) #find the first edge then do the union find\\n                    \\n            if find(p) == find(q):  #when there is a circle\\n                return first or (p,q)\\n            \\n            union(p,q)\\n            \\n        return second\\n\\t\\t\\n    def findRedundantConnection(self, edges):\\n\\t  \"\"\"Solution to LC684. Redundant Connection\"\"\"\\n\\tdef union(a,b):\\n            parent[find(b)] = find(a)\\n            \\n        def find(x):\\n            return x if x==parent.setdefault(x,x) else find(parent[x])\\n\\n        self.parent = {}\\n        \\n        for u, v in edges:\\n            if self.find(u)!=self.find(v):\\n                self.union(u,v)\\n            else:\\n                return [u,v]\\n        return\\n    \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 136213,
                "title": "concise-single-pass-solution",
                "content": "Similiar idea as https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C++Java-Union-Find-with-explanation-O(n) but uses only one iteration\\n\\n```js\\nfunction findRedundantDirectedConnection(edges) {\\n  const parent = {};\\n  let res1, res2;\\n  let hasLoop = false;\\n  \\n  for (let edge of edges) {\\n    let [p, c] = edge;\\n    const rp = find(p);\\n    const rc = find(c);\\n    \\n    if (rc !== rp) {\\n      if (rc !== c) {\\n        // dual parent, skip new edge\\n        res1 = [parent[c], c];\\n        res2 = edge;\\n      } else {\\n        parent[c] = p;\\n      }\\n    } else {\\n      // loop\\n      hasLoop = true;\\n      if (res1 === undefined) {\\n        res1 = edge;\\n      }\\n    }\\n  }\\n  \\n  return hasLoop ? res1 : res2;\\n  \\n  function find(v) {\\n    if (parent[v] === undefined) parent[v] = v;\\n    while (v !== parent[v]) v = parent[v];\\n    return v;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction findRedundantDirectedConnection(edges) {\\n  const parent = {};\\n  let res1, res2;\\n  let hasLoop = false;\\n  \\n  for (let edge of edges) {\\n    let [p, c] = edge;\\n    const rp = find(p);\\n    const rc = find(c);\\n    \\n    if (rc !== rp) {\\n      if (rc !== c) {\\n        // dual parent, skip new edge\\n        res1 = [parent[c], c];\\n        res2 = edge;\\n      } else {\\n        parent[c] = p;\\n      }\\n    } else {\\n      // loop\\n      hasLoop = true;\\n      if (res1 === undefined) {\\n        res1 = edge;\\n      }\\n    }\\n  }\\n  \\n  return hasLoop ? res1 : res2;\\n  \\n  function find(v) {\\n    if (parent[v] === undefined) parent[v] = v;\\n    while (v !== parent[v]) v = parent[v];\\n    return v;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486533,
                "title": "java-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n=edges.length,twoParents=-1; // num edges == num of nodes, relevant for later\\n        int [] parantEdgePointer  = new int [n+1]; //refer a node value to the edge connecting him to a parent\\n        Arrays.fill(parantEdgePointer,-1);\\n        for (int i=0;i<n;i++) {\\n            if (parantEdgePointer[edges[i][1]]!=-1) \\n                twoParents=i; //two parants to edge[i][1] node, one of them most be removed.\\n            else parantEdgePointer[edges[i][1]]=i; \\n        }\\n\\n\\n        if (twoParents!=-1){ //how do we know which of the two parents to remove? its the tricky part: lets try to remove the most right edge index first, we just have to make sure the graph componants are still connected how to do it???\\n            // now that we remove double parenting, we can start itarating up from the our marked node to his parent that left standing, if we encounter a cycle but never got back to the other parent that we removed, thats mean the graph had beconme dissconected.     \\n            int[] parent1 = edges[twoParents], parent2=edges[parantEdgePointer[edges[twoParents][1]]]; \\n            //set parent2 to be the bigger index\\n            boolean parent2IsMostRight = parantEdgePointer[edges[twoParents][1]]>twoParents;\\n            if (!parent2IsMostRight){\\n                 int[] tmp = parent1;\\n                 parent1 = parent2;\\n                 parent2 = tmp;\\n            } \\n            // parent2 removed, now itarate up on parent1 path and check for a cycle\\n            int curEdge = parent1[0];\\n            for (int i=0;i<n;i++) {\\n                if (parantEdgePointer[curEdge]==-1 || curEdge==parent2[0]) return parent2;\\n                if (curEdge==parent1[1]) return parent1;\\n                curEdge = edges[parantEdgePointer[curEdge]][0];\\n            }\\n            return null;\\n        }\\n\\n\\n        // no more parent duplications, so gerenteed each cell have 1 parent, using Pigeonhole principle we have a cycle in the graph.\\n        // lets start from a random node (1) and keep going up to his parent n times, by this time we are inside the cycle.\\n        int curEdge=1,mostRight=0;\\n        for (int i=0;i<n;i++) curEdge = edges[parantEdgePointer[curEdge]][0]; // moving curEdge to become his parent n times\\n        //now just itarate once again and mark the most right edge in the cycle.\\n        for (int i=0;i<n;i++) {\\n            curEdge = edges[parantEdgePointer[curEdge]][0];\\n            mostRight = Math.max(mostRight,parantEdgePointer[curEdge]);\\n        }\\n        return edges[mostRight];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n=edges.length,twoParents=-1; // num edges == num of nodes, relevant for later\\n        int [] parantEdgePointer  = new int [n+1]; //refer a node value to the edge connecting him to a parent\\n        Arrays.fill(parantEdgePointer,-1);\\n        for (int i=0;i<n;i++) {\\n            if (parantEdgePointer[edges[i][1]]!=-1) \\n                twoParents=i; //two parants to edge[i][1] node, one of them most be removed.\\n            else parantEdgePointer[edges[i][1]]=i; \\n        }\\n\\n\\n        if (twoParents!=-1){ //how do we know which of the two parents to remove? its the tricky part: lets try to remove the most right edge index first, we just have to make sure the graph componants are still connected how to do it???\\n            // now that we remove double parenting, we can start itarating up from the our marked node to his parent that left standing, if we encounter a cycle but never got back to the other parent that we removed, thats mean the graph had beconme dissconected.     \\n            int[] parent1 = edges[twoParents], parent2=edges[parantEdgePointer[edges[twoParents][1]]]; \\n            //set parent2 to be the bigger index\\n            boolean parent2IsMostRight = parantEdgePointer[edges[twoParents][1]]>twoParents;\\n            if (!parent2IsMostRight){\\n                 int[] tmp = parent1;\\n                 parent1 = parent2;\\n                 parent2 = tmp;\\n            } \\n            // parent2 removed, now itarate up on parent1 path and check for a cycle\\n            int curEdge = parent1[0];\\n            for (int i=0;i<n;i++) {\\n                if (parantEdgePointer[curEdge]==-1 || curEdge==parent2[0]) return parent2;\\n                if (curEdge==parent1[1]) return parent1;\\n                curEdge = edges[parantEdgePointer[curEdge]][0];\\n            }\\n            return null;\\n        }\\n\\n\\n        // no more parent duplications, so gerenteed each cell have 1 parent, using Pigeonhole principle we have a cycle in the graph.\\n        // lets start from a random node (1) and keep going up to his parent n times, by this time we are inside the cycle.\\n        int curEdge=1,mostRight=0;\\n        for (int i=0;i<n;i++) curEdge = edges[parantEdgePointer[curEdge]][0]; // moving curEdge to become his parent n times\\n        //now just itarate once again and mark the most right edge in the cycle.\\n        for (int i=0;i<n;i++) {\\n            curEdge = edges[parantEdgePointer[curEdge]][0];\\n            mostRight = Math.max(mostRight,parantEdgePointer[curEdge]);\\n        }\\n        return edges[mostRight];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052259,
                "title": "fast-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts on how to solve this problem is to identify the redundant edge by checking for a cycle in the directed graph. If there is a cycle, the edge that completes the cycle is the redundant edge.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach I will take is to use Union-Find data structure to detect the cycle in the directed graph. The Union-Find data structure will keep track of the parent of each node and will check if adding an edge will create a cycle by checking if the parent of the end node is already set. If a cycle is detected, the edge that completes the cycle is the redundant edge. To handle the case where there are multiple candidates for the redundant edge, the algorithm checks for a second edge pointing to the same node and saves it as a candidate for the redundant edge.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n + 1, 0);\\n        vector<int> candA, candB;\\n        for (auto& edge : edges) {\\n            if (parent[edge[1]] == 0) {\\n                parent[edge[1]] = edge[0];\\n            } else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        }\\n        for (int i = 1; i <= n; ++i) parent[i] = i;\\n        for (auto& edge : edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = find(parent, u), pv = find(parent, v);\\n            if (pu == pv) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[pv] = pu;\\n        }\\n        return candB;\\n    }\\n    \\n    int find(vector<int>& parent, int i) {\\n        return parent[i] == i ? i : find(parent, parent[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n + 1, 0);\\n        vector<int> candA, candB;\\n        for (auto& edge : edges) {\\n            if (parent[edge[1]] == 0) {\\n                parent[edge[1]] = edge[0];\\n            } else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        }\\n        for (int i = 1; i <= n; ++i) parent[i] = i;\\n        for (auto& edge : edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = find(parent, u), pv = find(parent, v);\\n            if (pu == pv) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[pv] = pu;\\n        }\\n        return candB;\\n    }\\n    \\n    int find(vector<int>& parent, int i) {\\n        return parent[i] == i ? i : find(parent, parent[i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761007,
                "title": "java-unionfind-easy-solution",
                "content": "class Solution {\\n\\n\\n\\n\\n\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        //check double parent\\n        int ans1 = -1;\\n        int ans2 = -1;\\n        int [] inDegree = new int[edges.length+1];\\n        Arrays.fill(inDegree,-1);\\n        \\n        for( int i = 0 ; i < edges.length; i++ ){\\n            int var1 = edges[i][0];\\n            int var2 = edges[i][1];\\n            if( inDegree[var2] == -1 ) inDegree[var2] = i;\\n            else {\\n                ans1 = inDegree[var2];\\n                ans2 = i;    //store the double parent\\n            }\\n        }\\n        \\n        \\n        //(u,v)  u is parent  u points to v\\n        UnionFind uf = new UnionFind(edges.length*2);\\n        for(int [] edge: edges){\\n            if(ans2!=-1 && edge == edges[ans2]) continue;\\n            int u = edge[0];\\n            int v = edge[1];\\n            int paru = uf.find(u);\\n            int parv = uf.find(v);\\n            if(paru == parv) return ans1==-1 ? edge: edges[ans1];\\n            uf.union(u,v);\\n        }\\n        return edges[ans2];\\n    }\\n    \\n    \\n    \\n    private class UnionFind{\\n        int parent[];\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for( int i = 0 ; i < n; i++ ){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find( int a ){\\n            int parA = parent[a];\\n            if(parA == a) return a;\\n            parent[a] = find(parent[a]);\\n            return parent[a];\\n        }\\n        \\n        public void union(int a, int b){\\n            int parA = find(a);\\n            int parB = find(b);\\n            if(parA == parB) return;\\n            parent[parB] = parA;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\n\\n\\n\\n\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        //check double parent\\n        int ans1 = -1;\\n        int ans2 = -1;\\n        int [] inDegree = new int[edges.length+1];\\n        Arrays.fill(inDegree,-1);\\n        \\n        for( int i = 0 ; i < edges.length; i++ ){\\n            int var1 = edges[i][0];\\n            int var2 = edges[i][1];\\n            if( inDegree[var2] == -1 ) inDegree[var2] = i;\\n            else {\\n                ans1 = inDegree[var2];\\n                ans2 = i;    //store the double parent\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2330756,
                "title": "c-fully-commented-explained-intuitions-from-pep-coding-youtube",
                "content": "```\\n  \\n        int find_par(int node , vector<int> &par)\\n    {\\n        if(node==par[node])\\n        {\\n            return node;\\n        }\\n        \\n        return par[node]=find_par(par[node] , par);\\n    }\\n    void union_set(int u , int v , vector<int> &rank , vector<int> &par)\\n    {\\n        u=find_par(u , par);\\n        v=find_par(v , par);\\n        \\n        if(rank[u]>rank[v])\\n        {\\n            // those whose rank is more is the parent of the node \\n            par[v]=u;\\n        }\\n        else\\n        if(rank[u]<rank[v])\\n        {\\n            par[u]=v;\\n        }\\n        else\\n        {\\n            par[v]=u;\\n            // incrase the rank of u as the height of u , is increased by 1\\n            rank[u]++;\\n        }\\n            return ;\\n    }\\n     vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        // We can use Disjoint Set \\n        \\n        // DSU \\n        \\n        int n=edges.size();\\n        \\n        vector<int> parent(n+1);\\n        \\n        vector<int> rank(n+1 , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n         \\n        // There are some cases ->\\n         \\n        // Case 1 -> there are  2 indegree nodes , not containing any cycle\\n         \\n         // Case 2 -> there exist  cycle not any 2 indegree nodes \\n         \\n         // Case 3-> there exist both cycle & 2 indegree nodes \\n         \\n         // As if there will be any cycle , then there will be only one cycle\\n         \\n         // Store the both indegree 2 containing edges\\n         \\n         vector<int> indegree(n+1 , -1);\\n         \\n         int black_list1=-1;// comes first in the edges vector\\n         int black_list2=-1; // comes later in the edges vector\\n         int black_list_node=-1;\\n\\t\\t \\n\\t\\t // [2 ,3] , [4 , 1] , [4,3] -> from this example just for understanding \\n\\t\\t //black_list1=2 , black_list2=4 , black_list_node=3\\n         \\n         for(int i=0;i<edges.size();i++)\\n         {\\n             int u=edges[i][0];\\n             int v=edges[i][1];\\n             \\n             if(indegree[v]!=-1)\\n             {\\n                 black_list1=indegree[v];\\n                 black_list2=u;\\n                 black_list_node=v;\\n                 break;\\n             }\\n             else\\n             {\\n                 indegree[v]=u;\\n             }\\n             \\n         }\\n         \\n         // This is for storing the indegree 2 blacklist 2 edges that contains it \\n         \\n         // Now check there is any cycle \\n         \\n         bool cycle_found=false;\\n         \\n         vector<int> cycle_edge={-1 , -1};\\n         \\n         //As it is fixed there can be maximum one cycle at all , so we can use \\n         \\n         // DSU for detection \\n         \\n         // As no. of edges = no. of nodes , as in normal tree -> \\n         \\n         // no of edges=no of nodes -1 \\n         \\n         // so only edges is more , so max possible is that edge can form a cycle\\n         \\n         // there \\n         \\n         for(int i=0;i<edges.size();i++)\\n         {\\n             // Remove that indegree node \\n              \\n             // for cycle detetcion , dont check having 2 indegree node which come\\n             //later\\n             \\n             // remove thet indegree edges which comes later \\n             \\n             // & if cycle is found now , then our answer will be \\n             \\n             // That means a cycle still exist after removing that indegree 2 edge\\n             \\n             // which comes later , but due to cycle our answer will be that \\n             \\n             // indegree edge which comes first \\n             \\n             \\n             vector<int> vec={black_list2 , black_list_node};\\n             \\n             if(edges[i]==vec )\\n             {\\n                 continue;\\n             }\\n             \\n             int u=edges[i][0];\\n             int v=edges[i][1];\\n             \\n             if(find_par(u , parent)==find_par(v , parent))\\n             {\\n                 cycle_edge={u,v};\\n                 cycle_found=true;\\n                 break;\\n             }\\n             else\\n             {\\n                 union_set(u , v , rank , parent);\\n             }\\n         }\\n         \\n         if(black_list1==-1)\\n         {\\n             return cycle_edge;\\n         }\\n         \\n         if(cycle_found==true && black_list1!=-1)\\n         {\\n             return {black_list1 , black_list_node};\\n         }\\n         \\n         return {black_list2 , black_list_node};\\n        \\n    }\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n  \\n        int find_par(int node , vector<int> &par)\\n    {\\n        if(node==par[node])\\n        {\\n            return node;\\n        }\\n        \\n        return par[node]=find_par(par[node] , par);\\n    }\\n    void union_set(int u , int v , vector<int> &rank , vector<int> &par)\\n    {\\n        u=find_par(u , par);\\n        v=find_par(v , par);\\n        \\n        if(rank[u]>rank[v])\\n        {\\n            // those whose rank is more is the parent of the node \\n            par[v]=u;\\n        }\\n        else\\n        if(rank[u]<rank[v])\\n        {\\n            par[u]=v;\\n        }\\n        else\\n        {\\n            par[v]=u;\\n            // incrase the rank of u as the height of u , is increased by 1\\n            rank[u]++;\\n        }\\n            return ;\\n    }\\n     vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        // We can use Disjoint Set \\n        \\n        // DSU \\n        \\n        int n=edges.size();\\n        \\n        vector<int> parent(n+1);\\n        \\n        vector<int> rank(n+1 , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n         \\n        // There are some cases ->\\n         \\n        // Case 1 -> there are  2 indegree nodes , not containing any cycle\\n         \\n         // Case 2 -> there exist  cycle not any 2 indegree nodes \\n         \\n         // Case 3-> there exist both cycle & 2 indegree nodes \\n         \\n         // As if there will be any cycle , then there will be only one cycle\\n         \\n         // Store the both indegree 2 containing edges\\n         \\n         vector<int> indegree(n+1 , -1);\\n         \\n         int black_list1=-1;// comes first in the edges vector\\n         int black_list2=-1; // comes later in the edges vector\\n         int black_list_node=-1;\\n\\t\\t \\n\\t\\t // [2 ,3] , [4 , 1] , [4,3] -> from this example just for understanding \\n\\t\\t //black_list1=2 , black_list2=4 , black_list_node=3\\n         \\n         for(int i=0;i<edges.size();i++)\\n         {\\n             int u=edges[i][0];\\n             int v=edges[i][1];\\n             \\n             if(indegree[v]!=-1)\\n             {\\n                 black_list1=indegree[v];\\n                 black_list2=u;\\n                 black_list_node=v;\\n                 break;\\n             }\\n             else\\n             {\\n                 indegree[v]=u;\\n             }\\n             \\n         }\\n         \\n         // This is for storing the indegree 2 blacklist 2 edges that contains it \\n         \\n         // Now check there is any cycle \\n         \\n         bool cycle_found=false;\\n         \\n         vector<int> cycle_edge={-1 , -1};\\n         \\n         //As it is fixed there can be maximum one cycle at all , so we can use \\n         \\n         // DSU for detection \\n         \\n         // As no. of edges = no. of nodes , as in normal tree -> \\n         \\n         // no of edges=no of nodes -1 \\n         \\n         // so only edges is more , so max possible is that edge can form a cycle\\n         \\n         // there \\n         \\n         for(int i=0;i<edges.size();i++)\\n         {\\n             // Remove that indegree node \\n              \\n             // for cycle detetcion , dont check having 2 indegree node which come\\n             //later\\n             \\n             // remove thet indegree edges which comes later \\n             \\n             // & if cycle is found now , then our answer will be \\n             \\n             // That means a cycle still exist after removing that indegree 2 edge\\n             \\n             // which comes later , but due to cycle our answer will be that \\n             \\n             // indegree edge which comes first \\n             \\n             \\n             vector<int> vec={black_list2 , black_list_node};\\n             \\n             if(edges[i]==vec )\\n             {\\n                 continue;\\n             }\\n             \\n             int u=edges[i][0];\\n             int v=edges[i][1];\\n             \\n             if(find_par(u , parent)==find_par(v , parent))\\n             {\\n                 cycle_edge={u,v};\\n                 cycle_found=true;\\n                 break;\\n             }\\n             else\\n             {\\n                 union_set(u , v , rank , parent);\\n             }\\n         }\\n         \\n         if(black_list1==-1)\\n         {\\n             return cycle_edge;\\n         }\\n         \\n         if(cycle_found==true && black_list1!=-1)\\n         {\\n             return {black_list1 , black_list_node};\\n         }\\n         \\n         return {black_list2 , black_list_node};\\n        \\n    }\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309104,
                "title": "c-union-find-time-o-n-space-o-n",
                "content": "Union Find solution\\n* given that one edge makes the rooted tree invalid\\n* the rooted tree is invalid if `1. there is a node has two parents` and/or `2. there is a cycle`\\n* we firstly record `edge_first` and `edge_second` if there is a node has two parents, where `edge_first` comes first in order of the input\\n* then we keep tracking the parents of the connected nodes, and to detect if there is a cycle\\n\\nReturn\\n* once we detect a cycle inside the loop, it may also has a node connected with two parents, thus which edge should be returned?\\n* if we did not find `edge_first` (also `edge_second`), we simply return the current edge that makes a cycle, it is the only answer\\n* if `edge_first` exists, it is the only one situation that we have to return `edge_first`, i.e. remove `edge_first` would get a valid rooted tree\\n* once the loop is end, which means there is no cycle detected, we have to output `edge_second` since it is the last invalid edge in order of the input\\n\\n![image](https://assets.leetcode.com/users/images/73edbe2b-64c0-4d28-884b-b0d1fd4aaea7_1658328338.4478197.png)\\n\\n\\n```\\n// time: O(n)\\n// space: O(n)\\n\\nclass Solution {\\npublic:\\n  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n    int n = edges.size();\\n    \\n    vector<int> parents (n + 1), edge_first, edge_second;\\n    for (auto& edge : edges) {\\n      int& parent = edge[0];\\n      int& child = edge[1]; // note that we use reference here\\n      if (parents[child] == 0)\\n        parents[child] = parent;\\n      else {\\n        edge_first = { parents[child], child };\\n        edge_second = edge;\\n        child = 0; // set child as 0 to avoid processing these edges in the following cycle detection\\n        break;\\n      }\\n    }\\n    \\n    for (int node = 1; node <= n; node++)\\n      parents[node] = node;\\n    \\n    for (const auto& edge : edges) {\\n      int parent = edge[0];\\n      int child = edge[1];\\n      if (child == 0)\\n        continue;\\n      int root = findRoot(parents, parent);\\n      if (root == parents[child]) { // if detected a cycle\\n        return edge_first.size() ? edge_first : edge;\\n      }\\n      parents[child] = root;\\n    }\\n    \\n    return edge_second;\\n  }\\n  \\nprivate:\\n  int findRoot(vector<int>& parents, int node) {\\n    while (node != parents[node]) {\\n      parents[node] = parents[parents[node]];\\n      node = parents[node];\\n    }\\n    return node;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(n)\\n// space: O(n)\\n\\nclass Solution {\\npublic:\\n  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n    int n = edges.size();\\n    \\n    vector<int> parents (n + 1), edge_first, edge_second;\\n    for (auto& edge : edges) {\\n      int& parent = edge[0];\\n      int& child = edge[1]; // note that we use reference here\\n      if (parents[child] == 0)\\n        parents[child] = parent;\\n      else {\\n        edge_first = { parents[child], child };\\n        edge_second = edge;\\n        child = 0; // set child as 0 to avoid processing these edges in the following cycle detection\\n        break;\\n      }\\n    }\\n    \\n    for (int node = 1; node <= n; node++)\\n      parents[node] = node;\\n    \\n    for (const auto& edge : edges) {\\n      int parent = edge[0];\\n      int child = edge[1];\\n      if (child == 0)\\n        continue;\\n      int root = findRoot(parents, parent);\\n      if (root == parents[child]) { // if detected a cycle\\n        return edge_first.size() ? edge_first : edge;\\n      }\\n      parents[child] = root;\\n    }\\n    \\n    return edge_second;\\n  }\\n  \\nprivate:\\n  int findRoot(vector<int>& parents, int node) {\\n    while (node != parents[node]) {\\n      parents[node] = parents[parents[node]];\\n      node = parents[node];\\n    }\\n    return node;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227339,
                "title": "java-dsu-solution-1ms-faster-than-99-31-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parent = new int[edges.length + 1];\\n        Arrays.fill(parent, -1);\\n        \\n        boolean twoParent = false;\\n        int[] e1 = null;\\n        int[] e2 = null;\\n        for(int[] edge : edges) {\\n            int p = edge[0];\\n            int c = edge[1];\\n            \\n            if(parent[c] == -1) {\\n                parent[c] = p;\\n            } else {\\n                twoParent = true;\\n                e2 = edge;\\n                e1 = new int[] {parent[c], c};\\n                break;\\n            }\\n        }\\n         \\n        dsu = new int[edges.length + 1];\\n        for(int i=0; i<dsu.length; i++) {\\n            dsu[i] = i;\\n        }\\n        \\n        if(!twoParent) {\\n            // edge creating the cycle is the answer\\n            for(int[] edge : edges) {\\n                int pl = find(edge[0]);\\n                int cl = find(edge[1]);\\n                \\n                if(pl != cl) {\\n                    dsu[cl] = pl;\\n                } else {\\n                    return edge;\\n                }\\n            }\\n        } else {\\n            // check for cycle\\n            boolean noCycle = true;\\n            for(int[] edge : edges) {\\n                if(edge != e2) {\\n                    int pl = find(edge[0]);\\n                    int cl = find(edge[1]);\\n\\n                    if(pl != cl) {\\n                        dsu[cl] = pl;\\n                    } else {\\n                        //cycle\\n                        noCycle = false;\\n                        break;\\n                    }   \\n                }\\n            }\\n            \\n            if(noCycle) {\\n                return e2;\\n            } \\n        }\\n        \\n        return e1;\\n    }\\n    \\n    public int[] dsu;\\n    \\n    public int find(int x) {\\n        if(dsu[x] == x) {\\n            return x;\\n        } else {\\n            dsu[x] = find(dsu[x]);\\n            return dsu[x];\\n        }\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parent = new int[edges.length + 1];\\n        Arrays.fill(parent, -1);\\n        \\n        boolean twoParent = false;\\n        int[] e1 = null;\\n        int[] e2 = null;\\n        for(int[] edge : edges) {\\n            int p = edge[0];\\n            int c = edge[1];\\n            \\n            if(parent[c] == -1) {\\n                parent[c] = p;\\n            } else {\\n                twoParent = true;\\n                e2 = edge;\\n                e1 = new int[] {parent[c], c};\\n                break;\\n            }\\n        }\\n         \\n        dsu = new int[edges.length + 1];\\n        for(int i=0; i<dsu.length; i++) {\\n            dsu[i] = i;\\n        }\\n        \\n        if(!twoParent) {\\n            // edge creating the cycle is the answer\\n            for(int[] edge : edges) {\\n                int pl = find(edge[0]);\\n                int cl = find(edge[1]);\\n                \\n                if(pl != cl) {\\n                    dsu[cl] = pl;\\n                } else {\\n                    return edge;\\n                }\\n            }\\n        } else {\\n            // check for cycle\\n            boolean noCycle = true;\\n            for(int[] edge : edges) {\\n                if(edge != e2) {\\n                    int pl = find(edge[0]);\\n                    int cl = find(edge[1]);\\n\\n                    if(pl != cl) {\\n                        dsu[cl] = pl;\\n                    } else {\\n                        //cycle\\n                        noCycle = false;\\n                        break;\\n                    }   \\n                }\\n            }\\n            \\n            if(noCycle) {\\n                return e2;\\n            } \\n        }\\n        \\n        return e1;\\n    }\\n    \\n    public int[] dsu;\\n    \\n    public int find(int x) {\\n        if(dsu[x] == x) {\\n            return x;\\n        } else {\\n            dsu[x] = find(dsu[x]);\\n            return dsu[x];\\n        }\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052903,
                "title": "java-dfs-solution-with-explain",
                "content": "From the question, we know that each node should contain only 1 parent. Therefore we can have 2 cases. \\n\\n1. All node contain only 1 parent. Then this is same as last question [Redundant Connection](https://leetcode.com/problems/redundant-connection/discuss/2052496/java-dfs-solution-with-explain). \\n\\n\\tWhat we need to do is to find out the edge that cause a cycle. \\n\\n\\tSame as in last question, for every edge, we do dfs, if we can start from edge end node (let say v) and find its father, which means adding this edge make a cycle, return this edge. \\n\\n2. One node contain 2 parents. Then the redundant edge must be one of the parents edge. \\n\\ta. If there is no cycle, we remove the latter parent edge as the question require us to return edge occurs last.  \\n\\tb. If there is cycle, we should remove the first parent edge. Assume we have a node with 2 parents \"a\", and there is a cycle with \"a\"\\n\\t`a -> b -> c -> a`\\n\\tand edge order\\n\\t`c -> a, b -> c, a -> b`\\n\\t\\n\\tWe should remove `a -> b` in normal case, but then \"b\" contain no parent and \"a\" still have 2 parents. Our choice is only a\\'s parent, and the redundant one must be the extra parent edge that form the cycle. As we construct the graph according to edge order, the previous parent edge added into graph first before we add the second one, therefore the first one must be the edge in the cycle when we find a cycle. \\n\\t\\n```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parents = new int[edges.length + 1];\\n        int[] case2a = new int[2];\\n        int[] case2b = new int[2];\\n\\n        boolean duplicateParent = false;\\n\\n        for(int i = 0; i < edges.length; i++){\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n\\n            if(parents[end] > 0){\\n                case2a = new int[] {parents[end], end};\\n                case2b = new int[] {edges[i][0], edges[i][1]};\\n                duplicateParent = true;\\n                edges[i][0] = edges[i][1] = -1;\\n            }else{\\n                parents[end] = start;\\n            }\\n        }\\n\\n        parents = new int[edges.length + 1];\\n        for(int i = 0; i < edges.length; i++){\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n            if(start < 0 || end < 0){\\n                continue;\\n            }\\n            \\n            parents[end] = start;\\n\\n            if(cycle(end, parents)){\\n                return duplicateParent ? case2a : edges[i];\\n            }\\n        }\\n        return case2b;\\n    }\\n\\n    private boolean cycle(int v, int[] parents){\\n        int parent = parents[v];\\n        while(parent != 0){\\n            if(parent == v){\\n                return true;\\n            }\\n            parent = parents[parent];\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parents = new int[edges.length + 1];\\n        int[] case2a = new int[2];\\n        int[] case2b = new int[2];\\n\\n        boolean duplicateParent = false;\\n\\n        for(int i = 0; i < edges.length; i++){\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n\\n            if(parents[end] > 0){\\n                case2a = new int[] {parents[end], end};\\n                case2b = new int[] {edges[i][0], edges[i][1]};\\n                duplicateParent = true;\\n                edges[i][0] = edges[i][1] = -1;\\n            }else{\\n                parents[end] = start;\\n            }\\n        }\\n\\n        parents = new int[edges.length + 1];\\n        for(int i = 0; i < edges.length; i++){\\n            int start = edges[i][0];\\n            int end = edges[i][1];\\n            if(start < 0 || end < 0){\\n                continue;\\n            }\\n            \\n            parents[end] = start;\\n\\n            if(cycle(end, parents)){\\n                return duplicateParent ? case2a : edges[i];\\n            }\\n        }\\n        return case2b;\\n    }\\n\\n    private boolean cycle(int v, int[] parents){\\n        int parent = parents[v];\\n        while(parent != 0){\\n            if(parent == v){\\n                return true;\\n            }\\n            parent = parents[parent];\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889787,
                "title": "c-code-for-beginners-find-union-by-rank",
                "content": "CASES-\\n1. Find node with two parents\\n\\t1.1 If NOT found, just use Disjoint sets to find the edge which is causing the loop and return it\\n2. For each and every edge having edge directed to the node having two parent, remove this edge and check if there exists a cycle\\n\\t\\t2.1 If removing/ignoring this edge detects a cycle, this edge should not be removed, cuz this is not the edge we are trying to find,\\n\\t\\t2.2. Otherwise, this edge shall be removed, since removing this made the graph detect no cycle\\n\\n```\\nclass Disjoint_Sets{\\n    private:\\n        int V;\\n        vector<int> parent;\\n        vector<int> rank;\\n    public:\\n        Disjoint_Sets(int V){\\n            this->V=V;\\n            parent.resize(V);\\n            rank.resize(V);\\n            for(int i=1;i<V;i++){\\n                parent[i]=i;\\n                rank[i]=0;\\n            }\\n        }\\n        int findParent(int v){\\n            if(parent[v]==v){\\n                return v;\\n            }\\n            return parent[v]=findParent(parent[v]);\\n        }\\n        bool merge(int u, int v){\\n            int parent_u=findParent(u);\\n            int parent_v=findParent(v);\\n            if(parent_u==parent_v){\\n                return true;\\n            }\\n            if(rank[parent_u]==rank[parent_v]){\\n                parent[parent_v]=parent_u;\\n                rank[parent_u]++;\\n            }\\n            else if(rank[parent_u]>rank[parent_v]){\\n                parent[parent_v]=parent_u;\\n            }\\n            else if(rank[parent_u]<rank[parent_v]){\\n                parent[parent_u]=parent_v;\\n            }\\n            return false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> isCycle(vector<vector<int>> &edges, vector<int> edgeDoNotConsider){\\n        int V=edges.size();\\n        Disjoint_Sets ds(V+1);\\n        for(auto edge: edges){\\n            if(edge[0]==edgeDoNotConsider[0] && edge[1]==edgeDoNotConsider[1]){\\n                continue;\\n            }\\n            if(ds.merge(edge[0],edge[1])==true){  //cycle found while merging edge[0] and edge[1]\\n                return {edge[0],edge[1]};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int V=edges.size();\\n        vector<int> inDegree(V+1,0);\\n        int TwoParentNode=-1;\\n        for(auto edge: edges){\\n            inDegree[edge[1]]++;\\n            if(inDegree[edge[1]]==2){\\n                TwoParentNode=edge[1];\\n            }\\n        }\\n        if(TwoParentNode==-1){ // if there is no two parent Node, start finding cycle from root\\n            return isCycle(edges,{-1,-1});  // find from root \\n        }\\n        \\n        vector<int> res;\\n        for(auto edge: edges){\\n            if(edge[1]==TwoParentNode){\\n                vector<int> temp=isCycle(edges,edge);\\n                if(temp[0]==-1 && temp[1]==-1){  // no cycles were found when we avoided this edge\\n                    res=edge;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Disjoint_Sets{\\n    private:\\n        int V;\\n        vector<int> parent;\\n        vector<int> rank;\\n    public:\\n        Disjoint_Sets(int V){\\n            this->V=V;\\n            parent.resize(V);\\n            rank.resize(V);\\n            for(int i=1;i<V;i++){\\n                parent[i]=i;\\n                rank[i]=0;\\n            }\\n        }\\n        int findParent(int v){\\n            if(parent[v]==v){\\n                return v;\\n            }\\n            return parent[v]=findParent(parent[v]);\\n        }\\n        bool merge(int u, int v){\\n            int parent_u=findParent(u);\\n            int parent_v=findParent(v);\\n            if(parent_u==parent_v){\\n                return true;\\n            }\\n            if(rank[parent_u]==rank[parent_v]){\\n                parent[parent_v]=parent_u;\\n                rank[parent_u]++;\\n            }\\n            else if(rank[parent_u]>rank[parent_v]){\\n                parent[parent_v]=parent_u;\\n            }\\n            else if(rank[parent_u]<rank[parent_v]){\\n                parent[parent_u]=parent_v;\\n            }\\n            return false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> isCycle(vector<vector<int>> &edges, vector<int> edgeDoNotConsider){\\n        int V=edges.size();\\n        Disjoint_Sets ds(V+1);\\n        for(auto edge: edges){\\n            if(edge[0]==edgeDoNotConsider[0] && edge[1]==edgeDoNotConsider[1]){\\n                continue;\\n            }\\n            if(ds.merge(edge[0],edge[1])==true){  //cycle found while merging edge[0] and edge[1]\\n                return {edge[0],edge[1]};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int V=edges.size();\\n        vector<int> inDegree(V+1,0);\\n        int TwoParentNode=-1;\\n        for(auto edge: edges){\\n            inDegree[edge[1]]++;\\n            if(inDegree[edge[1]]==2){\\n                TwoParentNode=edge[1];\\n            }\\n        }\\n        if(TwoParentNode==-1){ // if there is no two parent Node, start finding cycle from root\\n            return isCycle(edges,{-1,-1});  // find from root \\n        }\\n        \\n        vector<int> res;\\n        for(auto edge: edges){\\n            if(edge[1]==TwoParentNode){\\n                vector<int> temp=isCycle(edges,edge);\\n                if(temp[0]==-1 && temp[1]==-1){  // no cycles were found when we avoided this edge\\n                    res=edge;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607485,
                "title": "javascript-solution-connected-graph-idea",
                "content": "\\nvar findRedundantDirectedConnection = function (edges = [[0]]) {\\n    \\n\\tclass Vertices {\\n        constructor(vertex = 0) {\\n            this.vertex = vertex;\\n            this.d = 0;\\n            this.f = 0;\\n            this.color = \\'WHITE\\';\\n            this.parent = null;\\n            this.edgeIndex = [];\\n        }\\n    }\\n\\n    class Graph {\\n        constructor() {\\n            this.vertices = [];\\n            this.Adj = [];\\n        }\\n    }\\n\\n    let time = 0;\\n    let edgeIndex = -1;\\n    let vertices = [];\\n    let verticesIndex = 0;\\n    let skipRedundantNodeSeaarch = true;\\n\\n    var DFS_VISIT = function (G = new Graph(), u = new Vertices()) {\\n        time++;\\n        u.d = time;\\n        u.color = \\'GRAY\\';\\n        for (let i = 0; i < G.Adj[u.vertex].length; i++) {\\n            let v = G.Adj[u.vertex][i];\\n            if (v.color === \\'WHITE\\') {\\n                v.parent = u;\\n                DFS_VISIT(G, v);\\n            }\\n            else if (!skipRedundantNodeSeaarch) {\\n                if (v.color === \\'GRAY\\') { //back edge\\n                    edgeIndex = u.edgeIndex[v.vertex];\\n                    if (v.parent === null) {\\n                        let newParent = u.parent;\\n                        if (newParent.vertex === v.vertex) { //cycle\\n                            if (newParent.edgeIndex[u.vertex] > edgeIndex) edgeIndex = newParent.edgeIndex[u.vertex];\\n                        }\\n                        else {\\n                            let newV = u;\\n                            while (newParent && newParent.vertex !== v.vertex) {\\n                                if (newParent.edgeIndex[newV.vertex] > edgeIndex) edgeIndex = newParent.edgeIndex[newV.vertex];\\n                                newParent = newParent.parent;\\n                                newV = newV.parent;\\n                            }\\n                        }\\n                    }\\n                }\\n                else {\\n                    if(v.parent !== null) {\\n                        let newParent = v.parent;\\n                        edgeIndex = u.edgeIndex[v.vertex];\\n                        let aliasEdgeIndex = newParent.edgeIndex[v.vertex];\\n                        if (aliasEdgeIndex > edgeIndex) edgeIndex = aliasEdgeIndex;\\n                    }\\n                }\\n            }\\n        }\\n        u.color = \\'BLACK\\';\\n        time++;\\n        u.f = time;\\n        if (skipRedundantNodeSeaarch) vertices[vertices.length - 1 - verticesIndex++] = u;\\n\\n    }\\n\\n    var DFS = function (G = new Graph()) {\\n        for (let i = 0; i < G.vertices.length; i++) {\\n            if (G.vertices[i].color === \\'WHITE\\') {\\n                DFS_VISIT(G, G.vertices[i]);\\n            }\\n        }\\n    }\\n\\n    let G = new Graph();\\n\\n    for (let i = 0; i < edges.length; i++) {\\n        if (!G.vertices[edges[i][0] - 1]) G.vertices[edges[i][0] - 1] = new Vertices(edges[i][0] - 1);\\n        if (!G.vertices[edges[i][1] - 1]) G.vertices[edges[i][1] - 1] = new Vertices(edges[i][1] - 1);\\n\\n        G.vertices[edges[i][0] - 1].edgeIndex[edges[i][1] - 1] = i;\\n\\n        if (!G.Adj[edges[i][0] - 1]) G.Adj[edges[i][0] - 1] = [];\\n        if (!G.Adj[edges[i][1] - 1]) G.Adj[edges[i][1] - 1] = [];\\n        G.Adj[edges[i][0] - 1].push(G.vertices[edges[i][1] - 1]);\\n    }\\n\\n    vertices.length = G.vertices.length;\\n    DFS(G);\\n    for (let i = 0; i < vertices.length; i++) {\\n        vertices[i].d = 0;\\n        vertices[i].f = 0;\\n        vertices[i].color = \\'WHITE\\';\\n        vertices[i].parent = null;\\n    }\\n    G.vertices = vertices;\\n    skipRedundantNodeSeaarch = false;\\n    DFS(G);\\n    return edges[edgeIndex];\\n\\n}",
                "solutionTags": [],
                "code": "\\nvar findRedundantDirectedConnection = function (edges = [[0]]) {\\n    \\n\\tclass Vertices {\\n        constructor(vertex = 0) {\\n            this.vertex = vertex;\\n            this.d = 0;\\n            this.f = 0;\\n            this.color = \\'WHITE\\';\\n            this.parent = null;\\n            this.edgeIndex = [];\\n        }\\n    }\\n\\n    class Graph {\\n        constructor() {\\n            this.vertices = [];\\n            this.Adj = [];\\n        }\\n    }\\n\\n    let time = 0;\\n    let edgeIndex = -1;\\n    let vertices = [];\\n    let verticesIndex = 0;\\n    let skipRedundantNodeSeaarch = true;\\n\\n    var DFS_VISIT = function (G = new Graph(), u = new Vertices()) {\\n        time++;\\n        u.d = time;\\n        u.color = \\'GRAY\\';\\n        for (let i = 0; i < G.Adj[u.vertex].length; i++) {\\n            let v = G.Adj[u.vertex][i];\\n            if (v.color === \\'WHITE\\') {\\n                v.parent = u;\\n                DFS_VISIT(G, v);\\n            }\\n            else if (!skipRedundantNodeSeaarch) {\\n                if (v.color === \\'GRAY\\') { //back edge\\n                    edgeIndex = u.edgeIndex[v.vertex];\\n                    if (v.parent === null) {\\n                        let newParent = u.parent;\\n                        if (newParent.vertex === v.vertex) { //cycle\\n                            if (newParent.edgeIndex[u.vertex] > edgeIndex) edgeIndex = newParent.edgeIndex[u.vertex];\\n                        }\\n                        else {\\n                            let newV = u;\\n                            while (newParent && newParent.vertex !== v.vertex) {\\n                                if (newParent.edgeIndex[newV.vertex] > edgeIndex) edgeIndex = newParent.edgeIndex[newV.vertex];\\n                                newParent = newParent.parent;\\n                                newV = newV.parent;\\n                            }\\n                        }\\n                    }\\n                }\\n                else {\\n                    if(v.parent !== null) {\\n                        let newParent = v.parent;\\n                        edgeIndex = u.edgeIndex[v.vertex];\\n                        let aliasEdgeIndex = newParent.edgeIndex[v.vertex];\\n                        if (aliasEdgeIndex > edgeIndex) edgeIndex = aliasEdgeIndex;\\n                    }\\n                }\\n            }\\n        }\\n        u.color = \\'BLACK\\';\\n        time++;\\n        u.f = time;\\n        if (skipRedundantNodeSeaarch) vertices[vertices.length - 1 - verticesIndex++] = u;\\n\\n    }\\n\\n    var DFS = function (G = new Graph()) {\\n        for (let i = 0; i < G.vertices.length; i++) {\\n            if (G.vertices[i].color === \\'WHITE\\') {\\n                DFS_VISIT(G, G.vertices[i]);\\n            }\\n        }\\n    }\\n\\n    let G = new Graph();\\n\\n    for (let i = 0; i < edges.length; i++) {\\n        if (!G.vertices[edges[i][0] - 1]) G.vertices[edges[i][0] - 1] = new Vertices(edges[i][0] - 1);\\n        if (!G.vertices[edges[i][1] - 1]) G.vertices[edges[i][1] - 1] = new Vertices(edges[i][1] - 1);\\n\\n        G.vertices[edges[i][0] - 1].edgeIndex[edges[i][1] - 1] = i;\\n\\n        if (!G.Adj[edges[i][0] - 1]) G.Adj[edges[i][0] - 1] = [];\\n        if (!G.Adj[edges[i][1] - 1]) G.Adj[edges[i][1] - 1] = [];\\n        G.Adj[edges[i][0] - 1].push(G.vertices[edges[i][1] - 1]);\\n    }\\n\\n    vertices.length = G.vertices.length;\\n    DFS(G);\\n    for (let i = 0; i < vertices.length; i++) {\\n        vertices[i].d = 0;\\n        vertices[i].f = 0;\\n        vertices[i].color = \\'WHITE\\';\\n        vertices[i].parent = null;\\n    }\\n    G.vertices = vertices;\\n    skipRedundantNodeSeaarch = false;\\n    DFS(G);\\n    return edges[edgeIndex];\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1570850,
                "title": "c-685-redundant-connection-ii",
                "content": "\\n```\\nclass UnionFind {\\n    vector<int> parent, rank; \\npublic: \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size(); \\n        vector<int> parent(n, 0), cand0, cand1, cand2; \\n        bool mult = false, cycle = false; \\n        UnionFind *uf = new UnionFind(n); \\n        \\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1]; \\n            if (parent[v-1]) {\\n                mult = true; \\n                cand0 = {parent[v-1], v}; \\n                cand1 = {u, v}; \\n            } else {\\n                parent[v-1] = u; \\n                if (!uf->connect(u-1, v-1)) {\\n                    cycle = true; \\n                    cand2 = {u, v}; \\n                }\\n            }\\n        }\\n        return mult && cycle ? cand0 : mult ? cand1 : cand2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent, rank; \\npublic: \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size(); \\n        vector<int> parent(n, 0), cand0, cand1, cand2; \\n        bool mult = false, cycle = false; \\n        UnionFind *uf = new UnionFind(n); \\n        \\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1]; \\n            if (parent[v-1]) {\\n                mult = true; \\n                cand0 = {parent[v-1], v}; \\n                cand1 = {u, v}; \\n            } else {\\n                parent[v-1] = u; \\n                if (!uf->connect(u-1, v-1)) {\\n                    cycle = true; \\n                    cand2 = {u, v}; \\n                }\\n            }\\n        }\\n        return mult && cycle ? cand0 : mult ? cand1 : cand2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498872,
                "title": "python-3-union-find-99-faster",
                "content": "![image](https://assets.leetcode.com/users/images/ec66581a-d383-42e5-99a0-19712807610d_1633183552.5864737.png)\\n\\nRecommend to solve 684 first, since this question is a slight modified version of 684:\\n1. Connections are unidirectional, so for each edge we union child node (second element) to its parent (first element).\\n2. Find the node with two parents, there is exactly one such node guaranteed by the question setup.\\n3. Skip the edge to its second parent (which occurs later than the connection to its first parent), union the rest. If True, return the skipped, else return the connection to its first parent.\\n\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        N = len(edges)\\n        pars = list(range(N))\\n        \\n        def find(i: int):\\n            if pars[i] != i:\\n                pars[i] = find(pars[i])\\n            return pars[i]\\n        \\n        def union(edge: List[int]) -> bool:\\n            i, j = edge[0] - 1, edge[1] - 1\\n            pi, pj = find(i), find(j)\\n            if pi == pj:\\n                return False\\n            pars[pj] = pi\\n            return True\\n        \\n        i_2p = -1\\n        #ct_root = [0] * (N+1)\\n        ct_root = Counter()\\n        for edge in edges:\\n            _, child = edge\\n            ct_root[child] += 1\\n            if ct_root[child] == 2:\\n                i_2p = child\\n                break\\n        \\n        if i_2p < 0:\\n            for edge in edges:\\n                if not union(edge):\\n                    return edge\\n        else:\\n            tests = []\\n            for i in range(N):\\n                if edges[i][1] == i_2p:\\n                    tests.append(i)\\n                    if len(tests) == 2:\\n                        break\\n            for i in range(N):\\n                if i != tests[1]:\\n                    if not union(edges[i]):\\n                        return edges[tests[0]]\\n            return edges[tests[1]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        N = len(edges)\\n        pars = list(range(N))\\n        \\n        def find(i: int):\\n            if pars[i] != i:\\n                pars[i] = find(pars[i])\\n            return pars[i]\\n        \\n        def union(edge: List[int]) -> bool:\\n            i, j = edge[0] - 1, edge[1] - 1\\n            pi, pj = find(i), find(j)\\n            if pi == pj:\\n                return False\\n            pars[pj] = pi\\n            return True\\n        \\n        i_2p = -1\\n        #ct_root = [0] * (N+1)\\n        ct_root = Counter()\\n        for edge in edges:\\n            _, child = edge\\n            ct_root[child] += 1\\n            if ct_root[child] == 2:\\n                i_2p = child\\n                break\\n        \\n        if i_2p < 0:\\n            for edge in edges:\\n                if not union(edge):\\n                    return edge\\n        else:\\n            tests = []\\n            for i in range(N):\\n                if edges[i][1] == i_2p:\\n                    tests.append(i)\\n                    if len(tests) == 2:\\n                        break\\n            for i in range(N):\\n                if i != tests[1]:\\n                    if not union(edges[i]):\\n                        return edges[tests[0]]\\n            return edges[tests[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492376,
                "title": "java-dfs-one-pass",
                "content": "To be honest, it is not straightforward to me why would one use union find to locate the cycles instead of using DFS + coloring. In fact, you would not be able to find the cycle\\'s nodes unless there are specific constraints, like those in this question, namely there are only one problematic edge. Thus when we have a node with two incoming edges, removing one then execute union find would give you a hint about whether the remove edge is causing cycle. \\n\\nNow, not to say union find for this problem is a bad solution, but it is not a very easy strategy to come up with in a limited time, especially regarding the trick of removing one edge first, then test it by doing union find. This really comes down to trick mastering... \\n\\nAnyways, here is my standard DFS cycle finding solution. \\nThe ugly: \\n- The code is being lengthy and more code means more bugs. I do prefer union find solution\\'s cleaness in terms of code quality.\\n\\nThe good: \\n- you only need to understand the standard cycle finding DFS algorithm and you are good. \\n- Overall logic is very simple once you figured out the different cases. \\n\\nNow the cases that break the graph (this really is the core of this problem, you have to deal with it no matter what algorithm you use...):\\n1. There are directed cycles\\n\\ta. the cycle passes root -> every node on cycle has 1 parent exactly. In this case, deleting any edge will restore the tree status, but we are asked to delete the edge with largest index. \\n\\tb. the cycle does not pass root -> there is exactly 1 node in the cycle who has two parents. This is the most annoying case, cause you will have to find the node who has 2 parents, then remove the edge that is contained in the cycle. Now the graph is restored, this is the only way in this case.\\n\\t\\n2. There are no directed cycles but some node has two parents\\n\\ta. this is easy case, cause we can remove the parent edge with larger index.\\n\\nNow, the algorithm:\\n1. Build necessary data storage: parent status of each node, the graph itself, and edge index for each edge. Yea I know, this is the ugly part.\\n2. DFS traversal on every node.\\n\\ta. when you found a cycle, process the cycle. It will be one of the two cycle cases and you return results accordingly.\\n\\tb. Note: DFS on direct graph will be a bit wierd in the sense that you are visiting connected fragments, say you visited the child first, then you traversed all connected edges from this child, then later you visit this child\\'s parent, and you stopped right there before visiting the child again. But, this does not influence cycle finding, you will always being able to loop back to a node on dfs search path if there is cycle.\\n3. When DFS traversal did not find any cycle, you just return the two parent node\\'s edge, pick the one with bigger index.\\n\\n\\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        Map<Integer, Map<Integer, Integer>> edgeIndex = \\n            new HashMap<>();\\n        Map<Integer, List<Integer>> parent = new HashMap<>();\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int oddNode = -1;\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            \\n            // graph.\\n            List<Integer> tmp = graph.getOrDefault(e[0], \\n                                    new ArrayList<>());\\n            tmp.add(e[1]);\\n            graph.put(e[0], tmp);\\n            \\n            // Parent status.\\n            tmp = parent.getOrDefault(e[1], \\n                        new ArrayList<>());\\n            tmp.add(e[0]);\\n            if (tmp.size() > 1) oddNode = e[1];\\n            parent.put(e[1], tmp);\\n            \\n            // edge Index.\\n            Map<Integer, Integer> tmp2 =\\n                edgeIndex.getOrDefault(e[0], new HashMap<>());\\n            tmp2.put(e[1], i);\\n            edgeIndex.put(e[0], tmp2);\\n        }\\n        \\n        List<Integer> cycle = new ArrayList<>();\\n        int n = 1001;\\n        int[] stat = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (stat[i] != 0) continue;\\n            \\n            dfs(i, graph, stat, new ArrayList<>(), cycle);\\n                \\n            if (cycle.size() == 0) {\\n                continue;\\n            } else {\\n                // found cycle.\\n                int maxEdgeInd = 0;\\n                int twinInEdgeNode = -1;\\n                int cLen = cycle.size();\\n                Set<Integer> cycleSet = new HashSet<>();\\n                for (int c = 0; c < cLen; c++) {\\n                    int s = cycle.get(c);\\n                    int t = cycle.get((c + 1) % cLen);\\n\\n                    // Cycle did not pass root.\\n                    if (parent.get(s).size() == 2) {\\n                        twinInEdgeNode = s;\\n                    }\\n\\n                    cycleSet.add(s);\\n                    maxEdgeInd = Math.max(maxEdgeInd, \\n                                edgeIndex.get(s).get(t));\\n                }\\n\\n                // Cycle pass root, return maxInd edge.\\n                if (twinInEdgeNode == -1) return edges[maxEdgeInd];\\n\\n                // Cycle did not pass root.\\n                int a = parent.get(twinInEdgeNode).get(0);\\n                int b = parent.get(twinInEdgeNode).get(1);\\n                int ai = edgeIndex.get(a).get(twinInEdgeNode);\\n                int bi = edgeIndex.get(b).get(twinInEdgeNode);\\n\\n                return cycleSet.contains(a) ? edges[ai] : edges[bi];\\n            }\\n        }\\n        \\n        // visited some black node twice.\\n        int a = parent.get(oddNode).get(0);\\n        int b = parent.get(oddNode).get(1);\\n        int ai = edgeIndex.get(a).get(oddNode);\\n        int bi = edgeIndex.get(b).get(oddNode);\\n\\n        return ai > bi ? edges[ai] : edges[bi];\\n    }\\n    \\n    public void dfs(int cur, \\n                    Map<Integer, List<Integer>> graph,\\n                    int[] stat, List<Integer> tracker, \\n                    List<Integer> cycle) {\\n        if (cycle.size() > 0) return;\\n        \\n        if (stat[cur] == 1) {\\n            // found cycle.\\n            int i = 0;\\n            while (tracker.get(i) != cur) i++;\\n            \\n            for (int j = i; j < tracker.size(); j++) {\\n                cycle.add(tracker.get(j));\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (stat[cur] == 2) {\\n            return;\\n        }\\n        \\n        stat[cur] = 1;\\n        tracker.add(cur);\\n        \\n        if (graph.containsKey(cur)) {\\n            for (int n : graph.get(cur)) {\\n                dfs(n, graph, stat, tracker, cycle);\\n            }    \\n        }\\n        \\n        stat[cur] = 2;\\n        tracker.remove(tracker.size() - 1);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        Map<Integer, Map<Integer, Integer>> edgeIndex = \\n            new HashMap<>();\\n        Map<Integer, List<Integer>> parent = new HashMap<>();\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int oddNode = -1;\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            \\n            // graph.\\n            List<Integer> tmp = graph.getOrDefault(e[0], \\n                                    new ArrayList<>());\\n            tmp.add(e[1]);\\n            graph.put(e[0], tmp);\\n            \\n            // Parent status.\\n            tmp = parent.getOrDefault(e[1], \\n                        new ArrayList<>());\\n            tmp.add(e[0]);\\n            if (tmp.size() > 1) oddNode = e[1];\\n            parent.put(e[1], tmp);\\n            \\n            // edge Index.\\n            Map<Integer, Integer> tmp2 =\\n                edgeIndex.getOrDefault(e[0], new HashMap<>());\\n            tmp2.put(e[1], i);\\n            edgeIndex.put(e[0], tmp2);\\n        }\\n        \\n        List<Integer> cycle = new ArrayList<>();\\n        int n = 1001;\\n        int[] stat = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (stat[i] != 0) continue;\\n            \\n            dfs(i, graph, stat, new ArrayList<>(), cycle);\\n                \\n            if (cycle.size() == 0) {\\n                continue;\\n            } else {\\n                // found cycle.\\n                int maxEdgeInd = 0;\\n                int twinInEdgeNode = -1;\\n                int cLen = cycle.size();\\n                Set<Integer> cycleSet = new HashSet<>();\\n                for (int c = 0; c < cLen; c++) {\\n                    int s = cycle.get(c);\\n                    int t = cycle.get((c + 1) % cLen);\\n\\n                    // Cycle did not pass root.\\n                    if (parent.get(s).size() == 2) {\\n                        twinInEdgeNode = s;\\n                    }\\n\\n                    cycleSet.add(s);\\n                    maxEdgeInd = Math.max(maxEdgeInd, \\n                                edgeIndex.get(s).get(t));\\n                }\\n\\n                // Cycle pass root, return maxInd edge.\\n                if (twinInEdgeNode == -1) return edges[maxEdgeInd];\\n\\n                // Cycle did not pass root.\\n                int a = parent.get(twinInEdgeNode).get(0);\\n                int b = parent.get(twinInEdgeNode).get(1);\\n                int ai = edgeIndex.get(a).get(twinInEdgeNode);\\n                int bi = edgeIndex.get(b).get(twinInEdgeNode);\\n\\n                return cycleSet.contains(a) ? edges[ai] : edges[bi];\\n            }\\n        }\\n        \\n        // visited some black node twice.\\n        int a = parent.get(oddNode).get(0);\\n        int b = parent.get(oddNode).get(1);\\n        int ai = edgeIndex.get(a).get(oddNode);\\n        int bi = edgeIndex.get(b).get(oddNode);\\n\\n        return ai > bi ? edges[ai] : edges[bi];\\n    }\\n    \\n    public void dfs(int cur, \\n                    Map<Integer, List<Integer>> graph,\\n                    int[] stat, List<Integer> tracker, \\n                    List<Integer> cycle) {\\n        if (cycle.size() > 0) return;\\n        \\n        if (stat[cur] == 1) {\\n            // found cycle.\\n            int i = 0;\\n            while (tracker.get(i) != cur) i++;\\n            \\n            for (int j = i; j < tracker.size(); j++) {\\n                cycle.add(tracker.get(j));\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (stat[cur] == 2) {\\n            return;\\n        }\\n        \\n        stat[cur] = 1;\\n        tracker.add(cur);\\n        \\n        if (graph.containsKey(cur)) {\\n            for (int n : graph.get(cur)) {\\n                dfs(n, graph, stat, tracker, cycle);\\n            }    \\n        }\\n        \\n        stat[cur] = 2;\\n        tracker.remove(tracker.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433067,
                "title": "c-with-diagram-detailed-explanation",
                "content": "\\tThe problem states that there is an unnecessary edge which is not letting this graph to be a tree, Now an unncessary edge can lead to the following\\n\\n\\t\\t1) It can make a node have two parents\\n\\t\\t\\twhen only this condition is satisfied, that is there is a node having two parents (and we dont have any cycles),\\n\\t\\t\\tsimply return the last such edge in the edgeList, this can be done by using an in-degree array, where we store -1\\n\\t\\t\\twhen no one points to a given node, and in case someone points to this node, we store the location of that node (or the index )\\n\\t\\t\\twhere it occurred in the edge list\\n\\t\\t\\tin the below diagram , the edges in red are causing problem , so remove the one which comes the last in the edge list\\n![image](https://assets.leetcode.com/users/images/62eca74a-956c-40e9-8834-ff71a78bec62_1630249079.6178932.png)\\n\\n\\t\\n\\n\\n\\n\\n\\n\\n\\t\\t2) It may contain a cycle\\n\\t\\t\\twhen in the in-degree array, no one has two parents, it means that only way there can exist an unncessary edge is by having a cycle\\n\\t\\t\\tso simple detect a cycle using DSU \\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/07d34600-43b6-4431-b301-33fb66f25c6c_1630249205.5177577.png)\\n\\n\\n\\t\\n\\n\\n\\n\\n\\n\\t\\t3) both of the above, it may have a node having two parents and a cycle\\n\\t\\t\\tIn this case when both of the conditions are satisfied, then one of the two parents which point to the node having\\n\\t\\t\\tin-degree two is the answer (means parent->node edge)\\n\\t\\t\\tIn this case, the edge which is contained in the cycle and points to this node having two parents is the answer\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/214979d4-27da-4c26-9aa5-52ee110257c7_1630249285.6398723.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\t//\\n\\tvector<int> parent;\\n\\n\\tint findParent(int u) {\\n\\t\\treturn parent[u] = (parent[u] == u ? u : findParent(parent[u]));\\n\\t}\\n\\n\\n\\tvoid _union(int u, int v) {\\n\\n\\t\\tint pv = findParent(v); int pu = findParent(u);\\n\\t\\tparent[pv] = pu;\\n\\t}\\n\\n\\n\\tvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\t\\tparent.resize(1002);\\n\\t\\tfor (int i = 0; i < 1002; i++) parent[i] = i;\\n\\t\\tvector<int> pans;\\n\\t\\tvector<int> ans;\\n\\t\\tvector<int> ind(1002, -1);\\n\\t\\tint bl1 = -1, bl2 = -1;\\n\\n\\t\\tfor (int i = 0; i < edges.size(); i++) {\\n\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\tif (ind[v] == -1) ind[v] = i;\\n\\n\\t\\t\\telse if (ind[v] != -1) {\\n\\t\\t\\t\\tbl2 = ind[v];\\n\\t\\t\\t\\tbl1 = i;\\n\\t\\t\\t\\tind[v] = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (findParent(u) == findParent(v)) {\\n\\t\\t\\t\\t// cout<<\"parent of \"<<u<<\" is equal to parent of  \"<<v<<\" which is equal to \"<<findParent(u) <<\"\\\\n\";\\n\\t\\t\\t\\tpans = edges[i];\\n\\t\\t\\t} else if (findParent(u) != findParent(v)) {\\n\\t\\t\\t\\t_union(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t// cout<<bl1<<bl2<<\\'\\\\n\\';\\n\\t\\t// cout<<pans.empty()<<\\'\\\\n\\';\\n\\t\\t// for(int x : pans)cout<<x<<\" \";\\n\\t\\t// if there are no nodes with 2 parents (means bl1 and bl2 are -1 ) then it means that we have to detect just the cycle\\n\\t\\tif (bl1 == -1 && bl2 == -1) {\\n\\t\\t\\t// there are no nodes with 2 parents\\n\\t\\t\\tans = pans;\\n\\t\\t\\treturn ans;\\n\\n\\t\\t} else if (pans.empty()) {\\n\\t\\t\\t// means there are no cycles (we simply use the method in redundant connections 1)\\n\\t\\t\\tans = edges[bl1];\\n\\t\\t\\treturn ans;\\n\\t\\t} else {\\n\\t\\t\\t// in this case there are 2 parents and a cycle (so the answer can be any of bl1 and bl2)\\n\\t\\t\\t// bl1 is the latest edge which is pointing to the node which has two parents\\n\\t\\t\\t// bl2 was the first edge (according to what is given in the problem ) which is pointing to thee node having two parents\\n\\t\\t\\tparent.resize(1002);\\n\\t\\t\\tfor (int i = 0; i < 1002; i++) {\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// just expel bl1 and check\\n\\t\\t\\tfor (int i = 0; i < edges.size(); i++) {\\n\\t\\t\\t\\tif (i != bl1) {\\n\\t\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\t\\t\\tif (findParent(u) == findParent(v)) {\\n\\t\\t\\t\\t\\t\\tans = edges[bl2];\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t_union(u, v);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = edges[bl1];\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\n\\t}\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//\\n\\tvector<int> parent;\\n\\n\\tint findParent(int u) {\\n\\t\\treturn parent[u] = (parent[u] == u ? u : findParent(parent[u]));\\n\\t}\\n\\n\\n\\tvoid _union(int u, int v) {\\n\\n\\t\\tint pv = findParent(v); int pu = findParent(u);\\n\\t\\tparent[pv] = pu;\\n\\t}\\n\\n\\n\\tvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\t\\tparent.resize(1002);\\n\\t\\tfor (int i = 0; i < 1002; i++) parent[i] = i;\\n\\t\\tvector<int> pans;\\n\\t\\tvector<int> ans;\\n\\t\\tvector<int> ind(1002, -1);\\n\\t\\tint bl1 = -1, bl2 = -1;\\n\\n\\t\\tfor (int i = 0; i < edges.size(); i++) {\\n\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\tif (ind[v] == -1) ind[v] = i;\\n\\n\\t\\t\\telse if (ind[v] != -1) {\\n\\t\\t\\t\\tbl2 = ind[v];\\n\\t\\t\\t\\tbl1 = i;\\n\\t\\t\\t\\tind[v] = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (findParent(u) == findParent(v)) {\\n\\t\\t\\t\\t// cout<<\"parent of \"<<u<<\" is equal to parent of  \"<<v<<\" which is equal to \"<<findParent(u) <<\"\\\\n\";\\n\\t\\t\\t\\tpans = edges[i];\\n\\t\\t\\t} else if (findParent(u) != findParent(v)) {\\n\\t\\t\\t\\t_union(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t// cout<<bl1<<bl2<<\\'\\\\n\\';\\n\\t\\t// cout<<pans.empty()<<\\'\\\\n\\';\\n\\t\\t// for(int x : pans)cout<<x<<\" \";\\n\\t\\t// if there are no nodes with 2 parents (means bl1 and bl2 are -1 ) then it means that we have to detect just the cycle\\n\\t\\tif (bl1 == -1 && bl2 == -1) {\\n\\t\\t\\t// there are no nodes with 2 parents\\n\\t\\t\\tans = pans;\\n\\t\\t\\treturn ans;\\n\\n\\t\\t} else if (pans.empty()) {\\n\\t\\t\\t// means there are no cycles (we simply use the method in redundant connections 1)\\n\\t\\t\\tans = edges[bl1];\\n\\t\\t\\treturn ans;\\n\\t\\t} else {\\n\\t\\t\\t// in this case there are 2 parents and a cycle (so the answer can be any of bl1 and bl2)\\n\\t\\t\\t// bl1 is the latest edge which is pointing to the node which has two parents\\n\\t\\t\\t// bl2 was the first edge (according to what is given in the problem ) which is pointing to thee node having two parents\\n\\t\\t\\tparent.resize(1002);\\n\\t\\t\\tfor (int i = 0; i < 1002; i++) {\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// just expel bl1 and check\\n\\t\\t\\tfor (int i = 0; i < edges.size(); i++) {\\n\\t\\t\\t\\tif (i != bl1) {\\n\\t\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\t\\t\\tif (findParent(u) == findParent(v)) {\\n\\t\\t\\t\\t\\t\\tans = edges[bl2];\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t_union(u, v);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = edges[bl1];\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\n\\t}\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1298348,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\n    int rank_[1007],par[1007];\\n    int find(int x)\\n    {\\n        if(par[x]==x)return x;\\n        return par[x]=find(par[x]);\\n    }\\n    bool union_(int x,int y)\\n    {\\n        int a = find(x);\\n        int b = find(y);\\n        if(a==b)return true;\\n        if(rank_[a]>rank_[b])par[b]=a;\\n        else if(rank_[b]>rank_[a])par[a]=b;\\n        else\\n        {\\n            rank_[a]++; par[b]=a;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size(),x,y;\\n        for(int i=1;i<=n;i++)par[i]=0;\\n        vector<int> A,B;\\n        for(int i=0;i<n;i++)\\n        {\\n            x = edges[i][0];\\n            y = edges[i][1];\\n            if(par[y])\\n            {\\n                A = {par[y],y};\\n                B = {x,y};\\n                edges[i][1] = 0;\\n            }\\n            else\\n                par[y]=x;\\n        }\\n        for(int i=1;i<=n;i++)\\n        { par[i]=i; rank_[i]=1;}\\n        for(int i=0;i<n;i++)\\n        {\\n            x = edges[i][0];\\n            y = edges[i][1];\\n            if(y == 0)continue;\\n            if(union_(x,y))\\n            {\\n                if(A.size()==0)\\n                   A = {x,y};\\n                return A;\\n            }\\n        }\\n        return B;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int rank_[1007],par[1007];\\n    int find(int x)\\n    {\\n        if(par[x]==x)return x;\\n        return par[x]=find(par[x]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1230715,
                "title": "java-kruskal-algorithm",
                "content": "Kruskal Algorithm Solution\\n\\n1. The first problem we need to solve: when a new edge added , whether the new adding leads to a circle formed in the graph. when a circle is detected, we return the added edge, otherwise, return null;(Kruskal Algorithm), return this result when there is no node has two parents.\\n\\n2. The problem description gives a limitation that there is only one node in the graph that could have two parent nodes\\n(e.g. [1,3],[2,3], 3 has two parent nodes 1 and 2), \\nwhich means one of edges must be deleted. First we try delete the last one, and the check the circle existing, if it returns a null, the result should be the deleted edge, otherwise, another edge should be the right answer.\\n```\\nclass Solution {\\n    int[] parent1 = new int[2];\\n    int[] parent2 = new int[2];\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] ends = new int[edges.length+1]; \\n        ArrayList<int[]> nedges = deleteParent(edges);\\n        int[] res = checkCircle(nedges,ends);\\n        if(parent1[0]==0&&parent1[1]==0){\\n            return res;\\n        }else{\\n            if(res != null){\\n                return parent2;\\n            }else{\\n                return parent1;\\n            }\\n        }\\n    }\\n    //delete one of the edges of the node has two parent node;e.g.[1,3][2,3]\\n    public  ArrayList<int[]> deleteParent (int[][]edges){\\n        ArrayList<int[]> nedge = new ArrayList<int[]>();\\n        HashSet<Integer> tail = new HashSet<Integer>();\\n        for(int[] e : edges){\\n            \\n            if(!tail.add(e[1])){\\n                parent1[0]=e[0];\\n               parent1[1] = e[1];\\n                \\n            }else{\\n               nedge.add(e); \\n            }\\n                    \\n        }\\n        return nedge;\\n    }\\n    \\n    public int[] checkCircle(ArrayList<int[]>nedges, int[]ends){\\n        \\n        for(int[] edge: nedges){\\n            if(parent1[1]!=0 && edge[1]== parent1[1]){\\n                parent2 = edge;\\n            }\\n            int h = getEnd(edge[0],ends);\\n            int t = getEnd(edge[1],ends);\\n            if(h!=t){\\n                ends[edge[1]] = h;  \\n            }else{\\n                return edge;\\n            }\\n        }        \\n        return null;\\n    }\\n    public int getEnd(int head, int[]ends){\\n        while(ends[head]!= 0){\\n           head = ends[head];\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] parent1 = new int[2];\\n    int[] parent2 = new int[2];\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] ends = new int[edges.length+1]; \\n        ArrayList<int[]> nedges = deleteParent(edges);\\n        int[] res = checkCircle(nedges,ends);\\n        if(parent1[0]==0&&parent1[1]==0){\\n            return res;\\n        }else{\\n            if(res != null){\\n                return parent2;\\n            }else{\\n                return parent1;\\n            }\\n        }\\n    }\\n    //delete one of the edges of the node has two parent node;e.g.[1,3][2,3]\\n    public  ArrayList<int[]> deleteParent (int[][]edges){\\n        ArrayList<int[]> nedge = new ArrayList<int[]>();\\n        HashSet<Integer> tail = new HashSet<Integer>();\\n        for(int[] e : edges){\\n            \\n            if(!tail.add(e[1])){\\n                parent1[0]=e[0];\\n               parent1[1] = e[1];\\n                \\n            }else{\\n               nedge.add(e); \\n            }\\n                    \\n        }\\n        return nedge;\\n    }\\n    \\n    public int[] checkCircle(ArrayList<int[]>nedges, int[]ends){\\n        \\n        for(int[] edge: nedges){\\n            if(parent1[1]!=0 && edge[1]== parent1[1]){\\n                parent2 = edge;\\n            }\\n            int h = getEnd(edge[0],ends);\\n            int t = getEnd(edge[1],ends);\\n            if(h!=t){\\n                ends[edge[1]] = h;  \\n            }else{\\n                return edge;\\n            }\\n        }        \\n        return null;\\n    }\\n    public int getEnd(int head, int[]ends){\\n        while(ends[head]!= 0){\\n           head = ends[head];\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204356,
                "title": "c-dsu-with-steps",
                "content": "```\\n/*Steps----\\n     1.) Find the node having two parents(If there then two invalid possibilities(let A & B) and makes B invalid)\\n     2.) Use DSU to find cycle.\\n          ---->If no cycle found then return B\\n          ---->If cycle found and no node with two parents the return current edge\\n          ---->else return A\\n\\n*/\\nclass DSU   //NORMAL DSU\\n{\\n    public:\\n    vector<int>parent;\\n    DSU(int n)\\n    {\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int Find(int x)\\n    {\\n        if(x!=parent[x])\\n            parent[x]=Find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int a,int b)\\n    {\\n        parent[b]=a;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) \\n    {\\n        int n=edges.size();\\n        \\n        //Step-1\\n        \\n        vector<int>A,B;\\n        vector<int>parent(n+1,0); //To find node with two parents\\n        for(auto &edge:edges)\\n        {\\n            if(parent[edge[1]]==0)\\n                parent[edge[1]]=edge[0];\\n            else\\n            {\\n                A={parent[edge[1]],edge[1]};\\n                B=edge;                     \\n                //Two possibilities A & B\\n                edge[1]=0; //Make B invalid;\\n            }\\n        }\\n        \\n        //Step 2 DSU\\n        \\n        DSU dsu=DSU(n+1);\\n        for(auto v:edges)\\n        {\\n            int a=v[0],b=v[1];\\n            if(b==0)\\n                continue;\\n            int pa=dsu.Find(a),pb=dsu.Find(b);\\n            if(pa==pb)  //Cycle found\\n            {\\n                if(A.empty())   //If no node with two parents return current node\\n                    return v;\\n                return A;       //Else return A\\n            }\\n            else\\n                dsu.Union(pa,pb);\\n        }\\n        return B;  //No cycle found return B\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*Steps----\\n     1.) Find the node having two parents(If there then two invalid possibilities(let A & B) and makes B invalid)\\n     2.) Use DSU to find cycle.\\n          ---->If no cycle found then return B\\n          ---->If cycle found and no node with two parents the return current edge\\n          ---->else return A\\n\\n*/\\nclass DSU   //NORMAL DSU\\n{\\n    public:\\n    vector<int>parent;\\n    DSU(int n)\\n    {\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int Find(int x)\\n    {\\n        if(x!=parent[x])\\n            parent[x]=Find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int a,int b)\\n    {\\n        parent[b]=a;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) \\n    {\\n        int n=edges.size();\\n        \\n        //Step-1\\n        \\n        vector<int>A,B;\\n        vector<int>parent(n+1,0); //To find node with two parents\\n        for(auto &edge:edges)\\n        {\\n            if(parent[edge[1]]==0)\\n                parent[edge[1]]=edge[0];\\n            else\\n            {\\n                A={parent[edge[1]],edge[1]};\\n                B=edge;                     \\n                //Two possibilities A & B\\n                edge[1]=0; //Make B invalid;\\n            }\\n        }\\n        \\n        //Step 2 DSU\\n        \\n        DSU dsu=DSU(n+1);\\n        for(auto v:edges)\\n        {\\n            int a=v[0],b=v[1];\\n            if(b==0)\\n                continue;\\n            int pa=dsu.Find(a),pb=dsu.Find(b);\\n            if(pa==pb)  //Cycle found\\n            {\\n                if(A.empty())   //If no node with two parents return current node\\n                    return v;\\n                return A;       //Else return A\\n            }\\n            else\\n                dsu.Union(pa,pb);\\n        }\\n        return B;  //No cycle found return B\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180847,
                "title": "simple-union-find-java-solution",
                "content": "```\\nclass Solution {\\n    int par[];\\n    \\n    public int findpar(int u) {\\n        if(u == par[u]) return u;\\n        par[u] = findpar(par[u]);\\n        return par[u];\\n    }\\n    \\n    public int[] detectCycle(int[][] edges, int[] skipEdge) {\\n        par = new int[edges.length + 1];\\n        for(int i = 1; i < par.length; i++) par[i] = i;\\n        \\n        for(int[] e : edges) {\\n            int src = e[0];\\n            int dest = e[1];\\n            \\n            if(src == skipEdge[0] && dest == skipEdge[1]) continue;\\n            \\n            int p1 = findpar(src);\\n            int p2 = findpar(dest);\\n            \\n            if(p1 == p2) {\\n                return e;\\n            }  \\n            par[p2] = p1;\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        \\n        int twoIndegreeVtx = -1;\\n        \\n        for(int[] e : edges) {\\n            indegree[e[1]]++;\\n            if(indegree[e[1]] == 2) twoIndegreeVtx = e[1];\\n        }\\n        \\n        if(twoIndegreeVtx == -1) {\\n            return detectCycle(edges, new int[]{-1, -1});\\n        }\\n        \\n        for(int i = edges.length - 1; i >= 0; i--) {\\n            int[] e = edges[i];\\n            if(e[1] == twoIndegreeVtx) {\\n                int[] redEdge = detectCycle(edges, e);\\n                if(redEdge == null) {\\n                    return e;\\n                }\\n            } \\n        }\\n        \\n        return new int[0];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int par[];\\n    \\n    public int findpar(int u) {\\n        if(u == par[u]) return u;\\n        par[u] = findpar(par[u]);\\n        return par[u];\\n    }\\n    \\n    public int[] detectCycle(int[][] edges, int[] skipEdge) {\\n        par = new int[edges.length + 1];\\n        for(int i = 1; i < par.length; i++) par[i] = i;\\n        \\n        for(int[] e : edges) {\\n            int src = e[0];\\n            int dest = e[1];\\n            \\n            if(src == skipEdge[0] && dest == skipEdge[1]) continue;\\n            \\n            int p1 = findpar(src);\\n            int p2 = findpar(dest);\\n            \\n            if(p1 == p2) {\\n                return e;\\n            }  \\n            par[p2] = p1;\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        \\n        int twoIndegreeVtx = -1;\\n        \\n        for(int[] e : edges) {\\n            indegree[e[1]]++;\\n            if(indegree[e[1]] == 2) twoIndegreeVtx = e[1];\\n        }\\n        \\n        if(twoIndegreeVtx == -1) {\\n            return detectCycle(edges, new int[]{-1, -1});\\n        }\\n        \\n        for(int i = edges.length - 1; i >= 0; i--) {\\n            int[] e = edges[i];\\n            if(e[1] == twoIndegreeVtx) {\\n                int[] redEdge = detectCycle(edges, e);\\n                if(redEdge == null) {\\n                    return e;\\n                }\\n            } \\n        }\\n        \\n        return new int[0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014113,
                "title": "java-1ms-solution-with-explanation",
                "content": "There are two key rules for the directed tree:\\n1. There is only one root node (whose indegree is **0**) \\n2. The indegree of other nodes are all **1**. \\n\\nIn this problem, the redundant edge can break either the two rules. If the first rule is broken, then there is a cycle. Otherwise, there is a node whose indegree is 2. \\n\\nWe use two variables ```cycle``` and ```conflict``` to denote the edge that breaks the two rules respectively. We use union find set to help us check whether there is a ring, and use a array ```parent``` (denote parent node) to check whether second rule is broken.\\n\\n```\\nclass UnionFind {\\n   int root[];\\n   int height[];\\n\\n\\tpublic UnionFind(int n) {\\n\\t\\troot = new int[n];\\n\\t\\theight = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\troot[i] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void union(int x, int y) {\\n\\t\\tint rootX = find(x), rootY = find(y);\\n\\t\\tif (height[rootX] < height[rootY]) {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t}\\n\\t\\telse if (height[rootY] < height[rootX]) {\\n\\t\\t\\troot[rootY] = rootX;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t\\theight[rootY]++;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int find(int x) {\\n\\t\\treturn root[x] == x ? x : find(root[x]);\\n\\t}\\n}\\n\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\tint conflict = 0, cycle = 0;\\n\\tint parent[] = new int[edges.length + 1];\\n\\tUnionFind uf = new UnionFind(edges.length + 1);\\n\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\tif (parent[edges[i][1]] != 0) {\\n\\t\\t\\tconflict = i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[edges[i][1]] = edges[i][0];\\n\\t\\t\\tint sourceRoot = uf.find(edges[i][0]), targetRoot = uf.find(edges[i][1]);\\n\\t\\t\\tif (sourceRoot == targetRoot) {\\n\\t\\t\\t\\tcycle = i;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tuf.union(sourceRoot, targetRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cycle == 0) {\\n\\t\\treturn edges[conflict];\\n\\t}\\n\\telse if (conflict == 0) {\\n\\t\\treturn edges[cycle];\\n\\t}\\n\\telse {\\n\\t\\t// This is the key, when both conflict and cycle exist, conflict edge can\\'t be the redundant edge. \\n\\t\\t// Because if we remove it, the cycle still exist\\n\\t\\treturn new int[] {parent[edges[conflict][1]], edges[conflict][1]};\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```cycle```\n```conflict```\n```parent```\n```\\nclass UnionFind {\\n   int root[];\\n   int height[];\\n\\n\\tpublic UnionFind(int n) {\\n\\t\\troot = new int[n];\\n\\t\\theight = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\troot[i] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void union(int x, int y) {\\n\\t\\tint rootX = find(x), rootY = find(y);\\n\\t\\tif (height[rootX] < height[rootY]) {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t}\\n\\t\\telse if (height[rootY] < height[rootX]) {\\n\\t\\t\\troot[rootY] = rootX;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t\\theight[rootY]++;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int find(int x) {\\n\\t\\treturn root[x] == x ? x : find(root[x]);\\n\\t}\\n}\\n\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\tint conflict = 0, cycle = 0;\\n\\tint parent[] = new int[edges.length + 1];\\n\\tUnionFind uf = new UnionFind(edges.length + 1);\\n\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\tif (parent[edges[i][1]] != 0) {\\n\\t\\t\\tconflict = i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[edges[i][1]] = edges[i][0];\\n\\t\\t\\tint sourceRoot = uf.find(edges[i][0]), targetRoot = uf.find(edges[i][1]);\\n\\t\\t\\tif (sourceRoot == targetRoot) {\\n\\t\\t\\t\\tcycle = i;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tuf.union(sourceRoot, targetRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cycle == 0) {\\n\\t\\treturn edges[conflict];\\n\\t}\\n\\telse if (conflict == 0) {\\n\\t\\treturn edges[cycle];\\n\\t}\\n\\telse {\\n\\t\\t// This is the key, when both conflict and cycle exist, conflict edge can\\'t be the redundant edge. \\n\\t\\t// Because if we remove it, the cycle still exist\\n\\t\\treturn new int[] {parent[edges[conflict][1]], edges[conflict][1]};\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013241,
                "title": "union-find-with-path-compression-beats-100-java",
                "content": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        final int vertexCount   = edges.length;\\n        final int[] parents     = new int[vertexCount + 1];\\n        int[] possibleRedundantEdge = null;\\n        for (int i = 0; i < vertexCount; ++i) {\\n            final int[] edge    = edges[i];\\n            final int from      = edge[0];\\n            final int to        = edge[1];\\n            if (parents[to] != 0) {\\n                possibleRedundantEdge = edge;\\n                continue;\\n            }\\n            parents[to] = from;\\n        }\\n        if (possibleRedundantEdge != null) {\\n            final int crossVertex = possibleRedundantEdge[1];\\n            for (int p = parents[crossVertex]; ; ) {\\n                final int grandParent = parents[p];\\n                if (grandParent == 0)           return possibleRedundantEdge;\\n                if (grandParent == crossVertex) return new int[]{parents[crossVertex], crossVertex};\\n                p = grandParent;\\n            }\\n        }\\n        final int[] ancestors = new int[vertexCount + 1];\\n        for (int i = 1; i <= vertexCount; ++i) {\\n            ancestors[i] = i;\\n        }\\n        final int[] weights = new int[vertexCount + 1];\\n        for (int i = 1; i <= vertexCount; ++i) {\\n            weights[i] = 1;\\n        }\\n        for (int i = 0; i < vertexCount; ++i) {\\n            final int[] edge    = edges[i];\\n            final int from      = edge[0];\\n            final int to        = edge[1];\\n            final int fromRoot  = getRoot(ancestors, from);\\n            final int toRoot    = getRoot(ancestors, to);\\n            if (fromRoot == toRoot) return edge;\\n            final int fromWeight    = weights[fromRoot];\\n            final int toWeight      = weights[toRoot];\\n            if (fromWeight < toWeight) {\\n                ancestors[fromRoot] = toRoot;\\n                weights[toRoot]     += fromWeight;\\n            } else {\\n                ancestors[toRoot] = fromRoot;\\n                weights[fromRoot] += toWeight;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    private int getRoot(int[] ancestors, int vertex) {\\n        int p = ancestors[vertex];\\n        while (true) {\\n            final int grandparent = ancestors[p];\\n            if (p == grandparent) return p;\\n            ancestors[p]    = grandparent;\\n            p               = grandparent;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        final int vertexCount   = edges.length;\\n        final int[] parents     = new int[vertexCount + 1];\\n        int[] possibleRedundantEdge = null;\\n        for (int i = 0; i < vertexCount; ++i) {\\n            final int[] edge    = edges[i];\\n            final int from      = edge[0];\\n            final int to        = edge[1];\\n            if (parents[to] != 0) {\\n                possibleRedundantEdge = edge;\\n                continue;\\n            }\\n            parents[to] = from;\\n        }\\n        if (possibleRedundantEdge != null) {\\n            final int crossVertex = possibleRedundantEdge[1];\\n            for (int p = parents[crossVertex]; ; ) {\\n                final int grandParent = parents[p];\\n                if (grandParent == 0)           return possibleRedundantEdge;\\n                if (grandParent == crossVertex) return new int[]{parents[crossVertex], crossVertex};\\n                p = grandParent;\\n            }\\n        }\\n        final int[] ancestors = new int[vertexCount + 1];\\n        for (int i = 1; i <= vertexCount; ++i) {\\n            ancestors[i] = i;\\n        }\\n        final int[] weights = new int[vertexCount + 1];\\n        for (int i = 1; i <= vertexCount; ++i) {\\n            weights[i] = 1;\\n        }\\n        for (int i = 0; i < vertexCount; ++i) {\\n            final int[] edge    = edges[i];\\n            final int from      = edge[0];\\n            final int to        = edge[1];\\n            final int fromRoot  = getRoot(ancestors, from);\\n            final int toRoot    = getRoot(ancestors, to);\\n            if (fromRoot == toRoot) return edge;\\n            final int fromWeight    = weights[fromRoot];\\n            final int toWeight      = weights[toRoot];\\n            if (fromWeight < toWeight) {\\n                ancestors[fromRoot] = toRoot;\\n                weights[toRoot]     += fromWeight;\\n            } else {\\n                ancestors[toRoot] = fromRoot;\\n                weights[fromRoot] += toWeight;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    private int getRoot(int[] ancestors, int vertex) {\\n        int p = ancestors[vertex];\\n        while (true) {\\n            final int grandparent = ancestors[p];\\n            if (p == grandparent) return p;\\n            ancestors[p]    = grandparent;\\n            p               = grandparent;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913419,
                "title": "easy-to-read-unionfind-solution-c",
                "content": "```\\nclass Solution {\\n    struct UnionFind {\\n        UnionFind(int start_index, int size)\\n          : root_(size, -1),\\n            size_(size, 0),\\n            start_index_(start_index),\\n            count_(0)\\n        {\\n            for (int i = start_index_; i < root_.size(); i++) {\\n                root_[ i ] = i;\\n                count_++;\\n            }        \\n        }\\n        \\n        int findRoot(int node) {\\n            while (root_[ node ] != node) {\\n                root_[node] = root_[root_[node]];\\n                node = root_[node];\\n            }\\n            return node;\\n        }\\n        \\n        bool join(int node1, int node2) {\\n            int root1 = findRoot(node1);\\n            int root2 = findRoot(node2);\\n            if (root1 == root2) {\\n                return false;\\n            }\\n            \\n            if (size_[root1] > size_[root2]) {\\n                size_[root1] += size_[root2];\\n                root_[root2] = root1;\\n            } else {\\n                size_[root2] += size_[root1];\\n                root_[root1] = root2;\\n            }\\n            count_--;\\n            return true;\\n        }\\n        \\n        int size() const {\\n            return count_;\\n        }\\n      \\n    private:\\n        std::vector<int> root_;\\n        std::vector<int> size_;\\n        int start_index_;\\n        int count_;\\n    };\\n    \\npublic:\\n    std::vector<int> findRedundantDirectedConnection(const std::vector<std::vector<int>>& edges) {\\n        std::unordered_map<int, std::vector<int>> parents;\\n        for (const std::vector<int> & edge : edges) {\\n            int src = edge.front();\\n            int dst = edge.back();\\n            parents[dst].push_back(src);\\n            \\n            if (parents[dst].size() == 2) {\\n                // looking for the last occurrence in edges (backward) \\n                for (int p = parents[dst].size() - 1; p >= 0; p--) {\\n                    std::vector<int> redundant{ parents[dst][p], dst };\\n                    if (isValidWithout(edges, redundant)) {\\n                        return redundant;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // We have a cycle, union all nodes\\n        UnionFind dsu(1, edges.size() + 1);\\n        for (const std::vector<int> & edge : edges) {\\n            if (!dsu.join(edge.front(), edge.back())) {\\n                return edge; // the last edge in cycle (already connected)\\n            }\\n        }\\n        return {};\\n    }\\n    \\nprivate:\\n    bool isValidWithout(const std::vector<std::vector<int>>& edges, const std::vector<int>& redundant) {\\n        UnionFind dsu(1, edges.size() + 1);\\n        for (const std::vector<int> & edge : edges) {\\n            if (edge == redundant) {\\n                continue;\\n            }\\n            dsu.join(edge.front(), edge.back());\\n        }\\n        return dsu.size() == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    struct UnionFind {\\n        UnionFind(int start_index, int size)\\n          : root_(size, -1),\\n            size_(size, 0),\\n            start_index_(start_index),\\n            count_(0)\\n        {\\n            for (int i = start_index_; i < root_.size(); i++) {\\n                root_[ i ] = i;\\n                count_++;\\n            }        \\n        }\\n        \\n        int findRoot(int node) {\\n            while (root_[ node ] != node) {\\n                root_[node] = root_[root_[node]];\\n                node = root_[node];\\n            }\\n            return node;\\n        }\\n        \\n        bool join(int node1, int node2) {\\n            int root1 = findRoot(node1);\\n            int root2 = findRoot(node2);\\n            if (root1 == root2) {\\n                return false;\\n            }\\n            \\n            if (size_[root1] > size_[root2]) {\\n                size_[root1] += size_[root2];\\n                root_[root2] = root1;\\n            } else {\\n                size_[root2] += size_[root1];\\n                root_[root1] = root2;\\n            }\\n            count_--;\\n            return true;\\n        }\\n        \\n        int size() const {\\n            return count_;\\n        }\\n      \\n    private:\\n        std::vector<int> root_;\\n        std::vector<int> size_;\\n        int start_index_;\\n        int count_;\\n    };\\n    \\npublic:\\n    std::vector<int> findRedundantDirectedConnection(const std::vector<std::vector<int>>& edges) {\\n        std::unordered_map<int, std::vector<int>> parents;\\n        for (const std::vector<int> & edge : edges) {\\n            int src = edge.front();\\n            int dst = edge.back();\\n            parents[dst].push_back(src);\\n            \\n            if (parents[dst].size() == 2) {\\n                // looking for the last occurrence in edges (backward) \\n                for (int p = parents[dst].size() - 1; p >= 0; p--) {\\n                    std::vector<int> redundant{ parents[dst][p], dst };\\n                    if (isValidWithout(edges, redundant)) {\\n                        return redundant;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // We have a cycle, union all nodes\\n        UnionFind dsu(1, edges.size() + 1);\\n        for (const std::vector<int> & edge : edges) {\\n            if (!dsu.join(edge.front(), edge.back())) {\\n                return edge; // the last edge in cycle (already connected)\\n            }\\n        }\\n        return {};\\n    }\\n    \\nprivate:\\n    bool isValidWithout(const std::vector<std::vector<int>>& edges, const std::vector<int>& redundant) {\\n        UnionFind dsu(1, edges.size() + 1);\\n        for (const std::vector<int> & edge : edges) {\\n            if (edge == redundant) {\\n                continue;\\n            }\\n            dsu.join(edge.front(), edge.back());\\n        }\\n        return dsu.size() == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834800,
                "title": "java-unionfind-solution",
                "content": "```\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public UnionFind (int size) {\\n        parent = new int[size + 1];\\n        rank = new int[size + 1];\\n        for (int i = 0; i <= size; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int u) {\\n        if (parent[u] != u) {\\n            parent[u] = find(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    \\n    public void union(int u, int v) {\\n        int pu = find(u);\\n        int pv = find(v);\\n        if (pu == pv) {\\n            return;\\n        }\\n        if (rank[pu] < rank[pv]) {\\n            rank[pv]++;\\n            parent[pu] = pv;\\n        } else {\\n            rank[pu]++;\\n            parent[pv] = pu;\\n        }\\n    }\\n    \\n    public boolean isConnect(int u, int v) {\\n        return find(u) == find(v);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int size = edges.length;\\n        int[] indegree = new int[size + 1];\\n        int has2Indegrees = -1;\\n        for (int[] e : edges) {\\n            indegree[e[1]]++;\\n            if (indegree[e[1]] == 2) {\\n                has2Indegrees = e[1];\\n                break;\\n            }\\n        }\\n        if (has2Indegrees == -1) {\\n            return detectCycle(edges, size, null);\\n        }\\n        for (int i = size - 1; i >= 0; --i) {\\n            if (edges[i][1] == has2Indegrees) {\\n                if (detectCycle(edges, size, edges[i]) == null) {\\n                    return edges[i];\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n    \\n    private int[] detectCycle(int[][] edges, int size, int[] skipEdge) {\\n        UnionFind uf = new UnionFind(size);\\n        for (int[] e : edges) {\\n            if (Arrays.equals(e, skipEdge)) {\\n                continue;\\n            }\\n            if (uf.isConnect(e[0], e[1])) {\\n                return e;\\n            } else {\\n                uf.union(e[0], e[1]);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public UnionFind (int size) {\\n        parent = new int[size + 1];\\n        rank = new int[size + 1];\\n        for (int i = 0; i <= size; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int u) {\\n        if (parent[u] != u) {\\n            parent[u] = find(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    \\n    public void union(int u, int v) {\\n        int pu = find(u);\\n        int pv = find(v);\\n        if (pu == pv) {\\n            return;\\n        }\\n        if (rank[pu] < rank[pv]) {\\n            rank[pv]++;\\n            parent[pu] = pv;\\n        } else {\\n            rank[pu]++;\\n            parent[pv] = pu;\\n        }\\n    }\\n    \\n    public boolean isConnect(int u, int v) {\\n        return find(u) == find(v);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int size = edges.length;\\n        int[] indegree = new int[size + 1];\\n        int has2Indegrees = -1;\\n        for (int[] e : edges) {\\n            indegree[e[1]]++;\\n            if (indegree[e[1]] == 2) {\\n                has2Indegrees = e[1];\\n                break;\\n            }\\n        }\\n        if (has2Indegrees == -1) {\\n            return detectCycle(edges, size, null);\\n        }\\n        for (int i = size - 1; i >= 0; --i) {\\n            if (edges[i][1] == has2Indegrees) {\\n                if (detectCycle(edges, size, edges[i]) == null) {\\n                    return edges[i];\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n    \\n    private int[] detectCycle(int[][] edges, int size, int[] skipEdge) {\\n        UnionFind uf = new UnionFind(size);\\n        for (int[] e : edges) {\\n            if (Arrays.equals(e, skipEdge)) {\\n                continue;\\n            }\\n            if (uf.isConnect(e[0], e[1])) {\\n                return e;\\n            } else {\\n                uf.union(e[0], e[1]);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802876,
                "title": "classifying-redundant-edges-into-forward-cross-back-edges",
                "content": "When invoking DFS on a directed graph, it produces a DFS forest and all edges are classified into \\n* tree edges\\n* forward edges\\n* cross edges\\n* back edges\\n\\nIn this problem, the predecessor subgraph produced by DFS is in fact a tree because the graph is connected. Let `G_p` denote the predecessor subgraph, any edges not in `G_p` is a redundant edge. \\n`G_p` is not uniquely determined, it depends on the order of appearance of vertices in adj list. \\n\\nSuppose there is a vertex `s` such that the `in-degree(s) = 0` then `s` must be the root of the \\nof the tree we want. Starting dfs on `s` is equivalent to traverse the `G_p` in topologically sorted order. \\nIn this case, we have two senarios\\n* dfs finds a cycle\\n\\t* in this case, the first appearance of back edge is the one we want to remove\\n* dfs finds no cyle\\n\\t* all redunant edges are either forward edges or cross edges. Remove the one that appears last in the input \\n\\nSuppose there is no vertex with in-degree 0, that means the graph definitely has a cycle and it is unique (by the constraint of the problem). Moreover, any edge on the cycle can be removed and the graph remains a tree. To see this, separate the graph into two parts `A` and `B`, where `A` is the cycle and `B` is the rest. `B` is already a tree. Removing any edge on `A` results a tree,  call it `A\\'`. Then join `A\\'` and `B`. So remove the one appears last in the input\\n\\n```\\nfrom collections import defaultdict\\n\\ndef build_graph(edges):\\n    adj = defaultdict(list); in_degree = defaultdict(int)\\n    for u, v in edges:\\n        adj[u].append(v)\\n        in_degree[v]+=1; in_degree[u]+=0\\n        \\n    return adj, in_degree\\n\\ndef find_redundant(edges):\\n    \"\"\"Find all non tree edges in the directed graph\"\"\"\\n    adj, in_degree = build_graph(edges)\\n    \\n    visiting = set(); visited = set()\\n    parent = {}\\n    \\n    # collect back / forward / cross edges\\n    backedges = []; forward_cross = [] \\n    \\n    def dfs(v, p):\\n        \"\"\"\\n        v: vertex to be visit\\n        p: predecessor of v\\n        \"\"\"\\n        if v in visiting:\\n            # graph has a cycle\\n            backedges.append([p, v])\\n            while p != v:\\n                backedges.append([parent[p], p])\\n                p = parent[p]\\n            return\\n        \\n        if v in visited:\\n            if p is None:\\n                return \\n            # graph has forward or cross edges\\n            forward_cross.append([parent[v], v])\\n            forward_cross.append([p, v])\\n            return\\n        \\n        parent[v] = p\\n        visiting.add(v)\\n        if v in adj:\\n            for c in adj[v]:\\n                dfs(c, v)\\n        \\n        visiting.remove(v)\\n        visited.add(v)\\n        return \\n    \\n    \\n    H = {tuple(e): i for i, e in enumerate(edges)}\\n    \\n    # check if there is a vertex with in-degree 0\\n    for s in in_degree:\\n        if in_degree[s] == 0:\\n            dfs(s, None)\\n            # if the graph has a cycle, remove the \\n            # the first appearance of backedge\\n            if backedges:\\n                return backedges[0]    \\n            break\\n    else:\\n        for v in adj:\\n            dfs(v, None)\\n        \\n        if backedges:\\n            # remove the edge on the cycle that occurs last in the input\\n            return max(backedges, key=lambda x: H[x[0], x[1]])\\n    \\n    # if the graph has no cycle remove the last forward / cross edge\\n    return max(forward_cross, key=lambda x: H[x[0], x[1]])\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\ndef build_graph(edges):\\n    adj = defaultdict(list); in_degree = defaultdict(int)\\n    for u, v in edges:\\n        adj[u].append(v)\\n        in_degree[v]+=1; in_degree[u]+=0\\n        \\n    return adj, in_degree\\n\\ndef find_redundant(edges):\\n    \"\"\"Find all non tree edges in the directed graph\"\"\"\\n    adj, in_degree = build_graph(edges)\\n    \\n    visiting = set(); visited = set()\\n    parent = {}\\n    \\n    # collect back / forward / cross edges\\n    backedges = []; forward_cross = [] \\n    \\n    def dfs(v, p):\\n        \"\"\"\\n        v: vertex to be visit\\n        p: predecessor of v\\n        \"\"\"\\n        if v in visiting:\\n            # graph has a cycle\\n            backedges.append([p, v])\\n            while p != v:\\n                backedges.append([parent[p], p])\\n                p = parent[p]\\n            return\\n        \\n        if v in visited:\\n            if p is None:\\n                return \\n            # graph has forward or cross edges\\n            forward_cross.append([parent[v], v])\\n            forward_cross.append([p, v])\\n            return\\n        \\n        parent[v] = p\\n        visiting.add(v)\\n        if v in adj:\\n            for c in adj[v]:\\n                dfs(c, v)\\n        \\n        visiting.remove(v)\\n        visited.add(v)\\n        return \\n    \\n    \\n    H = {tuple(e): i for i, e in enumerate(edges)}\\n    \\n    # check if there is a vertex with in-degree 0\\n    for s in in_degree:\\n        if in_degree[s] == 0:\\n            dfs(s, None)\\n            # if the graph has a cycle, remove the \\n            # the first appearance of backedge\\n            if backedges:\\n                return backedges[0]    \\n            break\\n    else:\\n        for v in adj:\\n            dfs(v, None)\\n        \\n        if backedges:\\n            # remove the edge on the cycle that occurs last in the input\\n            return max(backedges, key=lambda x: H[x[0], x[1]])\\n    \\n    # if the graph has no cycle remove the last forward / cross edge\\n    return max(forward_cross, key=lambda x: H[x[0], x[1]])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786563,
                "title": "c-sulution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int> root(m+1, 0), first, second;\\n        for (auto& edge : edges)\\n        {\\n            if (root[edge[1]] == 0)\\n            {\\n                root[edge[1]] = edge[0];\\n            }\\n            else\\n            {\\n                first = {root[edge[1]], edge[1]};\\n                second = edge;\\n                edge[1] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < root.size(); ++i)\\n        {\\n            root[i] = i;\\n        }\\n        \\n        for (auto& edge : edges)\\n        {\\n            int root_a = find(edge[0], root), root_b = find(edge[1], root);\\n            if (root_a == root_b)\\n            {\\n                if (!first.empty())\\n                {\\n                    return first;\\n                }\\n                else\\n                {\\n                    return edge;\\n                }\\n            }\\n            \\n            root[root_a] = root_b;\\n        }\\n        \\n        return second;  // Two situations here: 1) No circle due to the deletion of second: second is in the circle and it should be returned. 2) No circle at all. It is the second (last) edge that should be deleted.\\n    }\\n    \\n    int find(int node, vector<int>& root)\\n    {\\n        if (root[node] == node) return node;\\n        return find(root[node], root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int> root(m+1, 0), first, second;\\n        for (auto& edge : edges)\\n        {\\n            if (root[edge[1]] == 0)\\n            {\\n                root[edge[1]] = edge[0];\\n            }\\n            else\\n            {\\n                first = {root[edge[1]], edge[1]};\\n                second = edge;\\n                edge[1] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < root.size(); ++i)\\n        {\\n            root[i] = i;\\n        }\\n        \\n        for (auto& edge : edges)\\n        {\\n            int root_a = find(edge[0], root), root_b = find(edge[1], root);\\n            if (root_a == root_b)\\n            {\\n                if (!first.empty())\\n                {\\n                    return first;\\n                }\\n                else\\n                {\\n                    return edge;\\n                }\\n            }\\n            \\n            root[root_a] = root_b;\\n        }\\n        \\n        return second;  // Two situations here: 1) No circle due to the deletion of second: second is in the circle and it should be returned. 2) No circle at all. It is the second (last) edge that should be deleted.\\n    }\\n    \\n    int find(int node, vector<int>& root)\\n    {\\n        if (root[node] == node) return node;\\n        return find(root[node], root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769297,
                "title": "c-union-find-path-compression-union-by-rank",
                "content": "**Algorithm**\\n\\n    1.The node having indegree>1 will be the part of the redundant edge.\\n    2.Processing the Union for that node later.\\n    3.The last edge in the queue for which the 2 nodes of that edge belong to the same set , will be the redundant one.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    bool flag;\\n    //path compression\\n    int find(int a,vector<int> &parent)\\n    {\\n        vector<int> v;\\n        while(parent[a]>0)\\n            v.push_back(a),a=parent[a];\\n        \\n        for(int i=0;i<v.size();++i)\\n            parent[v[i]]=a;\\n        return a;\\n    }\\n    //union by rank\\n    void Union(int A,int B,vector<int> &parent)\\n    {\\n        int a=find(A,parent);\\n        int b=find(B,parent);\\n        if(a==b)\\n        {\\n            res={A,B};\\n            flag=true;\\n            return;\\n        }\\n        int Ra=abs(parent[a]);\\n        int Rb=abs(parent[b]);\\n        if(Ra>Rb)\\n            parent[a]+=parent[b],parent[b]=a;\\n        else\\n            parent[b]+=parent[a],parent[a]=b;\\n        return;\\n    }\\n    \\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        vector<int> indegree(edges.size()+1,0);\\n        for(int i=0;i<edges.size();++i)\\n            ++indegree[edges[i][1]];\\n        \\n        vector<int> parent(edges.size()+1,-1);\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<edges.size();++i)\\n        {\\n            int a,b;\\n            a=edges[i][0],b=edges[i][1];\\n            if(indegree[b]>1)\\n                q.push({a,b});\\n            else\\n                Union(a,b,parent);\\n        }\\n        while(q.size())\\n        {\\n            Union(q.front().first,q.front().second,parent);\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> res;\\n    bool flag;\\n    //path compression\\n    int find(int a,vector<int> &parent)\\n    {\\n        vector<int> v;\\n        while(parent[a]>0)\\n            v.push_back(a),a=parent[a];\\n        \\n        for(int i=0;i<v.size();++i)\\n            parent[v[i]]=a;\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 671816,
                "title": "watch-this-easy-union-find-1ms-solution-with-detailed-explanations",
                "content": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/U7_ynlauYh0\" frameborder=\"0\"></iframe>\\n\\n\\nThis solution is an extention to leetcode - 684 . \\nSo I have extended same union-find solution to solve this with detailed steps .\\nThe only extra step that we have to consider is a node can\\'t have more than 1 parent\\nand return the last node if there are more thanh one solution.\\n\\nSo if you killed this two condition you are done. \\nTime Complexity is O(N)\\n#graph",
                "solutionTags": [],
                "code": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/U7_ynlauYh0\" frameborder=\"0\"></iframe>\\n\\n\\nThis solution is an extention to leetcode - 684 . \\nSo I have extended same union-find solution to solve this with detailed steps .\\nThe only extra step that we have to consider is a node can\\'t have more than 1 parent\\nand return the last node if there are more thanh one solution.\\n\\nSo if you killed this two condition you are done. \\nTime Complexity is O(N)\\n#graph",
                "codeTag": "Unknown"
            },
            {
                "id": 658126,
                "title": "shouldn-t-test-case-2-1-3-1-4-2-1-4-result-in-1-4",
                "content": "So below is UnionFind algorithm I implemented which uses compression to reduce the number of hops. Using that logic I realize I\\'m getting a different result from the test case. The steps are below:\\nI\\'ll use map form of {Root => Child1, Child 2, Child3} to represent the graph\\n* @input [2,1], the root map looks like this {2 => 1}\\n* @input[3, 1], the root of 1 is 2, hence we make 3 the root of 2, and compress the graph so 1 also points to 3. The result is {3 => 2, 1}\\n* @input[4, 2}, the root of 2 is 3, hence we make 4 the root of 3 and compress the graph so 1 & 2 also point to 4. The result is {4 => 3, 2, 1}\\n* @input[1,4], the root of 1 is  already 4. So this makes this edge redundant. \\n\\nI can\\'t figure out how the expected solution became [2,1]. Someone help.\\n\\n```\\nprivate int[] parents;\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\t//Since the nodes are numbered 0...N, find N, which will be the maximum node number in the input\\n\\tlet max = -1;\\n\\tfor i = 0 to edges.length{\\n\\t\\tmax = Math.max(max, edges[i][0]\\n\\t\\tmax = Math.max(max, edges[i][1]\\n\\t}\\n\\t//increase max by 1, so we don\\'t go out of bounds for array\\n\\tmax++\\n\\n\\t//For the test case [[2,1],[3,1],[4,2],[1,4]], our max will be 5 ( 4 + 1). Now we have the number of nodes, so initialize an array to hold the parents of the nodes\\n\\tint[] parents = new int[max];\\n\\t//intialize each node parent to point to itself\\n\\tfor i = 0 to max\\n\\t\\tparents[i] = i\\n\\n\\t//for the test case, our parent array will now look like this [0, 1, 2. 3. 4] . ie the parent of Node{1} is 1, parent of Node{2} is 2, etc\\n\\t\\n\\t//Now that parent array is instantiated, loop over the edges to track find the root of each node in the edge. If the root of each node in the edge is equal, then it means they are already connected and that edge is redundant. \\n\\tlet num = -1; //this will hold the index of the redundant edge\\n        for  i = 0 to edges.length {\\n            let parent1 = findParentWithCompression(edges[i][0]);\\n           let parent2 = findParentWithCompression(edges[i][1]);\\n            if(parent1 != parent2)\\n                parents[parent2] = parent1; //remember this is a directed graph. So example [X, Y] means X is the parent of Y. Hence if they have separate roots, you make the parents[Y] = X\\n            else\\n                num = i; //here, parents are equal so this edge is redundant. Keep track of that index;\\n        }\\n\\t\\t\\n\\t\\treturn num //This will automatically return the last index of the redundant edge.\\n}\\n\\n//this is a helper method to trace the root of each node. It also applies compression ie if Node{1}.parent = Node{2} and Node{2}.parent = Node{3}, it will assign Node{1}.parent = Node{3} , so we reduce the number of hops to find the root node on the next call.\\npublic int findParentWithCompression( int i){\\n        int parent = parents[i];\\n\\t\\t//if parent is not equal to index, then trace to the root and return that\\n        if(parent != i){\\n            parent = findParentWithCompression(parent);\\n            parents[i] = parent;\\n        }\\n        return parent;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int[] parents;\\npublic int[] findRedundantDirectedConnection(int[][] edges) {\\n\\t//Since the nodes are numbered 0...N, find N, which will be the maximum node number in the input\\n\\tlet max = -1;\\n\\tfor i = 0 to edges.length{\\n\\t\\tmax = Math.max(max, edges[i][0]\\n\\t\\tmax = Math.max(max, edges[i][1]\\n\\t}\\n\\t//increase max by 1, so we don\\'t go out of bounds for array\\n\\tmax++\\n\\n\\t//For the test case [[2,1],[3,1],[4,2],[1,4]], our max will be 5 ( 4 + 1). Now we have the number of nodes, so initialize an array to hold the parents of the nodes\\n\\tint[] parents = new int[max];\\n\\t//intialize each node parent to point to itself\\n\\tfor i = 0 to max\\n\\t\\tparents[i] = i\\n\\n\\t//for the test case, our parent array will now look like this [0, 1, 2. 3. 4] . ie the parent of Node{1} is 1, parent of Node{2} is 2, etc\\n\\t\\n\\t//Now that parent array is instantiated, loop over the edges to track find the root of each node in the edge. If the root of each node in the edge is equal, then it means they are already connected and that edge is redundant. \\n\\tlet num = -1; //this will hold the index of the redundant edge\\n        for  i = 0 to edges.length {\\n            let parent1 = findParentWithCompression(edges[i][0]);\\n           let parent2 = findParentWithCompression(edges[i][1]);\\n            if(parent1 != parent2)\\n                parents[parent2] = parent1; //remember this is a directed graph. So example [X, Y] means X is the parent of Y. Hence if they have separate roots, you make the parents[Y] = X\\n            else\\n                num = i; //here, parents are equal so this edge is redundant. Keep track of that index;\\n        }\\n\\t\\t\\n\\t\\treturn num //This will automatically return the last index of the redundant edge.\\n}\\n\\n//this is a helper method to trace the root of each node. It also applies compression ie if Node{1}.parent = Node{2} and Node{2}.parent = Node{3}, it will assign Node{1}.parent = Node{3} , so we reduce the number of hops to find the root node on the next call.\\npublic int findParentWithCompression( int i){\\n        int parent = parents[i];\\n\\t\\t//if parent is not equal to index, then trace to the root and return that\\n        if(parent != i){\\n            parent = findParentWithCompression(parent);\\n            parents[i] = parent;\\n        }\\n        return parent;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617428,
                "title": "python3-using-classic-union-find-data-structure",
                "content": "Here\\'s a clean example that uses \"classic\" Union-Find data structure with path compression as it\\'s often advertised in text books & online courses.\\n\\nThe solution also keeps track of the actual parents separately since UF can lose this information after forcefully \"uniting\" a cycle.\\n\\n```\\nclass UF:\\n    def __init__(self, cap):\\n        self.roots = [i for i in range(cap+1)]\\n        # print(self.roots)\\n        \\n    def root(self, i):\\n        \"\"\" Ascends the tree with i until we get the root i.e. i = root[i] \"\"\"\\n        while self.roots[i] != i:\\n            self.roots[i] = self.roots[self.roots[i]]\\n            i = self.roots[i]            \\n        return i\\n        \\n    def find(self, p):\\n        return self.root(p)\\n        \\n    def connected(self, p, q):\\n        return self.root(p) == self.root(q)\\n    \\n    def union(self, p, q):\\n        \"\"\" Adds a tree with q under root of p \"\"\"\\n        i = self.root(p)\\n        j = self.root(q)\\n        self.roots[j] = i\\n            \\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        cycle = None\\n\\t\\tparents = {}\\n        uf = UF(len(edges))\\n        for u, v in edges:\\n            if uf.connected(u, v):\\n                cycle = [u, v]\\n            uf.union(u,v)\\n            parents.setdefault(v, []).append(u)\\n\\n        two_parents = [v for v in parents if len(parents[v]) > 1]\\n        has_two = len(two_parents)\\n        if not has_two and cycle:\\n            return cycle\\n        \\n        if not cycle and has_two:\\n            return [parents[two_parents[0]][1], two_parents[0]]\\n            \\n        edge1 = [parents[two_parents[0]][0], two_parents[0]]\\n        edge2 = [parents[two_parents[0]][1], two_parents[0]]\\n        uf2 = UF(len(edges))\\n        for u, v in edges:\\n            if [u, v] == edge2:\\n                continue\\n            elif uf2.connected(u, v):\\n                return edge1\\n            else:\\n                uf2.union(u, v)\\n\\n        return edge2\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF:\\n    def __init__(self, cap):\\n        self.roots = [i for i in range(cap+1)]\\n        # print(self.roots)\\n        \\n    def root(self, i):\\n        \"\"\" Ascends the tree with i until we get the root i.e. i = root[i] \"\"\"\\n        while self.roots[i] != i:\\n            self.roots[i] = self.roots[self.roots[i]]\\n            i = self.roots[i]            \\n        return i\\n        \\n    def find(self, p):\\n        return self.root(p)\\n        \\n    def connected(self, p, q):\\n        return self.root(p) == self.root(q)\\n    \\n    def union(self, p, q):\\n        \"\"\" Adds a tree with q under root of p \"\"\"\\n        i = self.root(p)\\n        j = self.root(q)\\n        self.roots[j] = i\\n            \\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        cycle = None\\n\\t\\tparents = {}\\n        uf = UF(len(edges))\\n        for u, v in edges:\\n            if uf.connected(u, v):\\n                cycle = [u, v]\\n            uf.union(u,v)\\n            parents.setdefault(v, []).append(u)\\n\\n        two_parents = [v for v in parents if len(parents[v]) > 1]\\n        has_two = len(two_parents)\\n        if not has_two and cycle:\\n            return cycle\\n        \\n        if not cycle and has_two:\\n            return [parents[two_parents[0]][1], two_parents[0]]\\n            \\n        edge1 = [parents[two_parents[0]][0], two_parents[0]]\\n        edge2 = [parents[two_parents[0]][1], two_parents[0]]\\n        uf2 = UF(len(edges))\\n        for u, v in edges:\\n            if [u, v] == edge2:\\n                continue\\n            elif uf2.connected(u, v):\\n                return edge1\\n            else:\\n                uf2.union(u, v)\\n\\n        return edge2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588774,
                "title": "python-union-find-beats-90",
                "content": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        parents = [0] * (len(edges) + 1)\\n        roots = [0] * (len(edges) + 1)\\n        ranks = [1] * (len(edges) + 1)\\n        ans1 = 0\\n        ans2 = 0\\n        \\n        def find(x):\\n            if roots[x] != x:\\n                x = find(roots[x])\\n            return x\\n        ans1 = None\\n        ans2 = None\\n        for edge in edges:\\n            u, v = edge\\n            if parents[v] == 0:\\n                parents[v] = u\\n            else:\\n                ans1 = (parents[v], v)\\n                ans2 = (u, v)\\n                edge[0] = edge[1] = -1\\n        \\n        for edge in edges:\\n            u, v = edge\\n            if u < 0 or v < 0:\\n                continue\\n\\n            if roots[u] == 0:\\n                roots[u] = u\\n            if roots[v] == 0:\\n                roots[v] = v\\n            pu = find(u)\\n            pv = find(v)\\n            if pu == pv:\\n                return edge if not ans1 else ans1\\n            if ranks[pv] > ranks[pu]:\\n                pu, pv = pv, pu\\n            elif ranks[pv] == ranks[pu]:\\n                ranks[pu] += 1\\n            roots[pv] = pu\\n        \\n        return ans2\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        parents = [0] * (len(edges) + 1)\\n        roots = [0] * (len(edges) + 1)\\n        ranks = [1] * (len(edges) + 1)\\n        ans1 = 0\\n        ans2 = 0\\n        \\n        def find(x):\\n            if roots[x] != x:\\n                x = find(roots[x])\\n            return x\\n        ans1 = None\\n        ans2 = None\\n        for edge in edges:\\n            u, v = edge\\n            if parents[v] == 0:\\n                parents[v] = u\\n            else:\\n                ans1 = (parents[v], v)\\n                ans2 = (u, v)\\n                edge[0] = edge[1] = -1\\n        \\n        for edge in edges:\\n            u, v = edge\\n            if u < 0 or v < 0:\\n                continue\\n\\n            if roots[u] == 0:\\n                roots[u] = u\\n            if roots[v] == 0:\\n                roots[v] = v\\n            pu = find(u)\\n            pv = find(v)\\n            if pu == pv:\\n                return edge if not ans1 else ans1\\n            if ranks[pv] > ranks[pu]:\\n                pu, pv = pv, pu\\n            elif ranks[pv] == ranks[pu]:\\n                ranks[pu] += 1\\n            roots[pv] = pu\\n        \\n        return ans2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503825,
                "title": "java-solution-check-cycle-2-parents",
                "content": "```\\nclass Solution {\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int N = getNodes(edges);\\n        List<int[]> list = new ArrayList<>();\\n        List<Integer> graph[] = new ArrayList[N+1];\\n        \\n        for (int i = 1; i<= N; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] num: edges) {\\n            graph[num[0]].add(num[1]);\\n        }\\n        \\n        boolean found = false;\\n        boolean[] visited = new boolean[N+1];\\n        boolean[] sptset = new boolean[N+1];        \\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<int[]> parents = new ArrayList<>();\\n        // check for multiple parents first;\\n        int latest = -1; int last[] = new int[2];\\n        for (int num[]: edges) {\\n            if (map.containsKey(num[1])) {\\n                parents.add(new int[]{map.get(num[1]), num[1]});\\n                parents.add(num);\\n            }\\n            map.put(num[1], num[0]);\\n        }\\n        \\n        if (parents.size() > 0) {\\n            //check for last entry\\n            int[] temp = parents.get(1);\\n            List<Integer> tempList = graph[temp[0]];\\n            tempList.remove(Integer.valueOf(temp[1]));\\n            \\n            for (int node = 1; node <= N; node++) {\\n            if (cycle (graph, visited, -1, node, sptset, list)) \\n                found = true;\\n            }\\n            \\n            if (found) return parents.get(0); else return parents.get(1);\\n            //graph[temp[0]].add(temp[1]);\\n        }\\n        \\n        for (int node = 1; node <= N; node++) {\\n            if (cycle (graph, visited, -1, node, sptset, list)) \\n                found = true;\\n        }\\n        if (found) return list.get(0);\\n        \\n        return last;\\n    }\\n    \\n    public boolean cycle (List<Integer> graph[], boolean[] visited, int parent, int src, boolean[] sptset, List<int[]> list) {\\n        if (sptset[src]) {\\n            if (parent != -1) list.add(new int[]{parent, src});\\n            return true;  \\n        } \\n        if (visited[src]) return false;\\n        \\n        sptset[src] = true;\\n        visited[src] = true;\\n        \\n        for (int child : graph[src]) {\\n            if (cycle(graph, visited, src, child, sptset, list))\\n                return true;\\n        }\\n        \\n        sptset[src] = false;\\n        return false;\\n        \\n    }\\n    \\n    public int getNodes (int[][] edges) {\\n        int max = 0;\\n        for (int[] num : edges) {\\n            max = Math.max(Math.max(num[0], num[1]), max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int N = getNodes(edges);\\n        List<int[]> list = new ArrayList<>();\\n        List<Integer> graph[] = new ArrayList[N+1];\\n        \\n        for (int i = 1; i<= N; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] num: edges) {\\n            graph[num[0]].add(num[1]);\\n        }\\n        \\n        boolean found = false;\\n        boolean[] visited = new boolean[N+1];\\n        boolean[] sptset = new boolean[N+1];        \\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<int[]> parents = new ArrayList<>();\\n        // check for multiple parents first;\\n        int latest = -1; int last[] = new int[2];\\n        for (int num[]: edges) {\\n            if (map.containsKey(num[1])) {\\n                parents.add(new int[]{map.get(num[1]), num[1]});\\n                parents.add(num);\\n            }\\n            map.put(num[1], num[0]);\\n        }\\n        \\n        if (parents.size() > 0) {\\n            //check for last entry\\n            int[] temp = parents.get(1);\\n            List<Integer> tempList = graph[temp[0]];\\n            tempList.remove(Integer.valueOf(temp[1]));\\n            \\n            for (int node = 1; node <= N; node++) {\\n            if (cycle (graph, visited, -1, node, sptset, list)) \\n                found = true;\\n            }\\n            \\n            if (found) return parents.get(0); else return parents.get(1);\\n            //graph[temp[0]].add(temp[1]);\\n        }\\n        \\n        for (int node = 1; node <= N; node++) {\\n            if (cycle (graph, visited, -1, node, sptset, list)) \\n                found = true;\\n        }\\n        if (found) return list.get(0);\\n        \\n        return last;\\n    }\\n    \\n    public boolean cycle (List<Integer> graph[], boolean[] visited, int parent, int src, boolean[] sptset, List<int[]> list) {\\n        if (sptset[src]) {\\n            if (parent != -1) list.add(new int[]{parent, src});\\n            return true;  \\n        } \\n        if (visited[src]) return false;\\n        \\n        sptset[src] = true;\\n        visited[src] = true;\\n        \\n        for (int child : graph[src]) {\\n            if (cycle(graph, visited, src, child, sptset, list))\\n                return true;\\n        }\\n        \\n        sptset[src] = false;\\n        return false;\\n        \\n    }\\n    \\n    public int getNodes (int[][] edges) {\\n        int max = 0;\\n        for (int[] num : edges) {\\n            max = Math.max(Math.max(num[0], num[1]), max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498244,
                "title": "problematic-edge-union-find",
                "content": "the goal is to find one edge thats wrong (there can be two, and if so , the latter one)\\n\\n\\nif there was an edge that makes a node u have 2 parents, remove this edge [v,u] and remember that its removed \\nLater \\n1. if there is no problem then this edge was the problem and should remain removed (return it)\\n2. if there is a problem, then keep the edge that was removed, and return the other edge involved (if no edge are suspicious its a cycle)\\n\\npseudo code\\n\\n```\\nfor edge in edges:\\n\\tfindout if edge is problematic\\n\\ncandidates = [suspicous edge1, suspicous edge2] or []\\nremove 2nd suspicous edge\\n\\nfor edge in edges where suspicous edge2 is removed:\\n\\tedge = u -------> v\\n\\tunionfind(connected component u, connected component of v)\\n\\tif problem:\\n\\t\\tif candidates is empty: \\n\\t\\t\\tthis edge is the problem\\n\\t\\telif candidates has edge:\\n\\t\\t\\treturn the other edge\\n```\\n\\n\\ncode \\n\\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        indegree,candidates,parent = collections.defaultdict(list),[], {}\\n        for u,v in edges:\\n            indegree[v].append(u)\\n            if len(indegree[v]) == 2:\\n                candidates = [[uu,v] for uu in indegree[v]]\\n                indegree[v].pop()\\n\\t\\t\\t\\t\\n        \\n        if candidates: edges.remove(candidates[1])\\n        for u,v in edges:\\n            if u not in parent: parent[u] = u\\n            if v not in parent: parent[v] = v\\n            pu,pv = self.gp(u,parent), self.gp(v,parent) \\n            if pu == pv: \\n\\t\\t\\t\\t# PROBLEM DETECTED\\n\\t\\t\\t\\t# if candidates is [] then its a cycle return [u,v]\\n\\t\\t\\t\\t# else return the other one \\n\\t\\t\\t\\treturn candidates[0] if candidates else [u,v]\\n            if pu!= pv: parent[pu] = pv\\n        return candidates[1]\\n    def gp(self,u,parent):\\n        if parent[u] != u: parent[u] = self.gp(parent[u],parent)\\n        return parent[u]\\n```",
                "solutionTags": [],
                "code": "```\\nfor edge in edges:\\n\\tfindout if edge is problematic\\n\\ncandidates = [suspicous edge1, suspicous edge2] or []\\nremove 2nd suspicous edge\\n\\nfor edge in edges where suspicous edge2 is removed:\\n\\tedge = u -------> v\\n\\tunionfind(connected component u, connected component of v)\\n\\tif problem:\\n\\t\\tif candidates is empty: \\n\\t\\t\\tthis edge is the problem\\n\\t\\telif candidates has edge:\\n\\t\\t\\treturn the other edge\\n```\n```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        indegree,candidates,parent = collections.defaultdict(list),[], {}\\n        for u,v in edges:\\n            indegree[v].append(u)\\n            if len(indegree[v]) == 2:\\n                candidates = [[uu,v] for uu in indegree[v]]\\n                indegree[v].pop()\\n\\t\\t\\t\\t\\n        \\n        if candidates: edges.remove(candidates[1])\\n        for u,v in edges:\\n            if u not in parent: parent[u] = u\\n            if v not in parent: parent[v] = v\\n            pu,pv = self.gp(u,parent), self.gp(v,parent) \\n            if pu == pv: \\n\\t\\t\\t\\t# PROBLEM DETECTED\\n\\t\\t\\t\\t# if candidates is [] then its a cycle return [u,v]\\n\\t\\t\\t\\t# else return the other one \\n\\t\\t\\t\\treturn candidates[0] if candidates else [u,v]\\n            if pu!= pv: parent[pu] = pv\\n        return candidates[1]\\n    def gp(self,u,parent):\\n        if parent[u] != u: parent[u] = self.gp(parent[u],parent)\\n        return parent[u]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460194,
                "title": "easy-understand-explanation-for-highest-vote-solution",
                "content": "I spend hours trying to understand what the hell is this one. Hope this explanation help you guys\\n\\n```\\nclass Solution {\\n    /* explanation:\\n        Three cases before we delete one candidate edge\\n        1. there\\'s a ring, and two candidates found\\n        2. there\\'s a ring, no candidates found   e.g.  1->2->3->1\\n        3. no ring, two candidates found\\n    \\n        If there are 2 candidates, then we delete second candidate edge\\n        Three cases remaining:\\n        \\n        1#. there\\'s still a ring, and two candidates found\\n        This means deleted candidate edge is not inside the ring, so return first candidate\\n        \\n        2# there\\'s still a ring, no two candidates found\\n        This means we never made the deletion, so just return current edge which forms the ring\\n        \\n        3# no ring, two candidates found\\n        Either the deleted candidate edge break the ring, or there isn\\'t a ring exsiting before we make deletion. For both of two situation, we return the second candidate\\n    \\n    */\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parents = new int[2000];\\n        List<int[]> candidates = new ArrayList<>();\\n        int[] can1 = new int[]{-1, -1}, can2 = new int[]{-1, -1};\\n        for (int[] edge : edges) {\\n            if (parents[edge[1]] != 0) {    // already has one parent\\n                candidates.add(new int[]{parents[edge[1]], edge[1]});  // happens firstly\\n                candidates.add(new int[]{edge[0], edge[1]});\\n                edge[1] = 0;    // delete second candidate\\n            } else {\\n                parents[edge[1]] = edge[0];\\n            }\\n        }\\n        \\n        for (int i = 0; i < 2000; i++)  parents[i] = i;\\n        \\n        for (int[] edge : edges) {\\n            if (edge[1] == 0)   continue;\\n            int child = edge[1], father = edge[0];\\n            if (child == findAncestor(parents, father)) {    // directed ring\\n                if (candidates.size() == 0) {   // ring found, no candidate, return current edge which forms the ring\\n                    return edge;\\n                } else {    // after we delete can2, still found ring, must be can1\\n                    return candidates.get(0);\\n                }\\n            }\\n            parents[child] = father;\\n        }\\n        \\n        // no ring, 2 candidates\\n        // either deleted one cause the ring\\n        // or it never has the ring, so we delete the last candidate\\n        return candidates.get(1);\\n    }\\n    \\n    public int findAncestor(int[] parents, int i) {\\n        while (parents[i] != i) {\\n            i = parents[i];\\n        }\\n        \\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /* explanation:\\n        Three cases before we delete one candidate edge\\n        1. there\\'s a ring, and two candidates found\\n        2. there\\'s a ring, no candidates found   e.g.  1->2->3->1\\n        3. no ring, two candidates found\\n    \\n        If there are 2 candidates, then we delete second candidate edge\\n        Three cases remaining:\\n        \\n        1#. there\\'s still a ring, and two candidates found\\n        This means deleted candidate edge is not inside the ring, so return first candidate\\n        \\n        2# there\\'s still a ring, no two candidates found\\n        This means we never made the deletion, so just return current edge which forms the ring\\n        \\n        3# no ring, two candidates found\\n        Either the deleted candidate edge break the ring, or there isn\\'t a ring exsiting before we make deletion. For both of two situation, we return the second candidate\\n    \\n    */\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] parents = new int[2000];\\n        List<int[]> candidates = new ArrayList<>();\\n        int[] can1 = new int[]{-1, -1}, can2 = new int[]{-1, -1};\\n        for (int[] edge : edges) {\\n            if (parents[edge[1]] != 0) {    // already has one parent\\n                candidates.add(new int[]{parents[edge[1]], edge[1]});  // happens firstly\\n                candidates.add(new int[]{edge[0], edge[1]});\\n                edge[1] = 0;    // delete second candidate\\n            } else {\\n                parents[edge[1]] = edge[0];\\n            }\\n        }\\n        \\n        for (int i = 0; i < 2000; i++)  parents[i] = i;\\n        \\n        for (int[] edge : edges) {\\n            if (edge[1] == 0)   continue;\\n            int child = edge[1], father = edge[0];\\n            if (child == findAncestor(parents, father)) {    // directed ring\\n                if (candidates.size() == 0) {   // ring found, no candidate, return current edge which forms the ring\\n                    return edge;\\n                } else {    // after we delete can2, still found ring, must be can1\\n                    return candidates.get(0);\\n                }\\n            }\\n            parents[child] = father;\\n        }\\n        \\n        // no ring, 2 candidates\\n        // either deleted one cause the ring\\n        // or it never has the ring, so we delete the last candidate\\n        return candidates.get(1);\\n    }\\n    \\n    public int findAncestor(int[] parents, int i) {\\n        while (parents[i] != i) {\\n            i = parents[i];\\n        }\\n        \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450408,
                "title": "my-union-find-solution-written-in-java-with-clear-explanation-time-beats-97",
                "content": "There are 3 cases in this problem:\\n\\n1. Every node has ```only one parent```, and there is ```a circle``` which include the root node. That is to say, the root has an enter edge.\\n2. There is a node with ```two parents```, which have ```one common ancestor``` node.\\n3. There is a node with ```two parents```, one of which is ```in a circle```.\\n\\nMy solution:\\n1. Iterator all the edges.\\n2. For every edge, use ```Union Find``` to find the root of each node. \\n3. In the find process, if the node is in a circle, mark it\\'s root to 0.\\n4. If the roots of the two nodes are the same, it might be the case 1, just mark this edge as ```tempEdge```.\\n5. If the enter node is not a root one, it must be one has two parents, mark the two edges as ```[u1, v]``` and ```[u2, v]```.\\n6. After the iteration, if ```[u1, v]``` and ```[u2, v]``` are not exist, just return ```tempEdge```.\\n7. Else union find u1 and u2, if one of which is in a circle, just return it.\\n8. Else they must have the common root, just return u2(the last one).\\n\\n\\nMy code:\\n```java\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] id = new int[n + 1];\\n        for (int i = 0; i <= n; i++) id[i] = i;\\n\\n        int[] parents = new int[2];\\n        int child = 0;\\n        int[] result = new int[2];\\n        for (int[] e : edges) {\\n            int u = e[0], v = e[1];\\n            int up = find(id, u), vp = find(id, v);\\n\\n            if (up == vp && child == 0) result = e;\\n            else if (vp != v) {\\n                child = v;\\n                parents[0] = id[v];\\n                parents[1] = u;\\n            } else {\\n                id[v] = u;\\n            }\\n        }\\n\\n        if (child != 0) {\\n            int root0 = find(id, parents[0]);\\n            int root1 = find(id, parents[1]);\\n            if (root0 == root1 || root1 == 0) result = new int[]{parents[1], child};\\n            else result = new int[]{parents[0], child};\\n        }\\n\\n        return result;\\n    }\\n\\n    private int find(int[] id, int p) {\\n        int pp = p;\\n        while (pp != id[pp]) {\\n            pp = id[pp];\\n            if (pp == p) return 0;\\n        }\\n        return pp;\\n    }\\n}\\n```\\n\\nWe cannot use path compression in the union find, so the worst time complex is O(n^2).\\n",
                "solutionTags": [],
                "code": "```only one parent```\n```a circle```\n```two parents```\n```one common ancestor```\n```two parents```\n```in a circle```\n```Union Find```\n```tempEdge```\n```[u1, v]```\n```[u2, v]```\n```[u1, v]```\n```[u2, v]```\n```tempEdge```\n```java\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] id = new int[n + 1];\\n        for (int i = 0; i <= n; i++) id[i] = i;\\n\\n        int[] parents = new int[2];\\n        int child = 0;\\n        int[] result = new int[2];\\n        for (int[] e : edges) {\\n            int u = e[0], v = e[1];\\n            int up = find(id, u), vp = find(id, v);\\n\\n            if (up == vp && child == 0) result = e;\\n            else if (vp != v) {\\n                child = v;\\n                parents[0] = id[v];\\n                parents[1] = u;\\n            } else {\\n                id[v] = u;\\n            }\\n        }\\n\\n        if (child != 0) {\\n            int root0 = find(id, parents[0]);\\n            int root1 = find(id, parents[1]);\\n            if (root0 == root1 || root1 == 0) result = new int[]{parents[1], child};\\n            else result = new int[]{parents[0], child};\\n        }\\n\\n        return result;\\n    }\\n\\n    private int find(int[] id, int p) {\\n        int pp = p;\\n        while (pp != id[pp]) {\\n            pp = id[pp];\\n            if (pp == p) return 0;\\n        }\\n        return pp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429248,
                "title": "c-simple-union-find",
                "content": "```\\n    Dictionary<int,int> dict=new Dictionary<int,int>();\\n    public int[] FindRedundantDirectedConnection(int[][] edges) {\\n        int[] cand1=null,cand2=null;\\n        foreach(var edge in edges)\\n        {\\n            int x=find(edge[0]);\\n            int y=find(edge[1]);\\n            if(y!=edge[1])\\n                cand1=edge;\\n            else if(x==y)\\n                cand2=edge;\\n            else\\n                dict[y]=x;\\n        }\\n        if(cand1==null)\\n            return cand2;\\n        if(cand2==null)\\n            return cand1;\\n        foreach (var edge in edges)\\n            if (edge[1] == cand1[1])\\n                return edge;\\n        return new int[2];\\n    }\\n    private int find(int i)\\n    {\\n        if(!dict.ContainsKey(i))\\n            return i;\\n        return find(dict[i]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Dictionary<int,int> dict=new Dictionary<int,int>();\\n    public int[] FindRedundantDirectedConnection(int[][] edges) {\\n        int[] cand1=null,cand2=null;\\n        foreach(var edge in edges)\\n        {\\n            int x=find(edge[0]);\\n            int y=find(edge[1]);\\n            if(y!=edge[1])\\n                cand1=edge;\\n            else if(x==y)\\n                cand2=edge;\\n            else\\n                dict[y]=x;\\n        }\\n        if(cand1==null)\\n            return cand2;\\n        if(cand2==null)\\n            return cand1;\\n        foreach (var edge in edges)\\n            if (edge[1] == cand1[1])\\n                return edge;\\n        return new int[2];\\n    }\\n    private int find(int i)\\n    {\\n        if(!dict.ContainsKey(i))\\n            return i;\\n        return find(dict[i]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392157,
                "title": "java-union-find-solution",
                "content": "time: O(N)\\nspace: O(N)\\n```java\\nclass Solution {\\n  public int[] findRedundantDirectedConnection(int[][] edges) {\\n    int[] parent = new int[edges.length+1];\\n    for (int i = 0; i < parent.length; i++) parent[i] = i;\\n    int[] can1 = null, can2 = null;\\n    for (int[] e: edges) {\\n      int p0 = find(parent, e[0]), p1 = find(parent, e[1]);\\n      if (p1 != e[1]) can1 = e;\\n      else if (p0 == e[1]) can2 = e;\\n      else parent[e[1]] = e[0];\\n    }\\n    if (can1 == null) return can2;\\n    if (can2 == null) return can1;\\n    for (int[] e: edges) if (e[1] == can1[1]) return e;\\n    return new int[2];\\n  }\\n  private int find(int[] parent, int i) {\\n    if (i != parent[i]) parent[i] = find(parent, parent[i]);\\n    return parent[i];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public int[] findRedundantDirectedConnection(int[][] edges) {\\n    int[] parent = new int[edges.length+1];\\n    for (int i = 0; i < parent.length; i++) parent[i] = i;\\n    int[] can1 = null, can2 = null;\\n    for (int[] e: edges) {\\n      int p0 = find(parent, e[0]), p1 = find(parent, e[1]);\\n      if (p1 != e[1]) can1 = e;\\n      else if (p0 == e[1]) can2 = e;\\n      else parent[e[1]] = e[0];\\n    }\\n    if (can1 == null) return can2;\\n    if (can2 == null) return can1;\\n    for (int[] e: edges) if (e[1] == can1[1]) return e;\\n    return new int[2];\\n  }\\n  private int find(int[] parent, int i) {\\n    if (i != parent[i]) parent[i] = find(parent, parent[i]);\\n    return parent[i];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375720,
                "title": "java-unionfind",
                "content": "```\\nclass UnionFind{\\n        int[] f;\\n        public UnionFind(int size){\\n            f = new int[size];\\n            for(int i = 0; i < size; i++){\\n                f[i] = i;\\n            }\\n        }\\n        public int find(int x){\\n            int y = x;\\n            while(f[y] != y){\\n                y = f[y];\\n            }\\n            while(x != y){\\n                int fx = f[x];\\n                f[x] = y;\\n                x = fx;\\n            }\\n            return y;\\n        }\\n        public void union(int x, int y){\\n            int fx = find(x);\\n            int fy = find(y);\\n            if(fx != fy){\\n                f[fx] = fy;\\n            }\\n        }\\n    }\\n    //1.\\u6BCF\\u4E2A\\u8282\\u70B9\\u53EA\\u67091\\u4E2Aparent -> \\u5220\\u9664\\u5F62\\u6210\\u73AF\\u7684\\u90A3\\u6761\\u8FB9\\n    //2.1 \\u6709\\u4E00\\u4E2A\\u8282\\u70B9\\u67092\\u4E2Aparent\\uFF0C\\u6CA1\\u6709\\u5F62\\u6210\\u73AF\\uFF0C\\u5220\\u9664\\u7B2C\\u4E8C\\u6761\\u8FB9\\n    //2.2 \\u6709\\u4E00\\u4E2A\\u8282\\u70B9\\u67092\\u4E2Aparent\\uFF0C\\u5F62\\u6210\\u73AF\\uFF0C\\u5220\\u9664\\u5F62\\u6210\\u73AF\\u4E14\\u6709\\u4E24\\u4E2Aparent\\u7684\\u90A3\\u6761\\u8FB9\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        UnionFind uf = new UnionFind(n + 1);\\n        int[] parents = new int[n + 1];\\n        int[] ans1 = new int[2];\\n        int[] ans2 = new int[2];\\n        for(int i = 0; i < edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(parents[v] > 0){\\n                ans1[0] = parents[v];\\n                ans1[1] = v;\\n                \\n                ans2[0] = u;\\n                ans2[1] = v;\\n                \\n                edges[i][0] = -1;\\n                edges[i][1] = -1;\\n            }\\n            \\n            parents[v] = u;\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(u == -1 && v == -1){\\n               continue; \\n            }\\n            int fu = uf.find(u);\\n            int fv = uf.find(v);\\n            if(fu != fv){\\n                uf.union(fu, fv);\\n            }else{ //fu == fv\\n                if(ans1[0] != 0){\\n                    return ans1;\\n                }else{\\n                    return edges[i];\\n                }\\n            }\\n        }\\n        return ans2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind{\\n        int[] f;\\n        public UnionFind(int size){\\n            f = new int[size];\\n            for(int i = 0; i < size; i++){\\n                f[i] = i;\\n            }\\n        }\\n        public int find(int x){\\n            int y = x;\\n            while(f[y] != y){\\n                y = f[y];\\n            }\\n            while(x != y){\\n                int fx = f[x];\\n                f[x] = y;\\n                x = fx;\\n            }\\n            return y;\\n        }\\n        public void union(int x, int y){\\n            int fx = find(x);\\n            int fy = find(y);\\n            if(fx != fy){\\n                f[fx] = fy;\\n            }\\n        }\\n    }\\n    //1.\\u6BCF\\u4E2A\\u8282\\u70B9\\u53EA\\u67091\\u4E2Aparent -> \\u5220\\u9664\\u5F62\\u6210\\u73AF\\u7684\\u90A3\\u6761\\u8FB9\\n    //2.1 \\u6709\\u4E00\\u4E2A\\u8282\\u70B9\\u67092\\u4E2Aparent\\uFF0C\\u6CA1\\u6709\\u5F62\\u6210\\u73AF\\uFF0C\\u5220\\u9664\\u7B2C\\u4E8C\\u6761\\u8FB9\\n    //2.2 \\u6709\\u4E00\\u4E2A\\u8282\\u70B9\\u67092\\u4E2Aparent\\uFF0C\\u5F62\\u6210\\u73AF\\uFF0C\\u5220\\u9664\\u5F62\\u6210\\u73AF\\u4E14\\u6709\\u4E24\\u4E2Aparent\\u7684\\u90A3\\u6761\\u8FB9\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        UnionFind uf = new UnionFind(n + 1);\\n        int[] parents = new int[n + 1];\\n        int[] ans1 = new int[2];\\n        int[] ans2 = new int[2];\\n        for(int i = 0; i < edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(parents[v] > 0){\\n                ans1[0] = parents[v];\\n                ans1[1] = v;\\n                \\n                ans2[0] = u;\\n                ans2[1] = v;\\n                \\n                edges[i][0] = -1;\\n                edges[i][1] = -1;\\n            }\\n            \\n            parents[v] = u;\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(u == -1 && v == -1){\\n               continue; \\n            }\\n            int fu = uf.find(u);\\n            int fv = uf.find(v);\\n            if(fu != fv){\\n                uf.union(fu, fv);\\n            }else{ //fu == fv\\n                if(ans1[0] != 0){\\n                    return ans1;\\n                }else{\\n                    return edges[i];\\n                }\\n            }\\n        }\\n        return ans2;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368266,
                "title": "c-o-n-with-union-find-set-approach-easy-to-understand",
                "content": "**Firstly**, imagine that you have a valid directed tree,  and then you add an edge between two nodes of it.\\n\\nIf you **connect any other node with the root node**, you will get a invalid tree with cycle.\\n([[1, 2], [2, 3], [1, 3]] is not a cycle, while [[1, 2], [2, 3], [3, 1]] is a cycle).\\n\\nif you **connect between non-root node**, you will get a invalid tree with a node whose in-dgree in **two**.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int parent[1001];\\n    int rank[1001];\\n    \\n    void init(int n) {\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (x != parent[x]) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    void unite(int x, int y) {    \\n        int px = find(x);\\n        int py = find(y);\\n        if (rank[px] > rank[py]) {\\n            parent[py] = px;\\n        } else if (rank[px] < rank[py]) {\\n            parent[px] = py;\\n        } else {\\n            parent[px] = py;\\n            rank[py] += 1;\\n        }\\n    }\\n    \\n    int work(vector<vector<int>>& edges, int skip) {\\n        int n = edges.size();\\n        for (int  i = 0; i < n; ++i) {\\n            if (i == skip) continue;\\n            const auto& e = edges[i];\\n            int fx = find(e[0]);\\n            int fy = find(e[1]);\\n            if (fx == fy) {\\n                return i;\\n            }\\n            unite(e[0], e[1]);\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = -1;\\n        }\\n        \\n        vector<int> candidate;\\n        for (int i = 0; i < n; ++i) {\\n            const auto& e = edges[i];\\n            if (parent[e[1]] != -1) {\\n                candidate = {i, parent[e[1]]};\\n            }\\n            parent[e[1]] = i;\\n        }\\n        \\n        init(n);\\n        // no node with 2 parents, there must exist a cycle\\n        if (candidate.size() == 0) {\\n            int id = work(edges, -1);\\n            return edges[id];\\n        }\\n        \\n        if (work(edges, candidate[0]) == -1) {\\n            return edges[candidate[0]];\\n        } else {\\n            return edges[candidate[1]];\\n        }        \\n        return {0, 0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int parent[1001];\\n    int rank[1001];\\n    \\n    void init(int n) {\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (x != parent[x]) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    void unite(int x, int y) {    \\n        int px = find(x);\\n        int py = find(y);\\n        if (rank[px] > rank[py]) {\\n            parent[py] = px;\\n        } else if (rank[px] < rank[py]) {\\n            parent[px] = py;\\n        } else {\\n            parent[px] = py;\\n            rank[py] += 1;\\n        }\\n    }\\n    \\n    int work(vector<vector<int>>& edges, int skip) {\\n        int n = edges.size();\\n        for (int  i = 0; i < n; ++i) {\\n            if (i == skip) continue;\\n            const auto& e = edges[i];\\n            int fx = find(e[0]);\\n            int fy = find(e[1]);\\n            if (fx == fy) {\\n                return i;\\n            }\\n            unite(e[0], e[1]);\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        for (int i = 1; i <= n; ++i) {\\n            parent[i] = -1;\\n        }\\n        \\n        vector<int> candidate;\\n        for (int i = 0; i < n; ++i) {\\n            const auto& e = edges[i];\\n            if (parent[e[1]] != -1) {\\n                candidate = {i, parent[e[1]]};\\n            }\\n            parent[e[1]] = i;\\n        }\\n        \\n        init(n);\\n        // no node with 2 parents, there must exist a cycle\\n        if (candidate.size() == 0) {\\n            int id = work(edges, -1);\\n            return edges[id];\\n        }\\n        \\n        if (work(edges, candidate[0]) == -1) {\\n            return edges[candidate[0]];\\n        } else {\\n            return edges[candidate[1]];\\n        }        \\n        return {0, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301332,
                "title": "python3-solution-with-diagram-explanation",
                "content": "First detect cycles globally:\\nIf found:\\n\\t1) there is one node with more than 1 parents: then remove one of the two edges\\n\\t2) every node in the cycle has only one parent, remove the last one of them\\n\\nOtherwise:\\n\\tThere must be one node with more than 1 parents: just remove one of the two edges\\n![image](https://assets.leetcode.com/users/dengl11/image_1559107094.png)\\n\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        edges.reverse()\\n        nbrs = defaultdict(list)\\n        parents = defaultdict(list)\\n        n = 0\\n        for i, j in edges:\\n            nbrs[i].append(j)\\n            parents[j].append(i)\\n            n = max(n, i, j)\\n        \\n        # detect cycle globally\\n        visited = set()\\n        def detect_cycle(i):\\n            if i in visited: return\\n            visited.add(i)\\n            stack = [i]\\n            def dfs(i, V, path):\\n                for j in nbrs[i]:\\n                    if j in V:\\n                        return path[path.index(j):]\\n                    V.add(j)\\n                    visited.add(j)\\n                    path.append(j)\\n                    curr = dfs(j, V, path)\\n                    if curr: return curr\\n                    V.remove(path.pop())\\n            return dfs(i, {i}, [i])\\n                    \\n        for i in range(1, n+1):\\n            curr = detect_cycle(i)\\n            if curr:\\n                curr = set(curr)\\n                candidate = None\\n                for i, j in edges:\\n                    if i in curr and j in curr:\\n                        if candidate is None: candidate = [i, j]\\n                        if len(parents[j]) > 1: return [i, j]\\n                return candidate\\n                    \\n        for i, j in edges:\\n            if len(parents[j]) > 1:\\n                return [i, j]\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        edges.reverse()\\n        nbrs = defaultdict(list)\\n        parents = defaultdict(list)\\n        n = 0\\n        for i, j in edges:\\n            nbrs[i].append(j)\\n            parents[j].append(i)\\n            n = max(n, i, j)\\n        \\n        # detect cycle globally\\n        visited = set()\\n        def detect_cycle(i):\\n            if i in visited: return\\n            visited.add(i)\\n            stack = [i]\\n            def dfs(i, V, path):\\n                for j in nbrs[i]:\\n                    if j in V:\\n                        return path[path.index(j):]\\n                    V.add(j)\\n                    visited.add(j)\\n                    path.append(j)\\n                    curr = dfs(j, V, path)\\n                    if curr: return curr\\n                    V.remove(path.pop())\\n            return dfs(i, {i}",
                "codeTag": "Java"
            },
            {
                "id": 295471,
                "title": "short-java-union-find-code-in-map-with-explanation",
                "content": "```\\n/*\\nThere are basic 3 cases, which divided by two conditions\\ncon 1, there is a circle, con 2 there is a node with two parents.\\ncase 1, there is a circle but no nodes with two parents-- return the first edge complete a circle\\ncase 2, there is a circle, also with a node with two parents -- return the first edge points to the node with two parents\\ncase 3, there is no circle, but with a node with two parents -- return the second edge that points to the node with two parents.\\n\\n*/\\n```\\n```\\n/*\\nparent used to store nodes parent\\'\\nroot used to store the roots\\nans1 and ans2 use to store the two edges points to the node with two parents\\n*/\\n```\\n```\\nclass Solution {\\n    Map<Integer,Integer> parent= new HashMap<>();\\n    Map<Integer,Integer> root= new HashMap<>();\\n    int[] ans1 = {-1,-1}, ans2={-1,-1};\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n         for(int[] e: edges){\\n            int u= e[0],v=e[1];\\n            if(parent.containsKey(v)){\\n                ans2= new int[]{e[0], e[1]};\\n                ans1= new int[]{parent.get(v),v};\\n                e[0]=-1;e[1]=-1;\\n            }else parent.put(v,u);\\n        }\\n        \\n        for(int[] e: edges){\\n            int u= e[0],v=e[1];\\n            if(u<0 || v<0) continue;\\n            int p1= find(u),p2= find(v);\\n            if(p1==p2)\\n                return ans1[0]==-1? e: ans1;\\n            root.put(p1,p2);\\n        }\\n        return ans2;\\n    }\\n    int find(int x){\\n        root.putIfAbsent(x,x);\\n        while(x!=root.get(x)) x=root.get(x);\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThere are basic 3 cases, which divided by two conditions\\ncon 1, there is a circle, con 2 there is a node with two parents.\\ncase 1, there is a circle but no nodes with two parents-- return the first edge complete a circle\\ncase 2, there is a circle, also with a node with two parents -- return the first edge points to the node with two parents\\ncase 3, there is no circle, but with a node with two parents -- return the second edge that points to the node with two parents.\\n\\n*/\\n```\n```\\n/*\\nparent used to store nodes parent\\'\\nroot used to store the roots\\nans1 and ans2 use to store the two edges points to the node with two parents\\n*/\\n```\n```\\nclass Solution {\\n    Map<Integer,Integer> parent= new HashMap<>();\\n    Map<Integer,Integer> root= new HashMap<>();\\n    int[] ans1 = {-1,-1}, ans2={-1,-1};\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n         for(int[] e: edges){\\n            int u= e[0],v=e[1];\\n            if(parent.containsKey(v)){\\n                ans2= new int[]{e[0], e[1]};\\n                ans1= new int[]{parent.get(v),v};\\n                e[0]=-1;e[1]=-1;\\n            }else parent.put(v,u);\\n        }\\n        \\n        for(int[] e: edges){\\n            int u= e[0],v=e[1];\\n            if(u<0 || v<0) continue;\\n            int p1= find(u),p2= find(v);\\n            if(p1==p2)\\n                return ans1[0]==-1? e: ans1;\\n            root.put(p1,p2);\\n        }\\n        return ans2;\\n    }\\n    int find(int x){\\n        root.putIfAbsent(x,x);\\n        while(x!=root.get(x)) x=root.get(x);\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287623,
                "title": "description-is-wrong",
                "content": "The problem description says that:\\n```\\nevery node has exactly one parent, except for the root node which has no parents.\\n```\\n\\nbut one of the test cases is like this:\\n[[2,1],[3,1],[4,2],[1,4]]\\n\\nwhere 1 has 2 parents which are nodes 2 & 3. Am I missing something?",
                "solutionTags": [],
                "code": "```\\nevery node has exactly one parent, except for the root node which has no parents.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282760,
                "title": "a-different-solution-with-parent-and-child-maps-much-easier-to-understand-and-well-commented",
                "content": "These are the cases:\\n1. All nodes in single loop => there is no vertex with 2 parents and there is no vertex with 2 children. Just return last edge.\\n2. There is a cycle\\nThere are again two cases\\n(1) There is a child with 2 parents, like 1 in [[1,4], [4,2], [2,1], [3,1]]. We must remove one of the two parents, so we remove the one inside the loop\\n(2) There is a parent with 2 children, like 1 in [[1,4], [4,2], [2,1], [1,3]]. We can remove either incoming edge([2,1]) or the outgoing edge [1,4] inside the loop. We just check which one comes last in the edges array and remove it.\\n\\n3. There is no cycle => there must be a vertex with 2 parents, just return the edge for second one\\n```\\npublic class Solution {\\n    public int[] FindRedundantDirectedConnection(int[][] edges) {\\n        var childToParentMap = new Dictionary<int,List<int>>();\\n        var parentToChildrenMap = new Dictionary<int,List<int>>();\\n        var edgeToIndex=new Dictionary<(int,int),int>();\\n        var childWith2Parents=0;\\n        var parentWith2Children=0;\\n        for(var index=0;index<edges.Count();index++)\\n        {\\n            var u=edges[index][0];\\n            var v=edges[index][1];\\n\\n            edgeToIndex[(u,v)]=index;\\n            if(!childToParentMap.ContainsKey(v))\\n            {\\n                childToParentMap[v]=new List<int>();                \\n            }\\n            childToParentMap[v].Add(u);\\n            if(childToParentMap[v].Count() == 2) childWith2Parents=v;\\n\\n            if(!parentToChildrenMap.ContainsKey(u))\\n            {\\n                parentToChildrenMap[u]=new List<int>();                \\n            }\\n            parentToChildrenMap[u].Add(v);\\n            if(parentToChildrenMap[u].Count() == 2) parentWith2Children=u;\\n        }\\n\\n        // if all vertices are in 1 loop\\n        // everything would have 1 parent, 1 child\\n        // or nothing would have 2\\n        if(childWith2Parents ==0 \\n            && parentWith2Children == 0)\\n        {\\n            return edges[edges.Count()-1];\\n        }\\n\\n        if(childWith2Parents !=0)\\n        {\\n            for(var index=1;index>=0;index--)\\n            {\\n                var current=childToParentMap[childWith2Parents][index];\\n                while(childToParentMap.ContainsKey(current) && \\n                    childToParentMap[current].First() !=childWith2Parents)\\n                {\\n                    current=childToParentMap[current].First();\\n                }\\n\\n                if(childToParentMap.ContainsKey(current) && \\n                    childToParentMap[current].First() ==childWith2Parents)\\n                    {\\n                        // incoming is the only choice\\n                        // removing outgoing would remove cycle, but childWith2Parents would be the root\\n                        // and nothing would be reachable from it (invalid tree)\\n                        // (another way to see this is that childWith2Parents would still have 2 parents)\\n                        return new int[]{childToParentMap[childWith2Parents][index], childWith2Parents};\\n                    }\\n            }\\n            \\n        }   \\n        else\\n        {\\n            for(var index=1;index>=0;index--)\\n            {\\n                var current=parentToChildrenMap[parentWith2Children][index];\\n                while(parentToChildrenMap.ContainsKey(current) && \\n                    parentToChildrenMap[current].First() !=parentWith2Children)\\n                {\\n                    current=parentToChildrenMap[current].First();\\n                }\\n\\n                if(parentToChildrenMap.ContainsKey(current) && \\n                    parentToChildrenMap[current].First() ==parentWith2Children)\\n                    {\\n                        // for case [[1,2],[2,3],[3,4],[4,1],[1,5]] answer is 4,1 (incoming)\\n                        // but if you switch order of 1,2 and 4,1 answer is 1,2 (outgoing)\\n                        // either one makes a valid tree\\n                        var incoming=(current, parentWith2Children);\\n                        var outgoing=(parentWith2Children, parentToChildrenMap[parentWith2Children][index]);\\n                        if(edgeToIndex[incoming] > edgeToIndex[outgoing])\\n                        {\\n                            return new int[]{incoming.Item1,incoming.Item2};\\n                        }\\n                        else\\n                        {\\n                            return new int[]{outgoing.Item1,outgoing.Item2};\\n                        }\\n                    }\\n            }\\n        }    \\n\\n        // there is no loop, return 2nd encountered parent\\n        return new int[]{childToParentMap[childWith2Parents][1], childWith2Parents};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FindRedundantDirectedConnection(int[][] edges) {\\n        var childToParentMap = new Dictionary<int,List<int>>();\\n        var parentToChildrenMap = new Dictionary<int,List<int>>();\\n        var edgeToIndex=new Dictionary<(int,int),int>();\\n        var childWith2Parents=0;\\n        var parentWith2Children=0;\\n        for(var index=0;index<edges.Count();index++)\\n        {\\n            var u=edges[index][0];\\n            var v=edges[index][1];\\n\\n            edgeToIndex[(u,v)]=index;\\n            if(!childToParentMap.ContainsKey(v))\\n            {\\n                childToParentMap[v]=new List<int>();                \\n            }\\n            childToParentMap[v].Add(u);\\n            if(childToParentMap[v].Count() == 2) childWith2Parents=v;\\n\\n            if(!parentToChildrenMap.ContainsKey(u))\\n            {\\n                parentToChildrenMap[u]=new List<int>();                \\n            }\\n            parentToChildrenMap[u].Add(v);\\n            if(parentToChildrenMap[u].Count() == 2) parentWith2Children=u;\\n        }\\n\\n        // if all vertices are in 1 loop\\n        // everything would have 1 parent, 1 child\\n        // or nothing would have 2\\n        if(childWith2Parents ==0 \\n            && parentWith2Children == 0)\\n        {\\n            return edges[edges.Count()-1];\\n        }\\n\\n        if(childWith2Parents !=0)\\n        {\\n            for(var index=1;index>=0;index--)\\n            {\\n                var current=childToParentMap[childWith2Parents][index];\\n                while(childToParentMap.ContainsKey(current) && \\n                    childToParentMap[current].First() !=childWith2Parents)\\n                {\\n                    current=childToParentMap[current].First();\\n                }\\n\\n                if(childToParentMap.ContainsKey(current) && \\n                    childToParentMap[current].First() ==childWith2Parents)\\n                    {\\n                        // incoming is the only choice\\n                        // removing outgoing would remove cycle, but childWith2Parents would be the root\\n                        // and nothing would be reachable from it (invalid tree)\\n                        // (another way to see this is that childWith2Parents would still have 2 parents)\\n                        return new int[]{childToParentMap[childWith2Parents][index], childWith2Parents};\\n                    }\\n            }\\n            \\n        }   \\n        else\\n        {\\n            for(var index=1;index>=0;index--)\\n            {\\n                var current=parentToChildrenMap[parentWith2Children][index];\\n                while(parentToChildrenMap.ContainsKey(current) && \\n                    parentToChildrenMap[current].First() !=parentWith2Children)\\n                {\\n                    current=parentToChildrenMap[current].First();\\n                }\\n\\n                if(parentToChildrenMap.ContainsKey(current) && \\n                    parentToChildrenMap[current].First() ==parentWith2Children)\\n                    {\\n                        // for case [[1,2],[2,3],[3,4],[4,1],[1,5]] answer is 4,1 (incoming)\\n                        // but if you switch order of 1,2 and 4,1 answer is 1,2 (outgoing)\\n                        // either one makes a valid tree\\n                        var incoming=(current, parentWith2Children);\\n                        var outgoing=(parentWith2Children, parentToChildrenMap[parentWith2Children][index]);\\n                        if(edgeToIndex[incoming] > edgeToIndex[outgoing])\\n                        {\\n                            return new int[]{incoming.Item1,incoming.Item2};\\n                        }\\n                        else\\n                        {\\n                            return new int[]{outgoing.Item1,outgoing.Item2};\\n                        }\\n                    }\\n            }\\n        }    \\n\\n        // there is no loop, return 2nd encountered parent\\n        return new int[]{childToParentMap[childWith2Parents][1], childWith2Parents};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262554,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int, int> f;\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int, int> t;\\n        vector<vector<int>> cand;\\n        for(auto e:edges){\\n            if (!t.count(e[1])){\\n                t[e[1]]=e[0];\\n            }\\n            else{                \\n                cand.push_back(e);\\n                cand.push_back({t[e[1]],e[1]});                \\n            }\\n        }\\n        \\n        for(auto e:edges){\\n            if (!f.count(e[0])) f[e[0]] = e[0];\\n            if (!f.count(e[1])) f[e[1]] = e[1];\\n            if (!cand.size()){\\n                if(!uni(e[0], e[1])) return res;\\n            }\\n            else{\\n                if (!(e[0]==cand[0][0]&&e[1]==cand[0][1])){\\n                    if(!uni(e[0], e[1])) return cand[1];\\n                }\\n            }\\n        }\\n        \\n        return cand[0];\\n    }\\n    \\n    int find(int a){\\n        if (f[a]!=a){\\n            f[a]=find(f[a]);\\n        }\\n        return f[a];\\n    }\\n    \\n    bool uni(int a, int b){\\n        int af = find(a);\\n        int bf = find(b);\\n        if (af==bf){\\n            res = {a,b};\\n            return false;\\n        }        \\n        f[bf]=af;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int, int> f;\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int, int> t;\\n        vector<vector<int>> cand;\\n        for(auto e:edges){\\n            if (!t.count(e[1])){\\n                t[e[1]]=e[0];\\n            }\\n            else{                \\n                cand.push_back(e);\\n                cand.push_back({t[e[1]],e[1]});                \\n            }\\n        }\\n        \\n        for(auto e:edges){\\n            if (!f.count(e[0])) f[e[0]] = e[0];\\n            if (!f.count(e[1])) f[e[1]] = e[1];\\n            if (!cand.size()){\\n                if(!uni(e[0], e[1])) return res;\\n            }\\n            else{\\n                if (!(e[0]==cand[0][0]&&e[1]==cand[0][1])){\\n                    if(!uni(e[0], e[1])) return cand[1];\\n                }\\n            }\\n        }\\n        \\n        return cand[0];\\n    }\\n    \\n    int find(int a){\\n        if (f[a]!=a){\\n            f[a]=find(f[a]);\\n        }\\n        return f[a];\\n    }\\n    \\n    bool uni(int a, int b){\\n        int af = find(a);\\n        int bf = find(b);\\n        if (af==bf){\\n            res = {a,b};\\n            return false;\\n        }        \\n        f[bf]=af;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226588,
                "title": "c-beats-100-trim-nodes-of-degree-1-similar-to-minimum-height-trees",
                "content": "This solution is very similar to Minimum Height Trees and also Redundant Connection (I): https://leetcode.com/problems/redundant-connection/discuss/223338/C%2B%2B-beats-100%3A-trim-nodes-of-degree-1-similar-to-Minimum-Height-Trees\\n\\n```\\nclass Solution {\\npublic:\\n    struct Node {\\n        int degree;\\n        int edge;\\n        int inDegree;\\n    };\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<Node> nodes(edges.size(), Node{0, 0, 0});\\n        int inDegreeTwoNode = -1;\\n\\n        for (const auto& edge : edges) {\\n            nodes[edge[0] - 1].degree++;\\n            nodes[edge[0] - 1].edge ^= edge[1] - 1;\\n            nodes[edge[1] - 1].degree++;\\n            nodes[edge[1] - 1].edge ^= edge[0] - 1;\\n\\n            nodes[edge[1] - 1].inDegree++;\\n            if (nodes[edge[1] - 1].inDegree == 2) {\\n                inDegreeTwoNode = edge[1] - 1;\\n            }\\n        }\\n\\n        vector<int> u;\\n        vector<int> v;\\n\\n        for (int i = 0; i < nodes.size(); i++) {\\n            if (nodes[i].degree == 1) {\\n                u.push_back(i);\\n            }\\n        }\\n\\n        while (!u.empty()) {\\n            for (const auto id : u) {\\n                const auto node = &nodes[id];\\n                const auto otherNode = &nodes[node->edge];\\n                node->degree--;\\n                otherNode->degree--;\\n                otherNode->edge ^= id;\\n                if (otherNode->degree == 1) {\\n                    v.push_back(node->edge);\\n                }\\n            }\\n\\n            u.clear();\\n            swap(u, v);\\n        }\\n\\n        // Any edge in the remaining cycle is redundant, unless there is a node of\\n        // indegree two, in which case the edge must also point to that node.\\n        for (int i = edges.size() - 1; i >= 0; i--) {\\n            const auto& edge = edges[i];\\n            if ((nodes[edge[0] - 1].degree != 0) && (nodes[edge[1] - 1].degree != 0) &&\\n                ((inDegreeTwoNode == -1) || (edge[1] - 1 == inDegreeTwoNode))) {\\n                return edge;\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        int degree;\\n        int edge;\\n        int inDegree;\\n    };\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<Node> nodes(edges.size(), Node{0, 0, 0});\\n        int inDegreeTwoNode = -1;\\n\\n        for (const auto& edge : edges) {\\n            nodes[edge[0] - 1].degree++;\\n            nodes[edge[0] - 1].edge ^= edge[1] - 1;\\n            nodes[edge[1] - 1].degree++;\\n            nodes[edge[1] - 1].edge ^= edge[0] - 1;\\n\\n            nodes[edge[1] - 1].inDegree++;\\n            if (nodes[edge[1] - 1].inDegree == 2) {\\n                inDegreeTwoNode = edge[1] - 1;\\n            }\\n        }\\n\\n        vector<int> u;\\n        vector<int> v;\\n\\n        for (int i = 0; i < nodes.size(); i++) {\\n            if (nodes[i].degree == 1) {\\n                u.push_back(i);\\n            }\\n        }\\n\\n        while (!u.empty()) {\\n            for (const auto id : u) {\\n                const auto node = &nodes[id];\\n                const auto otherNode = &nodes[node->edge];\\n                node->degree--;\\n                otherNode->degree--;\\n                otherNode->edge ^= id;\\n                if (otherNode->degree == 1) {\\n                    v.push_back(node->edge);\\n                }\\n            }\\n\\n            u.clear();\\n            swap(u, v);\\n        }\\n\\n        // Any edge in the remaining cycle is redundant, unless there is a node of\\n        // indegree two, in which case the edge must also point to that node.\\n        for (int i = edges.size() - 1; i >= 0; i--) {\\n            const auto& edge = edges[i];\\n            if ((nodes[edge[0] - 1].degree != 0) && (nodes[edge[1] - 1].degree != 0) &&\\n                ((inDegreeTwoNode == -1) || (edge[1] - 1 == inDegreeTwoNode))) {\\n                return edge;\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224189,
                "title": "easy-union-by-rank-solution-java-beats-99",
                "content": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int parent[] = new int[edges.length + 1];\\n        Arrays.fill(parent, -1);\\n        for(int[] edge: edges) {\\n            if(parent[edge[1]] != -1) { //this means that this edge has already a parent\\n                    int [] redundant1 = {edge[0], edge[1]};\\n                    if(isValidWithoutEdge(redundant1, edges)) {\\n                        return redundant1;\\n                    }\\n                    \\n                    int [] redundant2 = {parent[edge[1]], edge[1]};\\n                    if(isValidWithoutEdge(redundant2, edges)) {\\n                        return redundant2;\\n                    }\\n            } else parent[edge[1]] = edge[0];\\n                \\n        }\\n\\n        return findInvalidEdge(edges);\\n    }\\n    \\n    //if a child has 2 parents, than either one can be removed to make it a proper graph, its possible return that edge\\n    public boolean isValidWithoutEdge(int[] redundant, int[][] edges) {\\n        Disjoint set = new Disjoint();\\n        set.make(edges.length);\\n\\n        for(int edge[]: edges) {\\n            if(edge[0] == redundant[0] && edge[1] == redundant[1]) continue;\\n            if(!set.unionPossible(edge[0], edge[1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    //if removing redundant edge does not work than return find cycle\\n    public int[] findInvalidEdge(int[][] edges) {\\n        Disjoint set = new Disjoint();\\n        set.make(edges.length);\\n\\n        for(int edge[]: edges) {\\n            if(!set.unionPossible(edge[0], edge[1])) return edge;\\n        }\\n        return edges[edges.length - 1];\\n    }\\n    \\n}\\n\\nclass Disjoint {\\n    int parent[]; \\n    int rank[];\\n    public void make(int n) {\\n        parent = new int[n + 1];\\n        rank = new int[n+1];\\n        for(int i = 0; i<parent.length; i++) parent[i] = i;\\n    }\\n    \\n    public int find(int i) {\\n        if(parent[i] == i) return i;\\n        else return find(parent[i]);       \\n    }\\n    \\n    //UNION by rank for efficiency\\n    public boolean unionPossible(int i, int j) {\\n         int p1 = find(i);\\n         int p2 = find(j);\\n         if(p1 != p2) {\\n             if(rank[p1] >= p2) {\\n                 parent[p2] = p1;\\n                 rank[p1]++;\\n             } else {\\n                 parent[p1] = p2;\\n                 rank[p2]++;\\n             }\\n            return true;\\n         } else return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int parent[] = new int[edges.length + 1];\\n        Arrays.fill(parent, -1);\\n        for(int[] edge: edges) {\\n            if(parent[edge[1]] != -1) { //this means that this edge has already a parent\\n                    int [] redundant1 = {edge[0], edge[1]};\\n                    if(isValidWithoutEdge(redundant1, edges)) {\\n                        return redundant1;\\n                    }\\n                    \\n                    int [] redundant2 = {parent[edge[1]], edge[1]};\\n                    if(isValidWithoutEdge(redundant2, edges)) {\\n                        return redundant2;\\n                    }\\n            } else parent[edge[1]] = edge[0];\\n                \\n        }\\n\\n        return findInvalidEdge(edges);\\n    }\\n    \\n    //if a child has 2 parents, than either one can be removed to make it a proper graph, its possible return that edge\\n    public boolean isValidWithoutEdge(int[] redundant, int[][] edges) {\\n        Disjoint set = new Disjoint();\\n        set.make(edges.length);\\n\\n        for(int edge[]: edges) {\\n            if(edge[0] == redundant[0] && edge[1] == redundant[1]) continue;\\n            if(!set.unionPossible(edge[0], edge[1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    //if removing redundant edge does not work than return find cycle\\n    public int[] findInvalidEdge(int[][] edges) {\\n        Disjoint set = new Disjoint();\\n        set.make(edges.length);\\n\\n        for(int edge[]: edges) {\\n            if(!set.unionPossible(edge[0], edge[1])) return edge;\\n        }\\n        return edges[edges.length - 1];\\n    }\\n    \\n}\\n\\nclass Disjoint {\\n    int parent[]; \\n    int rank[];\\n    public void make(int n) {\\n        parent = new int[n + 1];\\n        rank = new int[n+1];\\n        for(int i = 0; i<parent.length; i++) parent[i] = i;\\n    }\\n    \\n    public int find(int i) {\\n        if(parent[i] == i) return i;\\n        else return find(parent[i]);       \\n    }\\n    \\n    //UNION by rank for efficiency\\n    public boolean unionPossible(int i, int j) {\\n         int p1 = find(i);\\n         int p2 = find(j);\\n         if(p1 != p2) {\\n             if(rank[p1] >= p2) {\\n                 parent[p2] = p1;\\n                 rank[p1]++;\\n             } else {\\n                 parent[p1] = p2;\\n                 rank[p2]++;\\n             }\\n            return true;\\n         } else return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207354,
                "title": "straight-forward-java-solution",
                "content": "```\\nclass Solution {\\n    // Tree with directed graph will only have ONE vertex has 0 indegree and non-one outdegree. \\n    // Other vertices will have exactly 1 indegree and 1 or 0 outdegree.\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // Tree will have n - 1 edges, and there is one more redundant edge.\\n        // So the number of vertices is the length of input edges\\n        final int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        int[] outdegree = new int[n + 1];\\n        final Map<Integer, Set<Integer>> adjList = new HashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            adjList.put(i, new HashSet<>());\\n        }\\n        int edgeTo = -1;\\n        for (final int[] edge : edges) {\\n            outdegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n            if (indegree[edge[1]] > 1) {\\n                edgeTo = edge[1];\\n            }\\n            adjList.get(edge[0]).add(edge[1]);\\n        }\\n        \\n        int[] res = null;\\n        if (edgeTo != -1) {\\n            int root = -1;\\n            for (int i = 1; i <= n; i++) {\\n                if (indegree[i] == 0) root = i;\\n            }\\n            \\n            for (int i = n - 1; i >= 0; i--) {\\n                if (edges[i][1] == edgeTo) {\\n                    if (tryDeleteEdge(edges[i][0], edges[i][1], root, adjList)) {\\n                        res = edges[i];\\n                        break;\\n                    }\\n                }\\n            }\\n        } else {\\n            for (int i = n - 1; i >= 0; i--) {\\n                int v = edges[i][0];\\n                int w = edges[i][1];\\n                if (outdegree[w] - 1 != 0) {\\n                    res = edges[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean tryDeleteEdge(final int v, final int w, final int root, final Map<Integer, Set<Integer>> adjList) {\\n        final Set<Integer> visited = new HashSet<>();\\n        dfs(root, v, w, adjList, visited);\\n        return visited.size() == adjList.size();\\n    }\\n    \\n    private void dfs(int v, int from, int to, Map<Integer, Set<Integer>> adjList, Set<Integer> visited) {\\n        visited.add(v);\\n        for (final int adj : adjList.get(v)) {\\n            if (!visited.contains(adj) && (v != from || adj != to)) {\\n                dfs(adj, from, to, adjList, visited);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Tree with directed graph will only have ONE vertex has 0 indegree and non-one outdegree. \\n    // Other vertices will have exactly 1 indegree and 1 or 0 outdegree.\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // Tree will have n - 1 edges, and there is one more redundant edge.\\n        // So the number of vertices is the length of input edges\\n        final int n = edges.length;\\n        int[] indegree = new int[n + 1];\\n        int[] outdegree = new int[n + 1];\\n        final Map<Integer, Set<Integer>> adjList = new HashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            adjList.put(i, new HashSet<>());\\n        }\\n        int edgeTo = -1;\\n        for (final int[] edge : edges) {\\n            outdegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n            if (indegree[edge[1]] > 1) {\\n                edgeTo = edge[1];\\n            }\\n            adjList.get(edge[0]).add(edge[1]);\\n        }\\n        \\n        int[] res = null;\\n        if (edgeTo != -1) {\\n            int root = -1;\\n            for (int i = 1; i <= n; i++) {\\n                if (indegree[i] == 0) root = i;\\n            }\\n            \\n            for (int i = n - 1; i >= 0; i--) {\\n                if (edges[i][1] == edgeTo) {\\n                    if (tryDeleteEdge(edges[i][0], edges[i][1], root, adjList)) {\\n                        res = edges[i];\\n                        break;\\n                    }\\n                }\\n            }\\n        } else {\\n            for (int i = n - 1; i >= 0; i--) {\\n                int v = edges[i][0];\\n                int w = edges[i][1];\\n                if (outdegree[w] - 1 != 0) {\\n                    res = edges[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean tryDeleteEdge(final int v, final int w, final int root, final Map<Integer, Set<Integer>> adjList) {\\n        final Set<Integer> visited = new HashSet<>();\\n        dfs(root, v, w, adjList, visited);\\n        return visited.size() == adjList.size();\\n    }\\n    \\n    private void dfs(int v, int from, int to, Map<Integer, Set<Integer>> adjList, Set<Integer> visited) {\\n        visited.add(v);\\n        for (final int adj : adjList.get(v)) {\\n            if (!visited.contains(adj) && (v != from || adj != to)) {\\n                dfs(adj, from, to, adjList, visited);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199108,
                "title": "simple-not-union-find-scala-o-n",
                "content": "There is 2 possible cases:\\n1. One child (C) has 2 parents (A, B). It means we have to remove (A, C) or (B, C). In *rooted tree* A/B can be a sibling (or ancestor) of C, or be a child of C. Let\\'s suppose, that B goes after A. If we remove (B, C), and, after it, A is not a children of C (we did not remove (A, C)), then this graph is rooted. So we can delete (B, C). But if A is a child of C (and a parent the same time), the graph is not rooted, so we can\\'t delete (B, C), and must delete (A, C)\\n2. All nodes have 1 parent. It can be only if graph is a loop with rooted subgraphs growing from some loop nodes. In this case we can delete any edge from loop.\\n```\\n  import scala.collection.mutable.LinkedHashSet\\n  \\n  def findRedundantDirectedConnection(edges: Array[Array[Int]]): Array[Int] = {\\n    val (graph, parents, child) = // graph - array of parents. Only one node can have 2 parfents. we return it in parents and child\\n      ((Array.fill(edges.length)(Option.empty[Int]), Seq.empty[Int], Option.empty[Int]) /: edges) {\\n        case ((array, doubles, ch), edge) =>\\n          val (newParents, newChild) = array(edge.last - 1).map(v => (Seq(v, edge.head), Option(edge.last))).getOrElse((doubles, ch))\\n          array(edge.last-1) = Some(edge.head)\\n          (array, newParents, newChild)\\n      }\\n\\n    (parents, child) match {\\n      case (Seq(a1, a2), Some(c)) => // there is node with 2 parents\\n        graph(c-1) = Some(a1) // delete (a2, c) from graph\\n        if(!isChildOf(a1, c, graph)) // graph is rooted\\n          Array(a2, c) \\n        else // we have a loop\\n          Array(a1, c)\\n      case _ => // there is a loop\\n        val loop = getLoop(graph) // get the loop\\n        val l = (loop :+ loop.head).sliding(2).map(e => e.head -> e.last).toSet // transform it to set of edges\\n        val idx = edges.lastIndexWhere(e => l.contains((e.last, e.head))) // find the last edge\\n        edges(idx)\\n    }\\n  }\\n\\n  private def isChildOf(c: Int, p: Int, gr: Array[Option[Int]]): Boolean =\\n    if(c==p)\\n      true\\n    else\\n      gr(c-1) match {\\n        case Some(m) => isChildOf(m, p, gr)\\n        case _ => false\\n      }\\n// goes through the ancestors and keeps the path in res until it encounters a visited node\\n// it doesn\\'t matter which node to start from. I use 1 just because it is in every graph\\n  private def getLoop(gr: Array[Option[Int]], res: LinkedHashSet[Int] = new LinkedHashSet[Int], node: Int = 1): Seq[Int] =\\n    if (res.contains(node))\\n      res.dropWhile(node!=).toSeq\\n    else\\n      getLoop(gr, res+=node, gr(node-1).get)\\n```",
                "solutionTags": [],
                "code": "```\\n  import scala.collection.mutable.LinkedHashSet\\n  \\n  def findRedundantDirectedConnection(edges: Array[Array[Int]]): Array[Int] = {\\n    val (graph, parents, child) = // graph - array of parents. Only one node can have 2 parfents. we return it in parents and child\\n      ((Array.fill(edges.length)(Option.empty[Int]), Seq.empty[Int], Option.empty[Int]) /: edges) {\\n        case ((array, doubles, ch), edge) =>\\n          val (newParents, newChild) = array(edge.last - 1).map(v => (Seq(v, edge.head), Option(edge.last))).getOrElse((doubles, ch))\\n          array(edge.last-1) = Some(edge.head)\\n          (array, newParents, newChild)\\n      }\\n\\n    (parents, child) match {\\n      case (Seq(a1, a2), Some(c)) => // there is node with 2 parents\\n        graph(c-1) = Some(a1) // delete (a2, c) from graph\\n        if(!isChildOf(a1, c, graph)) // graph is rooted\\n          Array(a2, c) \\n        else // we have a loop\\n          Array(a1, c)\\n      case _ => // there is a loop\\n        val loop = getLoop(graph) // get the loop\\n        val l = (loop :+ loop.head).sliding(2).map(e => e.head -> e.last).toSet // transform it to set of edges\\n        val idx = edges.lastIndexWhere(e => l.contains((e.last, e.head))) // find the last edge\\n        edges(idx)\\n    }\\n  }\\n\\n  private def isChildOf(c: Int, p: Int, gr: Array[Option[Int]]): Boolean =\\n    if(c==p)\\n      true\\n    else\\n      gr(c-1) match {\\n        case Some(m) => isChildOf(m, p, gr)\\n        case _ => false\\n      }\\n// goes through the ancestors and keeps the path in res until it encounters a visited node\\n// it doesn\\'t matter which node to start from. I use 1 just because it is in every graph\\n  private def getLoop(gr: Array[Option[Int]], res: LinkedHashSet[Int] = new LinkedHashSet[Int], node: Int = 1): Seq[Int] =\\n    if (res.contains(node))\\n      res.dropWhile(node!=).toSeq\\n    else\\n      getLoop(gr, res+=node, gr(node-1).get)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189625,
                "title": "share-a-simple-union-find-resolution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> parents;\\n        int flag = -1;\\n        for(auto edge:edges){\\n            if(edge[0]==edge[1]) return edge;\\n            parents[edge[1]].push_back(edge[0]);\\n            if(parents[edge[1]].size()==2) flag = edge[1];\\n        }\\n        if(flag==-1){\\n            \\n            for(int i=(int)edges.size()-1;i>=0;--i){\\n                unordered_set<int> has_visited;\\n                int from = edges[i][0],to = edges[i][1];\\n                int p = from;\\n                \\n                while(parents.count(p)&&has_visited.count(p)==0){\\n                    has_visited.insert(p);\\n                    p = parents[p][0];\\n                    if(p==to) return edges[i];\\n                }\\n            }\\n            //return vector<int>({-1,-1});\\n        }\\n        else{\\n            int to = flag, from = parents[flag][1];\\n            int p = from;\\n            while(parents.count(p)){\\n                p = parents[p][0];\\n                if(p==flag) return vector<int>({from,to});\\n            }\\n            \\n            from = parents[flag][0];\\n            p = from;\\n            while(parents.count(p)){\\n                p = parents[p][0];\\n                if(p==flag) return vector<int>({from,to});\\n            }\\n            return vector<int>({parents[flag][1],flag});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> parents;\\n        int flag = -1;\\n        for(auto edge:edges){\\n            if(edge[0]==edge[1]) return edge;\\n            parents[edge[1]].push_back(edge[0]);\\n            if(parents[edge[1]].size()==2) flag = edge[1];\\n        }\\n        if(flag==-1){\\n            \\n            for(int i=(int)edges.size()-1;i>=0;--i){\\n                unordered_set<int> has_visited;\\n                int from = edges[i][0],to = edges[i][1];\\n                int p = from;\\n                \\n                while(parents.count(p)&&has_visited.count(p)==0){\\n                    has_visited.insert(p);\\n                    p = parents[p][0];\\n                    if(p==to) return edges[i];\\n                }\\n            }\\n            //return vector<int>({-1,-1});\\n        }\\n        else{\\n            int to = flag, from = parents[flag][1];\\n            int p = from;\\n            while(parents.count(p)){\\n                p = parents[p][0];\\n                if(p==flag) return vector<int>({from,to});\\n            }\\n            \\n            from = parents[flag][0];\\n            p = from;\\n            while(parents.count(p)){\\n                p = parents[p][0];\\n                if(p==flag) return vector<int>({from,to});\\n            }\\n            return vector<int>({parents[flag][1],flag});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188995,
                "title": "different-solution-using-topological-sort",
                "content": "```\\nfrom collections import defaultdict\\nimport copy\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        inTable = defaultdict(list)\\n        outTable = defaultdict(list)\\n        vertices = set()\\n        lastTwoIn = []\\n        for edge in edges :\\n            outTable[edge[0]].append(edge[1])\\n            inTable[edge[1]].append(edge[0])\\n            vertices.add(edge[0])\\n            vertices.add(edge[1])\\n            if len(inTable[edge[1]])>1 :\\n                lastTwoIn = edge\\n        heads = [v for v in vertices if not inTable[v]]\\n        inTableTemp = copy.deepcopy(inTable)\\n        for head in heads :\\n            for out in outTable[head] :\\n                inTable[out].remove(head)\\n                if not inTable[out] :\\n                    heads.append(out)\\n        last = []\\n        for edge in edges[::-1] :\\n            if edge[0] not in heads and edge[1] not in heads and outTable[edge[1]] :\\n                if not last :\\n                    last = edge\\n                if len(inTableTemp[edge[1]])>1 :\\n                    return edge\\n        if last : \\n            return last\\n        else :\\n            return lastTwoIn\\n```\\nThis is not a very efficient solution. I just want to provide some different ideas.",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nimport copy\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        inTable = defaultdict(list)\\n        outTable = defaultdict(list)\\n        vertices = set()\\n        lastTwoIn = []\\n        for edge in edges :\\n            outTable[edge[0]].append(edge[1])\\n            inTable[edge[1]].append(edge[0])\\n            vertices.add(edge[0])\\n            vertices.add(edge[1])\\n            if len(inTable[edge[1]])>1 :\\n                lastTwoIn = edge\\n        heads = [v for v in vertices if not inTable[v]]\\n        inTableTemp = copy.deepcopy(inTable)\\n        for head in heads :\\n            for out in outTable[head] :\\n                inTable[out].remove(head)\\n                if not inTable[out] :\\n                    heads.append(out)\\n        last = []\\n        for edge in edges[::-1] :\\n            if edge[0] not in heads and edge[1] not in heads and outTable[edge[1]] :\\n                if not last :\\n                    last = edge\\n                if len(inTableTemp[edge[1]])>1 :\\n                    return edge\\n        if last : \\n            return last\\n        else :\\n            return lastTwoIn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186367,
                "title": "python-short-readable",
                "content": "All the credit goes to great logic in this post => https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C++Java-Union-Find-with-explanation-O(n)\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        def root(i):\\n            return parent[i] == i and i or root(parent[i])\\n        \\n        parent, a, b, c = [0] * (len(edges) + 1), None, None, None\\n        for i, edge in enumerate(edges):\\n            if parent[edge[1]]: \\n                a, b, c, edges[i][0]= parent[edge[1]], edge[0], edge[1], 0\\n            else:\\n                parent[edge[1]] = edge[0]\\n        \\n        parent = [i for i in range(len(edges) + 1)]\\n        for u, v in edges:\\n            if u:\\n                if root(u) == v: \\n                    return a and [a, c] or [u, v]\\n                parent[v] = u   \\n        return [b, c]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        def root(i):\\n            return parent[i] == i and i or root(parent[i])\\n        \\n        parent, a, b, c = [0] * (len(edges) + 1), None, None, None\\n        for i, edge in enumerate(edges):\\n            if parent[edge[1]]: \\n                a, b, c, edges[i][0]= parent[edge[1]], edge[0], edge[1], 0\\n            else:\\n                parent[edge[1]] = edge[0]\\n        \\n        parent = [i for i in range(len(edges) + 1)]\\n        for u, v in edges:\\n            if u:\\n                if root(u) == v: \\n                    return a and [a, c] or [u, v]\\n                parent[v] = u   \\n        return [b, c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168959,
                "title": "union-find-solution-with-optimization-beats-100-explanation-included",
                "content": "```\\nclass Solution {\\n    private int[] father;\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        /* Tree with n nodes has exactly n-1 edges(every node possess exactly one parent node except the root node)\\n            Here we have one additional Edges Added, \\n            so edges.lenth == n\\n        */\\n        int n = edges.length;\\n        \\n        father = new int[n+1];\\n        /* Union & Find With Optimization */\\n        // 1. Locate the Node with Two Direct Parents\\n        for(int[] E : edges){\\n            if(father[E[1]] != 0){\\n                int[] edge1 = new int[]{father[E[1]], E[1]};\\n                int[] edge2 = E;\\n                // Later First\\n                if(ifTreeWithOutAnEdge(edges, edge2)){\\n                    return edge2;\\n                }\\n                if(ifTreeWithOutAnEdge(edges, edge1)){\\n                    return edge1;\\n                }\\n            }\\n            else father[E[1]] = E[0];\\n        }\\n        \\n        // 2. Extra Edge is Target at Root Node, Then There is Root Within, Found The Reduandancy Edge\\n        \\n        for(int i=0; i<=edges.length; i++)father[i] = i;\\n\\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(!union(u, v))return edges[i];\\n        }\\n        return null;\\n    }\\n    \\n    private boolean ifTreeWithOutAnEdge(int[][] edges, int[] edge){\\n        // Initialization\\n        for(int i=0; i<=edges.length; i++)father[i] = i;\\n\\n        for(int i=0; i<edges.length; i++){\\n            if(edges[i][0] == edge[0] && edges[i][1] == edge[1])continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(!union(u, v))return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    /* Approach: Union & Find */\\n    public int find(int cur){\\n        // No Path Compression\\n        if(father[cur] == cur)return cur;\\n        return find(father[cur]);\\n    }\\n    \\n    /* Union with Order, (u, v) => u -> v, v\\'s father is u */\\n    public boolean union(int u, int v){\\n        int uP = find(u);\\n        int vP = find(v);\\n        \\n        if(vP != v)return false; // A Node Cann\\'t Have Multiple Direct Father\\n        if(uP == vP)return false; // Redundancy Found\\n        else{\\n            father[vP] = uP;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] father;\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        /* Tree with n nodes has exactly n-1 edges(every node possess exactly one parent node except the root node)\\n            Here we have one additional Edges Added, \\n            so edges.lenth == n\\n        */\\n        int n = edges.length;\\n        \\n        father = new int[n+1];\\n        /* Union & Find With Optimization */\\n        // 1. Locate the Node with Two Direct Parents\\n        for(int[] E : edges){\\n            if(father[E[1]] != 0){\\n                int[] edge1 = new int[]{father[E[1]], E[1]};\\n                int[] edge2 = E;\\n                // Later First\\n                if(ifTreeWithOutAnEdge(edges, edge2)){\\n                    return edge2;\\n                }\\n                if(ifTreeWithOutAnEdge(edges, edge1)){\\n                    return edge1;\\n                }\\n            }\\n            else father[E[1]] = E[0];\\n        }\\n        \\n        // 2. Extra Edge is Target at Root Node, Then There is Root Within, Found The Reduandancy Edge\\n        \\n        for(int i=0; i<=edges.length; i++)father[i] = i;\\n\\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(!union(u, v))return edges[i];\\n        }\\n        return null;\\n    }\\n    \\n    private boolean ifTreeWithOutAnEdge(int[][] edges, int[] edge){\\n        // Initialization\\n        for(int i=0; i<=edges.length; i++)father[i] = i;\\n\\n        for(int i=0; i<edges.length; i++){\\n            if(edges[i][0] == edge[0] && edges[i][1] == edge[1])continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(!union(u, v))return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    /* Approach: Union & Find */\\n    public int find(int cur){\\n        // No Path Compression\\n        if(father[cur] == cur)return cur;\\n        return find(father[cur]);\\n    }\\n    \\n    /* Union with Order, (u, v) => u -> v, v\\'s father is u */\\n    public boolean union(int u, int v){\\n        int uP = find(u);\\n        int vP = find(v);\\n        \\n        if(vP != v)return false; // A Node Cann\\'t Have Multiple Direct Father\\n        if(uP == vP)return false; // Redundancy Found\\n        else{\\n            father[vP] = uP;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163560,
                "title": "python3-o-n-solution-by-finding-root-no-dfs-or-bfs",
                "content": "The insight here is that there are two possibilities:\\n1. There is a node with no incoming edge: the **root**. In that case there will be another node(**child**) with two parents. If the first parent (by edge order) continues back to the **child**, that is a cycle and that edge must go away. Otherwise we detach it from the second parent.\\n2. There is no **root** (node without a parent). That means the root lies on a cycle. We can start at any node and by following the parents we reach this cycle. Once we store all nodes on the root cycle (**rc** variable), we remove the last edge to break it.\\n\\n```python\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        nodes = set()\\n        for e in edges:\\n            nodes |= set(e)\\n        parents = {n: [] for n in nodes}\\n        root = set(nodes)\\n        for u, v in edges:\\n            parents[v].append(u)\\n            root.discard(v)\\n\\n        if root:\\n            root = root.pop()\\n            two_candidates = [e for e in edges if len(parents[e[1]]) > 1]\\n            child = two_candidates[0][1]\\n            parent = two_candidates[0][0]\\n            while parent != root:\\n                if parent == child:\\n                    return two_candidates[0]\\n                parent = parents[parent][0]\\n            return two_candidates[1]\\n        else: # root cycle\\n            rc = [nodes.pop()]\\n            while True:\\n                parent = parents[rc[-1]][0]\\n                if parent in rc:\\n                    rc = set(rc[rc.index(parent):])\\n                    break\\n                else:\\n                    rc.append(parent)\\n            for u, v in edges:\\n                rc.discard(v)\\n                if len(rc) == 1:\\n                    root = rc.pop()\\n                    return [parents[root][0], root]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        nodes = set()\\n        for e in edges:\\n            nodes |= set(e)\\n        parents = {n: [] for n in nodes}\\n        root = set(nodes)\\n        for u, v in edges:\\n            parents[v].append(u)\\n            root.discard(v)\\n\\n        if root:\\n            root = root.pop()\\n            two_candidates = [e for e in edges if len(parents[e[1]]) > 1]\\n            child = two_candidates[0][1]\\n            parent = two_candidates[0][0]\\n            while parent != root:\\n                if parent == child:\\n                    return two_candidates[0]\\n                parent = parents[parent][0]\\n            return two_candidates[1]\\n        else: # root cycle\\n            rc = [nodes.pop()]\\n            while True:\\n                parent = parents[rc[-1]][0]\\n                if parent in rc:\\n                    rc = set(rc[rc.index(parent):])\\n                    break\\n                else:\\n                    rc.append(parent)\\n            for u, v in edges:\\n                rc.discard(v)\\n                if len(rc) == 1:\\n                    root = rc.pop()\\n                    return [parents[root][0], root]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158852,
                "title": "solution-for-redundant-connection-ii-that-builds-on-top-of-redundant-connection-i",
                "content": "class Solution {\\n    // How is this question different from RC-I question?\\n    // In this question we have more rules about what a valid tree is\\n    // a valid tree should contain nodes which have only a single parent \\n    // a valid tree should also not contain any cycles\\n    // Step 1: we check for nodes that contain multiple parents\\n    // Step 2: we store two edges that point to invalid node and we set one of the edges to 0 (to invalidate the edge)\\n    // Step 3: we iterate through edges and see if its valid, if valid the edge we set to 0 is the culprit we return that otherwise if first edge is not empty we return that otherwise we return the current edge(there can be cases where a tree can just contain a invalid node which causes a cycle and doesn\\'t have multiple parents)\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        DisjointSet ds = new DisjointSet(edges.length);\\n        int[] parents = new int[edges.length+1];\\n        int[] nodeA = {-1,-1};\\n        int[] nodeB = {-1,-1};\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(parents[edges[i][1]] == 0)\\n            {\\n                parents[edges[i][1]] = edges[i][0];\\n            }\\n            else\\n            {\\n                nodeB = new int[] { edges[i][0], edges[i][1] };\\n                nodeA = new int[] { parents[edges[i][1]], edges[i][1] };\\n                edges[i][1] = 0;\\n            }\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(edges[i][1] == 0) continue;\\n            if(ds.find(edges[i][0]-1) == ds.find(edges[i][1]-1))\\n            {\\n                if(nodeA[0] != -1)\\n                {\\n                    return nodeA;\\n                }\\n                else\\n                {\\n                    return edges[i];\\n                }\\n            }\\n            else\\n            {\\n                ds.union(edges[i][0]-1,edges[i][1]-1);\\n            }\\n        }\\n        return nodeB;\\n    }\\n    \\n    class DisjointSet\\n    {\\n        int[] parents;\\n        \\n        public DisjointSet(int n)\\n        {\\n            parents = new int[n];\\n            for(int i=0;i<n;i++)\\n            {\\n                parents[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a,int b)\\n        {\\n            int rootA = parents[a];\\n            int rootB = parents[b];\\n            parents[rootA] = rootB;\\n        }\\n        \\n        public int find(int x)\\n        {\\n            while(x != parents[x])\\n            {\\n                x = parents[x];\\n            }\\n            return x;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // How is this question different from RC-I question?\\n    // In this question we have more rules about what a valid tree is\\n    // a valid tree should contain nodes which have only a single parent \\n    // a valid tree should also not contain any cycles\\n    // Step 1: we check for nodes that contain multiple parents\\n    // Step 2: we store two edges that point to invalid node and we set one of the edges to 0 (to invalidate the edge)\\n    // Step 3: we iterate through edges and see if its valid, if valid the edge we set to 0 is the culprit we return that otherwise if first edge is not empty we return that otherwise we return the current edge(there can be cases where a tree can just contain a invalid node which causes a cycle and doesn\\'t have multiple parents)\\n    \\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        DisjointSet ds = new DisjointSet(edges.length);\\n        int[] parents = new int[edges.length+1];\\n        int[] nodeA = {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 108059,
                "title": "explained-in-detail-my-java-solution-cosidering-two-topologies-using-union-find",
                "content": "The basic idea is still union find as in Redundant Connection I. However, as it is now `DAG`, we cannot simply remove an edge as we detect it may result in union of the visited group. BECAUSE, removing an edge might lead t:\\n1. a new root node is created, making it no tree any more\\n2. split the tree and turn it into forests\\n\\nThe problem description said only one extra edge is added. Therefore, the graph has the relation `E = V`, which means \\n1. All nodes have one input edge\\n2. Or, one node has two input edges.\\n\\nThen it is much simpler. In case 1, we just need to do a regular union find as we did in Redundant Connection I.\\n\\nIn case 2, firstly, identify the problematic node with two input edges. Then use union find in a regular way, skipping those edges pointing to our problematic node. `This is important, as the problematic edges might create trouble during our union process`. An example is `1->2, 2->4, 3->2, 4->3`. Union find would remove `4->3` while the correct answer should be `3->2`.\\n\\nAfter all other edges are executed union process, we can do our problematic edges in order and found out the extra one.\\n\\nCase 1 and 2 are easy to be combined together, as shown in my code below.\\n\\n```\\nclass Solution {\\n    private int N; // Node number\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // Count how many nodes\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] edge : edges) {\\n            set.add(edge[0]);\\n            set.add(edge[1]);\\n        }\\n        N = set.size();\\n        \\n        int[] count = new int[N + 1];\\n        int node = 0;\\n        // Calculate input counts\\n        for (int[] edge : edges) {\\n            // Record problematic node\\n            if (++count[edge[1]] == 2) node = edge[1];\\n        }\\n        \\n        // No problematic node, just normal union find is enough\\n        return findHelper(edges, node);\\n    }\\n    \\n    public int[] findHelper(int[][] edges, int node) {\\n        int[] relation = new int[N + 1];\\n        // Pending Edges need to decide which to remove\\n        Queue<int[]> pendingEdges = new ArrayDeque<>();\\n        for (int i = 0; i < relation.length; i++) {\\n            relation[i] = i;\\n        }\\n        for (int[] edge : edges) {\\n            if (edge[1] == node) {\\n                pendingEdges.add(edge);\\n                // No need to union now\\n                continue;\\n            }\\n            if (union(relation, edge[0], edge[1])) {\\n                return edge;\\n            }\\n        }\\n        // Execute the pending edges at last\\n        while (!pendingEdges.isEmpty()) {\\n            int[] edge = pendingEdges.poll();\\n            if (union(relation, edge[0], edge[1])) {\\n                return edge;\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    private boolean union(int[] relation, int p, int q) {\\n        int pRoot = findRoot(relation, p);\\n        int qRoot = findRoot(relation, q);\\n        if (pRoot == qRoot) return true;\\n        relation[qRoot] = pRoot;\\n        return false;\\n    }\\n    \\n    private int findRoot(int[] relation, int p) {\\n        while (p != relation[p]) {\\n            relation[p] = relation[relation[p]];\\n            p = relation[p];\\n        }\\n        return p;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int N; // Node number\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        // Count how many nodes\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] edge : edges) {\\n            set.add(edge[0]);\\n            set.add(edge[1]);\\n        }\\n        N = set.size();\\n        \\n        int[] count = new int[N + 1];\\n        int node = 0;\\n        // Calculate input counts\\n        for (int[] edge : edges) {\\n            // Record problematic node\\n            if (++count[edge[1]] == 2) node = edge[1];\\n        }\\n        \\n        // No problematic node, just normal union find is enough\\n        return findHelper(edges, node);\\n    }\\n    \\n    public int[] findHelper(int[][] edges, int node) {\\n        int[] relation = new int[N + 1];\\n        // Pending Edges need to decide which to remove\\n        Queue<int[]> pendingEdges = new ArrayDeque<>();\\n        for (int i = 0; i < relation.length; i++) {\\n            relation[i] = i;\\n        }\\n        for (int[] edge : edges) {\\n            if (edge[1] == node) {\\n                pendingEdges.add(edge);\\n                // No need to union now\\n                continue;\\n            }\\n            if (union(relation, edge[0], edge[1])) {\\n                return edge;\\n            }\\n        }\\n        // Execute the pending edges at last\\n        while (!pendingEdges.isEmpty()) {\\n            int[] edge = pendingEdges.poll();\\n            if (union(relation, edge[0], edge[1])) {\\n                return edge;\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    private boolean union(int[] relation, int p, int q) {\\n        int pRoot = findRoot(relation, p);\\n        int qRoot = findRoot(relation, q);\\n        if (pRoot == qRoot) return true;\\n        relation[qRoot] = pRoot;\\n        return false;\\n    }\\n    \\n    private int findRoot(int[] relation, int p) {\\n        while (p != relation[p]) {\\n            relation[p] = relation[relation[p]];\\n            p = relation[p];\\n        }\\n        return p;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099362,
                "title": "o-n-time-complexity-using-dsu-and-indegree-with-comments-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nA node has two parents if the indegree of the node is 2.\\n\\nSo ,if there is node with indegree 2. since it is mentioned in the question that there will be only one extra edge So there will be only one node with indegree 2.\\n\\nNow, we need to find edge that is coming towards node with indegree 2.\\nbeacuse any one edge among both of these edges is going to be the extra edge.\\n\\nThat extra edge we can find using DSU. \\n\\nAlthough The DSU is used only for undirected graph but we can use it here because we are sure that there will be cycle.\\n\\n\\nIF there is no node having indegree two it means there must be a cycle in graph and since we are sure about it then we can use DSU to detect cycle.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    class DSU {\\n\\n    private:\\n   \\n        int parent[1001];\\n        int rank[1001];\\n   \\n    public:\\n        \\n        DSU(int n) {\\n            \\n            for(int i = 0; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n\\n        }\\n\\n        int ultparent(int node) {\\n            if(parent[node] == node) return node;\\n            return parent[node] = ultparent(parent[node]);\\n        }\\n\\n        bool connected(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return true;\\n            else return false;\\n\\n        }\\n\\n        void unionbyrank(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return;\\n            else {\\n                if(rank[parent1] < rank[parent2]) {\\n                    parent[parent1] = parent2;\\n                } else if(rank[parent1] > rank[parent2]) {\\n                    parent[parent2] = parent1;\\n                } else {\\n                    parent[parent1] = parent2;\\n                    rank[parent2]++;\\n                }\\n            }\\n\\n        }\\n\\n    };\\n\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        int n = edges.size();\\n        int nodeindegree2 = -1;\\n\\n        int indegree[n + 1];\\n\\n        for(int i = 0; i <= n; i++) {\\n            indegree[i] = 0; \\n        }\\n\\n        //trying to find node with indegree 2\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            indegree[v]++;\\n\\n            if(indegree[v] == 2) {\\n                nodeindegree2 = v;\\n            }\\n\\n        }\\n\\n        //It means there that there is no node having indegree 2\\n\\n        if(nodeindegree2 == -1) {\\n            \\n            //there must be a cycle\\n\\n            DSU graph(n);\\n\\n            for(int i = 0; i < n; i++) {\\n                \\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n\\n                if(graph.connected(u, v)) {\\n                    return {u, v};\\n                } else {\\n                    graph.unionbyrank(u, v);\\n                }\\n            }\\n\\n    \\n        }\\n\\n        // trying to find two edges that are coming towards the node having indegree 2\\n\\n        int edgewithind1 = -1;\\n        int edgewithind2 = -1;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(indegree[v] == 2) {\\n                if(edgewithind1 == -1) {\\n                    edgewithind1 = i;\\n                } else {\\n                    edgewithind2 = i;\\n                }\\n            }\\n        }\\n\\n        //removing edge2 to check is it the extra edge\\n\\n        // why edge2 first because if both edge1 and edge2 are in the cycle then i need to remove that edge which is coming in the last\\n\\n        DSU graph(n);\\n\\n        bool stillcycle = false;\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(i == edgewithind2) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(graph.connected(u, v)) {\\n                stillcycle = true;\\n            } else {\\n                graph.unionbyrank(u, v);\\n            }\\n\\n        }\\n\\n        if(!stillcycle) {\\n            return {edges[edgewithind2][0], edges[edgewithind2][1]};\\n        }\\n\\n\\n        return { edges[edgewithind1][0], edges[edgewithind1][1] };\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    class DSU {\\n\\n    private:\\n   \\n        int parent[1001];\\n        int rank[1001];\\n   \\n    public:\\n        \\n        DSU(int n) {\\n            \\n            for(int i = 0; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n\\n        }\\n\\n        int ultparent(int node) {\\n            if(parent[node] == node) return node;\\n            return parent[node] = ultparent(parent[node]);\\n        }\\n\\n        bool connected(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return true;\\n            else return false;\\n\\n        }\\n\\n        void unionbyrank(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return;\\n            else {\\n                if(rank[parent1] < rank[parent2]) {\\n                    parent[parent1] = parent2;\\n                } else if(rank[parent1] > rank[parent2]) {\\n                    parent[parent2] = parent1;\\n                } else {\\n                    parent[parent1] = parent2;\\n                    rank[parent2]++;\\n                }\\n            }\\n\\n        }\\n\\n    };\\n\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        \\n        int n = edges.size();\\n        int nodeindegree2 = -1;\\n\\n        int indegree[n + 1];\\n\\n        for(int i = 0; i <= n; i++) {\\n            indegree[i] = 0; \\n        }\\n\\n        //trying to find node with indegree 2\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            indegree[v]++;\\n\\n            if(indegree[v] == 2) {\\n                nodeindegree2 = v;\\n            }\\n\\n        }\\n\\n        //It means there that there is no node having indegree 2\\n\\n        if(nodeindegree2 == -1) {\\n            \\n            //there must be a cycle\\n\\n            DSU graph(n);\\n\\n            for(int i = 0; i < n; i++) {\\n                \\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n\\n                if(graph.connected(u, v)) {\\n                    return {u, v};\\n                } else {\\n                    graph.unionbyrank(u, v);\\n                }\\n            }\\n\\n    \\n        }\\n\\n        // trying to find two edges that are coming towards the node having indegree 2\\n\\n        int edgewithind1 = -1;\\n        int edgewithind2 = -1;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(indegree[v] == 2) {\\n                if(edgewithind1 == -1) {\\n                    edgewithind1 = i;\\n                } else {\\n                    edgewithind2 = i;\\n                }\\n            }\\n        }\\n\\n        //removing edge2 to check is it the extra edge\\n\\n        // why edge2 first because if both edge1 and edge2 are in the cycle then i need to remove that edge which is coming in the last\\n\\n        DSU graph(n);\\n\\n        bool stillcycle = false;\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(i == edgewithind2) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(graph.connected(u, v)) {\\n                stillcycle = true;\\n            } else {\\n                graph.unionbyrank(u, v);\\n            }\\n\\n        }\\n\\n        if(!stillcycle) {\\n            return {edges[edgewithind2][0], edges[edgewithind2][1]};\\n        }\\n\\n\\n        return { edges[edgewithind1][0], edges[edgewithind1][1] };\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098726,
                "title": "o-n-2-approach-using-dsu-and-indegree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    class DSU {\\n\\n    private:\\n   \\n        int parent[1001];\\n        int rank[1001];\\n   \\n    public:\\n        \\n        DSU(int n) {\\n            \\n            for(int i = 0; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n\\n        }\\n\\n        int ultparent(int node) {\\n            if(parent[node] == node) return node;\\n            return parent[node] = ultparent(parent[node]);\\n        }\\n\\n        bool connected(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return true;\\n            else return false;\\n\\n        }\\n\\n        void unionbyrank(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return;\\n            else {\\n                if(rank[parent1] < rank[parent2]) {\\n                    parent[parent1] = parent2;\\n                } else if(rank[parent1] > rank[parent2]) {\\n                    parent[parent2] = parent1;\\n                } else {\\n                    parent[parent1] = parent2;\\n                    rank[parent2]++;\\n                }\\n            }\\n\\n        }\\n\\n    };\\n\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\n        vector<int>ans;\\n\\n        for(int j = edges.size() - 1; j >= 0; j--) {\\n             \\n             DSU graph(edges.size());\\n\\n             int indegree[edges.size() + 1];\\n\\n             for(int i = 0; i <= edges.size(); i++) {\\n                 indegree[i] = 0;\\n             }\\n\\n             bool cycle = false;\\n             bool indegree2 = false;\\n\\n             for(int i = 0; i < edges.size(); i++) {\\n                 \\n                 if(j == i) continue;\\n\\n                 else {\\n                     \\n                     int u = edges[i][0];\\n                     int v = edges[i][1];\\n\\n                     indegree[v]++;\\n\\n                     if(indegree[v] == 2) {\\n                         indegree2 = true;\\n                     }\\n\\n                     if(graph.connected(u, v)) {\\n                         cycle = true;\\n                     } else {\\n                         graph.unionbyrank(u, v);\\n                     }\\n\\n                 }\\n             }\\n\\n             if(cycle == false && indegree2 == false) {\\n                 ans.push_back(edges[j][0]);\\n                 ans.push_back(edges[j][1]);\\n                 break;\\n             }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    class DSU {\\n\\n    private:\\n   \\n        int parent[1001];\\n        int rank[1001];\\n   \\n    public:\\n        \\n        DSU(int n) {\\n            \\n            for(int i = 0; i < n + 1; i++) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n\\n        }\\n\\n        int ultparent(int node) {\\n            if(parent[node] == node) return node;\\n            return parent[node] = ultparent(parent[node]);\\n        }\\n\\n        bool connected(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return true;\\n            else return false;\\n\\n        }\\n\\n        void unionbyrank(int node1, int node2) {\\n            \\n            int parent1 = ultparent(node1);\\n            int parent2 = ultparent(node2);\\n\\n            if(parent1 == parent2) return;\\n            else {\\n                if(rank[parent1] < rank[parent2]) {\\n                    parent[parent1] = parent2;\\n                } else if(rank[parent1] > rank[parent2]) {\\n                    parent[parent2] = parent1;\\n                } else {\\n                    parent[parent1] = parent2;\\n                    rank[parent2]++;\\n                }\\n            }\\n\\n        }\\n\\n    };\\n\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n\\n        vector<int>ans;\\n\\n        for(int j = edges.size() - 1; j >= 0; j--) {\\n             \\n             DSU graph(edges.size());\\n\\n             int indegree[edges.size() + 1];\\n\\n             for(int i = 0; i <= edges.size(); i++) {\\n                 indegree[i] = 0;\\n             }\\n\\n             bool cycle = false;\\n             bool indegree2 = false;\\n\\n             for(int i = 0; i < edges.size(); i++) {\\n                 \\n                 if(j == i) continue;\\n\\n                 else {\\n                     \\n                     int u = edges[i][0];\\n                     int v = edges[i][1];\\n\\n                     indegree[v]++;\\n\\n                     if(indegree[v] == 2) {\\n                         indegree2 = true;\\n                     }\\n\\n                     if(graph.connected(u, v)) {\\n                         cycle = true;\\n                     } else {\\n                         graph.unionbyrank(u, v);\\n                     }\\n\\n                 }\\n             }\\n\\n             if(cycle == false && indegree2 == false) {\\n                 ans.push_back(edges[j][0]);\\n                 ans.push_back(edges[j][1]);\\n                 break;\\n             }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092122,
                "title": "python-topological-sort-solution-with-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, there are two cases to determine the redundant edge:\\ncase 1: One node has two parents :: **a -> b <- c**\\ncase 2: There exists a cycle :: **a -> b -> c -> a**\\n\\nNow, we are using topological sort to check the circle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(1) To check case 2, we have to remove the single chain from top to the circle and circle to the leafs.\\n**a -> b -> c -> Circle -> d -> e**  \\n\\nSo we need to record the indegree and outdegree to traversal from **e** and from **a**.\\nAlso maintains visit[n] to record the removing edges, then remaining edges form a circle. \\n\\n(2) To check case 1, we can simply find a node with indegree == 2.\\n\\n(3) \\n```\\nif (case 1):\\n    if (case 2):\\n        return the edge to the node which is in the circle\\n    else:\\n        return the lastset edge add to the node \\nelif (case 2):\\n    return the lastset edge add to the graph which is in the circle\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # topology sort\\n        n = len(edges)\\n        adj = [[] for _ in range(n)]\\n        # [idg, odg]\\n        deg = [[0, 0] for _ in range(n)]\\n        case = -1\\n        for i, (a, b) in enumerate(edges):\\n            a, b = a - 1, b - 1\\n            adj[a].append((b, i, 0))\\n            adj[b].append((a, i, 1))\\n            deg[b][0] += 1\\n            deg[a][1] += 1\\n            # critical case  1 -> 2 <- 3\\n            if deg[b][0] == 2:\\n                case = b\\n\\n        #   check cycle => remove single chain\\n        #   1 -> 2 -> ... odg == 1 && idg == 0\\n        #   1 <- 2 <- ... odg == 0 && idg == 1\\n        vis = [False] * n\\n        check = lambda x: (deg[x][0] + deg[x][1] == 1)\\n        q = [i for i in range(n) if check(i)]\\n        while q:\\n            i = q.pop()\\n            deg[i][1] = -1000\\n            for j, e, v in adj[i]:\\n                deg[j][v] -= 1\\n                vis[e] = True\\n                if check(j):\\n                    q.append(j)\\n        # case 1\\n        if case >= 0:\\n            ans = 0\\n            for _, e, v in adj[case]:\\n                if v == 0: continue\\n                if not vis[e]:\\n                    ans = max(ans, e)\\n            return edges[ans]\\n\\n        # case 2\\n        for i in range(n - 1, -1, -1):\\n            if not vis[i]:\\n                return edges[i]\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nif (case 1):\\n    if (case 2):\\n        return the edge to the node which is in the circle\\n    else:\\n        return the lastset edge add to the node \\nelif (case 2):\\n    return the lastset edge add to the graph which is in the circle\\n```\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # topology sort\\n        n = len(edges)\\n        adj = [[] for _ in range(n)]\\n        # [idg, odg]\\n        deg = [[0, 0] for _ in range(n)]\\n        case = -1\\n        for i, (a, b) in enumerate(edges):\\n            a, b = a - 1, b - 1\\n            adj[a].append((b, i, 0))\\n            adj[b].append((a, i, 1))\\n            deg[b][0] += 1\\n            deg[a][1] += 1\\n            # critical case  1 -> 2 <- 3\\n            if deg[b][0] == 2:\\n                case = b\\n\\n        #   check cycle => remove single chain\\n        #   1 -> 2 -> ... odg == 1 && idg == 0\\n        #   1 <- 2 <- ... odg == 0 && idg == 1\\n        vis = [False] * n\\n        check = lambda x: (deg[x][0] + deg[x][1] == 1)\\n        q = [i for i in range(n) if check(i)]\\n        while q:\\n            i = q.pop()\\n            deg[i][1] = -1000\\n            for j, e, v in adj[i]:\\n                deg[j][v] -= 1\\n                vis[e] = True\\n                if check(j):\\n                    q.append(j)\\n        # case 1\\n        if case >= 0:\\n            ans = 0\\n            for _, e, v in adj[case]:\\n                if v == 0: continue\\n                if not vis[e]:\\n                    ans = max(ans, e)\\n            return edges[ans]\\n\\n        # case 2\\n        for i in range(n - 1, -1, -1):\\n            if not vis[i]:\\n                return edges[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090493,
                "title": "very-detailed-explanation-why-and-how-union-find-python",
                "content": "# Consider following graphs :\\n- [[1,2] , [2,3] , [1,4] , [3,4]]\\n- [[1,2] , [2,3] , [3,4] , [4,1]]\\n- [[2,1] , [2,3] , [3,4] , [4,5] , [5,3]]\\n- [[1,2] , [1,5] , [2,3] , [3,4] , [3,5]]\\n- [[1,2] , [1,3] , [3,4] , [4,5] , [5,1]]\\n- [[1,2] , [3,2]]\\n\\n# Intuition\\nIt is given that there is an extra edge . So , without that extra edge the graph would have been a rooted tree (let\\'s say n vertices) which means indegree of n-1 vetices would be 1 and root\\'s indegree would be 0 . Adding an extra edge will cause either the increase of indegree of root by 1 or some other vertex\\'s indegree will increase by 1 . \\n\\n# Approach ( Using Union Find )\\nIn the case where every vertex\\'s indegree is 1 , the graph must have a cycle . We can use Union Find Algo to find it . ( Although we can use union find algo on undirected graph only , here code is written in such a way that union find will function , ***read bold part below in Understanding Code section*** )\\n\\nIn the case where 1 vertex has ***0*** indegree , one has ***2*** degree and others have ***1*** indegree , the answer has to be one of the edge which is causing indegree as ***2*** . Lets call them candidate edges .\\nIn this case we can either have a cycle or we wont have a cycle . \\nIn case where we will have a cycle both the candidate edges can\\'t be in the cycle . \\n\\n\\n# Understanding Code \\n\\nWe initalize cand1 and cand2 (candidate edges) as *None* and then run through the edge list . if we find an edge which points to the same vertex again which was already pointed before then cand1 and cand2 will be populated in the order of appearance in list *edges* . \\n\\n\\nNow , we start making graph and start checking if the edge ends up  making a cycle . While making graph we do not include edge cand2 ,  we skip it . Why do we skip it ? To make union find algo work . ***We know that Union find only works if graph is undirected . If we use it on directed graph the it will give false positive , eg : [[1,2] , [2,3] , [3,4] , [1,4]] . And if a false positive exists both cand1 and cand2 will be in the same false cycle . And we already for real cycle to exist both cand1 and cand2 can be present in the cycle .  So if we skip cand2 we know we will never encounter the false positive/cycle .***\\n\\nWith the above understanding , lets see the code again :- \\n\\n1. If cand1 and cand2 are none , all edges will be used to create graph . In this case graph must have a real cycle and union find will give the answer . \\n\\n2. If cand1 and cand2 is present , cand2 will not be used to create graph . Graph created can have a cycle or not . If cycle is found then cand1 is the answer . ( Remember if real cycle is present in graph both cand1 and cand2 can be part of that and if we get a cycle without using cand2 then we need to remove cand1 to have a tree , hence cand1 being the answer ) . \\nIf after considering all edges except cand2 , cycle is not formed , then it tells us possibiity of 2 situations :- \\n    1) *( False Positive Case )* Both cand1 and cand2 can be the answers , hence cand2 being the final answer as it appeared last . **eg :  [[1,2] , [2,3] , [3,4] , [1,5] , [3,5]]** \\n    2) No Real/False cycle present . **eg : [[1,2] , [3,2]]** \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\n        def findParent(parent , u) :\\n            if parent[u] == u : \\n                return u \\n            return findParent(parent , parent[u])\\n\\n        n = len(edges) \\n        parent = [i for i in range(n+1)] \\n        cand1 , cand2 , visited = None , None , {}\\n        for x, y in edges :\\n            if y in visited :\\n                cand1,cand2 = visited[y] , [x,y]\\n                break \\n            visited[y] = [x,y]\\n        \\n        for x,y in edges :\\n            if [x,y] == cand2 : continue \\n            a = findParent(parent , x) \\n            b = findParent(parent , y) \\n\\n            if(a == b) :\\n                if cand1 : return cand1 \\n                return [x,y]\\n            parent[b] = a\\n        return cand2\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n\\n        def findParent(parent , u) :\\n            if parent[u] == u : \\n                return u \\n            return findParent(parent , parent[u])\\n\\n        n = len(edges) \\n        parent = [i for i in range(n+1)] \\n        cand1 , cand2 , visited = None , None , {}\\n        for x, y in edges :\\n            if y in visited :\\n                cand1,cand2 = visited[y] , [x,y]\\n                break \\n            visited[y] = [x,y]\\n        \\n        for x,y in edges :\\n            if [x,y] == cand2 : continue \\n            a = findParent(parent , x) \\n            b = findParent(parent , y) \\n\\n            if(a == b) :\\n                if cand1 : return cand1 \\n                return [x,y]\\n            parent[b] = a\\n        return cand2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088731,
                "title": "c-disjoint-set-method-neat-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will be using 2 intuition and complete approach from this Youtube video -> <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/d0tqBMRZ6UQ?si=d3rc7D1laoeJ_5lp\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\nHe explained all 3 cases perfectly and how to solve each one of them individually.\\n\\nI will use Strivers Disjoint Set code template which helps in handling this disjoint set very easily and very easy to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee the code, I have commented the code very neatly!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    vector<int> rank, size, parent;\\n    \\n    public:\\n        DisjointSet(int n){\\n            rank.resize(n+1, 0);\\n            size.resize(n+1);\\n            parent.resize(n+1);\\n            for(int i = 0; i <= n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int findParent(int node){\\n            if(node == parent[node]){\\n                return node;\\n            }\\n            \\n            return parent[node] = findParent(parent[node]);\\n        }\\n        \\n        void unionByRank(int u, int v){\\n            int ulpU = findParent(u);\\n            int ulpV = findParent(v);\\n            \\n            // same component\\n            if(ulpU == ulpV)\\n                return ;\\n                \\n            // otherwise\\n            if(rank[ulpU] < rank[ulpV]){\\n                parent[ulpU] = ulpV;\\n            } else if(rank[ulpV] < rank[ulpU]){\\n                parent[ulpV] = ulpU;\\n            } else {\\n                parent[ulpV] = ulpU;\\n                rank[ulpU]++;\\n            }\\n        }\\n        \\n        void unionBySize(int u, int v){\\n            int ulpU = findParent(u);\\n            int ulpV = findParent(v);\\n            \\n            // same component\\n            if(ulpU == ulpV)\\n                return ;\\n                \\n            // otherwise\\n            if(size[ulpU] < size[ulpV]){\\n                parent[ulpU] = ulpV;\\n                size[ulpV] += size[ulpU];\\n            } else {\\n                parent[ulpV] = ulpU;\\n                size[ulpU] += size[ulpV];\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n\\n        // First get the two edges that are having two indegree\\n        vector<int> indegree(n+1, -1); // because of 1 based indexing\\n        int blacklist1 = -1;\\n        int blacklist2 = -2;\\n\\n        for(int i = 0; i < n; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(indegree[v] != -1){\\n                blacklist1 = i;\\n                blacklist2 = indegree[v];\\n                break;\\n            } else {\\n                indegree[v] = i;\\n            }\\n        }\\n\\n\\n        <!-- Create Disjoint set for cycle detection. -->\\n        DisjointSet ds(n+1);\\n        bool isCyclePresent = false;\\n        for(int i = 0; i < n; i++){\\n            <!-- Ignoring blacklist 1 edge -->\\n            if(i == blacklist1){\\n                continue;\\n            }\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            <!-- If parent different then add edge to graph -->\\n            if(ds.findParent(u) != ds.findParent(v)){\\n                ds.unionBySize(u, v);\\n            } else { // If parent same, we are in cycle and then process our answer\\n                isCyclePresent = true;\\n                if(isCyclePresent){\\n                    if(blacklist1 == -1)\\n                        return edges[i];\\n                    else\\n                        return edges[blacklist2];\\n                }\\n            }\\n        }\\n\\n        return edges[blacklist1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int> rank, size, parent;\\n    \\n    public:\\n        DisjointSet(int n){\\n            rank.resize(n+1, 0);\\n            size.resize(n+1);\\n            parent.resize(n+1);\\n            for(int i = 0; i <= n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int findParent(int node){\\n            if(node == parent[node]){\\n                return node;\\n            }\\n            \\n            return parent[node] = findParent(parent[node]);\\n        }\\n        \\n        void unionByRank(int u, int v){\\n            int ulpU = findParent(u);\\n            int ulpV = findParent(v);\\n            \\n            // same component\\n            if(ulpU == ulpV)\\n                return ;\\n                \\n            // otherwise\\n            if(rank[ulpU] < rank[ulpV]){\\n                parent[ulpU] = ulpV;\\n            } else if(rank[ulpV] < rank[ulpU]){\\n                parent[ulpV] = ulpU;\\n            } else {\\n                parent[ulpV] = ulpU;\\n                rank[ulpU]++;\\n            }\\n        }\\n        \\n        void unionBySize(int u, int v){\\n            int ulpU = findParent(u);\\n            int ulpV = findParent(v);\\n            \\n            // same component\\n            if(ulpU == ulpV)\\n                return ;\\n                \\n            // otherwise\\n            if(size[ulpU] < size[ulpV]){\\n                parent[ulpU] = ulpV;\\n                size[ulpV] += size[ulpU];\\n            } else {\\n                parent[ulpV] = ulpU;\\n                size[ulpU] += size[ulpV];\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n\\n        // First get the two edges that are having two indegree\\n        vector<int> indegree(n+1, -1); // because of 1 based indexing\\n        int blacklist1 = -1;\\n        int blacklist2 = -2;\\n\\n        for(int i = 0; i < n; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(indegree[v] != -1){\\n                blacklist1 = i;\\n                blacklist2 = indegree[v];\\n                break;\\n            } else {\\n                indegree[v] = i;\\n            }\\n        }\\n\\n\\n        <!-- Create Disjoint set for cycle detection. -->\\n        DisjointSet ds(n+1);\\n        bool isCyclePresent = false;\\n        for(int i = 0; i < n; i++){\\n            <!-- Ignoring blacklist 1 edge -->\\n            if(i == blacklist1){\\n                continue;\\n            }\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            <!-- If parent different then add edge to graph -->\\n            if(ds.findParent(u) != ds.findParent(v)){\\n                ds.unionBySize(u, v);\\n            } else { // If parent same, we are in cycle and then process our answer\\n                isCyclePresent = true;\\n                if(isCyclePresent){\\n                    if(blacklist1 == -1)\\n                        return edges[i];\\n                    else\\n                        return edges[blacklist2];\\n                }\\n            }\\n        }\\n\\n        return edges[blacklist1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077175,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int findParent(int v, int p[]){\\n        if(p[v] != v){\\n            return p[v] = findParent(p[v], p);\\n        }\\n        return v;\\n    }\\n    public boolean union(int a, int b, int p[]){\\n        int pa = findParent(a, p);\\n        int pb = findParent(b, p);\\n        if(pa == pb){return false;}\\n        p[pa] = pb;\\n        return true;\\n\\n    }\\n    \\n    public boolean dfs(int root, int[][]edges, int n,  int[]e2){\\n        List<Integer>[] adj= new ArrayList[n];\\n\\n        \\n        for(int i = 0; i < n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges){\\n            if(e != e2){\\n                adj[e[0] - 1].add(e[1] - 1);\\n            }\\n        }\\n\\n\\n        boolean visited[] = new boolean[n];\\n        visited[root] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int ver = q.poll();\\n            for(int x: adj[ver]){\\n                if(!visited[x]){\\n                    visited[x] = true;\\n                    q.add(x);\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        //root -> search for cycle start of the cycle \\n        // search for node with 2 parents\\n        //find mother vertex\\n            //1.\\n            //find the vertex with no parents \\n            //progressively go through the edges and find the edge whose addition makes the repeated vertex\\n            //2. \\n            //if no vertex with no parent \\n            //we will just get the add till you get a cycle \\n            \\n            int n = edges.length;\\n            boolean vis[] = new boolean[n];\\n\\n            for(int e[] : edges)\\n            {\\n                vis[e[1] - 1] = true;\\n            }\\n\\n            boolean rootPresent = false;\\n            int root = -1;\\n            for(int i = 0; i < n ; i++){\\n                if(!vis[i]){\\n                    rootPresent = true;\\n                    root = i;\\n                    break;\\n                }\\n            }\\n\\n\\n            if(rootPresent){\\n                int count[] = new int[n];\\n                int culPritVer = 0;\\n                int e1[] = null, e2[] = null ;\\n                for(int e[] : edges){\\n                    if(++count[e[1] - 1] > 1){\\n                        culPritVer = e[1] - 1;\\n                        e2 = e;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                for(int e[] : edges){\\n                    if(e[1] - 1 == culPritVer){\\n                        e1 = e;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                boolean visi[] = new boolean[n];\\n                int cnt = n;\\n                // System.out.println(\"e1: \"  + Arrays.toString(e1));\\n                // System.out.println(\"e2: \"  + Arrays.toString(e2));\\n                for(int e[] : edges){\\n                    if(e != e2){\\n                        // System.out.println(Arrays.toString(e));\\n                        if(!visi[e[0] - 1] && (e[0] - 1) == root){\\n                            visi[e[0] - 1] = true;\\n                            cnt--;\\n                        }\\n                        if(!visi[e[1] - 1]){\\n                            visi[e[1] - 1] = true;\\n                            cnt--;\\n                        }\\n                    }\\n                }\\n\\n\\n                if(cnt == 0 && dfs(root, edges,n, e2)) {\\n                    return e2;\\n                }\\n                else{\\n                    return e1;\\n                }\\n\\n            }\\n            else{\\n                int parent[] = new int[n];\\n                for(int i = 0; i < n; i++){\\n                    parent[i] = i;\\n                }\\n                for(int e[] : edges){\\n                    if(!union(e[0] - 1, e[1] - 1, parent)){\\n                        return e;\\n                    }\\n                }\\n\\n\\n            }\\n\\n            return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findParent(int v, int p[]){\\n        if(p[v] != v){\\n            return p[v] = findParent(p[v], p);\\n        }\\n        return v;\\n    }\\n    public boolean union(int a, int b, int p[]){\\n        int pa = findParent(a, p);\\n        int pb = findParent(b, p);\\n        if(pa == pb){return false;}\\n        p[pa] = pb;\\n        return true;\\n\\n    }\\n    \\n    public boolean dfs(int root, int[][]edges, int n,  int[]e2){\\n        List<Integer>[] adj= new ArrayList[n];\\n\\n        \\n        for(int i = 0; i < n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges){\\n            if(e != e2){\\n                adj[e[0] - 1].add(e[1] - 1);\\n            }\\n        }\\n\\n\\n        boolean visited[] = new boolean[n];\\n        visited[root] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int ver = q.poll();\\n            for(int x: adj[ver]){\\n                if(!visited[x]){\\n                    visited[x] = true;\\n                    q.add(x);\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        //root -> search for cycle start of the cycle \\n        // search for node with 2 parents\\n        //find mother vertex\\n            //1.\\n            //find the vertex with no parents \\n            //progressively go through the edges and find the edge whose addition makes the repeated vertex\\n            //2. \\n            //if no vertex with no parent \\n            //we will just get the add till you get a cycle \\n            \\n            int n = edges.length;\\n            boolean vis[] = new boolean[n];\\n\\n            for(int e[] : edges)\\n            {\\n                vis[e[1] - 1] = true;\\n            }\\n\\n            boolean rootPresent = false;\\n            int root = -1;\\n            for(int i = 0; i < n ; i++){\\n                if(!vis[i]){\\n                    rootPresent = true;\\n                    root = i;\\n                    break;\\n                }\\n            }\\n\\n\\n            if(rootPresent){\\n                int count[] = new int[n];\\n                int culPritVer = 0;\\n                int e1[] = null, e2[] = null ;\\n                for(int e[] : edges){\\n                    if(++count[e[1] - 1] > 1){\\n                        culPritVer = e[1] - 1;\\n                        e2 = e;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                for(int e[] : edges){\\n                    if(e[1] - 1 == culPritVer){\\n                        e1 = e;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                boolean visi[] = new boolean[n];\\n                int cnt = n;\\n                // System.out.println(\"e1: \"  + Arrays.toString(e1));\\n                // System.out.println(\"e2: \"  + Arrays.toString(e2));\\n                for(int e[] : edges){\\n                    if(e != e2){\\n                        // System.out.println(Arrays.toString(e));\\n                        if(!visi[e[0] - 1] && (e[0] - 1) == root){\\n                            visi[e[0] - 1] = true;\\n                            cnt--;\\n                        }\\n                        if(!visi[e[1] - 1]){\\n                            visi[e[1] - 1] = true;\\n                            cnt--;\\n                        }\\n                    }\\n                }\\n\\n\\n                if(cnt == 0 && dfs(root, edges,n, e2)) {\\n                    return e2;\\n                }\\n                else{\\n                    return e1;\\n                }\\n\\n            }\\n            else{\\n                int parent[] = new int[n];\\n                for(int i = 0; i < n; i++){\\n                    parent[i] = i;\\n                }\\n                for(int e[] : edges){\\n                    if(!union(e[0] - 1, e[1] - 1, parent)){\\n                        return e;\\n                    }\\n                }\\n\\n\\n            }\\n\\n            return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042183,
                "title": "clean-and-concise-solution-with-comments-beats-98",
                "content": "```\\nclass Solution {\\nprivate: \\n    vector<int> rank, par;\\n    int n;\\npublic:\\n        // if no in_deg == 2 node (cycle - all nodes with in_deg == 0 or in_deg == 1)\\n        // return the first occurence of union b/w nodes with same parent\\n        // if an in_deg == 2 node exists, remove the edge (of the 2 incoming edges) that doesn\\'t break the tree\\n        // first union all nodes except the ones that contribute to indgree == 2 node, then of the remaining two, return the ans according to the node/edge that that makes it a tree\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        n = edges.size();\\n        rank = vector<int>(n + 1,0);\\n        par = vector<int>(n + 1);\\n        for (int i = 0; i <= n; i++) par[i] = i;\\n        \\n        // find if a deg == 2 node exists\\n        int in2dnode = -1;\\n        vector<int> in = vector<int>(n + 1, 0);\\n        for (const vector<int> &edge: edges) {\\n            in[edge[1]]++;\\n            if (in[edge[1]] == 2) {\\n                in2dnode = edge[1];\\n                break;\\n            }\\n        }\\n                \\n        vector<int> in_start; // max size = 2 (will contain both nodes that contribute to 2 deg node)\\n        for (const vector<int> &edge: edges) {\\n            int l = edge[0], r = edge[1];\\n            if (in2dnode == -1) {\\n                if (merge(l, r)) return {l, r};\\n            } else {\\n                if (edge[1] != in2dnode)\\n                    union_(l, r);\\n                else in_start.push_back(edge[0]);\\n            }\\n        }\\n        return {merge(in_start[0], in2dnode) ? in_start[0] : in_start[1] , in2dnode};\\n    }\\n\\n    bool merge(int l, int r) {\\n        bool res = false;\\n        if (parent(l) == parent(r)) {\\n            res = true;\\n        } else {\\n            union_(l, r);\\n        }\\n        return res;\\n    }\\n\\n    int parent(int x) {\\n        while (x != par[x]) {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_(int x, int y) {\\n        x = parent(x), y = parent(y);\\n        if (x != y) {\\n            if (rank[x] < rank[y]) swap(x, y);\\n            par[y] = x;\\n            rank[x] += rank[x] == rank[y];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    vector<int> rank, par;\\n    int n;\\npublic:\\n        // if no in_deg == 2 node (cycle - all nodes with in_deg == 0 or in_deg == 1)\\n        // return the first occurence of union b/w nodes with same parent\\n        // if an in_deg == 2 node exists, remove the edge (of the 2 incoming edges) that doesn\\'t break the tree\\n        // first union all nodes except the ones that contribute to indgree == 2 node, then of the remaining two, return the ans according to the node/edge that that makes it a tree\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        n = edges.size();\\n        rank = vector<int>(n + 1,0);\\n        par = vector<int>(n + 1);\\n        for (int i = 0; i <= n; i++) par[i] = i;\\n        \\n        // find if a deg == 2 node exists\\n        int in2dnode = -1;\\n        vector<int> in = vector<int>(n + 1, 0);\\n        for (const vector<int> &edge: edges) {\\n            in[edge[1]]++;\\n            if (in[edge[1]] == 2) {\\n                in2dnode = edge[1];\\n                break;\\n            }\\n        }\\n                \\n        vector<int> in_start; // max size = 2 (will contain both nodes that contribute to 2 deg node)\\n        for (const vector<int> &edge: edges) {\\n            int l = edge[0], r = edge[1];\\n            if (in2dnode == -1) {\\n                if (merge(l, r)) return {l, r};\\n            } else {\\n                if (edge[1] != in2dnode)\\n                    union_(l, r);\\n                else in_start.push_back(edge[0]);\\n            }\\n        }\\n        return {merge(in_start[0], in2dnode) ? in_start[0] : in_start[1] , in2dnode};\\n    }\\n\\n    bool merge(int l, int r) {\\n        bool res = false;\\n        if (parent(l) == parent(r)) {\\n            res = true;\\n        } else {\\n            union_(l, r);\\n        }\\n        return res;\\n    }\\n\\n    int parent(int x) {\\n        while (x != par[x]) {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_(int x, int y) {\\n        x = parent(x), y = parent(y);\\n        if (x != y) {\\n            if (rank[x] < rank[y]) swap(x, y);\\n            par[y] = x;\\n            rank[x] += rank[x] == rank[y];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006059,
                "title": "python3-not-the-optimum-solution-but-different",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n + 1)]\\n        self.rank = [1] * (n + 1)\\n\\n    def find(self, n):\\n        p = self.par[n]\\n        while p != self.par[p]:\\n            self.par[p] = self.par[self.par[p]]\\n            p = self.par[p]\\n        return p\\n    \\n    def union(self, u, v):\\n        n1, n2 = self.find(u), self.find(v)\\n        if n1 == n2:\\n            return False\\n        \\n        if self.rank[n1] >= self.rank[n2]:\\n            self.par[n2] = self.par[n1]\\n            self.rank[n1] += self.rank[n2]\\n        else:\\n            self.par[n1] = self.par[n2]\\n            self.rank[n2] += self.rank[n1]\\n        return True\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # erasing one edge\\n            # one root node (indegree of zero)\\n            # can visit all the nodes from the root\\n\\n        # create adjList and indegree\\n        adjList = defaultdict(list)\\n        indegree = defaultdict(int)\\n        for u, v in edges:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n        V = len(edges)\\n\\n        # keep global variable to track the index of the edges that was redundant\\n        # second iteration\\n            # if there is two vertices with 0 indegree -> continue\\n            # from the indegree 0 -> union\\n                # if the graph is all connected; update the global\\n        res = -1\\n        for i in range(len(edges)):\\n            print(i)\\n            # reduce the indegree\\n            v = edges[i][1]\\n            indegree[v] -= 1\\n\\n            # remove the indegree of v if the value is 0\\n            if not indegree[v]:\\n                del indegree[v]\\n\\n            # compare the length of the indegree and vertices\\n            if V - len(indegree) >= 2:\\n                indegree[v] += 1\\n                continue\\n\\n\\n            # check if all the nodes are connected\\n            connected = 0\\n            uf = UnionFind(V)\\n            for j in range(len(edges)):\\n                a, b = edges[j]\\n                if j != i:\\n                    if uf.union(a, b):\\n                        connected += 1\\n\\n            if connected != V - 1:\\n                print(f\"connected:{connected}, V-1:{V - 1}\")\\n                print(f\"Called when; {edges[i]}\")\\n                indegree[v] += 1\\n                continue\\n\\n            res = i\\n\\n            # add the indegree back to where it was\\n            indegree[v] += 1\\n        return edges[res]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n + 1)]\\n        self.rank = [1] * (n + 1)\\n\\n    def find(self, n):\\n        p = self.par[n]\\n        while p != self.par[p]:\\n            self.par[p] = self.par[self.par[p]]\\n            p = self.par[p]\\n        return p\\n    \\n    def union(self, u, v):\\n        n1, n2 = self.find(u), self.find(v)\\n        if n1 == n2:\\n            return False\\n        \\n        if self.rank[n1] >= self.rank[n2]:\\n            self.par[n2] = self.par[n1]\\n            self.rank[n1] += self.rank[n2]\\n        else:\\n            self.par[n1] = self.par[n2]\\n            self.rank[n2] += self.rank[n1]\\n        return True\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        # erasing one edge\\n            # one root node (indegree of zero)\\n            # can visit all the nodes from the root\\n\\n        # create adjList and indegree\\n        adjList = defaultdict(list)\\n        indegree = defaultdict(int)\\n        for u, v in edges:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n        V = len(edges)\\n\\n        # keep global variable to track the index of the edges that was redundant\\n        # second iteration\\n            # if there is two vertices with 0 indegree -> continue\\n            # from the indegree 0 -> union\\n                # if the graph is all connected; update the global\\n        res = -1\\n        for i in range(len(edges)):\\n            print(i)\\n            # reduce the indegree\\n            v = edges[i][1]\\n            indegree[v] -= 1\\n\\n            # remove the indegree of v if the value is 0\\n            if not indegree[v]:\\n                del indegree[v]\\n\\n            # compare the length of the indegree and vertices\\n            if V - len(indegree) >= 2:\\n                indegree[v] += 1\\n                continue\\n\\n\\n            # check if all the nodes are connected\\n            connected = 0\\n            uf = UnionFind(V)\\n            for j in range(len(edges)):\\n                a, b = edges[j]\\n                if j != i:\\n                    if uf.union(a, b):\\n                        connected += 1\\n\\n            if connected != V - 1:\\n                print(f\"connected:{connected}, V-1:{V - 1}\")\\n                print(f\"Called when; {edges[i]}\")\\n                indegree[v] += 1\\n                continue\\n\\n            res = i\\n\\n            # add the indegree back to where it was\\n            indegree[v] += 1\\n        return edges[res]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989016,
                "title": "java-1ms-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    As per the problem statement, the rooted tree is a directed graph such that\\n    1. There is exactly one node (the root) for which all the nodes are descendants of this node.\\n    2. Every node has exactly one parent, except for the root node which has no parents.\\n\\n    Now, if an additionaledge is added, then there can be two cases\\n    1. The root node has an incoming edge, violating the first case above. This case a cycle is created. In this case, if we could identify the cycle we can find the redundant edge.\\n    2. A node has two incoming edges. In this case, there are two candidates for the redudant edge. To identify the redundant, we ignore the first edge and see if cycle is formed. If cycle is formed, then this is the candidate. Otherwise its the other edge which is redundant. \\n    */\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n\\n        int n = edges.length + 1;\\n        // Identify the two edges which are directed towards the same node.\\n        // The edge indices are stored in candidate 1 and candidate 2.\\n        int[] incomingEdgeIndices = new int[n];\\n        Arrays.fill(incomingEdgeIndices, -1);\\n\\n        int candidate1 = -1; int candidate2 = -1;\\n        for (int i = 0; i < n - 1; i++) {\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            if (incomingEdgeIndices[to] == -1) {\\n                incomingEdgeIndices[to] = i;\\n            }\\n            else {\\n                candidate1 = incomingEdgeIndices[to];\\n                candidate2 = i;\\n            }\\n        }\\n\\n        int[] parent = new int[n + 1];\\n        parent[0] = -1;\\n        for (int i = 1; i < n + 1; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] candidate = null;\\n\\n        //Check if cycle exists. For case 1, if cycle exists, the return the redundant edge forming the cycle. For case 2, ignore one edge and see if cycle is formed. If so this is the redundant edge otherwise its the second edge. \\n        for (int i = 0; i < edges.length; i++) {\\n            if (candidate2 != -1 && candidate2 == i) continue;\\n            int[] edge = edges[i];\\n            int u = edge[0];\\n            int v = edge[1];\\n            int rootU = find(u, parent);\\n            int rootV = find(v, parent);\\n            //even after ingnoring candidate2, cycle exists\\n            if (rootU == rootV) {\\n                return candidate1 == -1? edge : edges[candidate1];\\n            }\\n            else {\\n                parent[v] = rootU;\\n            }\\n        }\\n\\n        return edges[candidate2];\\n\\n    }\\n\\n    private int find(int x, int[] parent){\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n\\n        int parentX = find(parent[x], parent);\\n        parent[x] = parentX;\\n        return parentX;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    As per the problem statement, the rooted tree is a directed graph such that\\n    1. There is exactly one node (the root) for which all the nodes are descendants of this node.\\n    2. Every node has exactly one parent, except for the root node which has no parents.\\n\\n    Now, if an additionaledge is added, then there can be two cases\\n    1. The root node has an incoming edge, violating the first case above. This case a cycle is created. In this case, if we could identify the cycle we can find the redundant edge.\\n    2. A node has two incoming edges. In this case, there are two candidates for the redudant edge. To identify the redundant, we ignore the first edge and see if cycle is formed. If cycle is formed, then this is the candidate. Otherwise its the other edge which is redundant. \\n    */\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n\\n        int n = edges.length + 1;\\n        // Identify the two edges which are directed towards the same node.\\n        // The edge indices are stored in candidate 1 and candidate 2.\\n        int[] incomingEdgeIndices = new int[n];\\n        Arrays.fill(incomingEdgeIndices, -1);\\n\\n        int candidate1 = -1; int candidate2 = -1;\\n        for (int i = 0; i < n - 1; i++) {\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            if (incomingEdgeIndices[to] == -1) {\\n                incomingEdgeIndices[to] = i;\\n            }\\n            else {\\n                candidate1 = incomingEdgeIndices[to];\\n                candidate2 = i;\\n            }\\n        }\\n\\n        int[] parent = new int[n + 1];\\n        parent[0] = -1;\\n        for (int i = 1; i < n + 1; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] candidate = null;\\n\\n        //Check if cycle exists. For case 1, if cycle exists, the return the redundant edge forming the cycle. For case 2, ignore one edge and see if cycle is formed. If so this is the redundant edge otherwise its the second edge. \\n        for (int i = 0; i < edges.length; i++) {\\n            if (candidate2 != -1 && candidate2 == i) continue;\\n            int[] edge = edges[i];\\n            int u = edge[0];\\n            int v = edge[1];\\n            int rootU = find(u, parent);\\n            int rootV = find(v, parent);\\n            //even after ingnoring candidate2, cycle exists\\n            if (rootU == rootV) {\\n                return candidate1 == -1? edge : edges[candidate1];\\n            }\\n            else {\\n                parent[v] = rootU;\\n            }\\n        }\\n\\n        return edges[candidate2];\\n\\n    }\\n\\n    private int find(int x, int[] parent){\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n\\n        int parentX = find(parent[x], parent);\\n        parent[x] = parentX;\\n        return parentX;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986768,
                "title": "beats-100-users",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1, 0), candA, candB;\\n        // step 1, check whether there is a node with two parents\\n        for (auto &edge:edges) {\\n            if (parent[edge[1]] == 0)\\n                parent[edge[1]] = edge[0]; \\n            else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        } \\n        // step 2, union find\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        for (auto &edge:edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = root(parent, u);\\n            // Now every node only has 1 parent, so root of v is implicitly v\\n            if (pu == v) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[v] = pu;\\n        }\\n        return candB;\\n    }\\nprivate:\\n    int root(vector<int>& parent, int k) {\\n        if (parent[k] != k) \\n            parent[k] = root(parent, parent[k]);\\n        return parent[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1, 0), candA, candB;\\n        // step 1, check whether there is a node with two parents\\n        for (auto &edge:edges) {\\n            if (parent[edge[1]] == 0)\\n                parent[edge[1]] = edge[0]; \\n            else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        } \\n        // step 2, union find\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        for (auto &edge:edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = root(parent, u);\\n            // Now every node only has 1 parent, so root of v is implicitly v\\n            if (pu == v) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[v] = pu;\\n        }\\n        return candB;\\n    }\\nprivate:\\n    int root(vector<int>& parent, int k) {\\n        if (parent[k] != k) \\n            parent[k] = root(parent, parent[k]);\\n        return parent[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961855,
                "title": "c-solution-dsu",
                "content": "## from Pepcoding\\nhttps://www.youtube.com/watch?v=d0tqBMRZ6UQ\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // pepcoding \\n    // https://www.youtube.com/watch?v=d0tqBMRZ6UQ\\n    int find(int a , vector<int> & parent) {\\n        if(a == parent[a]){\\n            return a;\\n        }\\n        return parent[a] = find(parent[a],parent);\\n    }\\n    void union_(int a, int b,vector<int> &rank,vector<int>& parent){\\n        if(rank[a] > rank[b]){\\n            parent[b] = a;\\n        }else if(rank[a] < rank[b]){\\n            parent[a] = b;\\n        }else{\\n            parent[b] = a;\\n            rank[a]++;\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        int n{};\\n        for(auto &v: edges) {\\n            n = max({n,v[0],v[1]});\\n        }\\n\\n        int en = edges.size();\\n        int potEdge1{-1}; // potential Extra Edge\\n        int potEdge2{-1};\\n        vector<int>inDeg(n+1,-1); // -1 false ,other number tells which edge made indeg\\n        for(int i{}; i < en; i++) {\\n            if(inDeg[edges[i][1]] != -1) {\\n                potEdge1 = inDeg[edges[i][1]];\\n                potEdge2 = i;\\n                break;\\n            }\\n            inDeg[edges[i][1]] = i;\\n        }\\n\\n        vector<int> parent(n+1);\\n        for(int i{}; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        vector<int>rank(n+1,1);\\n\\n        vector<int> cycleEdge = {-1,-1};\\n        for(int i{}; i < en; i++) {\\n\\n            // if we found the node with inDegree 2 it will exclude \\n            // the later edge and then try to find the cycle \\n            // otherwise potEdge2 will be -1 and(hence) it will consider all edges\\n            if(i == potEdge2) {continue;} \\n\\n            int sp = find(edges[i][0],parent);\\n            int dp = find(edges[i][1],parent);\\n            if(sp == dp){\\n                cycleEdge = edges[i];\\n            }else{\\n                // merging is done as undirected graph \\n                // because there\\'s non property of  \\n                // directed graph that we are using here\\n                union_(sp,dp,rank,parent);\\n            }\\n        }\\n\\n        if(potEdge1 == -1){\\n            // no node with 2 inDegree -> Case 2\\n            return cycleEdge;\\n        }else if(cycleEdge[0] == -1){\\n            // node with 2 inDegree without cycle -> Case 1\\n            return edges[potEdge2];\\n        }else{\\n            // node with 2 inDegree with cycle -> Case 3\\n            return edges[potEdge1];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // pepcoding \\n    // https://www.youtube.com/watch?v=d0tqBMRZ6UQ\\n    int find(int a , vector<int> & parent) {\\n        if(a == parent[a]){\\n            return a;\\n        }\\n        return parent[a] = find(parent[a],parent);\\n    }\\n    void union_(int a, int b,vector<int> &rank,vector<int>& parent){\\n        if(rank[a] > rank[b]){\\n            parent[b] = a;\\n        }else if(rank[a] < rank[b]){\\n            parent[a] = b;\\n        }else{\\n            parent[b] = a;\\n            rank[a]++;\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        int n{};\\n        for(auto &v: edges) {\\n            n = max({n,v[0],v[1]});\\n        }\\n\\n        int en = edges.size();\\n        int potEdge1{-1}; // potential Extra Edge\\n        int potEdge2{-1};\\n        vector<int>inDeg(n+1,-1); // -1 false ,other number tells which edge made indeg\\n        for(int i{}; i < en; i++) {\\n            if(inDeg[edges[i][1]] != -1) {\\n                potEdge1 = inDeg[edges[i][1]];\\n                potEdge2 = i;\\n                break;\\n            }\\n            inDeg[edges[i][1]] = i;\\n        }\\n\\n        vector<int> parent(n+1);\\n        for(int i{}; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        vector<int>rank(n+1,1);\\n\\n        vector<int> cycleEdge = {-1,-1};\\n        for(int i{}; i < en; i++) {\\n\\n            // if we found the node with inDegree 2 it will exclude \\n            // the later edge and then try to find the cycle \\n            // otherwise potEdge2 will be -1 and(hence) it will consider all edges\\n            if(i == potEdge2) {continue;} \\n\\n            int sp = find(edges[i][0],parent);\\n            int dp = find(edges[i][1],parent);\\n            if(sp == dp){\\n                cycleEdge = edges[i];\\n            }else{\\n                // merging is done as undirected graph \\n                // because there\\'s non property of  \\n                // directed graph that we are using here\\n                union_(sp,dp,rank,parent);\\n            }\\n        }\\n\\n        if(potEdge1 == -1){\\n            // no node with 2 inDegree -> Case 2\\n            return cycleEdge;\\n        }else if(cycleEdge[0] == -1){\\n            // node with 2 inDegree without cycle -> Case 1\\n            return edges[potEdge2];\\n        }else{\\n            // node with 2 inDegree with cycle -> Case 3\\n            return edges[potEdge1];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936079,
                "title": "disjoing-set-union-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> parent ;\\n    vector<int> rank ;\\n    void memoryset(){\\n        for(int i=1;i<parent.size();i++){\\n            parent[i] = i ;\\n            rank[i]=0;\\n        }\\n    }\\n\\n    int findParent(int node){\\n        if(node == parent[node]) return node ;\\n\\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionSet(int a , int b){\\n        a = findParent(a);\\n        b = findParent(b);\\n\\n        if(a==b) return ;\\n\\n        if(rank[a]>rank[b]){\\n            parent[b] = a; \\n        }else if(rank[a]<rank[b]){\\n            parent[a] = b ;\\n        }else {\\n            parent[a] = b ;\\n            rank[b]++;\\n        }\\n        return ;\\n    }\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        int n = e.size();\\n        parent.resize(n+1);\\n        rank.resize(n+1);\\n\\n        memoryset();\\n        \\n        vector<int> ind(n+1,-1);\\n        int bl1 = -1 , bl2 = -1 ;\\n\\n        for(int i=0;i<n;i++){\\n            int v = e[i][1] ;\\n\\n            if(ind[v] != -1){\\n                bl1 = i;\\n                bl2 = ind[v];\\n                break ;\\n            }else{\\n                ind[v] = i ;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(i==bl1) continue ;\\n\\n            int u = findParent(e[i][0]);\\n            int v = findParent(e[i][1]);\\n\\n            if(u==v){\\n                if(bl1 == -1){\\n                    return e[i]; // when there is only cycle and each node has only one parent\\n                }else{\\n                    return e[bl2]; // when we remove current edge but there is still cycle \\n                }\\n            }else{\\n                unionSet(u,v);\\n            }\\n        }\\n        return e[bl1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parent ;\\n    vector<int> rank ;\\n    void memoryset(){\\n        for(int i=1;i<parent.size();i++){\\n            parent[i] = i ;\\n            rank[i]=0;\\n        }\\n    }\\n\\n    int findParent(int node){\\n        if(node == parent[node]) return node ;\\n\\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionSet(int a , int b){\\n        a = findParent(a);\\n        b = findParent(b);\\n\\n        if(a==b) return ;\\n\\n        if(rank[a]>rank[b]){\\n            parent[b] = a; \\n        }else if(rank[a]<rank[b]){\\n            parent[a] = b ;\\n        }else {\\n            parent[a] = b ;\\n            rank[b]++;\\n        }\\n        return ;\\n    }\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& e) {\\n        int n = e.size();\\n        parent.resize(n+1);\\n        rank.resize(n+1);\\n\\n        memoryset();\\n        \\n        vector<int> ind(n+1,-1);\\n        int bl1 = -1 , bl2 = -1 ;\\n\\n        for(int i=0;i<n;i++){\\n            int v = e[i][1] ;\\n\\n            if(ind[v] != -1){\\n                bl1 = i;\\n                bl2 = ind[v];\\n                break ;\\n            }else{\\n                ind[v] = i ;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(i==bl1) continue ;\\n\\n            int u = findParent(e[i][0]);\\n            int v = findParent(e[i][1]);\\n\\n            if(u==v){\\n                if(bl1 == -1){\\n                    return e[i]; // when there is only cycle and each node has only one parent\\n                }else{\\n                    return e[bl2]; // when we remove current edge but there is still cycle \\n                }\\n            }else{\\n                unionSet(u,v);\\n            }\\n        }\\n        return e[bl1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925715,
                "title": "easy-c-solution-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void makeset(vector<int> &parent, vector<int> &rank)\\n    {\\n        for(int i = 1 ; i < rank.size() ; i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &rank)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n\\n        if(rank[pu] > rank[pv])\\n        {\\n            parent[pv] = pu;\\n        }\\n        else if(rank[pv] > rank[pu])\\n        {\\n            parent[pu] = pv;\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            rank[pu]++;\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size(); // #edges = n-1+1\\n        vector<int> parent(n+1);\\n        vector<int> rank(n+1);\\n        makeset(parent, rank);\\n\\n        vector<int> indegree(n+1, -1);\\n        vector<int> blacklist(2); // containing index of edges that are contender of ans i.e. has 2 parents. \\n        blacklist[0] = -1;\\n        blacklist[1] = -1;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(indegree[edges[i][1]] == -1)\\n            {\\n                indegree[edges[i][1]] = i; \\n            }\\n            else\\n            {\\n                blacklist[0] = indegree[edges[i][1]];\\n                blacklist[1] = i;\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        if(blacklist[1] != -1)\\n            ans = edges[blacklist[1]];\\n\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(i != blacklist[1])\\n            {\\n                if(findparent(edges[i][1], parent) != findparent(edges[i][0], parent))\\n                {\\n                    Union(edges[i][0], edges[i][1], parent, rank);\\n                }\\n                else\\n                {\\n                    if(blacklist[0] == -1)\\n                        ans = edges[i];\\n                    else\\n                        ans = edges[blacklist[0]];\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void makeset(vector<int> &parent, vector<int> &rank)\\n    {\\n        for(int i = 1 ; i < rank.size() ; i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &rank)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n\\n        if(rank[pu] > rank[pv])\\n        {\\n            parent[pv] = pu;\\n        }\\n        else if(rank[pv] > rank[pu])\\n        {\\n            parent[pu] = pv;\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            rank[pu]++;\\n        }\\n    }\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size(); // #edges = n-1+1\\n        vector<int> parent(n+1);\\n        vector<int> rank(n+1);\\n        makeset(parent, rank);\\n\\n        vector<int> indegree(n+1, -1);\\n        vector<int> blacklist(2); // containing index of edges that are contender of ans i.e. has 2 parents. \\n        blacklist[0] = -1;\\n        blacklist[1] = -1;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(indegree[edges[i][1]] == -1)\\n            {\\n                indegree[edges[i][1]] = i; \\n            }\\n            else\\n            {\\n                blacklist[0] = indegree[edges[i][1]];\\n                blacklist[1] = i;\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        if(blacklist[1] != -1)\\n            ans = edges[blacklist[1]];\\n\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(i != blacklist[1])\\n            {\\n                if(findparent(edges[i][1], parent) != findparent(edges[i][0], parent))\\n                {\\n                    Union(edges[i][0], edges[i][1], parent, rank);\\n                }\\n                else\\n                {\\n                    if(blacklist[0] == -1)\\n                        ans = edges[i];\\n                    else\\n                        ans = edges[blacklist[0]];\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913104,
                "title": "disjoint-set-union-indegree-based-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int x,vector<int>& par) {\\n        if(x==par[x])\\n            return x;\\n        int y=find(par[x],par);\\n        return par[x]=y;\\n    }\\n\\n    bool merge(int x,int y,vector<int>& par,vector<int>& rank) {\\n        int lx=find(x,par);\\n        int ly=find(y,par);\\n        if(lx!=ly)\\n        {\\n            if(rank[lx]>rank[ly])\\n            par[ly]=lx;\\n            else if(rank[ly]>rank[lx])\\n            par[lx]=ly;\\n            else\\n            {\\n                par[ly]=lx;\\n                rank[lx]++;\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<int> par(n+1),rank(n+1),indeg(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            par[i]=i;\\n            rank[i]=0;\\n        }\\n        int e1=-1,e2=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[edges[i][1]]!=-1)\\n            {\\n                e1=indeg[edges[i][1]];\\n                e2=i;\\n                break;\\n            }\\n            indeg[edges[i][1]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==e2)\\n            continue;\\n            if(merge(edges[i][0],edges[i][1],par,rank))\\n            {\\n                if(e1!=-1)\\n                    return edges[e1];\\n                else\\n                    return edges[i];\\n            }\\n        }\\n        return edges[e2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(int x,vector<int>& par) {\\n        if(x==par[x])\\n            return x;\\n        int y=find(par[x],par);\\n        return par[x]=y;\\n    }\\n\\n    bool merge(int x,int y,vector<int>& par,vector<int>& rank) {\\n        int lx=find(x,par);\\n        int ly=find(y,par);\\n        if(lx!=ly)\\n        {\\n            if(rank[lx]>rank[ly])\\n            par[ly]=lx;\\n            else if(rank[ly]>rank[lx])\\n            par[lx]=ly;\\n            else\\n            {\\n                par[ly]=lx;\\n                rank[lx]++;\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        vector<int> par(n+1),rank(n+1),indeg(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            par[i]=i;\\n            rank[i]=0;\\n        }\\n        int e1=-1,e2=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[edges[i][1]]!=-1)\\n            {\\n                e1=indeg[edges[i][1]];\\n                e2=i;\\n                break;\\n            }\\n            indeg[edges[i][1]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==e2)\\n            continue;\\n            if(merge(edges[i][0],edges[i][1],par,rank))\\n            {\\n                if(e1!=-1)\\n                    return edges[e1];\\n                else\\n                    return edges[i];\\n            }\\n        }\\n        return edges[e2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883572,
                "title": "easy-understanding-solution-using-union-find-with-detailed-explanation",
                "content": "# Intuition\\nFigure out what edges can cause trouble:\\n> Essentially those who make one point has indegree 2\\n\\nSo need to record those two candidates.\\nAnd determine answer by\\n1. Is one of them in a loop\\n2. If not, which one is added later\\n\\n# Approach\\nThe second case is easy to dealt with because if there\\'s not a loop, just output the later added one. We can do loop check by Union Find.\\nOtherwise, we need to know which one of them is in the loop, then that one is the answer.\\nTo do this, simply remove one of the edge and see if there\\'s still a loop. The \\'clever way\\' to do this removal is to rebuild the graph without that particular edge.\\n\\n# Complexity\\n- Time complexity:\\nQuick\\n- Space complexity:\\nSmall\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.parent[px] = py\\n            return 0\\n        return 1\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        uf = UF(n)\\n        in_edge = defaultdict(list)\\n        candidate_1, candidate_2 = None, None\\n\\n        for x, y in edges:\\n            if len(in_edge[y]) == 0:\\n                in_edge[y].append([x, y])\\n            else:\\n                candidate_1 = [x, y]\\n                candidate_2 = in_edge[y][0]\\n        for x, y in edges:\\n            if [x, y] == candidate_1:\\n                continue\\n            if uf.union(x, y):\\n                if not candidate_1:\\n                    return [x, y]\\n                else:\\n                    return candidate_2\\n        return candidate_1\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.parent[px] = py\\n            return 0\\n        return 1\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\\n        n = len(edges)\\n        uf = UF(n)\\n        in_edge = defaultdict(list)\\n        candidate_1, candidate_2 = None, None\\n\\n        for x, y in edges:\\n            if len(in_edge[y]) == 0:\\n                in_edge[y].append([x, y])\\n            else:\\n                candidate_1 = [x, y]\\n                candidate_2 = in_edge[y][0]\\n        for x, y in edges:\\n            if [x, y] == candidate_1:\\n                continue\\n            if uf.union(x, y):\\n                if not candidate_1:\\n                    return [x, y]\\n                else:\\n                    return candidate_2\\n        return candidate_1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834197,
                "title": "easy-simple-explanation-disjointset-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. int n = edges.size();: Get the number of edges in the input vector edges. The variable n represents the total number of edges in the graph.\\n\\n2. Create three vectors:\\n\\nparnode: A vector of size n+1 initialized with all zeros. It will be used to keep track of the parent node of each node in the tree.\\ndout1 and dout2: These two vectors will be used to store two edges forming the redundant connection (cycle) in the graph.\\nIterate through each edge in the edges vector using a range-based for loop.\\n\\n3. Inside the loop, check if the parent node of the second node (edge[1]) is not already set (parnode[edge[1]] == 0). If it is not set, then set the parent node to be the first node (edge[0]). This means that the edge connects edge[0] as the parent to edge[1].\\n\\n4. If the parent node of the second node is already set, it means we have found a redundant connection (cycle) in the graph. In this case, store the two edges that form the redundant connection in the vectors dout1 and dout2. The dout1 vector will contain the parent node of edge[1] and edge[1] itself. The dout2 vector will store the current edge.\\n\\n4. Create a Disjoint Set Union (DSU) data structure of size n+1. This DSU will be used to track connected components.\\n\\n5. Iterate through each edge in the edges vector again using a range-based for loop.\\n\\n6. Inside the loop, skip the iteration if the current edge is equal to dout2. This means that the current edge was identified as part of a redundant connection in the previous loop, so we skip it.\\n\\n7. Otherwise, get the parent nodes of both nodes u and v of the current edge.\\n\\n8. Check if both nodes u and v belong to the same connected component (i.e., ds1.findUPar(u) == ds1.findUPar(v)). If they do, it means adding the current edge will form a cycle, and it is a redundant connection.\\n\\n9. In this case, if dout1 is not empty, return dout1, which contains the two edges forming the redundant connection. If dout1 is empty, return dout2, which contains the two edges found in the previous loop.\\n\\n10. If the nodes do not belong to the same connected component, union the sets to merge them using the ds1.unionBySize(u, v); operation. This ensures that the graph remains acyclic.\\n\\n11. If the loop completes without finding a redundant connection, it means that the last edge in dout2 is the redundant connection. Return dout2.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n * \\u03B1(n)), where n is the number of edges, and \\u03B1 is the inverse Ackermann function (a very slowly growing function), which makes the DSU operations almost constant time in practice.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    \\n    public:\\n    vector<int> rank,parent,size;\\n     DisjointSet(int n){\\n         rank.resize(n+1,0);\\n         parent.resize(n+1);\\n         size.resize(n+1,1);\\n         for(int i=0;i<n;i++){\\n             parent[i]=i;\\n         }\\n     }\\n     int findUPar(int node){\\n         if(node==parent[node]) return node;\\n         return parent[node]=findUPar(parent[node]);\\n     }\\n     void unionByRank(int u,int v){\\n         int ulp_u = findUPar(u);\\n         int ulp_v = findUPar(v);\\n         if(ulp_u == ulp_v) return;\\n         if(rank[ulp_u]<rank[ulp_v]){\\n             parent[ulp_u]=ulp_v;\\n         }\\n         else if(rank[ulp_u]>rank[ulp_v]){\\n             parent[ulp_v]=ulp_u;\\n         }\\n         else{\\n             parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n         }\\n     }\\n     void unionBySize(int u,int v){\\n         int ulp_u = findUPar(u);\\n         int ulp_v = findUPar(v);\\n         if(ulp_u == ulp_v) return;\\n         if(size[ulp_u]<size[ulp_v]){\\n             parent[ulp_u]=ulp_v;\\n             size[ulp_v]++;\\n         }\\n         \\n         else{\\n             parent[ulp_v] = ulp_u;\\n            size[ulp_u]++;\\n         }\\n     }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n       \\n      vector<int> parnode(n+1,0),dout1,dout2;\\n      for(auto &edge : edges){\\n          if(parnode[edge[1]]==0){\\n              parnode[edge[1]]=edge[0];\\n          }else{\\n              dout1 = {parnode[edge[1]],edge[1]};\\n              dout2 = edge;\\n              edge[1]=0;\\n          }\\n      }\\n          DisjointSet ds1(n+1);\\n          for(auto &edge: edges){\\n              if(edge == dout2) continue;\\n              int u = edge[0];\\n              int v = edge[1];\\n              if(ds1.findUPar(u)==ds1.findUPar(v)){\\n                  if(dout1.empty()) return edge;\\n                  return dout1;\\n              }\\n                  ds1.unionBySize(u,v);\\n          }\\n      \\n      return dout2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    \\n    public:\\n    vector<int> rank,parent,size;\\n     DisjointSet(int n){\\n         rank.resize(n+1,0);\\n         parent.resize(n+1);\\n         size.resize(n+1,1);\\n         for(int i=0;i<n;i++){\\n             parent[i]=i;\\n         }\\n     }\\n     int findUPar(int node){\\n         if(node==parent[node]) return node;\\n         return parent[node]=findUPar(parent[node]);\\n     }\\n     void unionByRank(int u,int v){\\n         int ulp_u = findUPar(u);\\n         int ulp_v = findUPar(v);\\n         if(ulp_u == ulp_v) return;\\n         if(rank[ulp_u]<rank[ulp_v]){\\n             parent[ulp_u]=ulp_v;\\n         }\\n         else if(rank[ulp_u]>rank[ulp_v]){\\n             parent[ulp_v]=ulp_u;\\n         }\\n         else{\\n             parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n         }\\n     }\\n     void unionBySize(int u,int v){\\n         int ulp_u = findUPar(u);\\n         int ulp_v = findUPar(v);\\n         if(ulp_u == ulp_v) return;\\n         if(size[ulp_u]<size[ulp_v]){\\n             parent[ulp_u]=ulp_v;\\n             size[ulp_v]++;\\n         }\\n         \\n         else{\\n             parent[ulp_v] = ulp_u;\\n            size[ulp_u]++;\\n         }\\n     }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n       \\n      vector<int> parnode(n+1,0),dout1,dout2;\\n      for(auto &edge : edges){\\n          if(parnode[edge[1]]==0){\\n              parnode[edge[1]]=edge[0];\\n          }else{\\n              dout1 = {parnode[edge[1]],edge[1]};\\n              dout2 = edge;\\n              edge[1]=0;\\n          }\\n      }\\n          DisjointSet ds1(n+1);\\n          for(auto &edge: edges){\\n              if(edge == dout2) continue;\\n              int u = edge[0];\\n              int v = edge[1];\\n              if(ds1.findUPar(u)==ds1.findUPar(v)){\\n                  if(dout1.empty()) return edge;\\n                  return dout1;\\n              }\\n                  ds1.unionBySize(u,v);\\n          }\\n      \\n      return dout2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565600,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1568681,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1566564,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1753318,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1569281,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1572411,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1575735,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1574558,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1573048,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1569224,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1565600,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1568681,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1566564,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1753318,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1569281,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1572411,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1575735,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1574558,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1573048,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1569224,
                "content": [
                    {
                        "username": "saurabh042",
                        "content": "Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be acheved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "cs_engineer",
                        "content": "Now, the question statement says the original tree satisfied these below conditions: \\n\\n* There is a root node with zero indegree.\\n* All other nodes have only one parent.\\n* All other nodes are descendant of the root node.\\n\\nNow in this above setup, only **ONE** edge is added. This forms a graph G. \\n\\nNow this graph G can have two possibilities.  \\n\\n(How these thoughts came to our mind, I was looking to satisfy the first condition above, for that we need a root node, some node with zero indegree)\\n\\n# Case-1: It contains a node with zero indegree.\\n\\nNow, this node with zero indegree is our root, we do not need to find any other root. This condition is already satisfied in G. Now, let\\'s move to condition two: all nodes must have only one parent. Now addition of new edge can fail this condition, we need to remove that edge, to satisfy the condition.  Now find all such nodes with more than one parent/indegree. \\n\\n![image](https://assets.leetcode.com/users/images/0cf76cf2-b17f-4e17-ad8d-595236547ad8_1636638023.3093653.jpeg)\\n\\n\\nNow, In Scenario 1, we have only one problem: twoparents for a node.\\n\\nSolution:   remove any parent edge, preferrable coming late in order.\\n\\n\\nIn scenario 2, we have two problems:\\n* Cycle.\\n* Two parents of a node.\\n\\nSolution:   remove the parent edge which is part of cycle. We cannot remove the other parent edge because it will make the graph disconnected violating the 3rd property. See, here cycle is not the actual problem, the actual problem is two parents only, the case manifests as a cycle thats the case. \\n\\n# Case-2: It does not contain any node with zero indegree.\\n\\nNow there is no node with zero indegree means, there is no node which does not have any pre-requisites. This implies this directed graph cannot have its topological sorting. This implies its not a DAG. But the graph is indeed directed and not a DAG. This means **the graph MUST have a cycle. **\\n\\nSolution: Remove ***any edge of the circle*** a -> b. (Preferrably the one which comes later in the order). If you remove the circle edge a -> b, ***b now becomes the root***. Try this on paper, this concept is cool, when you realise, you can remove any edge from the circle. \\n\\n![image](https://assets.leetcode.com/users/images/1227d9bd-4104-43a4-8f3e-118b3f1ba3c4_1636638897.5092797.jpeg)\\n\\nNow, in the original tree, only one edge was added, this graph:\\n* Cannot have more than one cycles, because that would have required addition of more than one edges. \\n* Cannot have nodes with two or more indegree because that would have required addition of more than one edges. \\n\\n"
                    },
                    {
                        "username": "hiitsherby",
                        "content": "Hi, \\n\\nI don\\'t understand why this case is wrong answer. \\nIf we remove [2,1], the input won\\'t even be a valid tree. \\nAnd it makes sense to remove [1,4] since 1 and 4 is already connected through 2.\\n\\nDid I misunderstand the quesion? Any help with be appreciated. Thanks in advance.\\n\\n![image](https://assets.leetcode.com/users/hiitsherby/image_1562058288.png)\\n"
                    },
                    {
                        "username": "keshav3899",
                        "content": "[@VineethKumarM](/VineethKumarM)  thanks man you cleared my doubt"
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "On removing edge [1,4] u can observe the indegree of node 4 and 3 are both 0. But in a rooted tree there should be only one root and we should be able to traverse the whole tree through it. This can be achieved by removing the edge [2,1] and root will be node 3."
                    },
                    {
                        "username": "FelixLin99",
                        "content": "This shit damages my brain"
                    },
                    {
                        "username": "laura721",
                        "content": "The answer should be [3,1], but it gives [2,1]"
                    },
                    {
                        "username": "bparanj",
                        "content": "For the problem, you\\'re working with a directed graph that starts as a rooted tree, then gets one additional edge that creates a cycle or multiple parents situation. The task is to remove one edge such that the resulting graph is again a rooted tree.\\n\\nIf the graph structure is such that removing the edge [2,1] creates a rooted tree and this edge appears later in the input array than [3,1], the algorithm would correctly return [2,1] instead of [3,1].\\n\\nThis is because the problem statement specifies to return the answer that occurs last in the given 2D-array if there are multiple solutions."
                    },
                    {
                        "username": "user0332U",
                        "content": "In the problem description, it says if there are multiple answers, return the answer that occurs last in the given 2D-array. My output gives [1,4] as the answer but the expected output is [2,1]. Isn\\'t [1,4] the actual answer?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy you\\'re observing might be due to the specificities of the problem. As per the problem, you\\'re given a directed graph that initially is a rooted tree, and then one additional edge is added. This edge may create a cycle or multiple parents scenario. Your task is to identify and remove one edge so that the resulting graph becomes a rooted tree again.\\n\\nThe phrase \"if there are multiple answers, return the answer that occurs last in the given 2D-array\" applies when there are multiple edges that, when removed, would lead to a rooted tree.\\n\\nHowever, it doesn\\'t mean that any edge can be removed. The edge to be removed should be the one that restores the graph into a rooted tree structure."
                    },
                    {
                        "username": "404akhan",
                        "content": "Assume you had a directed tree. Then let\\'s look at the number of incoming edges to a vertex. Root has 0 incoming, all remaining has 1 incoming edge. So, we have an array of incoming edges looking as following [0, 1, 1, 1, ... 1].\\n\\nWhat happens when we add extra directed edge to a graph. Our array can become one of following types:\\n[0, 2, 1, 1, ... 1] and [1, 1, 1, 1, ... 1].\\n\\nIn first case, we got vertex with two incoming edges. It becomes clear to which vertex new edge has been added, and since it has only two incoming edges it is possible in linear time to check whether we can delete each of them.\\n\\nIn second case, it is possible to prove that there is a cycle, and that all edges connected to that cycle are outcoming. Thus, we can remove any edge from this cycle.\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct. In a rooted tree, the root node has no incoming edges and all other nodes have exactly one incoming edge. Adding one more edge could lead to one of two scenarios:\\n\\n1. One node ends up with two parents. In this case, the added edge is easy to identify as it is the second incoming edge to this node. We then have to determine which edge to remove to maintain the tree structure. Typically, since we need to keep the edge that occurs later in the 2D array, we\\'d remove the earlier edge unless doing so would create a cycle.\\n\\n2. There is a cycle in the graph. In this case, all nodes still have exactly one parent but there is a cycle. Since all edges on this cycle are equal in terms of maintaining the tree structure (removing any of them would result in a valid tree), we remove the one that occurs last in the input array as per the problem\\'s instructions.\\n\\nThe complexity of this problem is primarily in identifying which of these two scenarios has occurred and then identifying which edge to remove. This can usually be achieved in linear time by scanning through the list of edges and maintaining a record of the parent of each node."
                    },
                    {
                        "username": "abhik1998chakraborty",
                        "content": "Consider the test case [[2,1],[3,1],[4,2],[1,4]]\\nThe graph comes out to be : \\n\\n. 2\\n / .. ^\\nv   ..  |\\n1 <-4\\n^\\n|\\n3\\nIn this case, shouldn\\'t the [1,4] be removed, as removing that makes it cycle free, and it is the last edge.\\n \\n Edit : I got the answer, we need to find the rooted tree, and a tree has a single root only , which means, only 1 node having indegree 0.\\n"
                    },
                    {
                        "username": "eashion",
                        "content": "For case: [[1,2],[2,3],[3,4],[4,1],[1,5]]. The best answer is remove [1,2], then there is a tree strat with 2. The standard solution gives [4,1].\\nIf test case is [[1,2],[2,3],[3,4],[4,1],[5,1]], then we should remove [4,1], since 5 should be the root node."
                    },
                    {
                        "username": "vikramvj",
                        "content": "[[2,1],[3,1],[4,2],[1,4]]\\n\\nFor this example every node has exactly one parent condition fails.\\nCan anyone kindly explain to me what am I missing here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The input [[2,1],[3,1],[4,2],[1,4]] represents a graph with four nodes and four directed edges. The edges are 2->1, 3->1, 4->2, and 1->4.\\n\\nIn this case, the node 1 has two parents which are nodes 2 and 3. This indicates that an extra edge was added to a rooted tree to form this graph. This is why it seems like the condition of \"every node has exactly one parent\" is violated. The extra edge violates the property of a rooted tree, and the problem asks us to find this extra edge and remove it so that the graph becomes a valid rooted tree again.\\n\\nIn other words, the graph was initially a rooted tree where each node had exactly one parent, but the addition of one extra edge made it so that one node ended up with two parents. We\\'re asked to return this extra edge."
                    }
                ]
            },
            {
                "id": 1576445,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1575099,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1573883,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1571903,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 2059466,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 2059461,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1999510,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1997962,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1962036,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            },
            {
                "id": 1910514,
                "content": [
                    {
                        "username": "leadbi",
                        "content": "For the first input sample, curious on why removing edge [1,3] is not a right answer? it also leaves a tree 1->2 -> 3\\n\\nInput: edges = [[1,2],[1,3],[2,3]]\\nOutput: [2,3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the removal of an edge that will restore the graph to a rooted tree. In the case where there are multiple correct answers, you are asked to return the one that occurs last in the input list of edges.\\n\\nFor the input [[1,2],[1,3],[2,3]], both [1,3] and [2,3] could be removed to result in a valid tree. However, [2,3] is the one that occurs last in the input list. Therefore, according to the problem\\'s conditions, [2,3] is the correct answer. \\n\\nIn other words, if we have multiple valid answers, we choose the edge that was added last (appears last in the input). The assumption here is that the additional edge that broke the tree property was added last."
                    },
                    {
                        "username": "VineethKumarM",
                        "content": "In the question it is mentioned to return the last added edge in the input.\\n"
                    },
                    {
                        "username": "shreyasbalakrishna19",
                        "content": "1) Do dfs from every node. Also keep track of of many nodes were visited.\\n2) When you find a node that can reach all n vertices, it can be taken as a root.\\n3) For every edge (reverse order input), remove the edge and see whether you can traverse all n nodes from the root. If yes then that edge can be removed."
                    },
                    {
                        "username": "mge_learn",
                        "content": "Input: [[2,1],[3,1],[4,2],[1,4]]\\nOutput : [3,1]\\nExpected: [2,1]\\n\\n2->1->4->2\\n\\t ^\\n\\t 3\\n\\t \\n[3,1] is correct answer since it is after [2,1] in list."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the case of the input [[2,1],[3,1],[4,2],[1,4]], both edges [2,1] and [3,1] could be removed to result in a valid tree. However, the problem asks for the removal of an edge that will restore the graph to a rooted tree and if there are multiple correct answers, you should return the one that occurs last in the input list of edges.\\n\\nIn your input, both [2,1] and [3,1] cause a node to have two parents, creating a situation that is not a valid tree. Both of them can be removed to form a valid tree. However, [3,1] appears after [2,1] in the input, and per the problem\\'s instructions, you should return the one that appears last. Thus, [3,1] is the correct output.\\n\\nHere\\'s how the graph looks like for each edge:\\n\\n1. [2,1] : 2 -> 1\\n2. [3,1] : 3 -> 1 and 2 -> 1\\n3. [4,2] : 4 -> 2 -> 1 and 3 -> 1\\n4. [1,4] : 1 -> 4 -> 2 -> 1 (cycle) and 3 -> 1\\n\\nRemoving [3,1] will break the cycle and leave us with a valid tree."
                    },
                    {
                        "username": "lczazu",
                        "content": "\\u4E00\\u9897\\u6709\\u5411\\u6811\\uFF0C\\u5728\\u6811\\u4E0A\\u589E\\u52A0\\u4E00\\u6761\\u8FB9\\u3002\\n\\n\\u6211\\u4EEC\\u63A5\\u4E0B\\u6765\\u7814\\u7A76\\u589E\\u52A0\\u8FB9\\u6240\\u5E26\\u6765\\u7684\\u7279\\u5F81\\u3002\\n\\n\\u8BBE\\u589E\\u52A0\\u7684\\u8FB9\\u4E3Au->v(v\\u4E3A\\u7236\\u8282\\u70B9\\uFF09\\uFF0C\\u82E5u\\u4E3A\\u975E\\u6839\\u8282\\u70B9\\uFF0C\\u82E5v\\u4E3Au\\u7684\\u7956\\u5148\\uFF0C\\u5219\\u5176\\u4E3A1\\u4E2Acircle\\uFF0C\\u4E14u\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t\\t\\t     \\u5426\\u5219\\uFF0C\\u7B80\\u5355\\u7684\\uFF0Cu\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\n\\t\\t\\t      \\u82E5u\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u5219\\u6709\\u4E00\\u4E2Acircle\\n\\n\\n\\u63A5\\u4E0B\\u6765\\uFF0C\\u51B3\\u5B9A\\u89E3\\u51B3\\u65B9\\u6848\\u3002\\n\\n\\u82E5\\u4E0D\\u5B58\\u5728\\u6709\\u4E24\\u4E2A\\u7956\\u5148\\u7684\\u7279\\u5F81\\uFF0C\\u5219\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u53BB\\u6389\\u627E\\u5230circle\\u65F6\\u7684\\u8FB9\\u5373\\u53EF\\n\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u51B3\\u5B9A\\u53BB\\u6389\\u4EE5u\\u4E3A\\u5B50\\u8282\\u70B9\\u7684\\u67D0\\u4E00\\u6761\\u8FB9\\u3002\\u6211\\u4EEC\\u9700\\u8981\\u53BB\\u6389\\u6784\\u6210circle\\u7684\\u90A3\\u6761\\u8FB9\\uFF0C\\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u63A7\\u5236\\u53D8\\u91CF\\u6CD5\\uFF0C\\u53BB\\u6389\\u67D0\\u4E00\\u6761\\u8FB9\\uFF0C\\u82E5\\u4ECD\\u5B58\\u5728circle\\uFF0C\\u5C31\\u8FD4\\u56DE\\u4E4B\\u524D\\u6CA1\\u6709\\u53BB\\u6389\\u7684\\u8FB9\\uFF0C\\u5426\\u5219\\u8FD4\\u56DE\\u53BB\\u6389\\u7684\\u8FB9\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If a tree is directed and an edge is added to it:\\n\\nLet\\'s analyze the characteristics that the added edge will bring:\\n\\nAssume the added edge is u->v (v is the parent). If u is not the root node, and v is the ancestor of u, then it forms a circle, and u has two ancestors. Otherwise, it\\'s simple: u has two ancestors. If u is the root node, then there is a circle.\\n\\nNext, let\\'s decide on the solution:\\n\\nIf there are no nodes with two ancestors, then we just need to remove the edge that forms the circle.\\n\\nOtherwise, we need to decide which edge with u as a child to remove. We need to remove the edge that forms the circle, so we can use a control variable method: remove one edge, if there is still a circle, then return the edge that was not removed, otherwise, return the edge that was removed.\"\\n\\nThis strategy essentially involves detecting whether a cycle exists and if so, removing an edge from the cycle. If a node has two parents, the edge creating the second parent relationship should be removed. It\\'s a clear analysis of the problem and an effective strategy for solving it."
                    },
                    {
                        "username": "SeineAle",
                        "content": "<H1>HINT</H1>\nEither the graph will have <B>indegree > 1</B> for one node or a <B>cycle</B> or may be <B>both</B> !!!"
                    },
                    {
                        "username": "SeineAle",
                        "content": "<h1>Should be marked <u>medium </u> !!</h1>"
                    },
                    {
                        "username": "Amansingh90",
                        "content": "some test cases :\\n[[1,2],[1,3],[2,3]]\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[910,646],[745,564],[390,903],[173,60],[727,875],[672,80],[64,934],[805,265],[909,5],[934,332],[317,130],[961,557],[532,155],[196,880],[966,734],[91,132],[310,774],[24,299],[735,480],[497,48],[979,127],[989,752],[811,18],[506,85],[8,750],[218,304],[724,326],[153,722],[48,142],[259,893],[871,851],[682,990],[819,468],[852,278],[600,829],[252,164],[638,506],[864,664],[84,951],[645,317],[65,180],[608,712],[401,100],[674,751],[336,56],[208,412],[152,86],[476,770],[654,580],[132,149],[808,292],[667,559],[19,259],[134,915],[741,90],[824,150],[436,581],[991,737],[519,462],[126,871],[612,513],[209,102],[783,437],[164,477],[788,402],[348,923],[243,657],[35,496],[904,305],[235,421],[990,982],[337,178],[285,256],[228,658],[410,553],[744,813],[590,233],[214,802],[437,133],[554,885],[671,314],[799,757],[856,964],[430,933],[949,336],[564,579],[119,47],[246,647],[688,331],[837,208],[993,986],[496,403],[687,597],[740,407],[902,630],[52,434],[198,346],[913,26],[251,854],[773,84],[10,522],[131,111],[570,166],[873,463],[17,334],[782,192],[677,99],[915,596],[448,605],[758,410],[680,516],[482,830],[74,375],[640,352],[703,137],[552,29],[403,339],[454,635],[573,417],[29,161],[596,542],[480,714],[853,504],[858,252],[965,758],[803,141],[691,221],[670,263],[731,864],[775,779],[368,321],[528,675],[955,631],[166,405],[800,429],[184,886],[308,753],[944,147],[622,849],[335,285],[174,931],[901,198],[265,536],[147,567],[442,937],[63,558],[478,41],[832,229],[778,676],[861,954],[706,74],[664,912],[399,481],[468,674],[579,184],[186,639],[495,202],[460,204],[975,120],[444,743],[258,667],[906,209],[809,801],[535,475],[75,12],[27,992],[527,708],[839,823],[256,811],[217,505],[628,173],[219,756],[947,38],[956,327],[300,575],[931,143],[108,648],[266,40],[877,866],[637,539],[693,613],[72,172],[898,396],[138,151],[903,138],[20,803],[338,13],[226,213],[168,500],[765,479],[964,65],[181,514],[161,551],[896,621],[885,195],[205,514],[116,322],[515,689],[7,807],[240,11],[968,615],[556,980],[393,254],[188,467],[879,78],[125,790],[796,313],[93,797],[14,624],[916,484],[924,61],[756,395],[857,485],[868,393],[928,179],[464,898],[210,563],[272,625],[585,784],[87,583],[66,272],[545,897],[511,978],[549,79],[946,191],[305,447],[516,972],[747,243],[396,101],[58,941],[996,88],[560,576],[483,943],[746,409],[510,822],[548,767],[346,902],[211,370],[712,32],[37,764],[350,573],[792,820],[234,207],[683,94],[997,800],[922,364],[660,703],[948,582],[39,273],[920,693],[287,461],[562,399],[843,863],[189,645],[220,287],[630,604],[764,182],[958,649],[288,651],[563,716],[710,970],[826,449],[534,748],[655,280],[728,717],[610,1],[566,245],[943,298],[295,344],[507,306],[294,503],[21,681],[894,659],[3,359],[881,442],[648,177],[427,338],[431,197],[517,967],[262,989],[133,834],[402,3],[106,928],[550,57],[665,508],[941,733],[394,309],[314,324],[385,271],[45,203],[490,950],[136,571],[737,781],[190,865],[77,785],[982,55],[407,587],[540,377],[68,501],[224,565],[49,262],[322,77],[643,125],[828,366],[114,598],[248,124],[767,284],[781,633],[92,42],[34,618],[129,686],[609,152],[854,175],[685,742],[889,391],[784,476],[466,521],[621,998],[594,940],[278,328],[408,519],[419,136],[212,187],[135,699],[312,586],[425,991],[923,234],[417,720],[233,28],[44,805],[617,43],[206,244],[717,945],[698,231],[56,260],[938,345],[992,562],[172,687],[192,488],[599,983],[524,158],[963,358],[41,107],[467,661],[187,308],[141,725],[474,455],[197,997],[340,493],[801,819],[371,83],[223,745],[849,888],[426,776],[850,426],[406,896],[364,985],[957,736],[60,114],[834,917],[914,30],[726,499],[388,591],[26,219],[369,791],[972,297],[650,835],[932,634],[463,140],[761,189],[362,617],[616,436],[145,241],[380,762],[275,427],[292,584],[359,549],[306,383],[936,217],[929,669],[309,958],[714,640],[704,349],[502,775],[424,973],[578,766],[721,170],[798,157],[175,443],[439,814],[602,715],[461,62],[271,799],[977,275],[498,511],[446,526],[743,185],[343,953],[31,981],[447,841],[572,264],[352,382],[499,685],[316,787],[908,103],[569,445],[802,248],[400,156],[360,105],[492,773],[167,882],[544,457],[339,590],[409,979],[930,268],[494,528],[255,755],[768,70],[939,31],[191,167],[568,842],[845,826],[379,64],[143,356],[435,524],[875,809],[625,879],[269,296],[80,593],[694,654],[267,843],[221,117],[462,483],[412,529],[981,46],[537,312],[953,355],[103,932],[565,747],[90,333],[273,448],[238,815],[334,154],[479,398],[154,225],[973,672],[89,379],[83,230],[434,914],[222,51],[779,181],[150,354],[921,388],[791,456],[16,236],[794,878],[373,293],[156,110],[960,16],[657,655],[690,4],[451,82],[789,226],[950,433],[815,318],[374,469],[911,910],[970,899],[771,935],[367,961],[842,832],[917,948],[555,215],[686,441],[264,460],[595,710],[124,666],[140,517],[105,548],[567,695],[149,552],[523,474],[386,239],[456,183],[855,555],[644,572],[605,545],[95,543],[237,523],[216,727],[589,374],[253,546],[607,473],[333,430],[241,104],[319,106],[629,118],[786,824],[355,836],[236,550],[539,368],[588,947],[491,446],[43,860],[38,428],[559,115],[618,806],[829,211],[458,453],[980,671],[363,907],[959,855],[940,656],[723,49],[874,724],[656,425],[604,926],[354,929],[774,325],[307,874],[707,828],[722,200],[332,2],[692,323],[283,754],[177,72],[561,735],[848,608],[2,887],[231,705],[673,237],[676,999],[384,295],[574,199],[945,27],[182,537],[846,761],[587,668],[870,844],[503,438],[450,816],[443,818],[433,214],[739,73],[281,570],[886,330],[662,494],[860,796],[518,380],[15,348],[716,498],[270,400],[23,212],[438,868],[661,134],[862,281],[99,283],[471,694],[509,665],[890,470],[11,300],[207,520],[392,98],[793,847],[356,459],[866,389],[62,884],[94,168],[584,491],[999,34],[611,129],[67,650],[257,190],[250,66],[971,821],[766,160],[78,691],[330,316],[681,361],[893,772],[733,663],[753,76],[525,955],[606,968],[736,122],[195,859],[13,856],[475,942],[817,363],[245,726],[113,108],[962,451],[883,495],[76,601],[951,482],[115,892],[201,924],[504,890],[421,378],[155,607],[297,218],[708,602],[601,19],[557,930],[244,771],[69,853],[878,35],[719,660],[100,611],[586,387],[952,533],[213,977],[162,713],[635,518],[591,603],[636,530],[738,612],[597,702],[57,994],[329,176],[754,632],[328,37],[180,793],[818,497],[347,679],[891,416],[748,577],[457,922],[705,253],[833,670],[61,532],[536,360],[302,560],[967,739],[73,376],[620,210],[986,439],[689,249],[349,698],[469,71],[351,365],[619,21],[769,839],[493,465],[869,682],[171,97],[985,1000],[432,276],[142,294],[675,381],[880,369],[148,916],[678,867],[301,938],[151,678],[702,390],[477,637],[713,609],[538,741],[249,394],[679,353],[440,238],[81,251],[289,846],[117,432],[571,267],[320,63],[470,186],[415,290],[247,54],[59,540],[593,788],[279,6],[641,600],[242,261],[814,423],[42,59],[836,116],[580,228],[603,995],[905,371],[533,163],[626,512],[341,759],[318,93],[699,424],[276,126],[887,52],[659,310],[404,311],[633,471],[321,25],[551,895],[974,763],[413,135],[900,872],[97,372],[522,962],[813,20],[6,128],[22,719],[649,242],[315,92],[994,10],[547,876],[127,67],[823,627],[821,44],[397,957],[199,478],[286,619],[88,850],[1,738],[984,592],[146,319],[405,224],[381,566],[325,232],[176,153],[631,408],[500,971],[50,123],[919,14],[375,162],[268,392],[422,525],[777,749],[520,9],[576,159],[933,556],[254,50],[888,401],[277,808],[521,544],[118,827],[169,599],[485,812],[998,39],[71,595],[847,247],[954,794],[732,351],[546,906],[897,723],[342,881],[742,385],[730,900],[416,740],[840,343],[382,845],[137,452],[639,711],[111,337],[978,515],[194,848],[227,489],[193,22],[185,561],[139,795],[751,652],[423,340],[558,282],[204,643],[123,889],[752,109],[582,692],[324,920],[734,707],[762,420],[976,918],[711,870],[122,683],[40,206],[541,527],[632,69],[486,315],[790,23],[353,975],[54,418],[282,623],[441,905],[30,642],[25,472],[785,988],[18,119],[345,269],[453,487],[772,384],[159,911],[501,769],[514,541],[755,89],[323,538],[86,680],[280,696],[969,413],[232,697],[455,588],[859,486],[530,949],[835,644],[488,594],[420,68],[260,227],[983,288],[851,701],[804,335],[505,404],[663,574],[377,974],[729,440],[107,75],[230,431],[797,58],[120,589],[701,706],[770,96],[5,606],[634,963],[787,554],[816,684],[592,534],[684,987],[36,406],[170,729],[284,721],[806,831],[428,286],[203,861],[988,904],[313,220],[414,91],[543,732],[163,792],[459,341],[668,24],[98,196],[165,502],[55,798],[293,858],[274,969],[697,610],[46,746],[658,960],[942,223],[101,677],[646,944],[925,490],[669,857],[263,250],[51,965],[378,786],[725,869],[615,255],[487,946],[937,81],[526,817],[763,641],[489,765],[200,507],[812,568],[820,628],[47,240],[825,673],[935,194],[927,936],[542,547],[28,927],[892,201],[361,804],[652,8],[827,913],[331,121],[863,414],[623,509],[418,956],[327,620],[299,112],[529,7],[508,36],[987,350],[575,307],[750,952],[484,690],[112,662],[311,257],[720,569],[614,921],[647,222],[666,342],[429,852],[202,838],[553,744],[759,873],[472,146],[642,362],[130,274],[715,993],[389,148],[776,909],[298,585],[583,709],[304,87],[831,810],[12,458],[445,145],[907,193],[326,113],[229,466],[613,454],[696,53],[918,891],[296,347],[395,925],[473,188],[358,653],[581,636],[709,419],[513,174],[102,216],[70,731],[33,894],[531,144],[85,984],[290,578],[624,15],[700,760],[627,531],[82,510],[760,329],[53,357],[876,444],[795,386],[121,95],[882,840],[449,165],[109,996],[79,966],[144,397],[844,270],[577,833],[239,704],[158,976],[452,730],[884,789],[183,171],[841,422],[867,780],[179,266],[365,783],[366,235],[261,277],[807,492],[912,638],[838,464],[651,450],[303,919],[749,862],[383,303],[810,959],[865,700],[215,782],[32,626],[225,728],[178,139],[344,837],[387,883],[718,435],[411,301],[899,901],[391,616],[830,367],[372,373],[926,279],[376,320],[653,45],[291,169],[780,131],[4,415],[757,939],[695,622],[512,777],[895,535],[822,825],[1000,17],[157,718],[398,614],[96,258],[465,411],[598,302],[128,778],[9,246],[160,289],[357,688],[110,768],[104,908],[872,877],[481,291],[370,629],[995,33]]\\n[[764,675],[752,431],[492,799],[422,13],[907,548],[591,854],[148,752],[865,405],[822,486],[294,639],[526,199],[942,373],[351,47],[708,268],[803,925],[643,717],[868,599],[837,395],[830,293],[842,993],[35,340],[179,562],[723,596],[239,859],[547,190],[30,919],[477,7],[607,761],[684,25],[646,625],[506,241],[157,142],[53,896],[789,196],[359,444],[180,65],[899,710],[688,461],[473,983],[765,466],[311,581],[845,364],[548,186],[823,798],[53,555],[339,984],[611,448],[302,809],[182,79],[232,155],[140,816],[883,815],[871,881],[533,867],[322,415],[885,276],[347,69],[768,700],[936,586],[373,651],[228,716],[880,399],[188,638],[164,414],[194,59],[505,132],[323,41],[148,793],[358,768],[722,339],[457,28],[794,779],[335,104],[952,931],[549,994],[959,328],[629,316],[590,427],[200,517],[279,52],[101,106],[887,686],[513,357],[468,593],[493,537],[33,708],[710,485],[45,814],[609,501],[503,606],[784,573],[367,514],[856,995],[713,345],[355,259],[343,258],[473,135],[836,274],[811,905],[57,335],[642,810],[201,565],[844,763],[974,955],[76,909],[491,826],[53,290],[418,969],[352,95],[442,504],[837,349],[968,742],[80,301],[164,458],[827,612],[931,238],[360,795],[477,366],[343,202],[870,151],[285,456],[846,692],[939,1],[182,146],[642,777],[59,715],[106,592],[949,635],[224,609],[228,981],[521,474],[784,760],[707,145],[384,608],[199,958],[740,912],[448,374],[949,695],[396,237],[544,125],[217,324],[66,21],[425,103],[152,269],[401,906],[108,828],[402,748],[926,137],[679,536],[119,882],[997,503],[872,10],[358,19],[871,44],[86,267],[92,468],[429,985],[897,907],[177,153],[864,285],[511,480],[992,723],[861,57],[445,147],[367,212],[856,720],[776,594],[237,37],[841,515],[327,246],[72,27],[457,260],[126,650],[561,978],[261,693],[406,447],[888,944],[118,630],[425,745],[450,294],[853,653],[840,965],[632,307],[593,423],[323,819],[960,535],[786,194],[413,96],[791,14],[955,278],[778,277],[614,929],[62,434],[283,538],[204,805],[792,830],[708,341],[321,275],[379,757],[370,157],[700,327],[328,921],[539,949],[840,818],[694,263],[979,534],[886,797],[39,960],[858,831],[328,952],[660,66],[114,772],[174,198],[955,287],[197,764],[653,158],[302,299],[811,119],[454,168],[584,247],[819,457],[455,233],[59,507],[160,564],[298,789],[627,631],[50,343],[958,71],[830,660],[977,291],[373,541],[365,42],[770,452],[359,575],[257,450],[761,614],[100,726],[832,424],[523,970],[978,698],[951,911],[149,207],[681,974],[543,175],[350,964],[152,658],[421,561],[498,284],[246,572],[559,377],[657,446],[447,800],[856,897],[685,18],[536,420],[428,977],[102,391],[572,490],[469,97],[920,435],[763,185],[36,472],[229,621],[771,136],[180,220],[48,836],[10,24],[866,226],[304,219],[44,80],[322,801],[138,352],[205,619],[164,782],[918,941],[237,620],[25,688],[801,480],[990,170],[242,972],[60,914],[92,659],[324,648],[510,936],[879,379],[307,4],[825,189],[604,885],[944,430],[741,251],[318,179],[774,428],[842,286],[443,807],[435,109],[294,749],[958,785],[838,786],[702,164],[767,384],[500,422],[11,961],[387,823],[306,932],[594,539],[696,451],[386,161],[641,973],[69,948],[659,460],[468,409],[958,437],[305,439],[357,122],[957,642],[925,493],[875,303],[443,804],[218,901],[947,835],[500,670],[122,571],[336,195],[451,383],[643,532],[370,580],[109,598],[620,273],[929,687],[580,257],[921,671],[181,143],[842,403],[2,482],[804,355],[372,178],[885,365],[566,496],[733,354],[616,416],[38,139],[207,224],[531,522],[5,470],[431,834],[501,685],[6,916],[266,23],[765,11],[2,737],[147,822],[746,824],[354,38],[59,927],[669,254],[136,637],[449,329],[637,567],[616,216],[306,280],[350,751],[216,484],[1,582],[301,56],[541,605],[858,945],[264,232],[693,382],[549,838],[464,558],[705,641],[460,869],[47,253],[444,174],[879,989],[392,996],[691,878],[740,113],[756,714],[161,126],[864,740],[458,491],[596,718],[856,39],[228,180],[835,156],[713,318],[681,511],[233,73],[198,649],[55,509],[564,413],[615,214],[901,372],[778,900],[500,991],[131,76],[335,858],[594,812],[554,304],[71,319],[649,724],[809,346],[986,367],[58,755],[291,987],[222,528],[779,617],[87,946],[909,756],[644,808],[877,443],[825,205],[963,530],[505,753],[951,426],[77,333],[985,121],[133,410],[864,817],[28,407],[533,600],[624,49],[20,281],[446,827],[385,549],[903,401],[649,70],[692,421],[919,193],[898,105],[964,89],[420,988],[857,584],[843,902],[833,240],[566,388],[558,709],[633,917],[310,172],[40,888],[583,402],[520,615],[580,843],[248,540],[946,918],[686,591],[489,160],[649,784],[281,701],[74,50],[443,338],[626,188],[430,663],[549,411],[772,694],[557,861],[108,469],[865,674],[68,644],[117,872],[221,81],[760,462],[87,78],[360,29],[970,3],[262,292],[622,930],[533,453],[872,545],[481,975],[271,385],[41,666],[243,632],[292,242],[459,962],[469,887],[367,732],[809,647],[530,350],[90,997],[764,876],[939,526],[824,778],[200,895],[596,498],[507,171],[455,506],[393,455],[152,913],[14,393],[547,183],[137,624],[676,959],[751,227],[638,846],[863,120],[771,825],[359,215],[378,910],[201,313],[879,525],[254,780],[825,231],[383,788],[750,613],[815,326],[5,703],[851,363],[83,312],[260,91],[346,690],[814,5],[169,860],[355,492],[399,665],[710,957],[619,181],[661,813],[897,746],[733,855],[572,898],[250,140],[380,633],[124,297],[756,783],[836,330],[162,963],[179,353],[658,741],[52,935],[219,856],[486,519],[599,471],[544,560],[872,98],[708,308],[103,48],[156,531],[640,794],[273,53],[921,64],[715,221],[772,167],[953,129],[105,150],[170,597],[910,774],[24,191],[853,162],[215,938],[309,527],[311,489],[144,820],[384,866],[856,154],[220,279],[494,682],[62,225],[313,463],[375,892],[512,873],[471,767],[268,92],[397,217],[974,497],[890,769],[677,34],[324,570],[79,58],[111,976],[831,811],[793,706],[228,618],[595,704],[698,771],[299,940],[854,673],[590,479],[544,524],[214,68],[60,397],[592,124],[481,84],[377,177],[764,502],[580,362],[937,684],[144,244],[826,331],[986,336],[645,429],[198,652],[126,862],[936,60],[159,75],[230,369],[865,117],[439,184],[374,577],[114,9],[689,645],[693,371],[322,33],[461,512],[230,667],[476,933],[904,893],[450,942],[887,762],[128,321],[100,640],[635,922],[582,840],[45,792],[172,163],[29,115],[719,43],[594,248],[919,187],[903,46],[788,923],[917,590],[730,200],[459,320],[887,747],[645,966],[284,857],[53,654],[909,141],[884,209],[804,806],[976,473],[815,118],[695,999],[272,130],[699,262],[614,255],[23,585],[748,249],[979,272],[677,744],[749,239],[333,954],[547,559],[300,837],[945,754],[597,296],[478,739],[38,88],[745,908],[327,643],[564,31],[484,45],[863,829],[177,884],[605,601],[609,623],[58,368],[270,289],[229,487],[894,40],[928,646],[624,282],[392,144],[222,36],[934,951],[146,738],[903,556],[117,743],[152,110],[653,315],[779,229],[237,208],[336,2],[544,381],[258,85],[187,607],[660,529],[342,476],[821,87],[379,6],[859,610],[125,370],[102,850],[686,298],[456,766],[904,725],[591,889],[581,390],[791,662],[667,552],[844,697],[653,821],[896,731],[299,94],[742,77],[747,265],[81,449],[726,419],[435,705],[301,22],[505,223],[723,344],[622,953],[582,441],[538,356],[36,17],[824,375],[73,733],[594,924],[316,672],[775,201],[114,210],[660,236],[584,735],[329,868],[889,903],[638,603],[482,655],[992,894],[931,361],[346,513],[576,406],[402,657],[282,845],[392,20],[141,211],[824,521],[712,877],[621,283],[183,998],[293,557],[466,980],[796,30],[411,702],[27,433],[942,773],[487,404],[528,629],[804,520],[266,418],[998,926],[724,347],[839,261],[376,12],[497,398],[879,134],[303,173],[407,417],[608,544],[948,82],[214,802],[929,86],[46,54],[86,1000],[974,842],[893,721],[376,337],[571,937],[272,61],[64,425],[564,551],[342,192],[192,477],[867,100],[707,523],[438,971],[758,992],[493,93],[327,656],[951,967],[312,152],[163,587],[228,454],[423,729],[778,359],[844,790],[666,116],[840,63],[777,90],[716,467],[86,310],[435,256],[898,222],[98,323],[488,250],[526,107],[712,750],[955,883],[331,387],[157,15],[960,886],[201,266],[620,770],[837,891],[938,681],[359,759],[325,691],[987,728],[468,847],[466,803],[244,488],[69,394],[377,62],[507,436],[248,699],[836,713],[765,727],[651,438],[536,956],[741,791],[151,864],[284,553],[253,939],[93,833],[681,432],[881,234],[509,386],[954,880],[701,915],[833,99],[886,464],[630,568],[633,602],[254,55],[911,547],[916,264],[155,979],[274,664],[151,83],[651,396],[729,928],[244,712],[178,131],[528,408],[5,166],[194,440],[199,839],[941,325],[318,392],[567,947],[417,442],[984,874],[500,616],[751,483],[424,412],[299,114],[106,604],[366,554],[279,583],[287,627],[477,8],[354,376],[913,311],[249,505],[88,138],[211,481],[966,589],[512,851],[350,475],[439,871],[468,841],[827,899],[850,108],[791,26],[228,546],[921,127],[38,230],[470,203],[931,683],[464,516],[536,677],[496,16],[945,776],[172,358],[534,35],[493,32],[860,775],[789,182],[521,518],[337,197],[861,243],[973,879],[378,578],[388,306],[886,849],[165,533],[386,832],[357,510],[64,235],[608,213],[876,676],[607,72],[85,169],[889,400],[578,950],[268,550],[674,206],[580,668],[621,611],[301,389],[132,920],[1000,123],[231,796],[263,51],[686,459],[397,351],[141,348],[452,378],[833,934],[731,875],[477,309],[804,904],[265,844],[429,982],[919,495],[619,719],[542,102],[616,711],[964,696],[211,636],[93,478],[487,986],[124,500],[991,628],[64,465],[306,270],[816,890],[212,494],[373,295],[378,990],[949,634],[417,781],[638,680],[326,271],[231,852],[242,865],[253,204],[744,149],[574,342],[477,707],[135,380],[794,622],[123,661],[264,678],[301,853],[318,736],[150,758],[630,863],[428,542],[116,765],[81,252],[85,543],[979,218],[63,574],[430,165],[364,74],[224,305],[926,569],[365,563],[212,499],[734,228],[492,626],[253,288],[270,734],[811,508],[4,112],[993,133],[919,787],[25,848],[755,322],[878,870],[186,317],[481,128],[692,576],[774,245],[95,300],[738,159],[209,148],[680,445],[1,579],[822,669],[427,67],[133,943],[834,314],[949,334],[321,101],[679,111],[854,332],[307,730],[255,595],[217,588],[463,679],[238,689],[75,176],[102,722],[869,566],[584,968],[882,360]]"
                    },
                    {
                        "username": "pengzuo",
                        "content": "Did anyone got this for real interview? I don\\'t know what my face would be like if I got."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "it is hurting"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": " Question states that every node has exactly one parent, except for the root node which has no parents.\\nthen how following test case is valid test case??\\n[[1,2],[2,3],[3,4],[4,1],[1,5]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The question actually presents a scenario where an additional directed edge has been added to a rooted tree. In a normal rooted tree, indeed, every node has exactly one parent, except for the root node which has no parents.\\n\\nHowever, the problem statement adds an additional edge that was not already part of the tree, thereby introducing a situation where a node may end up with two parents, or a cycle may form in the graph.\\n\\nIn the case of the graph represented by [[1,2],[2,3],[3,4],[4,1],[1,5]], there\\'s a cycle formed by nodes 1, 2, 3, 4 (because of the extra edge [4,1]), and also node 1 ends up with two parents: 4 and 5. Thus, the graph is a valid test case according to the problem statement."
                    }
                ]
            }
        ]
    }
]